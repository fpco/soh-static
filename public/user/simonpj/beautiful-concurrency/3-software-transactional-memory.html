<!DOCTYPE html>
<html><head><title>3. Software Transactional Memory - School of Haskell | School of Haskell</title><meta http-equiv="x-ua-compatible" content="IE=9"><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="google-site-verification" content="Rfxk2TdeMMXEXHgJ2_OO8Rt3hPbQSDao0OXQV_n6z_s" /><link href="//fonts.googleapis.com/css?family=Merriweather" rel="stylesheet" type="text/css"><link href="https://www.schoolofhaskell.com/recent-content/feed" type="application/rss+xml" rel="alternate" title="Recently published content">
<link rel="stylesheet" href="https://www.schoolofhaskell.com/static/combined/UlwEHVcM.css"><style>.social{margin-right:1em}h1{font-family:Merriweather !important}article{font-family:Merriweather !important}article li{font-family:Merriweather !important;line-height:1.6em}h1,h2,h3,h4,h4,h5{font-family:Merriweather !important}.editor p{font-family:Frutiger, "Frutiger Linotype", Univers, Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans Condensed", "Liberation Sans", "Nimbus Sans L", Tahoma, Geneva, "Helvetica Neue", Helvetica, Arial, sans-serif}.article-footer{border-top:1px solid #ddd;padding-top:1em;margin-top:1em}body{font-size:16px !important}.navbar .navbar-inner{background:#3c3f41}.navbar .brand{font-size:14px}.navbar .brand img{width:6em}.navbar .icon-wrench{margin:0 -0.5em 0 -0.5em;padding:0 1em 0 1em;height:20px}.navbar-inverse .nav .active a{background:#333638}.navbar-inverse .nav > li > a{color:#a7a7a7
}.navbar-inverse .btn-navbar{background:#333638}.navbar-inverse .nav > li a:hover,.navbar-inverse .btn{background:#333537 !important}@media (max-width: 979px) {.icon-wrench{padding-left:1em !important}}.breadcrumb{border-top-left-radius:0;border-top-right-radius:0}h1{margin-top:20px}.breadcrumb-container + .main-content h1{margin-top:0}.footer{padding:30px 0;margin-top:70px;border-top:1px solid #e5e5e5;background-color:#f5f5f5}.footer ul.footer-menu{list-style-type:none}.footer ul.footer-menu li{display:inline-block}.footer ul.footer-menu li + li{margin-left:0.5em}.footer ul.footer-menu li + li:before{margin-right:0.5em;content:"·";color:#999}.footer ul.menu li{display:inline-block}.footer ul.menu li + li{margin-left:0.5em}.footer .copyright{margin-left:25px}.main-content{min-height:100%}.gravatar{width:80px;height:80px;border-radius:2px;background:#eee}.empty-gravatar{width:0}.container{font-family:"Segoe UI", Candara, "Bitstream Vera Sans", "DejaVu Sans", "Bitstream Vera Sans", "Trebuchet MS", Verdana, "Verdana Ref", sans-serif}.container h1,.container h2,.container h4,.container h4,.container h5{font-family:"Segoe UI", Candara, "Bitstream Vera Sans", "DejaVu Sans", "Bitstream Vera Sans", "Trebuchet MS", Verdana, "Verdana Ref", sans-serif}article{font-family:Merriweather !important}article h1{font-family:Merriweather !important}article li{font-family:Merriweather !important;line-height:1.6em}article li + li{margin-top:0.5em}article div.code{background:#f9f9f9;border:1px solid #d1d1d1;position:relative;border-radius:0.2em;margin:0.25em 0 0.75em 0;min-height:2.5em}article code{color:#005580;font-size:14px;white-space:pre}article a.hoogle > code{color:#0088cc;font-size:14px;white-space:pre;border:0}article .expand-code{display:none}article pre{overflow:auto;word-wrap:normal}article code.active{display:block;max-height:430px}article h1{font-size:31.5px}article h3{font-size:17.5px}article h4{font-size:14px}article h5,article h6{font-size:11.9px}article p{line-height:1.7em}article h1 code,article h2 code,article h3 code,article h4 code,article h5 code,article h6 code{font-size:inherit !important}article h1 a,article h2 a,article h3 a,article h4 a,article h5 a,article h6 a{color:#444}article h1 a:before,article h2 a:before,article h3 a:before,article h4 a:before,article h5 a:before,article h6 a:before{margin-left:-1.5em;padding-right:0.5em;font-family:fontawesome;content:"\f0c1";font-size:20px;color:#fff}article h1 a:hover,article h2 a:hover,article h3 a:hover,article h4 a:hover,article h5 a:hover,article h6 a:hover{text-decoration:none;color:#0088cc}article h1 a:hover:before,article h2 a:hover:before,article h3 a:hover:before,article h4 a:hover:before,article h5 a:hover:before,article h6 a:hover:before{color:#888}article h2{font-size:24.5px}article .popover{font-family:actor}article .popover h3.popover-title{font-family:actor !important;font-size:1em}article .popover .popover-content{width:15em;font-size:1em}article .controlsRun{display:block;padding:0.5em;text-align:right;background:#f2f2f2}article .controlsRun a.clone{margin-right:1em;font-family:actor;text-decoration:none}article .controlsRun a.clone span{padding-left:0.5em}article .controlsRun a.run,article .controlsRun a.reset,article .controlsRun a.show-code{font-size:16px}article .controlsRun a.run span,article .controlsRun a.reset span,article .controlsRun a.show-code span{display:none}article .controlsRun a.reset{margin-left:0.5em;color:#a2becc}article .controlsRun a.reset{display:none}article .controlsRun a.show-code{margin-right:0.75em}article .controlsRun a.run:hover,article .controlsRun a.show-code:hover{text-decoration:none}article .controlsRun a.show-code.active{color:#DC0D0D}article .controlsRun a[disabled]{color:#a2becc;cursor:default}article .collapse-area .collapse-header{background:#0088cc;color:#fff;padding:0.3em;cursor:pointer}article .collapse-area .hidden-toggle:before{content:"\f0d7";font-family:fontawesome;margin-right:0.5em;margin-left:0.25em}article .collapse-area .collapsed-files{overflow:auto;height:auto}article .collapse-area.collapse-disabled{display:none}article .collapse-area.collapse-area-off .collapsed-files{height:0px;overflow:hidden}article .collapse-area.collapse-area-off .hidden-toggle:before{content:"\f0da"}article .snippet-stdio .stdout{margin:0.5em;padding-right:2em;position:relative;word-wrap:break-word}article .snippet-stdio .stdin{-webkit-box-shadow:none;-moz-box-shadow:none;box-shadow:none;-webkit-transition:none;-moz-transition:none;-o-transition:none;transition:none;padding:0;margin:0}article .hoogle-results{margin:0.25em}article .hoogle-results .hoogle-inner{background:#fff;padding:0.5em;border-radius:3px;border:1px solid #ddd}article .hoogle-results .hoogle-inner .close-link{position:relative;float:right;margin-top:-0.5em;margin-right:-0.5em}article .snippet-output-errors{margin:1em 0.5em 0.5em 0.5em;position:relative}article .snippet-output-errors ul{list-style-type:none;margin:0;position:relative}article .snippet-output-errors pre{border:0;border-radius:0;padding:0.25em;margin:0;background:inherit;color:inherit}article .snippet-output-errors .close-link{color:inherit;background:inherit}article .snippet-editors{z-index:0;padding:0.25em}article .close-link{padding:0.5em;background:#eaeaea;border-bottom-left-radius:0.2em;border-top-right-radius:0.2em;position:absolute;top:0;right:0}article .close-link:hover{text-decoration:none}article .snippet-title{padding:0.5em 0 0 0.5em}article .snippet-title .snippet-icon{font-family:FontAwesome;display:inline-block;margin-right:0.5em}article .fullModuleCode + div .snippet-title{margin-top:0.5em;border-top:1px solid #ccc;padding-top:0.5em}article .CodeMirror{height:auto;min-height:1em;line-height:1.5em;background:transparent;font-size:14px !important}article .CodeMirror .highlighted{background:rgba(250, 210, 0, 0.45) !important}article .CodeMirror-widget{margin-left:2em;line-height:1.8}article .CodeMirror.collapsed{height:10em !important}article .editor .expander{text-align:center;display:block;padding:0.5em;text-decoration:none;border-bottom-left-radius:2px;border-bottom-right-radius:2px}article .editor .expander .ellipsis{background:white;border:1px solid #ccc;padding:0 0.5em;height:1em;line-height:0.5em;display:inline-block;color:#555;cursor:pointer}article .editor .expander .ellipsis:hover{background:#ddd;color:#333}article .web-runner{margin:0.5em;padding:0.5em;border:1px solid #ccc;border-radius:3px;background:#f5f5f5}article .web-runner iframe{border:0;margin-top:0.5em;margin-bottom:0;background:white}article .web-runner .controls i{cursor:pointer;color:#0088cc}article .web-runner .controls i:hover{color:#222}article .web-runner .controls i + i{margin-left:0.5em}article .web-runner .controls .icon-remove{float:right}article .hidden{display:block;visibility:visible}article .controlsShowHide{margin-bottom:0.5em}.tutorial-body{float:left !important}.tutorial-nav{float:right !important}@media (max-width: 979px) {.related-content{float:right}.author-name{display:block;margin-left:20px !important;padding-left:5px;margin-top:5px}article h1 a:hover:before,article h2 a:hover:before,article h3 a:hover:before,article h4 a:hover:before,article h5 a:hover:before,article h6 a:hover:before{color:#fff}.tutorial-nav{float:none !important;width:auto !important}.tutorial-body{float:none !important;width:auto !important}}@media (min-width: 980px) and (max-width: 1199px) {.navbar-search{display:none}.tutorial-nav{width:200px}.tutorial-body{width:720px}}#accountPage h1{margin:20px 0 0 0}#accountPage h2{font-size:20px}.group-contents .span8{float:left}.group-contents .span4{float:right}.container > .alert-block{margin-top:1em}.alert{color:#aa874a
}.social{margin-bottom:.8em;display:block}.social a{text-decoration:none}.social i{font-size:1.1em;color:#fff;padding:0.25em;border-radius:0.25em;width:1em;display:inline-block;text-align:center}.social i.icon-twitter{background:#0088cc}.social i.icon-facebook{background:#3b5998
  }.social i.icon-google-plus{background:#dd4b39
  }.well pre{background:#fcfcfc}.well h2{margin-top:0}code{color:#005580;font-size:14px;white-space:pre}</style><!--[if lt IE 8]><link rel="stylesheet" href="https://www.schoolofhaskell.com/static/design/css/ie7.css?etag=TSMl9x1V"><![endif]--><!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]--></head><body class="not-logged-in" itemscope itemtype="http://schema.org/Product"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-H62P" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-H62P');</script><div class="navbar navbar-inverse navbar-static-top"><div class="navbar-inner"><div class="container"><a class="btn btn-navbar" type="button" data-toggle="collapse" data-target=".nav-collapse"><span class="icon-bar"></span>
<span class="icon-bar"></span>
<span class="icon-bar"></span>
</a>
<a class="brand" href="/"><img src="/static/img/haskell-logo-wide.png" title="School of Haskell">
</a>
<div class="nav-collapse collapse"><ul class="nav"><li><a href="https://www.schoolofhaskell.com/">School</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user">Users</a>
</li>
</ul>
<form class="navbar-search pull-left" action="https://www.schoolofhaskell.com/search"><input class="search-query" type="text" placeholder="Search" name="search">
</form>
</div>
</div>
</div>
</div>
<div class="container breadcrumb-container"><div class="row"><div class="span12"><ul class="breadcrumb"><li><a href="https://www.schoolofhaskell.com/user/simonpj">Simon Peyton Jones</a>
<span class="divider">/</span>
</li>
<li><a href="https://www.schoolofhaskell.com/user/simonpj/beautiful-concurrency">Beautiful Concurrency</a>
<span class="divider">/</span>
</li>
<li><a href="https://www.schoolofhaskell.com/user/simonpj/beautiful-concurrency/3-software-transactional-memory">3. Software Transactional Memory</a>
</li>
</ul>
</div>
</div>
</div>
<div class="container main-content"><div class="row"><div class="span12"><h1 itemprop="name">3. Software Transactional Memory</h1>
</div>
</div>
<div class="row"><div class="span7 meta"><p><span class="date"> 2 Apr 2015</span>
<span class="author"><a href="https://www.schoolofhaskell.com/user/simonpj">Simon Peyton Jones</a>
</span>
<span class="view-edit-link pull-right"><a class="view-source-link" href="https://www.schoolofhaskell.com/tutorial-raw/5556/e5efed537dea3fff309ef46e1f03a3d4f192ef40">View Markdown source</a>
</span>
</p>
<p class="tags"></p>
</div>
</div>
<div class="row"><div class="span7 meta"><span class="sociallinksunicode social">
<a href="https://twitter.com/home?status=$url$" target="_blank"><i class="icon-twitter"></i></a>&nbsp;
<a href="http://www.facebook.com/sharer/sharer.php?u=$url$" target="_blank"><i class="icon-facebook"></i></a>&nbsp;
<a href="https://plus.google.com/share?url=$url$" target="_blank"><i class="icon-google-plus"></i></a></span>
</div>
</div>
<p class="alert">As of March 2020, School of Haskell has been switched to read-only mode.</p>
<div class="row" itemprop="desc"><div class="span4 tutorial-nav"><div class="related-content"><ul class="nav nav-tabs nav-stacked"><li><script>reddit_target='fpcomplete'</script>
<script src="https://redditstatic.s3.amazonaws.com/button/button1.js"></script>
</li>
<li><a href="https://www.schoolofhaskell.com/user/simonpj/beautiful-concurrency/2-a-simple-example-bank-accounts">Previous content: 2. A simple example: bank accounts</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user/simonpj/beautiful-concurrency/4-the-santa-claus-problem">Next content: 4. The Santa Claus problem</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user/simonpj/beautiful-concurrency">Go up to: Beautiful Concurrency</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user/simonpj">See all content by Simon Peyton Jones</a>
</li>
</ul>

</div>
<div class="aside"><h3>Sections</h3>
<ul><li><a href="#3-1-side-effects-and-input-output-in-haskell">3.1 Side effects and input/output in Haskell</a></li><li><a href="#3-2-transactions-in-haskell">3.2 Transactions in Haskell</a></li><li><a href="#3-3-implementing-transactional-memory">3.3 Implementing transactional memory</a></li><li><a href="#3-4-blocking-and-choice">3.4 Blocking and choice</a></li><li><a href="#3-5-summary-so-far">3.5 Summary so far</a></li></ul></div>
</div>
<div class="span8 tutorial-body" data-environment="ghc-7.8-stable-14.09">
<article><p>Software Transactional Memory is a promising new approach to the challenge of
concurrency, as I will explain in this section. I shall explain STM using Haskell,
the most beautiful programming language I know, because STM fits into Haskell
particularly elegantly. If you don’t know any Haskell, don’t worry; we’ll learn
it as we go.</p><h2 id="3-1-side-effects-and-input-output-in-haskell"><a href="#3-1-side-effects-and-input-output-in-haskell">3.1 Side effects and input/output in Haskell</a></h2><p>Here is the beginning of the code for transfer in Haskell:</p><pre><code class="haskell">transfer :: Account -&gt; Account -&gt; Int -&gt; IO ()
-- Transfer ’amount’ from account ’from’ to account ’to’
transfer from to amount = ...</code></pre><p>The second line of this definition, starting “<code>--</code>”, is a comment. The first line
gives the <i>type signature</i> for <code>transfer</code>. This signature says that <code>transfer</code> takes
as its arguments<sup>2</sup> two values of type <code>Account</code> (the source and destination accounts), and an <code>Int</code> (the amount to transfer), and returns a value of type <code>IO ()</code>.
This result type says “<code>transfer</code> returns an action that, when performed, may
have some side effects, and then returns a value of type <code>()</code>”. The type <code>()</code>, pronounced “unit”, has just one value, which is also written <code>()</code>; it is akin to <code>void</code>
in C. So <code>transfer</code>’s result type <code>IO ()</code> announces that its side effects constitute
the only reason for calling it. Before we go further, we must explain how side
effects are handled in Haskell.</p><p>A “side effect” is anything that reads or writes mutable state. Input/output is
a prominent example of a side effect. For example, here are the signatures of
two Haskell functions with input/output effects:</p><pre><code class="haskell">hPutStr  :: Handle -&gt; String -&gt; IO ()
hGetLine :: Handle -&gt; IO String</code></pre><p>We call any value of type <code>IO t</code> an “action”. So <code>(hPutStr h &quot;hello&quot;)</code><sup>3</sup> is an
action that, when performed, will print <code>&quot;hello&quot;</code> on handle<sup>4</sup> <code>h</code> and return the
unit value. Similarly, <code>(hGetLine h)</code> is an action that, when performed, will
read a line of input from handle <code>h</code> and return it as a <code>String</code>. We can glue
together little side-effecting programs to make bigger side-effecting programs
using Haskell’s “<code>do</code>” notation. For example, <code>hEchoLine</code> reads a string from the
input and prints it:</p><pre><code class="haskell">hEchoLine :: Handle -&gt; IO String
hEchoLine h = do
    s &lt;- hGetLine h
    hPutStr h (&quot;I just read that &quot; ++ s)
    return s</code></pre><div class="hidden" title="Try it..."><p>Here's a small program that calls the function <code>hEchoLine</code> and sets up data for it. Run it!</p><pre><code class="active haskell">{-# START_FILE main.hs #-}
import System.IO

hEchoLine :: Handle -&gt; IO String
hEchoLine h = do
    s &lt;- hGetLine h
    hPutStr h (&quot;I just read that &quot; ++ s)
    return s
        
main = do
    h &lt;- openFile &quot;test.txt&quot; ReadWriteMode
    str &lt;- {-hi-}hEchoLine h{-/hi-}
    hClose h
    str1 &lt;- readFile &quot;test.txt&quot;
    hPutStr stdout str1

{-# START_FILE test.txt #-}
Haskell rules!</code></pre><p>First, we <code>import</code> the appropriate library, in this case <code>System.IO</code>, which contains the definitions of <code>hGetLine</code>, <code>hPutStr</code>, and a few others used in <code>main</code>. Function <code>main</code> makes the call to <code>hEchoLine</code> with the appropriate argument -- a file handle, <code>h</code>. 
We get the handle by calling <code>openFile</code> with two arguments: the name of the file and the file mode -- <code>ReadWriteMode</code> in this case. Finally, we read the whole modified file using <code>readFile</code> and send the result to the standard output, <code>stdout</code>, for display.</p><p>Notice that we are discarding the result of <code>hEchoLine</code>: <code>str</code>. If you want to display it, change the last line of <code>main</code>.</p><p>The file <code>test.txt</code> is provided too (feel free to edit its content and run the program again).</p></div><p>The notation:</p><pre><code class="haskell">do
   a1
   ...
   an </code></pre><p>constructs an action by gluing together the
smaller actions <i>a<sub>1</sub> . . . a<sub>n</sub></i> in sequence. So <code>hEchoLine h</code> is an action that, when
performed, will first perform <code>hGetLine h</code> to read a line from <code>h</code>, naming the result <code>s</code>. Then it will perform <code>hPutStr</code> to print <code>s</code>, preceded<sup>5</sup> by “<code>I just read: </code>”.
Finally, it returns the string <code>s</code>. This last line is interesting, because <code>return</code> is
not a built-in language construct: rather, it is a perfectly ordinary function with
type</p><pre><code class="haskell">return :: a -&gt; IO a</code></pre><p>The action <code>return v</code>, when performed, returns <code>v</code> without having caused any
side effects<sup>6</sup>. This function works on values of any type, and we indicate this
by using a type variable <code>a</code> in its type.</p><p>Input/output is one important sort of side effect. Another is the act of reading
or writing a mutable variable. For example, here is a function that increments
the value of a mutable variable:</p><pre><code class="haskell">incRef :: IORef Int -&gt; IO ()
incRef var = do
    val &lt;- readIORef var
    writeIORef var (val+1)
</code></pre><div class="hidden" title="Try it..."><p>Here is a small test program calling <code>incRef</code>:</p><pre><code class="active haskell">import System.IO
import Data.IORef

incRef :: IORef Int -&gt; IO ()
incRef var = do
    val &lt;- readIORef var
    writeIORef var (val+1)
                
main = do
    var &lt;- newIORef 42
    {-hi-}incRef var{-/hi-} 
    val &lt;- readIORef var
    hPutStr stdout (show val)
</code></pre><p>This time <code>main</code> creates a new <code>IORef</code> with the initial value <code>42</code>, passes it to our function <code>incRef</code>, reads the new value from <code>IORef</code>, and displays it. To display a number we convert it to a string using the function <code>show</code>.</p></div><p>Here, <code>incRef var</code> is an action that first performs <code>readIORef var</code> to read the
value of the variable, naming its value <code>val</code>, and then performs <code>writeIORef</code>
to write the value <code>(val+1)</code> into the variable. The types of <code>readIORef</code> and
<code>writeIORef</code> are as follows:</p><pre><code class="haskell">readIORef  :: IORef a -&gt; IO a
writeIORef :: IORef a -&gt; a -&gt; IO ()</code></pre><p>A value of type <code>IORef t</code> should be thought of as a pointer, or reference, to a
mutable location containing a value of type <code>t</code>, a bit like the type <code>(t *)</code> in C.
In the case of <code>incRef</code>, the argument has type <code>IORef Int</code> because <code>incRef</code> only
applies to locations that contain an <code>Int</code>.</p><p>So far I have explained how to build big actions by combining smaller ones
together — but how does an action ever actually get performed? In Haskell,
the whole program defines a single <code>IO</code> action, called <code>main</code>. To run the program
is to perform the action <code>main</code>. For example, here is a complete program:</p><pre><code class="active haskell">import System.IO

-- show
main :: IO ()
main = do
    hPutStr stdout &quot;Hello&quot;
    hPutStr stdout &quot; world\n&quot;</code></pre><p>This program is a sequential program, because the <code>do</code>-notation combines <code>IO</code>
actions in sequence. To construct a concurrent program we need one more
primitive, <code>forkIO</code>:</p><pre><code class="haskell">forkIO :: IO a -&gt; IO ThreadId</code></pre><p>The function <code>forkIO</code>, which is built into Haskell, takes an <code>IO</code> action as its
argument, and spawns it as a concurrent Haskell thread. Once created, it is run
concurrently with all the other Haskell threads, by the Haskell runtime system.
For example, suppose we modified our main program thus<sup>7</sup>:</p><pre><code class="active haskell">import System.IO
import Control.Concurrent

-- show
main :: IO ()
main = do 
    forkIO (hPutStr stdout &quot;Hello&quot;)
    hPutStr stdout &quot; world\n&quot;</code></pre><div class="hidden" title="Note..."><p>In the first line of main, we could instead have written <code>tid &lt;- forkIO (hPutStr ...)</code>,
to bind the <code>ThreadId</code> returned by <code>forkIO</code> to <code>tid</code>. However, since we do not use the returned
<code>ThreadId</code>, we are free to discard it by omitting the “<code>tid &lt;-</code>” part.</p><pre><code class="active haskell">import System.IO
import Control.Concurrent

main :: IO ()
main = do
    tid &lt;- forkIO (hPutStr stdout &quot;Hello&quot;)
    hPutStr stdout &quot; world\n&quot;</code></pre></div><p>Now the two <code>hPutStr</code> actions would run concurrently. Which of them would
“win” (by printing its string first) is unspecified. Haskell threads spawned by
<code>forkIO</code> are extremely lightweight: they occupy a few hundred bytes of memory,
and it is perfectly reasonable for a single program to spawn thousands of them.</p><p>Gentle reader, you may by now be feeling that Haskell is a very clumsy and
verbose language. After all, our three-line definition of <code>incRef</code> accomplishes
no more than <code>x++</code> does in C! Indeed, in Haskell side effects are extremely explicit and somewhat verbose. However, remember first that Haskell is primarily
a <i>functional</i> language. Most programs are written in the functional core of
Haskell, which is rich, expressive, and concise. Haskell thereby gently encourages you to write programs that make sparing use of side effects.</p><p>Second, notice that being explicit about side effects reveals a good deal of useful
information. Consider two functions:</p><pre><code class="haskell">f :: Int -&gt; Int
g :: Int -&gt; IO Int</code></pre><p>From looking only at their types we can see that <code>f</code> is a pure function: it has
no side effects. Given a particular <code>Int</code>, say <code>42</code>, the call <code>(f 42)</code> will return the
same value every time it is called. In contrast, <code>g</code> has side effects, and this is
apparent in its type. Each time <code>g</code> is performed it may give a different result —
for example it may read from <code>stdin</code>, or modify a mutable variable — even if its
argument is the same every time. This ability to make side effects explicit will
prove very useful in what follows.</p><p>Lastly, actions are first-class values: they may be passed as arguments as well
as returned as results. For example, here is the definition of a (simplified) <code>for</code>
loop function, written entirely in Haskell rather than being built in:</p><pre><code class="haskell">nTimes :: Int -&gt; IO () -&gt; IO ()
nTimes 0 do_this = return ()
nTimes n do_this = do
    do_this
    nTimes (n-1) do_this</code></pre><p>This recursive function takes an <code>Int</code> saying how many times to loop, and an action <code>do_this</code>; it returns an action that, when performed, performs the <code>do_this</code>
action <code>n</code> times. Here is an example of a use of <code>nTimes</code> to print “<code>Hello</code>” 10 times:</p><pre><code class="haskell">main = nTimes 10 (hPutStr stdout &quot;Hello\n&quot;)</code></pre><div class="hidden" title="Try it..."><pre><code class="active haskell">import System.IO

nTimes :: Int -&gt; IO () -&gt; IO ()
nTimes 0 do_this = return ()
nTimes n do_this = do 
    do_this
    nTimes (n-1) do_this

main = nTimes 10 (hPutStr stdout &quot;Hello\n&quot;)</code></pre><p>We are calling <code>nTimes</code> with <code>10</code> and the action returned by <code>(hPutStr stdout &quot;Hello\n&quot;)</code> that prints &quot;Hello&quot; to the standard input.</p></div><p>In effect, by treating actions as first-class values, Haskell supports <i>user-defined
control structures</i>.</p><p>This chapter is not the place for a full introduction to Haskell, or even to side
effects in Haskell. A good starting point for further reading is the tutorial
“<i>Tackling the awkward squad</i>” [9].</p><h2 id="3-2-transactions-in-haskell"><a href="#3-2-transactions-in-haskell">3.2 Transactions in Haskell</a></h2><p>Now we can return to our <code>transfer</code> function. Here is its code:</p><pre><code class="haskell">transfer :: Account -&gt; Account -&gt; Int -&gt; IO ()
-- Transfer ’amount’ from account ’from’ to account ’to’
transfer from to amount
  = atomically (do  deposit to amount
                    withdraw from amount)</code></pre><p>The inner <code>do</code>-block should by now be fairly self-explanatory: we call <code>deposit</code>
to deposit amount in <code>to</code>, and <code>withdraw</code> to withdraw amount from account <code>from</code>.
We will write these auxiliary functions in a moment, but first look at the call
to <code>atomically</code>. It takes an action as its argument, and performs it atomically.
More precisely, it makes two guarantees:</p><blockquote><p><b>Atomicity:</b> the effects of <code>atomically act</code> become visible to another thread
all at once. This ensures that no other thread can see a state in which
money has been deposited in to but not yet withdrawn from from.</p></blockquote><blockquote><p><b>Isolation:</b> during a call <code>atomically act</code>, the action <code>act</code> is completely unaffected by other threads. It is as if act takes a snapshot of the state of the
world when it begins running, and then executes against that snapshot.</p></blockquote><p>Here is a simple execution model for <code>atomically</code>. Suppose there is a single,
global lock. Then <code>atomically act</code> grabs the lock, performs the action <code>act</code>,
and releases the lock. This implementation brutally ensures that no two atomic
blocks can be executed simultaneously, and thereby ensures atomicity.</p><p>There are two problems with this model. First, it does not ensure isolation
at all: while one thread is accessing an <code>IORef</code> inside an atomic block (holding
the Global Lock), there is nothing to stop <i>another</i> thread writing the same
<code>IORef</code> directly (i.e. outside <code>atomically</code>, without holding the Global Lock),
thereby destroying the isolation guarantee. Second, performance is dreadful,
because every atomic block would be serialised even if no actual interference
was possible.</p><p>I will discuss the second problem shortly, in Section 3.3. Meanwhile, the first
objection is easily addressed with the type system. We give <code>atomically</code> the
following type:</p><pre><code class="haskell">atomically :: STM a -&gt; IO a</code></pre><p>The argument of atomically is an action of type <code>STM a</code>. An <code>STM</code> action is like
an <code>IO</code> action, in that it can have side effects, but the range of side effects for <code>STM</code>
actions is much smaller. The main thing you can do in an <code>STM</code> action is read
or write a transactional variable, of type <code>(TVar a)</code>, much as we could read or
write <code>IORefs</code> in an <code>IO</code> action<sup>8</sup>.</p><pre><code class="haskell">readTVar  :: TVar a -&gt; STM a
writeTVar :: TVar a -&gt; a -&gt; STM ()</code></pre><p><code>STM</code> actions can be composed together with the same <code>do</code>-notation as <code>IO</code> actions
— the <code>do</code>-notation is overloaded to work on both types, as is <code>return</code><sup>9</sup>. Here,
for example, is the code for <code>withdraw</code>:</p><pre><code class="haskell">type Account = TVar Int

withdraw :: Account -&gt; Int -&gt; STM ()
withdraw acc amount = do
    bal &lt;- readTVar acc
    writeTVar acc (bal - amount)</code></pre><p>We represent an <code>Account</code> by a transactional variable containing an <code>Int</code> for the
account balance. Then withdraw is an <code>STM</code> action that decrements the balance
in the account by <code>amount</code>.</p><p>To complete the definition of <code>transfer</code> we can define <code>deposit</code> in terms of
<code>withdraw</code>:</p><pre><code class="haskell">deposit :: Account -&gt; Int -&gt; STM ()
deposit acc amount = withdraw acc (- amount)</code></pre><div class="hidden" title="Try it..."><pre><code class="active haskell">import System.IO
import Control.Concurrent.STM

type Account = TVar Int

withdraw :: Account -&gt; Int -&gt; STM ()
withdraw acc amount = do
    bal &lt;- readTVar acc
    writeTVar acc (bal - amount)

deposit :: Account -&gt; Int -&gt; STM ()
deposit acc amount = withdraw acc (- amount)

transfer :: Account -&gt; Account -&gt; Int -&gt; IO ()
-- Transfer ’amount’ from account ’from’ to account ’to’
transfer from to amount 
    = atomically (do deposit to amount
                     withdraw from amount)

showAccount :: Account -&gt; IO Int
showAccount acc = atomically (readTVar acc)

main = do
    from &lt;- atomically (newTVar 200)
    to   &lt;- atomically (newTVar 100)
    transfer from to 50
    v1 &lt;- showAccount from
    v2 &lt;- showAccount to
    putStrLn $ (show v1) ++ &quot;, &quot; ++ (show v2)</code></pre><p>We are uning <code>newTVar</code> to create two <code>TVar</code>s representing two accounts, <code>from</code> and <code>to</code>.</p></div><p>Notice that, <code>transfer</code> ultimately performs four primitive read/write actions: a
read and then write on account <code>to</code>, followed by a read and then write on account
<code>from</code>. These four actions execute atomically, and that meets the specification
given at the start of Section 2.</p><p>The type system neatly prevents us from reading or writing a <code>TVar</code> outside of a
transaction. For example, suppose we tried this:</p><pre><code class="haskell">bad :: Account -&gt; IO ()
bad acc = do
    hPutStr stdout &quot;Withdrawing...&quot;
    withdraw acc 10</code></pre><div class="hidden" title="Try it..."><p>This program won't compile:</p><pre><code class="active haskell">import System.IO
import Control.Concurrent.STM

type Account = TVar Int

withdraw :: Account -&gt; Int -&gt; STM ()
withdraw acc amount = do
    bal &lt;- readTVar acc
    writeTVar acc (bal - amount)

bad :: Account -&gt; IO ()
bad acc = do
    hPutStr stdout &quot;Withdrawing...&quot;
    withdraw acc 10

main = do
    acc &lt;- atomically (newTVar 200)
    bad acc 
    hPutStr stdout &quot;\nDone!\n&quot;</code></pre></div><p>This program is rejected because the <code>hPutStr</code> is an <code>IO</code> action, while the
withdraw is an <code>STM</code> action, and the two cannot be combined in a single do
block. If we wrap a call to <code>atomically</code> around the <code>withdraw</code>, all is well:</p><pre><code class="haskell">good :: Account -&gt; IO ()
good acc = do 
    hPutStr stdout &quot;Withdrawing...&quot;
    atomically (withdraw acc 10)</code></pre><div class="hidden" title="Try it..."><p>This program compiles and runs:</p><pre><code class="active haskell">import System.IO
import Control.Concurrent.STM

type Account = TVar Int

withdraw :: Account -&gt; Int -&gt; STM ()
withdraw acc amount = do
    bal &lt;- readTVar acc    
    writeTVar acc (bal - amount)

good :: Account -&gt; IO ()
good acc = do
    hPutStr stdout &quot;Withdrawing...&quot;
    {-hi-}atomically{-/hi-} (withdraw acc 10)

main = do
    acc &lt;- atomically (newTVar 200)
    good acc 
    hPutStr stdout &quot;\nDone!\n&quot;</code></pre></div><h2 id="3-3-implementing-transactional-memory"><a href="#3-3-implementing-transactional-memory">3.3 Implementing transactional memory</a></h2><p>The guarantees of atomicity and isolation that I described earlier should be all
that a programmer needs in order to use STM. Even so, I often find it helpful
to have a reasonable implementation model to guide my intuitions, and I will
sketch one such implementation in this section. But remember that this is just
<i>one</i> possible implementation. One of the beauties of the STM abstraction is
that it presents a small, clean interface that can be implemented in a variety of
ways, some simple and some sophisticated.</p><p>One particularly attractive implementation is well established in the database
world, namely <i>optimistic execution</i>. When <code>(atomically act)</code> is performed, a
thread-local <i>transaction log</i> is allocated, initially empty. Then the action <code>act</code>
is performed, without taking any locks at all. While performing <code>act</code>, each call
to <code>writeTVar</code> writes the address of the <code>TVar</code> and its new value into the log; it
does not write to the <code>TVar</code> itself. Each call to <code>readTVar</code> first searches the log
(in case the <code>TVar</code> was written by an earlier call to <code>writeTVar</code>); if no such record
is found, the value is read from the <code>TVar</code> itself, and the <code>TVar</code> and value read
are recorded in the log. In the meantime, other threads might be running their
own atomic blocks, reading and writing <code>TVars</code> like crazy.</p><p>When the action <code>act</code> is finished, the implementation first <i>validates</i> the log and,
if validation is successful, <i>commits</i> the log. The validation step examines each
<code>readTVar</code> recorded in the log, and checks that the value in the log matches the
value currently in the real <code>TVar</code>. If so, validation succeeds, and the commit step
takes all the writes recorded in the log and writes them into the real <code>TVars</code>.</p><p>These steps are performed truly indivisibly: the implementation disables interrupts, or uses locks or compare-and-swap instructions — whatever is necessary
to ensure that validation and commit are perceived by other threads as completely indivisible. All of this is handled by the implementation, however, and
the programmer does not need to know or care how it is done.</p><p>What if validation fails? Then the transaction has had an inconsistent view of
memory. So we abort the transaction, re-initialise the log, and run <code>act</code> all over
again. This process is called <i>re-execution</i>. Since none of <code>act</code>’s writes have been
committed to memory, it is perfectly safe to run it again. However, notice that
it is crucial that act contains no effects <i>other than</i> reads and writes on <code>TVars</code>.
For example, consider</p><pre><code class="haskell">atomically (do x &lt;- readTVar xv
               y &lt;- readTVar yv
               if x&gt;y then launchMissiles
                      else return () )</code></pre><p>where <code>launchMissiles :: IO ()</code> causes serious international side-effects.
Since the atomic block is executed without taking locks, it might have an inconsistent view of memory if other threads are concurrently modifying <code>xv</code> and
<code>yv</code>. If that happens, it would be a mistake to launch the missiles, and only <i>then</i> discover that validation fails so the transaction should be re-run. Fortunately,
the type system prevents us running <code>IO</code> actions inside <code>STM</code> actions, so the above
fragment would be rejected by the type checker. This is another big advantage
of distinguishing the types of <code>IO</code> and <code>STM</code> actions.</p><div class="hidden" title="Try it..."><pre><code class="active haskell">import System.IO
import Control.Concurrent.STM

launchMissiles :: IO ()
launchMissiles = hPutStr stdout &quot;Zzzing!&quot;

main = do 
    xv &lt;- atomically (newTVar 2)
    yv &lt;- atomically (newTVar 1)
    atomically (do x &lt;- readTVar xv
                   y &lt;- readTVar yv
                   if x &gt; y then launchMissiles
                            else return () )
</code></pre></div><h2 id="3-4-blocking-and-choice"><a href="#3-4-blocking-and-choice">3.4 Blocking and choice</a></h2><p>Atomic blocks as we have introduced them so far are utterly inadequate to
coordinate concurrent programs. They lack two key facilities: <i>blocking</i> and
<i>choice</i>. In this section I’ll describe how the basic STM interface is elaborated
to include them in a fully-modular way.</p><p>Suppose that a thread should <i>block</i> if it attempts to overdraw an account (i.e.
withdraw more than the current balance). Situations like this are common in
concurrent programs: for example, a thread should block if it reads from an
empty buffer, or when it waits for an event. We achieve this in STM by adding
the single function <code>retry</code>, whose type is</p><pre><code class="haskell">retry :: STM a</code></pre><p>Here is a modified version of withdraw that blocks if the balance would go
negative:</p><pre><code class="haskell">limitedWithdraw :: Account -&gt; Int -&gt; STM ()
limitedWithdraw acc amount = do
    bal &lt;- readTVar acc
    if amount &gt; 0 &amp;&amp; amount &gt; bal
    then retry
    else writeTVar acc (bal - amount)</code></pre><div class="hidden" title="Try it..."><pre><code class="active haskell">import System.IO
import Control.Concurrent.STM
import Control.Concurrent

type Account = TVar Int

limitedWithdraw :: Account -&gt; Int -&gt; STM ()
limitedWithdraw acc amount = do
    bal &lt;- readTVar acc
    if amount &gt; 0 &amp;&amp; amount &gt; bal
    then retry
    else writeTVar acc (bal - amount)

delayDeposit acc amount = do
    hPutStr stdout &quot;Getting ready to deposit money...hunting through pockets...\n&quot;
    threadDelay 3000000
    hPutStr stdout &quot;OK! Depositing now!\n&quot;
    atomically ( do bal &lt;- readTVar acc
                    writeTVar acc (bal + amount) )

main = do
    acc &lt;- atomically (newTVar 100)
    forkIO (delayDeposit acc 1)
    hPutStr stdout &quot;Trying to withdraw money...\n&quot;
    atomically (limitedWithdraw acc 101)
    hPutStr stdout &quot;Successful withdrawal!\n&quot;</code></pre><p>We are forking a thread that calls <code>delayDeposit</code>, which waits for 3 seconds before depositing the amount. In the meanwhile <code>limitedWithraw</code> blocks because of insufficient funds. Soon after the deposit from the other thread goes through, <code>limitedWithdraw</code> succeeds.</p></div><p>The semantics of <code>retry</code> are simple: if a <code>retry</code> action is performed, the current
transaction is abandoned and retried at some later time. It would be correct to
<code>retry</code> the transaction immediately, but it would also be inefficient: the state of
the account will probably be unchanged, so the transaction will again hit the
<code>retry</code>. An efficient implementation would instead block the thread until some
other thread writes to <code>acc</code>. How does the implementation know to wait on <code>acc</code>?
Because the transaction read <code>acc</code> on the way to the <code>retry</code>, and that fact is
conveniently recorded in the transaction log.</p><p>The conditional in <code>limitedWithdraw</code> has a very common pattern: check that a
boolean condition is satisfied and, if not, <code>retry</code>. This pattern is easy to abstract
as a function, <code>check</code>:</p><pre><code class="haskell">check :: Bool -&gt; STM ()
check True  = return ()
check False = retry</code></pre><p>Now we can use <code>check</code> to re-express <code>limitedWithdraw</code> a little more neatly:</p><pre><code class="haskell">limitedWithdraw :: Account -&gt; Int -&gt; STM ()
limitedWithdraw acc amount = do
    bal &lt;- readTVar acc
    check (amount &lt;= 0 || amount &lt;= bal)
    writeTVar acc (bal - amount)</code></pre><div class="hidden" title="Try it..."><p>The same program using <code>check</code>, which is actually a library function:</p><pre><code class="active haskell">import System.IO
import Control.Concurrent.STM
import Control.Concurrent

type Account = TVar Int

limitedWithdraw :: Account -&gt; Int -&gt; STM ()
limitedWithdraw acc amount = do
    bal &lt;- readTVar acc
    check (amount &lt;= 0 || amount &lt;= bal)
    writeTVar acc (bal - amount)

delayDeposit acc amount = do
    threadDelay 3000000
    hPutStr stdout &quot;Depositing right now!\n&quot;
    atomically ( do bal &lt;- readTVar acc
                    writeTVar acc (bal + amount) )

main = do
    acc &lt;- atomically (newTVar 100)
    forkIO (delayDeposit acc 1)
    hPutStr stdout &quot;Withdrawing... Hope the deposit has cleared...\n&quot;
    atomically (limitedWithdraw acc 101)
    hPutStr stdout &quot;Oh, phew!\n&quot;</code></pre></div><p>We now turn our attention to <i>choice</i>. Suppose you want to withdraw money
from account A if it has enough money, but if not then withdraw it from account
B? For that, we need the ability to choose an alternative action if the first one
retries. To support choice, STM Haskell has one further primitive action, called
<code>orElse</code>, whose type is</p><pre><code class="haskell">orElse :: STM a -&gt; STM a -&gt; STM a</code></pre><p>Like <code>atomically</code> itself, <code>orElse</code> takes actions as its arguments, and glues them
together to make a bigger action. Its semantics are as follows. The action
<code>(orElse a1 a2)</code> first performs <code>a1</code>; if <code>a1</code> retries (i.e. calls <code>retry</code>), it tries <code>a2</code>
instead; if <code>a2</code> also retries, the whole action retries. It may be easier to see how
<code>orElse</code> is used:</p><pre><code class="haskell">limitedWithdraw2 :: Account -&gt; Account -&gt; Int -&gt; STM ()
-- (limitedWithdraw2 acc1 acc2 amt) withdraws amt from acc1,
-- if acc1 has enough money, otherwise from acc2.
-- If neither has enough, it retries.
limitedWithdraw2 acc1 acc2 amt
  = orElse (limitedWithdraw acc1 amt) (limitedWithdraw acc2 amt)</code></pre><div class="hidden" title="Try it..."><pre><code class="active haskell">import System.IO
import Control.Concurrent.STM
import Control.Concurrent

type Account = TVar Int

limitedWithdraw :: Account -&gt; Int -&gt; STM ()
limitedWithdraw acc amount = do
    bal &lt;- readTVar acc
    check (amount &lt;= 0 || amount &lt;= bal)
    writeTVar acc (bal - amount) 

showAcc name acc = do
    bal &lt;- atomically (readTVar acc)
    hPutStr stdout (name ++ &quot;: $&quot;)
    hPutStr stdout (show bal ++ &quot;\n&quot;)

limitedWithdraw2 :: Account -&gt; Account -&gt; Int -&gt; STM ()
-- (limitedWithdraw2 acc1 acc2 amt) withdraws amt from acc1,
-- if acc1 has enough money, otherwise from acc2.
-- If neither has enough, it retries.
limitedWithdraw2 acc1 acc2 amt
  = orElse (limitedWithdraw acc1 amt) (limitedWithdraw acc2 amt)
  
delayDeposit name acc amount = do
    threadDelay 3000000
    hPutStr stdout (&quot;Depositing $&quot; ++ show amount ++ &quot; into &quot; ++ name ++ &quot;\n&quot;)
    atomically ( do bal &lt;- readTVar acc
                    writeTVar acc (bal + amount) )

main = do
    acc1 &lt;- atomically (newTVar 100)
    acc2 &lt;- atomically (newTVar 100)
    showAcc &quot;Left pocket&quot; acc1
    showAcc &quot;Right pocket&quot; acc2
    forkIO (delayDeposit &quot;Right pocket&quot; acc2 1)
    hPutStr stdout &quot;Withdrawing $101 from either pocket...\n&quot;
    atomically (limitedWithdraw2 acc1 acc2 101)
    hPutStr stdout &quot;Successful withdrawal!\n&quot;
    showAcc &quot;Left pocket&quot; acc1
    showAcc &quot;Right pocket&quot; acc2</code></pre><p>We use a helper function <code>showAcc</code> to display the contents of accounts before and after the withdrawal. We have two accounts, <code>acc1</code> and <code>acc2</code>, both with insufficient funds for the <code>limitedWithdraw2</code> to succeed immediately. However, when the background thread deposits $1 into <code>acc2</code>, the call succeeds.</p></div><p>Since the result of <code>orElse</code> is itself an <code>STM</code> action, you can feed it to another call
to <code>orElse</code> and so choose among an arbitrary number of alternatives.</p><h2 id="3-5-summary-so-far"><a href="#3-5-summary-so-far">3.5 Summary so far</a></h2><p>In this section I have introduced all the key transactional memory operations
supported by STM Haskell. They are summarised in Figure 1.</p><p><img alt="STM.PNG" src="https://www.schoolofhaskell.com/content-proxy?src=https%3A%2F%2Fwww.fpcomplete.com%2Fmedia%2Fdb5dbe9d-7461-45c1-b1d2-ca6da66be69e.png" /></p><p>This figure
includes one operation that has not so far arisen: <code>newTVar</code> is the way in which
you can create new <code>TVar</code> cells, and we will use it in the following section.</p><p>» <a href="4-the-santa-claus-problem">Next: The Santa Claus problem</a>.</p><hr /><p> <sup>2</sup> You may think it odd that there are three function arrows in this type signature, rather
than one. That’s because Haskell supports <i>currying</i>, which you can find described in any
book about Haskell (e.g. [13]), or on <a href="http://en.wikipedia.org/wiki/Currying">Wikipedia</a>. For the purposes of this paper, simply treat
all the types except the final one as arguments.</p><p> <sup>3</sup> In Haskell we write function application using simple juxtaposition. In most languages you
would write <code>hPutStr(h,&quot;hello&quot;)</code>, but in Haskell you write simply <code>(hPutStr h &quot;hello&quot;)</code>.</p><p> <sup>4</sup> A <code>Handle</code> in Haskell plays the role of a file descriptor in C: it says which file or pipe to
read or write. As in Unix, there are three pre-defined handles, <code>stdin</code>, <code>stdout</code>, and <code>stderr</code>.</p><p> <sup>5</sup> The <code>(++)</code> operator concatenates two strings.</p><p> <sup>6</sup> The <code>IO</code> type indicates the <i>possibility</i> of side effects, not the certainty!</p><p> <sup>7</sup> In the first line of <code>main</code>, we could instead have written <code>tid &lt;- forkIO (hPutStr ...)</code>,
to bind the <code>ThreadId</code> returned by <code>forkIO</code> to <code>tid</code>. However, since we do not use the returned
<code>ThreadId</code>, we are free to discard it by omitting the “<code>tid &lt;-</code>” part.</p><p> <sup>8</sup> The nomenclature is inconsistent here: it would be more consistent to use either <code>TVar</code> and
<code>IOVar</code>, or <code>TRef</code> and <code>IORef</code>. But it would be disruptive to change at this stage; for better or
worse we have <code>TVar</code> and <code>IORef</code>.</p><p> <sup>9</sup> This overloading of <code>do</code>-notation and <code>return</code> is not an ad-hoc trick to support <code>IO</code> and
<code>STM</code>. Rather, <code>IO</code> and <code>STM</code> are both examples of a common pattern, called a <i>monad</i> [15], and
the overloading is achieved by expressing that common pattern using Haskell’s very general
<i>type-class</i> mechanism [16, 10].</p><hr /><p>[9] Simon Peyton Jones. Tackling the awkward squad: monadic input/output,
concurrency, exceptions, and foreign-language calls in Haskell. In CAR
Hoare, M Broy, and R Steinbrueggen, editors, <i>Engineering Theories of
Software Construction, Marktoberdorf Summer School 2000</i>, NATO ASI
Series, pages 47–96. IOS Press, 2001.</p><p>[10] Simon Peyton Jones, Mark Jones, and Erik Meijer. Type classes: an exploration of the design space. In J Launchbury, editor, <i>Haskell workshop</i>,
Amsterdam, 1997.</p><p>[13] SJ Thompson. <i>Haskell: the craft of functional programming.</i> Addison
Wesley, 1999.</p><p>[15] PL Wadler. The essence of functional programming. In <i>20th ACM Sym-
posium on Principles of Programming Languages (POPL’92)</i>, pages 1–14.
ACM, Albuquerque, January 1992.</p><p>[16] PL Wadler and S Blott. How to make ad-hoc polymorphism less ad hoc.
In <i>Proc 16th ACM Symposium on Principles of Programming Languages,
Austin, Texas</i>. ACM, January 1989.</p></article>


</div>
</div>
<div class="row article-footer"><div class="span7 meta"><span class="sociallinksunicode social">
<a href="https://twitter.com/home?status=$url$" target="_blank"><i class="icon-twitter"></i></a>&nbsp;
<a href="http://www.facebook.com/sharer/sharer.php?u=$url$" target="_blank"><i class="icon-facebook"></i></a>&nbsp;
<a href="https://plus.google.com/share?url=$url$" target="_blank"><i class="icon-google-plus"></i></a></span>
</div>
</div>
</div>
<div class="footer"><div class="container"><div class="row"><div class="span12"><ul class="menu"><li><a href="https://www.schoolofhaskell.com/">School</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user">Users</a>
</li>

<li><a class="brand" href="https://fpcomplete.com">Sponsored by:
<img src="/static/img/logo.png" title="FPComplete">
</a>
</li>
</ul>
</div>
</div>
<div class="row"><div class="span12"></div>
</div>
</div>
</div>
<link rel="stylesheet" type="text/css" href="/static/bootstrap/css/bootstrap-responsive.css" />
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script><script src="https://www.schoolofhaskell.com/static/combined/Y-3k9_tW.js"></script><script>$(function(){
  $("a.logout").click(function(){
    var form = $("<form method='post'/>");
    form.attr("action", $(this).attr("href"));
    $("body").append(form);
    form.submit();
    return false;
  });
});

$(function(){
    $('.sociallinksunicode a').each(function(){
        $(this).attr('href',$(this).attr('href').replace('$url$',document.location));
    });
});

$(function(){
  // If we need to select a user/select a password then show the
  // details confirmation form, otherwise enable the getting started
  // section.
  if($('.alert-block a').text().match(/(selected a username|change your password)/)) {
    $("#confirm-details").show();
    $("#confirm-details #inputUsername").focus();
  } else {
    $("#get-started").removeClass('disabled').addClass('enabled');
  }

  // For lack of a plain HTML validation story this will do.
  $('.welcome-page').each(function(){
    $('form').submit(check);
  });
  function check(){
    setTimeout(check,500);
    var error = false;
    $('.error').removeClass('error');
    $('#enter-details input').each(function(){
      if($(this).val() == '') {
        $(this).parent().parent().addClass('error');
        error = true;
      }
    });
    if(error) return false;
    if($('[name=password]').val() == $('[name=confirm]').val()) {
      $('#confirm').removeClass('error');
      return true;
    } else {
      $('#confirm').addClass('error');
      return false;
    }
  }
});

$(function(){
  // When scrolling over a snippet editor, activate the "clone in IDE" popovers
  $('article').each(function(){
    var n = 100;
    var wait = 10000;
    function check(){
      if($('.clone').length == 0) {
        setTimeout(check,n);
        return;
      }
      var activated = $.cookie('clone-popover');
      if (activated) return;
      var activate = false;
      $('.controlsRun:onScreen').each(function(){
        $.cookie('clone-popover', 'true', { expires: 30, path: '/' });
        activate = true;
        return false;
      });
      if(activate) {
          $('.clone').each(function(){
              // The bootstrap API is rather unreasonable to say the
              // least.
              next = $(this).parent();
              var title = next.attr('title');
              next.attr('data-content',$(this).attr('data-content'));
              next.attr('title',$(this).attr('title'));
              next.popover('show',{
                  title: $(this).attr('title')
              });
              next.attr('title',title);
          });
          setTimeout(function(){
              $('.clone').each(function(){
                  $(this).parent().popover('hide');
              });
          },wait);
      } else {
        setTimeout(check,n);
      }
    }
    setTimeout(check,n);
  });
});

// onScreen jQuery plugin v0.2.1
// (c) 2011-2013 Ben Pickles
//
// http://benpickles.github.com/onScreen
//
// Released under MIT license.
(function(a){a.expr[":"].onScreen=function(b){var c=a(window),d=c.scrollTop(),e=c.height(),f=d+e,g=a(b),h=g.offset().top,i=g.height(),j=h+i;return h>=d&&h<f||j>d&&j<=f||i>e&&h<=d&&j>=f}})(jQuery);

/*!
 * jQuery Cookie Plugin v1.1
 * https://github.com/carhartl/jquery-cookie
 *
 * Copyright 2011, Klaus Hartl
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.opensource.org/licenses/GPL-2.0
 */
(function($, document) {

  var pluses = /\+/g;
  function raw(s) {
    return s;
  }
  function decoded(s) {
    return decodeURIComponent(s.replace(pluses, ' '));
  }

  $.cookie = function(key, value, options) {

    // key and at least value given, set cookie...
    if (arguments.length > 1 && (!/Object/.test(Object.prototype.toString.call(value)) || value == null)) {
      options = $.extend({}, $.cookie.defaults, options);

      if (value == null) {
	options.expires = -1;
      }

      if (typeof options.expires === 'number') {
	var days = options.expires, t = options.expires = new Date();
	t.setDate(t.getDate() + days);
      }

      value = String(value);

      return (document.cookie = [
	encodeURIComponent(key), '=', options.raw ? value : encodeURIComponent(value),
	options.expires ? '; expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE
	options.path    ? '; path=' + options.path : '',
	options.domain  ? '; domain=' + options.domain : '',
	options.secure  ? '; secure' : ''
      ].join(''));
    }

    // key and possibly options given, get cookie...
    options = value || $.cookie.defaults || {};
    var decode = options.raw ? raw : decoded;
    var cookies = document.cookie.split('; ');
    for (var i = 0, parts; (parts = cookies[i] && cookies[i].split('=')); i++) {
      if (decode(parts.shift()) === key) {
	return decode(parts.join('='));
      }
    }
    return null;
  };
  $.cookie.defaults = {};})(jQuery, document);
</script><!--[if lt IE 10]><script src="https://www.schoolofhaskell.com/static/design/js/ie.js?etag=ayV2DuJ0"></script><![endif]--><script>if(!window.location.href.match(/localhost/)){var track = '/tutorial/user/simonpj/beautiful-concurrency/3-software-transactional-memory';
window._gaq = [['_setAccount','UA-36928035-1'],track != ''? ['_trackPageview',track] : ['_trackPageview']
,['_trackPageLoadTime']];window._gaq.push(['_setCustomVar',1,'Section','School of Haskell',3]);
window._gaq.push(['_setCustomVar',2,'User Type','Visitor',1]);
(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);

})();}</script>
<!-- Prompt IE 6 users to install Chrome Frame. Remove this if you want to support IE 6.  chromium.org/developers/how-tos/chrome-frame-getting-started --><!--[if lt IE 7 ]><script src="//ajax.googleapis.com/ajax/libs/chrome-frame/1.0.3/CFInstall.min.js"></script><script>window.attachEvent('onload',function(){CFInstall.check({mode:'overlay'})})</script><![endif]--></body></html>