<!DOCTYPE html>
<html><head><title>Working with databases using Groundhog - School of Haskell | School of Haskell</title><meta http-equiv="x-ua-compatible" content="IE=9"><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="google-site-verification" content="Rfxk2TdeMMXEXHgJ2_OO8Rt3hPbQSDao0OXQV_n6z_s" /><link href="//fonts.googleapis.com/css?family=Merriweather" rel="stylesheet" type="text/css"><link href="https://www.schoolofhaskell.com/recent-content/feed" type="application/rss+xml" rel="alternate" title="Recently published content">
<link rel="stylesheet" href="https://www.schoolofhaskell.com/static/combined/UlwEHVcM.css"><style>.social{margin-right:1em}h1{font-family:Merriweather !important}article{font-family:Merriweather !important}article li{font-family:Merriweather !important;line-height:1.6em}h1,h2,h3,h4,h4,h5{font-family:Merriweather !important}.editor p{font-family:Frutiger, "Frutiger Linotype", Univers, Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans Condensed", "Liberation Sans", "Nimbus Sans L", Tahoma, Geneva, "Helvetica Neue", Helvetica, Arial, sans-serif}.article-footer{border-top:1px solid #ddd;padding-top:1em;margin-top:1em}body{font-size:16px !important}.navbar .navbar-inner{background:#3c3f41}.navbar .brand{font-size:14px}.navbar .brand img{width:6em}.navbar .icon-wrench{margin:0 -0.5em 0 -0.5em;padding:0 1em 0 1em;height:20px}.navbar-inverse .nav .active a{background:#333638}.navbar-inverse .nav > li > a{color:#a7a7a7
}.navbar-inverse .btn-navbar{background:#333638}.navbar-inverse .nav > li a:hover,.navbar-inverse .btn{background:#333537 !important}@media (max-width: 979px) {.icon-wrench{padding-left:1em !important}}.breadcrumb{border-top-left-radius:0;border-top-right-radius:0}h1{margin-top:20px}.breadcrumb-container + .main-content h1{margin-top:0}.footer{padding:30px 0;margin-top:70px;border-top:1px solid #e5e5e5;background-color:#f5f5f5}.footer ul.footer-menu{list-style-type:none}.footer ul.footer-menu li{display:inline-block}.footer ul.footer-menu li + li{margin-left:0.5em}.footer ul.footer-menu li + li:before{margin-right:0.5em;content:"·";color:#999}.footer ul.menu li{display:inline-block}.footer ul.menu li + li{margin-left:0.5em}.footer .copyright{margin-left:25px}.main-content{min-height:100%}.gravatar{width:80px;height:80px;border-radius:2px;background:#eee}.empty-gravatar{width:0}.container{font-family:"Segoe UI", Candara, "Bitstream Vera Sans", "DejaVu Sans", "Bitstream Vera Sans", "Trebuchet MS", Verdana, "Verdana Ref", sans-serif}.container h1,.container h2,.container h4,.container h4,.container h5{font-family:"Segoe UI", Candara, "Bitstream Vera Sans", "DejaVu Sans", "Bitstream Vera Sans", "Trebuchet MS", Verdana, "Verdana Ref", sans-serif}article{font-family:Merriweather !important}article h1{font-family:Merriweather !important}article li{font-family:Merriweather !important;line-height:1.6em}article li + li{margin-top:0.5em}article div.code{background:#f9f9f9;border:1px solid #d1d1d1;position:relative;border-radius:0.2em;margin:0.25em 0 0.75em 0;min-height:2.5em}article code{color:#005580;font-size:14px;white-space:pre}article a.hoogle > code{color:#0088cc;font-size:14px;white-space:pre;border:0}article .expand-code{display:none}article pre{overflow:auto;word-wrap:normal}article code.active{display:block;max-height:430px}article h1{font-size:31.5px}article h3{font-size:17.5px}article h4{font-size:14px}article h5,article h6{font-size:11.9px}article p{line-height:1.7em}article h1 code,article h2 code,article h3 code,article h4 code,article h5 code,article h6 code{font-size:inherit !important}article h1 a,article h2 a,article h3 a,article h4 a,article h5 a,article h6 a{color:#444}article h1 a:before,article h2 a:before,article h3 a:before,article h4 a:before,article h5 a:before,article h6 a:before{margin-left:-1.5em;padding-right:0.5em;font-family:fontawesome;content:"\f0c1";font-size:20px;color:#fff}article h1 a:hover,article h2 a:hover,article h3 a:hover,article h4 a:hover,article h5 a:hover,article h6 a:hover{text-decoration:none;color:#0088cc}article h1 a:hover:before,article h2 a:hover:before,article h3 a:hover:before,article h4 a:hover:before,article h5 a:hover:before,article h6 a:hover:before{color:#888}article h2{font-size:24.5px}article .popover{font-family:actor}article .popover h3.popover-title{font-family:actor !important;font-size:1em}article .popover .popover-content{width:15em;font-size:1em}article .controlsRun{display:block;padding:0.5em;text-align:right;background:#f2f2f2}article .controlsRun a.clone{margin-right:1em;font-family:actor;text-decoration:none}article .controlsRun a.clone span{padding-left:0.5em}article .controlsRun a.run,article .controlsRun a.reset,article .controlsRun a.show-code{font-size:16px}article .controlsRun a.run span,article .controlsRun a.reset span,article .controlsRun a.show-code span{display:none}article .controlsRun a.reset{margin-left:0.5em;color:#a2becc}article .controlsRun a.reset{display:none}article .controlsRun a.show-code{margin-right:0.75em}article .controlsRun a.run:hover,article .controlsRun a.show-code:hover{text-decoration:none}article .controlsRun a.show-code.active{color:#DC0D0D}article .controlsRun a[disabled]{color:#a2becc;cursor:default}article .collapse-area .collapse-header{background:#0088cc;color:#fff;padding:0.3em;cursor:pointer}article .collapse-area .hidden-toggle:before{content:"\f0d7";font-family:fontawesome;margin-right:0.5em;margin-left:0.25em}article .collapse-area .collapsed-files{overflow:auto;height:auto}article .collapse-area.collapse-disabled{display:none}article .collapse-area.collapse-area-off .collapsed-files{height:0px;overflow:hidden}article .collapse-area.collapse-area-off .hidden-toggle:before{content:"\f0da"}article .snippet-stdio .stdout{margin:0.5em;padding-right:2em;position:relative;word-wrap:break-word}article .snippet-stdio .stdin{-webkit-box-shadow:none;-moz-box-shadow:none;box-shadow:none;-webkit-transition:none;-moz-transition:none;-o-transition:none;transition:none;padding:0;margin:0}article .hoogle-results{margin:0.25em}article .hoogle-results .hoogle-inner{background:#fff;padding:0.5em;border-radius:3px;border:1px solid #ddd}article .hoogle-results .hoogle-inner .close-link{position:relative;float:right;margin-top:-0.5em;margin-right:-0.5em}article .snippet-output-errors{margin:1em 0.5em 0.5em 0.5em;position:relative}article .snippet-output-errors ul{list-style-type:none;margin:0;position:relative}article .snippet-output-errors pre{border:0;border-radius:0;padding:0.25em;margin:0;background:inherit;color:inherit}article .snippet-output-errors .close-link{color:inherit;background:inherit}article .snippet-editors{z-index:0;padding:0.25em}article .close-link{padding:0.5em;background:#eaeaea;border-bottom-left-radius:0.2em;border-top-right-radius:0.2em;position:absolute;top:0;right:0}article .close-link:hover{text-decoration:none}article .snippet-title{padding:0.5em 0 0 0.5em}article .snippet-title .snippet-icon{font-family:FontAwesome;display:inline-block;margin-right:0.5em}article .fullModuleCode + div .snippet-title{margin-top:0.5em;border-top:1px solid #ccc;padding-top:0.5em}article .CodeMirror{height:auto;min-height:1em;line-height:1.5em;background:transparent;font-size:14px !important}article .CodeMirror .highlighted{background:rgba(250, 210, 0, 0.45) !important}article .CodeMirror-widget{margin-left:2em;line-height:1.8}article .CodeMirror.collapsed{height:10em !important}article .editor .expander{text-align:center;display:block;padding:0.5em;text-decoration:none;border-bottom-left-radius:2px;border-bottom-right-radius:2px}article .editor .expander .ellipsis{background:white;border:1px solid #ccc;padding:0 0.5em;height:1em;line-height:0.5em;display:inline-block;color:#555;cursor:pointer}article .editor .expander .ellipsis:hover{background:#ddd;color:#333}article .web-runner{margin:0.5em;padding:0.5em;border:1px solid #ccc;border-radius:3px;background:#f5f5f5}article .web-runner iframe{border:0;margin-top:0.5em;margin-bottom:0;background:white}article .web-runner .controls i{cursor:pointer;color:#0088cc}article .web-runner .controls i:hover{color:#222}article .web-runner .controls i + i{margin-left:0.5em}article .web-runner .controls .icon-remove{float:right}article .hidden{display:block;visibility:visible}article .controlsShowHide{margin-bottom:0.5em}.tutorial-body{float:left !important}.tutorial-nav{float:right !important}@media (max-width: 979px) {.related-content{float:right}.author-name{display:block;margin-left:20px !important;padding-left:5px;margin-top:5px}article h1 a:hover:before,article h2 a:hover:before,article h3 a:hover:before,article h4 a:hover:before,article h5 a:hover:before,article h6 a:hover:before{color:#fff}.tutorial-nav{float:none !important;width:auto !important}.tutorial-body{float:none !important;width:auto !important}}@media (min-width: 980px) and (max-width: 1199px) {.navbar-search{display:none}.tutorial-nav{width:200px}.tutorial-body{width:720px}}#accountPage h1{margin:20px 0 0 0}#accountPage h2{font-size:20px}.group-contents .span8{float:left}.group-contents .span4{float:right}.container > .alert-block{margin-top:1em}.alert{color:#aa874a
}.social{margin-bottom:.8em;display:block}.social a{text-decoration:none}.social i{font-size:1.1em;color:#fff;padding:0.25em;border-radius:0.25em;width:1em;display:inline-block;text-align:center}.social i.icon-twitter{background:#0088cc}.social i.icon-facebook{background:#3b5998
  }.social i.icon-google-plus{background:#dd4b39
  }.well pre{background:#fcfcfc}.well h2{margin-top:0}code{color:#005580;font-size:14px;white-space:pre}</style><!--[if lt IE 8]><link rel="stylesheet" href="https://www.schoolofhaskell.com/static/design/css/ie7.css?etag=TSMl9x1V"><![endif]--><!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]--></head><body class="not-logged-in" itemscope itemtype="http://schema.org/Product"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-H62P" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-H62P');</script><div class="navbar navbar-inverse navbar-static-top"><div class="navbar-inner"><div class="container"><a class="btn btn-navbar" type="button" data-toggle="collapse" data-target=".nav-collapse"><span class="icon-bar"></span>
<span class="icon-bar"></span>
<span class="icon-bar"></span>
</a>
<a class="brand" href="/"><img src="/static/img/haskell-logo-wide.png" title="School of Haskell">
</a>
<div class="nav-collapse collapse"><ul class="nav"><li><a href="https://www.schoolofhaskell.com/">School</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user">Users</a>
</li>
</ul>
<form class="navbar-search pull-left" action="https://www.schoolofhaskell.com/search"><input class="search-query" type="text" placeholder="Search" name="search">
</form>
</div>
</div>
</div>
</div>
<div class="container breadcrumb-container"><div class="row"><div class="span12"><ul class="breadcrumb"><li><a href="https://www.schoolofhaskell.com/">School of Haskell</a>
<span class="divider">/</span>
</li>
<li><a href="https://www.schoolofhaskell.com/school/to-infinity-and-beyond">To infinity and beyond</a>
<span class="divider">/</span>
</li>
<li><a href="https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week">Pick of the Week</a>
<span class="divider">/</span>
</li>
<li><a href="https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/groundhog">Working with databases using Groundhog</a>
</li>
</ul>
</div>
</div>
</div>
<div class="container main-content"><div class="row"><div class="span12"><h1 itemprop="name">Working with databases using Groundhog</h1>
</div>
</div>
<div class="row"><div class="span7 meta"><p><span class="date">13 Nov 2013</span>
<span class="author"><a href="https://www.schoolofhaskell.com/user/lykahb">lykahb</a>
</span>
<span class="view-edit-link pull-right"><a class="view-source-link" href="https://www.schoolofhaskell.com/tutorial-raw/2969/378584572e9569435988936c54ff4acafcacac34">View Markdown source</a>
</span>
</p>
<p class="tags"></p>
</div>
</div>
<div class="row"><div class="span7 meta"><span class="sociallinksunicode social">
<a href="https://twitter.com/home?status=$url$" target="_blank"><i class="icon-twitter"></i></a>&nbsp;
<a href="http://www.facebook.com/sharer/sharer.php?u=$url$" target="_blank"><i class="icon-facebook"></i></a>&nbsp;
<a href="https://plus.google.com/share?url=$url$" target="_blank"><i class="icon-google-plus"></i></a></span>
</div>
</div>
<p class="alert">As of March 2020, School of Haskell has been switched to read-only mode.</p>
<div class="row" itemprop="desc"><div class="span4 tutorial-nav"><div class="related-content"><ul class="nav nav-tabs nav-stacked"><li><script>reddit_target='fpcomplete'</script>
<script src="https://redditstatic.s3.amazonaws.com/button/button1.js"></script>
</li>
<li><a href="https://www.schoolofhaskell.com/user/school/to-infinity-and-beyond/pick-of-the-week/coinChange">Previous content: coin change</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user/school/to-infinity-and-beyond/pick-of-the-week/part-3">Next content: Part III: A World in a Bottle</a>
</li>
<li><a href="https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week">Go up to: Pick of the Week</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user/lykahb">See all content by lykahb</a>
</li>
</ul>

</div>
<div class="aside"><h3>Sections</h3>
<ul><li><a href="#let-s-get-started-">Let&#39;s get started!</a></li><li><a href="#types-and-classes">Types and classes</a><ul><li><a href="#persistentity">PersistEntity</a></li><li><a href="#mapping-fields-to-columns">Mapping fields to columns</a></li><li><a href="#backend">Backend</a></li></ul></li><li><a href="#keys-and-references">Keys and references</a></li><li><a href="#queries-and-data-manipulation">Queries and data manipulation</a><ul><li><a href="#inserting">Inserting</a></li><li><a href="#modification">Modification</a></li><li><a href="#selecting-data">Selecting data</a></li><li><a href="#expressions">Expressions</a></li></ul></li><li><a href="#embedded-data-types">Embedded data types</a></li></ul></div>
</div>
<div class="span8 tutorial-body" data-environment="def">
<article><p>The object-oriented languages have had high-level Object-Relational Mapping (ORM) tools for a long time. ORM is a layer over the relational storage which allows to manipulate DB using code idiomatic for the language. Groundhog brings this idea to Haskell being an ADT-Relational Mapping library. In a type-safe manner it handles data serialization, schema migration, supports complex queries, and increases portability by providing database-independent API, just to name a few. It ensures that your database, datatypes, and generated queries are coherent, making it easier to follow the DRY principle (Don't Repeat Yourself).</p><p>One of the Groundhog goals is not to restrict neither datatypes, nor database schema. Your Haskell datatypes may have type parameters, or several constructors. Your relational schema may have composite primary keys, indexes, references across several schemas. Groundhog will bind them together with minimal configuration.</p><h2 id="let-s-get-started-"><a href="#let-s-get-started-">Let's get started!</a></h2><p>After the language extensions and imports there are our data definitions.</p><pre><code class="haskell">{-# LANGUAGE GADTs, TypeFamilies, TemplateHaskell, QuasiQuotes, FlexibleInstances, StandaloneDeriving #-}
import Control.Monad.IO.Class (liftIO)
import Database.Groundhog.TH
import Database.Groundhog.Sqlite

data Customer = Customer {
  customerName :: String,
  phone :: String
} deriving Show
data Product = Product {
  productName :: String,
  quantity :: Int,
  customer :: DefaultKey Customer
}
deriving instance Show Product</code></pre><p>This schema demonstrates plain relationship. The ordered Product references Customer through its default key. Groundhog supports many types of keys, but by default it chooses autoincremented integer key. Instead of a universal <code>Show (Key v r)</code> instance there are separate instances for each entity, so we have to use standalone deriving instances to create the <code>Show</code> instance for <code>Product</code>.</p><p>Then Template Haskell assisted by QuasiQuotation comes into play.</p><pre><code class="yaml">mkPersist defaultCodegenConfig [groundhog|
- entity: Customer               # Name of the datatype
  constructors:
    - name: Customer
      fields:
        - name: customerName
          # Set column name to &quot;name&quot; instead of &quot;customerName&quot;
          dbName: name
      uniques:
        - name: NameConstraint
          fields: [customerName] # Inline format of list
- entity: Product
|]</code></pre><p>Function <code>mkPersist</code> creates all instances and definitions for you datatypes so that they can be used mapped to the tables. The datatypes you want to map to database are described in the list of entities. Groundhog analyzes the structure of each datatype and automatically creates its description which is used for codegeneration. The defaults in the description can be overridden explicitly through configuration written in YAML. It is a more readable superset of JSON. Each new item in YAML's multiline lists starts with hyphen+space. In the associative arrays keys and values are separated by colon+space.</p><p>For example, to change a field column name we access its constructor <code>Customer</code> at first. To do this we  access list with constructors by its &quot;constructors&quot; key. Then we choose an element from the list by its &quot;name&quot; key. In a similar way we access a field by its &quot;name&quot; in the &quot;fields&quot; list. Adding new parts to the description (e.g., unique constraints) follows the same convention as overriding the default values of description. In this example we leave the default values for Product, so a single line is enough.</p><p>Now let's connect to Sqlite and see Groundhog in action!</p><pre><code class="active haskell">-- show
-- /show
{-# LANGUAGE GADTs, TypeFamilies, TemplateHaskell, QuasiQuotes, FlexibleInstances, StandaloneDeriving #-}
import Control.Monad.IO.Class (liftIO)
import Database.Groundhog.TH
import Database.Groundhog.Sqlite

data Customer = Customer {
  customerName :: String,
  phone :: String
} deriving Show
data Product = Product {
  productName :: String,
  quantity :: Int,
  customer :: DefaultKey Customer
}
deriving instance Show Product

mkPersist defaultCodegenConfig [groundhog|
- entity: Customer               # Name of the datatype
  constructors:
    - name: Customer
      fields:
        - name: customerName
          # Set column name to &quot;name&quot; instead of &quot;customerName&quot;
          dbName: name
      uniques:
        - name: NameConstraint
          fields: [customerName] # Inline format of list
- entity: Product
|]
-- show
main :: IO ()
main = withSqliteConn &quot;:memory:&quot; $ runDbConn $ do
  runMigration defaultMigrationLogger $ do
    migrate (undefined :: Customer)
    migrate (undefined :: Product)
  johnKey &lt;- insert $ Customer &quot;John Doe&quot; &quot;0123456789&quot;
  get johnKey &gt;&gt;= liftIO . print
  insert $ Product &quot;Oranges&quot; 3 johnKey
  insert $ Product &quot;Apples&quot; 5 johnKey
  janeKey &lt;- insert $ Customer &quot;Jane Doe&quot; &quot;9876543210&quot;
  insert $ Product &quot;Oranges&quot; 4 janeKey
  johnOrders &lt;- select $ (CustomerField ==. johnKey)
    `orderBy` [Asc ProductNameField]
  liftIO $ putStrLn $ &quot;Products for John: &quot; ++ show johnOrders
-- /show</code></pre><p>The <code>main</code> starts from opening connection using bracket-like function <code>withSqliteConn</code>. The function <code>runDbConn</code> runs the code block within a transaction. If an exception is thrown within transaction, it will be rolled back. The next step is migration that compares the existing schema in DB with expected one and produces a script to alter DB. It can create schema from scratch, or alter it. The list of entities to be migrated is passed to <code>runMigration</code>. Enumerating all entities explicitly is a good style, but Groundhog tracks references and it would behave the same even if there were only <code>Product</code> because it has key of <code>Customer</code>.</p><p>The insert returns value of the autoincremented key <code>johnKey</code> for the newly inserted customer John Doe. We use it to <code>get</code> the data back from DB and as a foreign key for Products. Function <code>select</code> receives a combination of condition and other options, namely ordering, limit, and offset.</p><h2 id="types-and-classes"><a href="#types-and-classes">Types and classes</a></h2><p>There are classes for three main abstractions: mapping datatypes to a tables, mapping datatype field to columns, and backend.</p><h3 id="persistentity"><a href="#persistentity">PersistEntity</a></h3><p>Class <code>PersistEntity</code> is necessary to map an entity to a table. The CRUD operations and migration work only with instances of this class. It has data family <code>Field</code> which is used in queries to refer to columns. <code>ProductNameField</code> and <code>QuantityField</code> we saw above are constructors of its instances. Also it has data family <code>Key</code> that defines what kinds of keys we have.</p><h3 id="mapping-fields-to-columns"><a href="#mapping-fields-to-columns">Mapping fields to columns</a></h3><p>Each database can have its own format of data. It is inconvenient to work with this format or with values of the original field types. So we have an intermediate type <code>PersistValue</code> for uniform data representation. This sum type stores numbers, strings, dates, etc. The information is converted in directions field &lt;-&gt; PersistValue &lt;-&gt; column.</p><p>However, conversion between fields and PersistValues is not straightforward because Groundhog has embedded datatypes corresponding to several columns. Some fields may require access to other tables, so we need a monad in the signature. There are four typeclasses whose conversion functions types capture these specifics and they form a hierarchy from the general <code>PersistField</code> to the most restricted <code>PrimitivePersistField</code>.</p><table>
    <tr><td></td><td>Single column</td><td>Multiple columns</td></tr> 
    <tr><td>Pure</td><td><code>PrimitivePersistField</code></td><td><code>PurePersistField</code></td></tr>
    <tr><td>Non-pure </td><td><code>SinglePersistField</code></td><td><code>PersistField</code></td></tr>
</table> <br /><p>Here we show functions from <code>PersistField</code>. Similar functions from the other typeclasses have simpler signatures without monad or with a single <code>PersistValue</code> instead of a list.</p><code>toPersistValues :: PersistBackend m =&gt; a -&gt; m ([PersistValue] -&gt; [PersistValue])</code> returns a difference list.
<code>fromPersistValues :: PersistBackend m =&gt; [PersistValue] -&gt; m (a, [PersistValue])</code> creates a value taking several elements from the list and returns it together with list leftovers.<p>Let's define instances for an enum:</p><pre><code class="haskell">data Cutlery = Spoon | Fork | Knife | Spork
  deriving (Enum, Show, Read)

instance PersistField Cutlery where
  persistName _ = &quot;Cutlery&quot;
  -- primToPersistValue are from Database.Groundhog.Generic
  toPersistValues = primToPersistValue
  fromPersistValues = primFromPersistValue
  -- is stored as string column, not nullable, no default value, no reference
  dbType _ = DbTypePrimitive DbString False Nothing Nothing

instance PrimitivePersistField Cutlery where
  toPrimitivePersistValue p a = toPrimitivePersistValue p $ show a
  fromPrimitivePersistValue p x = read $ fromPrimitivePersistValue p x</code></pre><p>Now <code>WeekDay</code> can be stored in database and queried in expressions like <code>MyField ==. Friday</code>.</p><p>These classes are handy to do conversion from one type to another:</p><pre><code class="haskell">myKey &lt;- insert user
myInt &lt;- toSinglePersistValue myKey &gt;&gt;= fromSinglePersistValue
liftIO $ print (myInt :: Int)</code></pre><h3 id="backend"><a href="#backend">Backend</a></h3><p>Class <code>PersistBackend</code> defines what operations backends support. Its functions generate SQL, do marshall and unmarshalling, and talk to a database. It is the top-level interface for manipulating data in DB, so the most application calls to Groundhog will be through it. The inserts, selects, migrations and other operations are executed within its instance. There is a separate instance for each backend. This both keeps code simple and gives high performance because we can do database-specific adjustments. In the section <a href="#queries">Queries and data manipulation</a> there is description of <code>PersistBackend</code> functions and how to use them.</p><h2 id="keys-and-references"><a href="#keys-and-references">Keys and references</a></h2><p>In a database schema the tables may reference each other in many different ways. There can be the integer autoincremented primary key, composite unique keys, etc. All kinds of foreign keys are represented by data family <code>Key</code> which belongs to class <code>PersistEntity</code>. To reference another entity, your field can store one of its keys (preferably) or the entity itself. The first parameter of <code>Key</code> is its entity, the second is a phantom type which describes the key and helps to ensure that the keys match.</p><p>There are two other type families for keys which repeat types of certain <code>Key</code> GADT constructors.</p><ul><li><code>AutoKey</code> is a type for the autoincremented primary key. If an entity does not have such key, it will be <code>()</code>. In particular, this allows to insert entities regardless of their primary key with the same function <code>insert :: PersistEntity v =&gt; v -&gt; m (AutoKey v)</code>.</li><li><code>DefaultKey</code> helps to choose a key in a situation when an entity is stored directly and has multiple keys. Also it may simplify the type signatures.</li></ul><p>Consider the following examples:</p><pre><code class="haskell">data LinkedList a = LinkedList a (Maybe (Key (LinkedList a) BackendSpecific))      </code></pre><p>The type <code>BackendSpecific</code> means that it key is defined by backend. For the current SQL backends we have autoincremented integer primary key. If we had MongoDB it would be ObjectId. For the other types of keys (non-autoincremented primary key, unique constraints and unique indexes) the type looks like <code>Unique SomeUniqueConstraintName</code>. If the mapping does not override the default key, this example can be rewritten as:</p><pre><code class="haskell">data LinkedList a = LinkedList a (Maybe (DefaultKey (LinkedList a))      </code></pre><p>Alternatively, instead of its Key, your field may store the entity directly:</p><pre><code class="haskell">data LinkedList a = LinkedList a (Maybe (LinkedList a))</code></pre><p>In this case when you <code>insert</code> your linked list, the list from the field will be inserted with function <code>insertByAll</code>. Using <code>insertByAll</code> prevents creating duplicate records. It returns id of an existing record which has a matching unique constraint, or inserts the entity and returns its id. Note that if an inner entity has matching unique constraint but some other fields differ, it will still be considered the same and no updates or inserts on it will be performed. To have cleaner semantics, it is recommended to store keys.</p><p>Here we see the most commonly used configuration parameters for the keys and references:</p><p>The datatype <code>Album</code> does not have autoincremented primary key. Instead, we create our own natural primary key - album name. Its definition in YAML consists of two parts. At first, we define a unique set of fields with type primary. Then we put the name of unique set into section <code>keys</code>. This is necessary to use the constraint in the foreign keys. It results in creating a phantom type <code>AlbumName</code> and another constructor for <code>Key</code> with the corresponding instances. If it had more columns, a composite key would be created. Uniques are not treated as keys by default to avoid polluting the namespace with the phantom types. In a similar way we could declare our key AlbumName to be a constraint or a unique index.</p><p>We create <code>AlbumName</code> manually because we use it in <code>Track</code> before Template Haskell does its work. If we used it after calling mkPersist, the generated name would be already available.</p><pre><code class="haskell">data Album = Album {
  albumName :: String,
  albumDescr :: String
} deriving (Eq, Show)
data Track = Track {
  trackAlbum :: Key Album (Unique AlbumName),
  trackName :: String
}
deriving instance Eq Track
deriving instance Show Track

-- It is phantom datatype of the AlbumName unique key.
-- Usually they are generated by Template Haskell, but we define
-- it here manually to use in Track datatype
data AlbumName v where
  AlbumName :: AlbumName (UniqueMarker Album)

mkPersist defaultCodegenConfig [groundhog|
definitions:
  - entity: Album
    autoKey: null # Disable creation of the autoincrement integer key
    keys:
      - name: AlbumName # Matches name of one of the uniques
        default: true
    constructors:
      - name: Album
        uniques:
          - name: AlbumName
            type: primary
            fields: [albumName]
  - entity: Track
    autoKey:
      # Optional constructor name in the Key data family instance
      constrName: TrackAutoKey
    constructors:
      - name: Track
        keyDbName: trackId
        fields:
          - name: trackAlbum
            reference:
              onDelete: cascade
              onUpdate: restrict
|]
</code></pre><p>The <code>Track</code> demonstrates how to change constructor name and column name (<code>keyDbName</code>) for the default primary key. It also shows how we can tweak clauses ON DELETE and ON UPDATE. Note that many options are not listed in the examples. The complete configuration format description is available at <a href="http://hackage.haskell.org/packages/archive/groundhog-th/latest/doc/html/Database-Groundhog-TH.html">Database.Groundhog.TH</a>.</p><pre><code class="active haskell">-- show
-- /show
{-# LANGUAGE GADTs, TypeFamilies, TemplateHaskell, QuasiQuotes, FlexibleInstances, StandaloneDeriving #-}
import Control.Monad
import Control.Monad.IO.Class (liftIO)
import Database.Groundhog.Core (UniqueMarker)
import Database.Groundhog.TH
import Database.Groundhog.Sqlite

data Album = Album {
  albumName :: String,
  albumDescr :: String
} deriving (Eq, Show)
data Track = Track {
  trackAlbum :: Key Album (Unique AlbumName),
  trackName :: String
}
deriving instance Eq Track
deriving instance Show Track

-- It is phantom datatype of the AlbumName unique key.
-- Usually they are generated by Template Haskell, but we define
-- it here manually to use in Track datatype
data AlbumName v where
  AlbumName :: AlbumName (UniqueMarker Album)

mkPersist defaultCodegenConfig [groundhog|
definitions:
  - entity: Album
    autoKey: null # Disable creation of the autoincrement integer key
    keys:
      - name: AlbumName # Matches name of one of the uniques
        default: true
    constructors:
      - name: Album
        uniques:
          - name: AlbumName
            type: primary
            fields: [albumName]
  - entity: Track
    autoKey:
      # Optional constructor name in the Key data family instance
      constrName: TrackAutoKey
    constructors:
      - name: Track
        keyDbName: trackId
        fields:
          - name: trackAlbum
            reference:
              onDelete: cascade
              onUpdate: restrict
|]
-- show
main :: IO ()
main = withSqliteConn &quot;:memory:&quot; $ runDbConn $ do
  let imagineAlbum = Album &quot;Imagine&quot; &quot;Recorded and released in 1971. Side two&quot;
  runMigration defaultMigrationLogger $ do
    migrate (undefined :: Album)
    migrate (undefined :: Track)
  insert imagineAlbum
  let tracks = [&quot;Gimme Some Truth&quot;, &quot;Oh My Love&quot;, &quot;How Do You Sleep?&quot;, &quot;How?&quot;, &quot;Oh Yoko!&quot;]       
  let imagineKey = extractUnique imagineAlbum
  mapM_ insert $ map (Track imagineKey) tracks
  tracks' &lt;- select $ (TrackAlbumField ==. imagineKey)
    `orderBy` [Asc AutoKeyField]
  liftIO $ mapM_ print tracks'
-- /show</code></pre><p>After establishing connection and migration we insert album Imagine. To insert the tracks we need a key for this album. Function <code>insert</code> does not return it because Album has a custom primary key. Instead, we use <code>extractUnique</code> from class <code>IsUniqueKey</code> that creates a key by extracting key fields from the entity. Finally, we select the tracks ordering them by their primary key. A datatype AutoKeyField behaves like a regular field and can be used in conditions or ordering clause.</p><p>As the unique keys contain columns of a specific constructor, they cannot be created for sum types.</p><h2 id="queries-and-data-manipulation"><a href="#queries-and-data-manipulation">Queries and data manipulation</a></h2><p>We've already inserted some records and queried. Now let's look more closely at the Groundhog API.</p><h3 id="inserting"><a href="#inserting">Inserting</a></h3><p>There is a family of insert functions. They differ with regard to keys.</p><pre><code class="haskell">insert :: PersistEntity v =&gt; v -&gt; m (AutoKey v)</code></pre><p>inserts a new record to a database and return its autogenerated key or (). If there are any unique constraints violations, it will throw an error.</p><pre><code class="haskell">insert_ :: PersistEntity v =&gt; v -&gt; m ()</code></pre><p>also inserts a new record, but does not return the primary key. It is noticeably faster on Sqlite and MySQL because they need an extra query to retrieve it.</p><pre><code class="haskell">insertBy :: (PersistEntity v, IsUniqueKey (Key v (Unique u)))
         =&gt; u (UniqueMarker v)
         -&gt; v
         -&gt; m (Either (AutoKey v) (AutoKey v))</code></pre><p>checks if the unique key our entity matches already existing one. If there is such record, it returns <code>Left oldKey</code>, otherwise, it inserts our entity and returns <code>Right newKey</code>. For example, having already inserted <code>imagineAlbum</code> from the last example we could safely run <code>insertBy AlbumName imagineAlbum</code>. It would see that there is already an album with this name return <code>Left ()</code> because album table does not have autoincremented primary key.</p><pre><code class="haskell">insertByAll :: PersistEntity v
            =&gt; v
            -&gt; m (Either (AutoKey v) (AutoKey v))</code></pre><p>checks all existing constraints before inserting the entity. If there are any matches, it returns <code>Left oldKey</code>. Note that if our entity matches several records on different constraints, it will return a key for an arbitrary record.</p><h3 id="modification"><a href="#modification">Modification</a></h3><p>There are two functions for modifying a record in a database:</p><pre><code class="haskell">replace :: (PersistEntity v, PrimitivePersistField (Key v BackendSpecific))    
        =&gt; Key v BackendSpecific -&gt; v -&gt; m ()</code></pre><p>completely replaces the record. It receives an autogenerated id. You can replace values created by the same or different constructors.</p><pre><code class="haskell">update :: (PersistEntity v, EntityConstr v c)
       =&gt; [Update (PhantomDb m) (RestrictionHolder v c)]
       -&gt; Cond (PhantomDb m) (RestrictionHolder v c)
       -&gt; m ()</code></pre><p>Update receives the list of fields to be updated and condition and the chosen fields. An <code>Update</code> is created with <code>=.</code> operator</p><pre><code class="haskell">-- double quantity column for record with the given id
update [QuantityField =. toArith QuantityField * 2]
  $ AutoKeyField ==. k
-- rename customer
update [CustomerNameField =. &quot;John Doe&quot;]
  $ CustomerNameField ==. &quot;John&quot; ||.
    CustomerNameField `like` &quot;%Smith%&quot;</code></pre><h3 id="selecting-data"><a href="#selecting-data">Selecting data</a></h3><p>Groundhog has many functions to query a database. Some of them are more specialized, but simpler to use, while others offer high flexibility.</p><pre><code class="haskell">get :: (PersistEntity v, PrimitivePersistField (Key v BackendSpecific))
    =&gt; Key v BackendSpecific -&gt; m (Maybe v)</code></pre><p>is one of the simplest functions for querying. It gets an entity by its primary autogenerated key. As an entity may be absent, it returns Maybe.</p><pre><code class="haskell">getBy :: (PersistEntity v, IsUniqueKey (Key v (Unique u)))
      =&gt; Key v (Unique u) -&gt; m (Maybe v)</code></pre><p>is similar to <code>get</code>, but accepts a unique key.</p><pre><code class="haskell">count :: (PersistEntity v, Constructor c)
      =&gt; Cond (PhantomDb m) (RestrictionHolder v c) -&gt; m Int</code></pre><p>returns total number of records satisfying the condition. The parameter <code>PhantomDb m</code> of <code>Cond</code> ensures that for example, a PostgreSQL-specific operator which occurs in condition can be run only in PostgreSQL database.</p><pre><code class="haskell">countAll :: PersistEntity v =&gt; v -&gt; m Int</code></pre><p>returns total number of records of all constructors. We cannot use <code>count</code> for this as the condition can refer to fields of only one constructor, The parameter <code>v</code> is used only to infer type of the record.</p><pre><code class="haskell">select :: (PersistEntity v, Constructor c, HasSelectOptions opts (PhantomDb m) (RestrictionHolder v c))
       =&gt; opts -&gt; m [v]</code></pre><p>has more complicated type, but it is simple to use. It returns a list of entities which satisfy a condition. The parameter <code>opts</code> is condition with optional ordering, limit, and offset. The convenience class <code>HasSelectOptions</code> helps to make the the clauses optional and ensure that we don't duplicate them.</p><pre><code class="haskell">select $ QuantityField &gt;=. (5 :: Int)
select $ (10 :: Int) &lt;. toArith QuantityField * 2
     &amp;&amp;. (ProductNameField ==. &quot;Apples&quot;
     ||. ProductNameField ==. &quot;Melons&quot;)
select $ (CustomerField ==. johnKey)
  `orderBy` [Asc ProductNameField] `offsetBy` 20 `limitTo` 10</code></pre><p>The condition operators are similar to Haskell ones, but with a dot at the end. They work both with fields, constants, and complex expressions, e.g., arithmetics. A downside of this flexibility is that the arguments may need an explicit type annotations. If you want to run a query without condition, just pass <code>CondEmpty</code>.</p><pre><code class="haskell">selectAll :: PersistEntity v =&gt; m [(AutoKey v, v)]</code></pre><p>is to <code>select</code> as <code>count</code> is to <code>countAll</code>. It selects from all constructor tables and does not have a condition.</p><pre><code class="haskell">project :: (PersistEntity v, Constructor c,
            Projection p (PhantomDb m) (RestrictionHolder v c) a,
            HasSelectOptions opts (PhantomDb m) (RestrictionHolder v c))    
        =&gt; p -&gt; opts -&gt; m [a]</code></pre><p>is the most powerful query function. While <code>select</code> returns a list of entities, with <code>project</code> you choose which columns and expressions to select. Parameter <code>p</code> describes what things you would like to get from a table and defines type of result <code>a</code>.
                        <br /><br /></p><table> 
    <tr><td width="20%">Projection</td><td width="20%">Result</td><td width="60%">Description</td></tr> 
    <tr><td><code>Field v c a</code></td><td><code>a</code></td><td>Regular entity field</td></tr>
    <tr><td><code>SubField v c a</code></td><td><code>a</code></td><td>Field of embedded entity. It is created by <code>~&gt;</code> operator.</td></tr>
    <tr><td><code>Expr db r a</code></td><td><code>a</code></td><td>Arbitrary expression (see section below)</td></tr>
    <tr><td><code>AutoKeyField v c</code></td><td><code>AutoKey v</code></td><td>Field for autogenerated key</td></tr>
    <tr><td><code>c (ConstructorMarker v)</code></td><td><code>v</code></td><td>Constructor phantom type gives its entity</td></tr>
    <tr><td><code>u (UniqueMarker v)</code></td><td><code>Key v (Unique u)</code></td><td>Unique key phantom type can be used as an shortcut for fields it consists of</td></tr>
</table>
                        <br />
                        A tuple of projections is also a projection and will give you a tuple of corresponding results. Now there are instances for tuples of arity up to five. If you need to select more fields, you can nest the tuples.
``` haskell
project (AutoKeyField, (NameField, MyTupleField ~&gt; Tuple2_1Selector))    
  $ someCond :: m [(AutoKey SomeEntity, (String, Double))]
```
It may an alternative to <code>select</code> if you want to get a key too.
``` haskell
project (AutoKeyField, UserConstructor)
  $ AutoKeyField ==. k :: m [(AutoKey SomeEntity, SomeEntity)]
```<h3 id="expressions"><a href="#expressions">Expressions</a></h3><p>You may have noticed that the parameters on the left and right sides of <code>==.</code> and other operators are very different. They are fields, constants, arithmetics, and more. This is possible because all they are instances of the class <code>Expression</code>. With its power we can build a DSL that closely matches capabilities of SQL expressions in a type-safe way.</p><pre><code class="haskell">-- | Instances of this type can be converted to 'UntypedExpr'.
-- It is useful for uniform manipulation over fields, constant values, etc.
class Expression db r a where
  toExpr :: a -&gt; UntypedExpr db r</code></pre><p>The parameter <code>a</code> is for the value that can be lifted. The <code>db</code> constraints the databases where this expression can be used. For example, if expression is rendered into SQL with an operator which exists only in PostgreSQL, we would be able to use it only for PostgreSQL connections. Parameter <code>r</code> is used to restrict other properties. Usually it is <code>RestrictionHolder v c</code> - container for value type and its constructor. Together they uniquely define a table we use. It is important to prevent querying one table using columns from others.</p><p>The expressions are used in WHERE conditions, projections and updates. They are rendered into a part of SQL query (or several parts for embedded datatypes) with placeholders and a list of <code>PersistValue</code>. The functions and infix operators can be created as follows:</p><pre><code class="haskell">like :: (SqlDb db, QueryRaw db ~ Snippet db, ExpressionOf db r a String)    
     =&gt; a -&gt; String -&gt; Cond db r
-- operator priority, operator string, parameters
like a b = CondRaw $ operator 40 &quot; LIKE &quot; a b

upper :: (SqlDb db, QueryRaw db ~ Snippet db, ExpressionOf db r a String)
      =&gt; a -&gt; Expr db r String
upper a = Expr $ function &quot;upper&quot; [toExpr a]</code></pre><p>The constructor <code>CondRaw</code> brings expressions with SQL to conditions. The operators priority parameter is used to decide when to put parentheses. The <code>Expr</code> is just a wrapper around <code>UntypedExpr</code>. It carries a type parameter which keeps the type of expressions.</p><p>The <code>ExpressionOf db r a String</code> is a shorthand for <code>(Expression db r a, Unifiable a String)</code>. Class <code>Unifiable</code> ensures type safety of the expressions. It unifies the values of similar types. Expression <code>Field v c String</code> matches with <code>String</code> or <code>SubField v c String</code>. But it would not match <code>Field v c Int</code>.</p><pre><code class="haskell">project (&quot;username: &quot; `append` upper UserNameField)
  $ lower UserNameField `like` &quot;%smith%&quot;
project ((toArith NumberField + 1) * 2)
  $   upper FirstNameField ==. upper UserNameField
  ||. (toArith NumberField * 5) &gt;. (25 :: Int)
update (EmailField =. upper EmailField) (AutoKeyField ==. k)</code></pre><p>would be rendered into the following SQL queries (actually they would have placeholders instead of constants).</p><pre><code class="SQL">SELECT 'username: ' || upper(username) FROM mytable WHERE lower(username) LIKE '%smith%'
SELECT (number + 1) * 2 FROM mytable WHERE upper(firstname) = upper(username) OR number * 5 &gt; 25
UPDATE mytable SET email = upper(email) WHERE id = k</code></pre><h2 id="embedded-data-types"><a href="#embedded-data-types">Embedded data types</a></h2><p>The embedded data types are a way to map a single field to multiple columns. Entity table does not reference them but embeds their columns. A tuple is a characteristic example of such type. Fields of embedded types may include other embedded types or references, pretty much like entity fields. Their subfields can be accessed individually or as a whole.</p><p>The same embedded type may occur several times in one record. We would like both to avoid column name clashes and keep the name configuration optional. To achieve this, by default the column names are prefixed by the name of the outer field. For example, <code>myField :: (Int, (Int, Int))</code> will be mapped to columns <code>myField#val0</code>, <code>myField#val1#val0</code>, <code>myField#val1#val1</code>. The names of the inner columns can be overridden. If any of the embedded field names is changed, its other fields will lose their prefixes too.</p><p>We define entity <code>Company</code> and an embedded type <code>Address</code> which is kept inside a tuple along with the address coordinates.</p><pre><code class="haskell">data Company = Company {
  name :: String,
  location :: ((Double, Double), Address)
} deriving (Eq, Show)
data Address = Address {
  city :: String,
  zipCode :: String,
  street :: String
} deriving (Eq, Show)</code></pre><p>The embeddeds may have only a single constructor, so unlike entities they don't have <code>constructors</code> parameter. To change the default values of column name and column type we use field key <code>embeddedType</code>. There are slight differences between configuring regular fields in the definition itself and modifying them through <code>embeddedType</code>. In the first case changes are applied at compile time. But at the second case since we cannot call function <code>dbType</code> for a field due to Template Haskell phase restrictions, the changes are applied at runtime. Also because of this we have to use default dbName column name to access a subfield as with <code>zip_code</code> below.</p><pre><code class="yaml">mkPersist defaultCodegenConfig [groundhog|
definitions:
  - entity: Company
    constructors:
      - name: Company
        fields:
          - name: location
            embeddedType:               # If a field has an embedded type you can access its subfields.
              - name: val1
                embeddedType:
                  - name: city          # Just a regular list of fields. However, note that you should use default dbNames of embedded
                    dbName: hq_city
                    type: varchar       # Change type of column
                  - name: zip_code      # Here we use embedded dbName (zip_code) which differs from the name used in Address definition (zipCode)
                    dbName: hq_zipcode
                  - name: street
                    dbName: hq_street
  - embedded: Address
    fields:                             # The syntax is the same as for constructor fields. Nested embedded types are allowed.
      - name: zipCode
        dbName: zip_code                # Change column name.
 |]</code></pre><p>After all instances are created by TH, we can run a program.</p><pre><code class="active haskell">-- show
-- /show
{-# LANGUAGE GADTs, TypeFamilies, TemplateHaskell, QuasiQuotes, FlexibleInstances, StandaloneDeriving #-}
import Control.Monad.IO.Class (liftIO)
import Database.Groundhog.TH
import Database.Groundhog.Sqlite

data Company = Company {
  name :: String,
  location :: ((Double, Double), Address)
} deriving (Eq, Show)
data Address = Address {
  city :: String,
  zipCode :: String,
  street :: String
} deriving (Eq, Show)

mkPersist defaultCodegenConfig [groundhog|
definitions:
  - entity: Company
    constructors:
      - name: Company
        fields:
          - name: location
            embeddedType:               # If a field has an embedded type you can access its subfields.
              - name: val1
                embeddedType:
                  - name: city          # Just a regular list of fields. However, note that you should use default dbNames of embedded
                    dbName: hq_city
                    type: varchar       # Change type of column
                  - name: zip_code      # Here we use embedded dbName (zip_code) which differs from the name used in Address definition (zipCode)
                    dbName: hq_zipcode
                  - name: street
                    dbName: hq_street
  - embedded: Address
    fields:                             # The syntax is the same as for constructor fields. Nested embedded types are allowed.
      - name: zipCode
        dbName: zip_code                # Change column name.
 |]
-- show
main = withSqliteConn &quot;:memory:&quot; $ runDbConn $ do
  let address = Address &quot;Sunnyvale&quot; &quot;18144&quot; &quot;El Camino Real&quot;
      coords = (37.355362, -122.016633)
      company = Company &quot;Cyberdyne Systems&quot; (coords, address)
  runMigration defaultMigrationLogger $ migrate company
  insert company
  cs &lt;- select
    $   LocationField ~&gt; Tuple2_0Selector ==. coords
    &amp;&amp;. LocationField ~&gt; Tuple2_1Selector ~&gt; ZipCodeSelector ==. &quot;18144&quot;    
  liftIO $ print cs
-- /show</code></pre><p>In condition of select we both access a tuple as a whole for coordinates, and drill down to a string zip code value. The subfields created by <code>~&gt;</code> operator are expressions and can be used everywhere. The tuple fields have names like <code>val0</code>, <code>val1</code>, and so on. Their selectors have corresponding names of form TupleN_MSelector where N is number of elements in a tuple, and M is number of the selected element. This flexibilty allows high-level and concise statements that affect multiple columns like</p><pre><code class="haskell">update [MyAddress =. newAddress] $ MyAddress ==. oldAddress</code></pre></article>

<div id="disqus_thread"><script>var disqus_shortname = "fpcomplete"; (function() { var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true; dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq); })();</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">comments powered by <span class="logo-disqus">Disqus</span></a></a>
</div>

</div>
</div>
<div class="row article-footer"><div class="span7 meta"><span class="sociallinksunicode social">
<a href="https://twitter.com/home?status=$url$" target="_blank"><i class="icon-twitter"></i></a>&nbsp;
<a href="http://www.facebook.com/sharer/sharer.php?u=$url$" target="_blank"><i class="icon-facebook"></i></a>&nbsp;
<a href="https://plus.google.com/share?url=$url$" target="_blank"><i class="icon-google-plus"></i></a></span>
</div>
</div>
</div>
<div class="footer"><div class="container"><div class="row"><div class="span12"><ul class="menu"><li><a href="https://www.schoolofhaskell.com/">School</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user">Users</a>
</li>

<li><a class="brand" href="https://fpcomplete.com">Sponsored by:
<img src="/static/img/logo.png" title="FPComplete">
</a>
</li>
</ul>
</div>
</div>
<div class="row"><div class="span12"></div>
</div>
</div>
</div>
<link rel="stylesheet" type="text/css" href="/static/bootstrap/css/bootstrap-responsive.css" />
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script><script src="https://www.schoolofhaskell.com/static/combined/Y-3k9_tW.js"></script><script>$(function(){
  $("a.logout").click(function(){
    var form = $("<form method='post'/>");
    form.attr("action", $(this).attr("href"));
    $("body").append(form);
    form.submit();
    return false;
  });
});

$(function(){
    $('.sociallinksunicode a').each(function(){
        $(this).attr('href',$(this).attr('href').replace('$url$',document.location));
    });
});

$(function(){
  // If we need to select a user/select a password then show the
  // details confirmation form, otherwise enable the getting started
  // section.
  if($('.alert-block a').text().match(/(selected a username|change your password)/)) {
    $("#confirm-details").show();
    $("#confirm-details #inputUsername").focus();
  } else {
    $("#get-started").removeClass('disabled').addClass('enabled');
  }

  // For lack of a plain HTML validation story this will do.
  $('.welcome-page').each(function(){
    $('form').submit(check);
  });
  function check(){
    setTimeout(check,500);
    var error = false;
    $('.error').removeClass('error');
    $('#enter-details input').each(function(){
      if($(this).val() == '') {
        $(this).parent().parent().addClass('error');
        error = true;
      }
    });
    if(error) return false;
    if($('[name=password]').val() == $('[name=confirm]').val()) {
      $('#confirm').removeClass('error');
      return true;
    } else {
      $('#confirm').addClass('error');
      return false;
    }
  }
});

$(function(){
  // When scrolling over a snippet editor, activate the "clone in IDE" popovers
  $('article').each(function(){
    var n = 100;
    var wait = 10000;
    function check(){
      if($('.clone').length == 0) {
        setTimeout(check,n);
        return;
      }
      var activated = $.cookie('clone-popover');
      if (activated) return;
      var activate = false;
      $('.controlsRun:onScreen').each(function(){
        $.cookie('clone-popover', 'true', { expires: 30, path: '/' });
        activate = true;
        return false;
      });
      if(activate) {
          $('.clone').each(function(){
              // The bootstrap API is rather unreasonable to say the
              // least.
              next = $(this).parent();
              var title = next.attr('title');
              next.attr('data-content',$(this).attr('data-content'));
              next.attr('title',$(this).attr('title'));
              next.popover('show',{
                  title: $(this).attr('title')
              });
              next.attr('title',title);
          });
          setTimeout(function(){
              $('.clone').each(function(){
                  $(this).parent().popover('hide');
              });
          },wait);
      } else {
        setTimeout(check,n);
      }
    }
    setTimeout(check,n);
  });
});

// onScreen jQuery plugin v0.2.1
// (c) 2011-2013 Ben Pickles
//
// http://benpickles.github.com/onScreen
//
// Released under MIT license.
(function(a){a.expr[":"].onScreen=function(b){var c=a(window),d=c.scrollTop(),e=c.height(),f=d+e,g=a(b),h=g.offset().top,i=g.height(),j=h+i;return h>=d&&h<f||j>d&&j<=f||i>e&&h<=d&&j>=f}})(jQuery);

/*!
 * jQuery Cookie Plugin v1.1
 * https://github.com/carhartl/jquery-cookie
 *
 * Copyright 2011, Klaus Hartl
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.opensource.org/licenses/GPL-2.0
 */
(function($, document) {

  var pluses = /\+/g;
  function raw(s) {
    return s;
  }
  function decoded(s) {
    return decodeURIComponent(s.replace(pluses, ' '));
  }

  $.cookie = function(key, value, options) {

    // key and at least value given, set cookie...
    if (arguments.length > 1 && (!/Object/.test(Object.prototype.toString.call(value)) || value == null)) {
      options = $.extend({}, $.cookie.defaults, options);

      if (value == null) {
	options.expires = -1;
      }

      if (typeof options.expires === 'number') {
	var days = options.expires, t = options.expires = new Date();
	t.setDate(t.getDate() + days);
      }

      value = String(value);

      return (document.cookie = [
	encodeURIComponent(key), '=', options.raw ? value : encodeURIComponent(value),
	options.expires ? '; expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE
	options.path    ? '; path=' + options.path : '',
	options.domain  ? '; domain=' + options.domain : '',
	options.secure  ? '; secure' : ''
      ].join(''));
    }

    // key and possibly options given, get cookie...
    options = value || $.cookie.defaults || {};
    var decode = options.raw ? raw : decoded;
    var cookies = document.cookie.split('; ');
    for (var i = 0, parts; (parts = cookies[i] && cookies[i].split('=')); i++) {
      if (decode(parts.shift()) === key) {
	return decode(parts.join('='));
      }
    }
    return null;
  };
  $.cookie.defaults = {};})(jQuery, document);
</script><!--[if lt IE 10]><script src="https://www.schoolofhaskell.com/static/design/js/ie.js?etag=ayV2DuJ0"></script><![endif]--><script>if(!window.location.href.match(/localhost/)){var track = '/tutorial/school/to-infinity-and-beyond/pick-of-the-week/groundhog';
window._gaq = [['_setAccount','UA-36928035-1'],track != ''? ['_trackPageview',track] : ['_trackPageview']
,['_trackPageLoadTime']];window._gaq.push(['_setCustomVar',1,'Section','School of Haskell',3]);
window._gaq.push(['_setCustomVar',2,'User Type','Visitor',1]);
(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);

})();}</script>
<!-- Prompt IE 6 users to install Chrome Frame. Remove this if you want to support IE 6.  chromium.org/developers/how-tos/chrome-frame-getting-started --><!--[if lt IE 7 ]><script src="//ajax.googleapis.com/ajax/libs/chrome-frame/1.0.3/CFInstall.min.js"></script><script>window.attachEvent('onload',function(){CFInstall.check({mode:'overlay'})})</script><![endif]--></body></html>