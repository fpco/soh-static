<!DOCTYPE html>
<html><head><title>5. Tokenizer: Data Types - School of Haskell | School of Haskell</title><meta http-equiv="x-ua-compatible" content="IE=9"><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="google-site-verification" content="Rfxk2TdeMMXEXHgJ2_OO8Rt3hPbQSDao0OXQV_n6z_s" /><link href="//fonts.googleapis.com/css?family=Merriweather" rel="stylesheet" type="text/css"><link href="https://www.schoolofhaskell.com/recent-content/feed" type="application/rss+xml" rel="alternate" title="Recently published content">
<link rel="stylesheet" href="https://www.schoolofhaskell.com/static/combined/UlwEHVcM.css"><style>.social{margin-right:1em}h1{font-family:Merriweather !important}article{font-family:Merriweather !important}article li{font-family:Merriweather !important;line-height:1.6em}h1,h2,h3,h4,h4,h5{font-family:Merriweather !important}.editor p{font-family:Frutiger, "Frutiger Linotype", Univers, Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans Condensed", "Liberation Sans", "Nimbus Sans L", Tahoma, Geneva, "Helvetica Neue", Helvetica, Arial, sans-serif}.article-footer{border-top:1px solid #ddd;padding-top:1em;margin-top:1em}body{font-size:16px !important}.navbar .navbar-inner{background:#3c3f41}.navbar .brand{font-size:14px}.navbar .brand img{width:6em}.navbar .icon-wrench{margin:0 -0.5em 0 -0.5em;padding:0 1em 0 1em;height:20px}.navbar-inverse .nav .active a{background:#333638}.navbar-inverse .nav > li > a{color:#a7a7a7
}.navbar-inverse .btn-navbar{background:#333638}.navbar-inverse .nav > li a:hover,.navbar-inverse .btn{background:#333537 !important}@media (max-width: 979px) {.icon-wrench{padding-left:1em !important}}.breadcrumb{border-top-left-radius:0;border-top-right-radius:0}h1{margin-top:20px}.breadcrumb-container + .main-content h1{margin-top:0}.footer{padding:30px 0;margin-top:70px;border-top:1px solid #e5e5e5;background-color:#f5f5f5}.footer ul.footer-menu{list-style-type:none}.footer ul.footer-menu li{display:inline-block}.footer ul.footer-menu li + li{margin-left:0.5em}.footer ul.footer-menu li + li:before{margin-right:0.5em;content:"Â·";color:#999}.footer ul.menu li{display:inline-block}.footer ul.menu li + li{margin-left:0.5em}.footer .copyright{margin-left:25px}.main-content{min-height:100%}.gravatar{width:80px;height:80px;border-radius:2px;background:#eee}.empty-gravatar{width:0}.container{font-family:"Segoe UI", Candara, "Bitstream Vera Sans", "DejaVu Sans", "Bitstream Vera Sans", "Trebuchet MS", Verdana, "Verdana Ref", sans-serif}.container h1,.container h2,.container h4,.container h4,.container h5{font-family:"Segoe UI", Candara, "Bitstream Vera Sans", "DejaVu Sans", "Bitstream Vera Sans", "Trebuchet MS", Verdana, "Verdana Ref", sans-serif}article{font-family:Merriweather !important}article h1{font-family:Merriweather !important}article li{font-family:Merriweather !important;line-height:1.6em}article li + li{margin-top:0.5em}article div.code{background:#f9f9f9;border:1px solid #d1d1d1;position:relative;border-radius:0.2em;margin:0.25em 0 0.75em 0;min-height:2.5em}article code{color:#005580;font-size:14px;white-space:pre}article a.hoogle > code{color:#0088cc;font-size:14px;white-space:pre;border:0}article .expand-code{display:none}article pre{overflow:auto;word-wrap:normal}article code.active{display:block;max-height:430px}article h1{font-size:31.5px}article h3{font-size:17.5px}article h4{font-size:14px}article h5,article h6{font-size:11.9px}article p{line-height:1.7em}article h1 code,article h2 code,article h3 code,article h4 code,article h5 code,article h6 code{font-size:inherit !important}article h1 a,article h2 a,article h3 a,article h4 a,article h5 a,article h6 a{color:#444}article h1 a:before,article h2 a:before,article h3 a:before,article h4 a:before,article h5 a:before,article h6 a:before{margin-left:-1.5em;padding-right:0.5em;font-family:fontawesome;content:"\f0c1";font-size:20px;color:#fff}article h1 a:hover,article h2 a:hover,article h3 a:hover,article h4 a:hover,article h5 a:hover,article h6 a:hover{text-decoration:none;color:#0088cc}article h1 a:hover:before,article h2 a:hover:before,article h3 a:hover:before,article h4 a:hover:before,article h5 a:hover:before,article h6 a:hover:before{color:#888}article h2{font-size:24.5px}article .popover{font-family:actor}article .popover h3.popover-title{font-family:actor !important;font-size:1em}article .popover .popover-content{width:15em;font-size:1em}article .controlsRun{display:block;padding:0.5em;text-align:right;background:#f2f2f2}article .controlsRun a.clone{margin-right:1em;font-family:actor;text-decoration:none}article .controlsRun a.clone span{padding-left:0.5em}article .controlsRun a.run,article .controlsRun a.reset,article .controlsRun a.show-code{font-size:16px}article .controlsRun a.run span,article .controlsRun a.reset span,article .controlsRun a.show-code span{display:none}article .controlsRun a.reset{margin-left:0.5em;color:#a2becc}article .controlsRun a.reset{display:none}article .controlsRun a.show-code{margin-right:0.75em}article .controlsRun a.run:hover,article .controlsRun a.show-code:hover{text-decoration:none}article .controlsRun a.show-code.active{color:#DC0D0D}article .controlsRun a[disabled]{color:#a2becc;cursor:default}article .collapse-area .collapse-header{background:#0088cc;color:#fff;padding:0.3em;cursor:pointer}article .collapse-area .hidden-toggle:before{content:"\f0d7";font-family:fontawesome;margin-right:0.5em;margin-left:0.25em}article .collapse-area .collapsed-files{overflow:auto;height:auto}article .collapse-area.collapse-disabled{display:none}article .collapse-area.collapse-area-off .collapsed-files{height:0px;overflow:hidden}article .collapse-area.collapse-area-off .hidden-toggle:before{content:"\f0da"}article .snippet-stdio .stdout{margin:0.5em;padding-right:2em;position:relative;word-wrap:break-word}article .snippet-stdio .stdin{-webkit-box-shadow:none;-moz-box-shadow:none;box-shadow:none;-webkit-transition:none;-moz-transition:none;-o-transition:none;transition:none;padding:0;margin:0}article .hoogle-results{margin:0.25em}article .hoogle-results .hoogle-inner{background:#fff;padding:0.5em;border-radius:3px;border:1px solid #ddd}article .hoogle-results .hoogle-inner .close-link{position:relative;float:right;margin-top:-0.5em;margin-right:-0.5em}article .snippet-output-errors{margin:1em 0.5em 0.5em 0.5em;position:relative}article .snippet-output-errors ul{list-style-type:none;margin:0;position:relative}article .snippet-output-errors pre{border:0;border-radius:0;padding:0.25em;margin:0;background:inherit;color:inherit}article .snippet-output-errors .close-link{color:inherit;background:inherit}article .snippet-editors{z-index:0;padding:0.25em}article .close-link{padding:0.5em;background:#eaeaea;border-bottom-left-radius:0.2em;border-top-right-radius:0.2em;position:absolute;top:0;right:0}article .close-link:hover{text-decoration:none}article .snippet-title{padding:0.5em 0 0 0.5em}article .snippet-title .snippet-icon{font-family:FontAwesome;display:inline-block;margin-right:0.5em}article .fullModuleCode + div .snippet-title{margin-top:0.5em;border-top:1px solid #ccc;padding-top:0.5em}article .CodeMirror{height:auto;min-height:1em;line-height:1.5em;background:transparent;font-size:14px !important}article .CodeMirror .highlighted{background:rgba(250, 210, 0, 0.45) !important}article .CodeMirror-widget{margin-left:2em;line-height:1.8}article .CodeMirror.collapsed{height:10em !important}article .editor .expander{text-align:center;display:block;padding:0.5em;text-decoration:none;border-bottom-left-radius:2px;border-bottom-right-radius:2px}article .editor .expander .ellipsis{background:white;border:1px solid #ccc;padding:0 0.5em;height:1em;line-height:0.5em;display:inline-block;color:#555;cursor:pointer}article .editor .expander .ellipsis:hover{background:#ddd;color:#333}article .web-runner{margin:0.5em;padding:0.5em;border:1px solid #ccc;border-radius:3px;background:#f5f5f5}article .web-runner iframe{border:0;margin-top:0.5em;margin-bottom:0;background:white}article .web-runner .controls i{cursor:pointer;color:#0088cc}article .web-runner .controls i:hover{color:#222}article .web-runner .controls i + i{margin-left:0.5em}article .web-runner .controls .icon-remove{float:right}article .hidden{display:block;visibility:visible}article .controlsShowHide{margin-bottom:0.5em}.tutorial-body{float:left !important}.tutorial-nav{float:right !important}@media (max-width: 979px) {.related-content{float:right}.author-name{display:block;margin-left:20px !important;padding-left:5px;margin-top:5px}article h1 a:hover:before,article h2 a:hover:before,article h3 a:hover:before,article h4 a:hover:before,article h5 a:hover:before,article h6 a:hover:before{color:#fff}.tutorial-nav{float:none !important;width:auto !important}.tutorial-body{float:none !important;width:auto !important}}@media (min-width: 980px) and (max-width: 1199px) {.navbar-search{display:none}.tutorial-nav{width:200px}.tutorial-body{width:720px}}#accountPage h1{margin:20px 0 0 0}#accountPage h2{font-size:20px}.group-contents .span8{float:left}.group-contents .span4{float:right}.container > .alert-block{margin-top:1em}.alert{color:#aa874a
}.social{margin-bottom:.8em;display:block}.social a{text-decoration:none}.social i{font-size:1.1em;color:#fff;padding:0.25em;border-radius:0.25em;width:1em;display:inline-block;text-align:center}.social i.icon-twitter{background:#0088cc}.social i.icon-facebook{background:#3b5998
  }.social i.icon-google-plus{background:#dd4b39
  }.well pre{background:#fcfcfc}.well h2{margin-top:0}code{color:#005580;font-size:14px;white-space:pre}</style><!--[if lt IE 8]><link rel="stylesheet" href="https://www.schoolofhaskell.com/static/design/css/ie7.css?etag=TSMl9x1V"><![endif]--><!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]--></head><body class="not-logged-in" itemscope itemtype="http://schema.org/Product"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-H62P" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-H62P');</script><div class="navbar navbar-inverse navbar-static-top"><div class="navbar-inner"><div class="container"><a class="btn btn-navbar" type="button" data-toggle="collapse" data-target=".nav-collapse"><span class="icon-bar"></span>
<span class="icon-bar"></span>
<span class="icon-bar"></span>
</a>
<a class="brand" href="/"><img src="/static/img/haskell-logo-wide.png" title="School of Haskell">
</a>
<div class="nav-collapse collapse"><ul class="nav"><li><a href="https://www.schoolofhaskell.com/">School</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user">Users</a>
</li>
</ul>
<form class="navbar-search pull-left" action="https://www.schoolofhaskell.com/search"><input class="search-query" type="text" placeholder="Search" name="search">
</form>
</div>
</div>
</div>
</div>
<div class="container breadcrumb-container"><div class="row"><div class="span12"><ul class="breadcrumb"><li><a href="https://www.schoolofhaskell.com/">School of Haskell</a>
<span class="divider">/</span>
</li>
<li><a href="https://www.schoolofhaskell.com/school/starting-with-haskell">Starting with Haskell</a>
<span class="divider">/</span>
</li>
<li><a href="https://www.schoolofhaskell.com/school/starting-with-haskell/basics-of-haskell">Basics of Haskell</a>
<span class="divider">/</span>
</li>
<li><a href="https://www.schoolofhaskell.com/school/starting-with-haskell/basics-of-haskell/5-tokenizer-data-types">5. Tokenizer: Data Types</a>
</li>
</ul>
</div>
</div>
</div>
<div class="container main-content"><div class="row"><div class="span12"><h1 itemprop="name">5. Tokenizer: Data Types</h1>
</div>
</div>
<div class="row"><div class="span7 meta"><p><span class="date">26 Jun 2013</span>
<span class="author"><a href="https://www.schoolofhaskell.com/user/bartosz">Bartosz Milewski</a>
</span>
<span class="view-edit-link pull-right"><a class="view-source-link" href="https://www.schoolofhaskell.com/tutorial-raw/4/c2cd6143fb9fa65918041ad7e6b1634ed9b75a00">View Markdown source</a>
</span>
</p>
<p class="tags"></p>
</div>
</div>
<div class="row"><div class="span7 meta"><span class="sociallinksunicode social">
<a href="https://twitter.com/home?status=$url$" target="_blank"><i class="icon-twitter"></i></a>&nbsp;
<a href="http://www.facebook.com/sharer/sharer.php?u=$url$" target="_blank"><i class="icon-facebook"></i></a>&nbsp;
<a href="https://plus.google.com/share?url=$url$" target="_blank"><i class="icon-google-plus"></i></a></span>
</div>
</div>
<p class="alert">As of March 2020, School of Haskell has been switched to read-only mode.</p>
<div class="row" itemprop="desc"><div class="span4 tutorial-nav"><div class="related-content"><ul class="nav nav-tabs nav-stacked"><li><script>reddit_target='fpcomplete'</script>
<script src="https://redditstatic.s3.amazonaws.com/button/button1.js"></script>
</li>
<li><a href="https://www.schoolofhaskell.com/user/school/starting-with-haskell/basics-of-haskell/4-symbolic-calculator-recursion">Previous content: 4. Symbolic Calculator: Recursion</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user/school/starting-with-haskell/basics-of-haskell/6-tokenizer-function-types">Next content: 6. Tokenizer: Function Types</a>
</li>
<li><a href="https://www.schoolofhaskell.com/school/starting-with-haskell/basics-of-haskell">Go up to: Basics of Haskell</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user/bartosz">See all content by Bartosz Milewski</a>
</li>
</ul>

</div>
<div class="aside"><h3>Sections</h3>
<ul><li><a href="#haskell-data-types">Haskell Data Types</a></li><li><a href="#enumerated-data-types">Enumerated Data Types</a></li><li><a href="#token">Token</a></li><li><a href="#lists-and-recursion">Lists and Recursion</a></li><li><a href="#exercises">Exercises</a></li></ul></div>
</div>
<div class="span8 tutorial-body" data-environment="ghc-7.8-stable-14.09">
<article><p>In the <a href="https://www.fpcomplete.com/user/bartosz/basics-of-haskell/4-symbolic-calculator-recursion">previous tutorial</a> I sketched the desing of a calculator and implemented the top-level input/output loop. This is a typical pattern in Haskell: the top level is implemented in the <code>IO</code> monad (after all, the signature of <code>main</code> is <code>IO ()</code>) but, as you descend to the lower levels, you enter the realm of side-effect-free pure functions. The first such function is <code>tokenize</code> with the following signature:</p><pre><code class="haskell">tokenize :: String -&gt; [Token]</code></pre><p>Before we can start implementing it, we have to define the <code>Token</code> data type and learn more about <code>String</code>s.</p><h2 id="haskell-data-types"><a href="#haskell-data-types">Haskell Data Types</a></h2><p>There is one major difference between data in imperative languages and data in Haskell. Haskell data is immutable. Once you construct a data item, it will forever stay the same.</p><p>Well, it's not entirely true because of another property of Haskell: laziness. Calling a constructor of a data type is not the same as <i>evaluating</i> it. It's only when you actually peek inside a data item that the constructor is evaluated, and only the part that you're looking at.</p><p>But for all intents and purposes, the state of a data item remains frozen after its construction. Moreover, every data item <i>remembers</i> the way it's been constructed. It remembers which constructor was used and what values were passed to it.</p><p>But how can you write programs without mutable data? Actually, those of us who had to deal with concurrent programming in imperative languages had to learn (often the hard way) to eschew mutability whenever possible. The fewer opportunities for those hard to reproduce and debug low-level data races, the more reliable your code. This is one more reason to learn programming in Haskell even if your job requries the use of imperative languages: You'll learn how to solve problems without mutable variables.</p><p>In Haskell you'll often see mutation replaced by construction. Instead of modifying one element of a data structure, you construct a copy of it with the appropriate change in place. This trick could be prohibitively expensive if you use the wrong data structures. We'll be steering away from such data structures in favor of the so called <i>persistent</i> data structures, which don't require a lot of copying when they are modified. For instance, the workhorse of Haskell data structures is the list, not the array of the vector. We'll talk more about this later.</p><h2 id="enumerated-data-types"><a href="#enumerated-data-types">Enumerated Data Types</a></h2><p>The simplest data types just enumerate all possible values. For instance, <code>Bool</code> is an enumeration of <code>True</code> and <code>False</code> (as defined in the Prelude, the Haskell's standard library):</p><pre><code class="haskell">data Bool = True | False</code></pre><p>A data structure definition is introduced by the keyword <code>data</code>. <code>Bool</code> is the name of the type we are defining. The right hand side of the equal sign lists the <i>constructors</i> separated by vertical bars. When you create a new <code>Bool</code> value, you use one of these two constructors. Constructor names must start with a capital letter and must be unique per file (two data structures can't share the same constructor name).</p><p>When you want to inspect a <code>Bool</code> value, you <i>match</i> it with one of the constructors (remember, a value <i>remembers</i> how it was constructed). There are several ways of matching values to constructors in Haskell. Let's start with the simplest one: Defining a function using multiple equations. Instead of defining a function with one equation, like this:</p><pre><code class="active haskell">boolToInt :: Bool -&gt; Int
boolToInt b = if b then 1 else 0

main = print $ boolToInt False</code></pre><p>you may split it into two equations corresponding to two constructor patterns, <code>True</code> and <code>False</code>:</p><pre><code class="active haskell">boolToInt :: Bool -&gt; Int
boolToInt True  = 1
boolToInt False = 0

main = print $ boolToInt False</code></pre><p>Patterns are matched in order, so when <code>boolToInt</code> is called with <code>False</code>, the runtime first tries to match it to <code>True</code> and fails, so it moves to the second pattern <code>False</code> and succeeds. (All equations for the same function must be consecutive.)</p><p>(Note: In order to save on parentheses I will start using the function application operator <code>$</code> that I introduced in the first tutorial. It's been a long time, so here's a quick recap: <code>$</code> separates a function call from its argument. It's very useful when the argument is another function call, because function calls bind to the left. In our example, without the <code>$</code> or parenteheses, the function calls would bind: <code>(print boolToInt) False</code>, and would fail to compile. Operator <code>$</code> has very low precedence so the thing to its right will be evaluated before the function to the left is called, and it binds to the right.)</p><p>Here's a useful enumeration that we will use in our project:</p><pre><code class="haskell">data Operator = Plus | Minus | Times | Div</code></pre><p><b>Ex 1</b>.
Write a function that takes an <code>Operator</code> and returns one of the characters, <code>'+'</code>, <code>'-'</code>, <code>'*'</code>, or <code>'/'</code>.</p><pre><code class="active haskell">data Operator = Plus | Minus | Times | Div

opToChar :: Operator -&gt; Char
opToChar = undefined

main = print $ opToChar Plus</code></pre><div class="hidden" title="Show solution"><pre><code class="active haskell">data Operator = Plus | Minus | Times | Div

opToChar :: Operator -&gt; Char
opToChar Plus  = '+'
opToChar Minus = '-'
opToChar Times = '*'
opToChar Div   = '/'

main = print $ opToChar Plus</code></pre></div><h2 id="token"><a href="#token">Token</a></h2><p>Our tokenizer should recognize operators, identifiers, and numbers. We can enumerate the four operators, but we can't enumerate all possible indentifiers or numbers. For those tokens we need to store additional information: a <code>String</code> and an <code>Int</code> respectively. Here's the definition of <code>Token</code>:</p><pre><code class="haskell">data Token = TokOp Operator
           | TokIdent String
           | TokNum Int
    deriving (Show, Eq)</code></pre><p>All three constructors now take arguments. The <code>TokOp</code> constructor takes a value of the type <code>Operator</code>, <code>TokIdent</code> takes a <code>String</code>, and <code>TokNum</code> takes an <code>Int</code>. For instance, you can create a <code>Token</code> using (<code>TokIdent &quot;x&quot;</code>), etc.</p><p>I'll explain the <code>deriving</code> clause in more detail when we talk about type classes. For now it will suffice to know that <code>deriving</code> <code>Show</code> means that there is a way to convert any <code>Token</code> to string (either by calling <code>show</code> or by <code>print</code>'ing it), and <code>deriving</code> <code>Eq</code> means that we can compare <code>Token</code>s for (in-)equality. The compiler is clever enough to implement this functionality all by itself (if it can't, it will issue an error).</p><p>Pattern matching on these constructors is more interesting: We not only match the constructor name but also the value with which it was originally called. Here's a definition of a function <code>showContent</code> that uses this kind of pattern matching:</p><pre><code class="active haskell">-- show
data Token = TokOp Operator
           | TokIdent String
           | TokNum Int
    deriving (Show, Eq)

showContent :: Token -&gt; String
showContent (TokOp op) = opToStr op
showContent (TokIdent str) = str
showContent (TokNum i) = show i

token :: Token
token = TokIdent &quot;x&quot;

main = do
    putStrLn $ showContent token
    print token
-- /show
data Operator = Plus | Minus | Times | Div
    deriving (Show, Eq)

opToStr :: Operator -&gt; String
opToStr Plus  = &quot;+&quot;
opToStr Minus = &quot;-&quot;
opToStr Times = &quot;*&quot;
opToStr Div   = &quot;/&quot;</code></pre><p>Notice that non-trivial constructor patterns require parentheses. In these patterns the argument to the constructor is replaced by a (lower-case) variable that is to be bound to the value stored inside the <code>Token</code>. For instance, in the <code>(TokIdent str)</code> pattern, <code>str</code> will be bound to the string that was used in the construction of the matched token. If the token was constructed using <code>TokIdent &quot;x&quot;</code>, <code>str</code> will be bound to <code>&quot;x&quot;</code>. (For immutable variables we prefer to use the word &quot;bind&quot; rather than &quot;assign.&quot;)</p><p>In general, constructors may take many arguments of various types, and they can all be matched by patterns.</p><p><b>Ex 2</b>.
Define a data type <code>Point</code> with one constructor <code>Pt</code> that takes two <code>Double</code>s, corresponding to the x and y coordinates of a point. Write a function <code>inc</code> that takes a <code>Point</code> and returns a new <code>Point</code> whose coordinates are one more than the original coordinates. Use pattern matching.</p><pre><code class="active haskell">data Point = Pt ... 
    deriving Show

inc :: Point -&gt; Point
inc ... = ...

p :: Point
p = Pt (-1) 3

main = print $ inc p</code></pre><div class="hidden" title="Show solution"><pre><code class="active haskell">data Point = Pt Int Int 
    deriving Show

inc :: Point -&gt; Point
inc (Pt x y) = Pt (x + 1) (y + 1)

p :: Point
p = Pt (-1) 3

main = print $ inc p
</code></pre></div><p>By the way, we've seen pattern matching previously applied to pairs. The constructor of a pair is <code>(,)</code>.</p><p><b>Ex 3</b>.
Solve the previous exercise using pairs rather than <code>Point</code>s.</p><pre><code class="active haskell">inc :: (Int, Int) -&gt; (Int, Int)
inc ... = ...

p :: (Int, Int)
p = ...

main = print $ inc p</code></pre><div class="hidden" title="Show solution"><pre><code class="active haskell">inc :: (Int, Int) -&gt; (Int, Int)
inc (x, y) = (x + 1, y + 1)

p :: (Int, Int)
p = (-1, 3)

main = print $ inc p</code></pre></div><h2 id="lists-and-recursion"><a href="#lists-and-recursion">Lists and Recursion</a></h2><p>In Haskell a <code>String</code> is a list of characters. Admittedly, list storage and processing is less space/time efficient than the processing of arrays of characters in imperative languages. However, unless your application is string-intensive, the convenience of list manipulation overcomes these shortcomings. And it's easy enough to replace <code>String</code> with the more efficient array-based <code>ByteString</code> in string-intensive applications.</p><p>Since we'll be manipulating strings -- and strings are list of characters -- we need to learn about lists first.</p><p>First we have to ask ourselvest: What is a list? If you're thinking, &quot;Singly-linked or doubly-linked?&quot;, you are talking about implementation, not the essence of a list. So what's the essence of a list? Like any abstract data type, list is defined by operations you can perform on it. The most essential operation is the <i>creation</i> of a list.</p><p>One should be able to create a new list by prepending an element to an existing list. This operation is often called &quot;cons,&quot; a word taken from Lisp jargon. Notice that this definition is self-referential -- you create a list from a list. To start somewhere, you should also be able to create a list from nothing -- an empty list. Here's a definition of a list of integers that is based just on this description:</p><pre><code class="haskell">data List = Cons Int List | Empty</code></pre><p>The fact that this definition is recursive shouldn't bother us in the least. The important thing is that it lets us create arbitrary lists:</p><pre><code class="haskell">lst0, lst1, lst2 :: List
lst0 = Empty        -- empty list
lst1 = Cons 1 lst0  -- one-element list
lst2 = Cons 2 lst1  -- two-element list</code></pre><p>This definition can also be used in pattern matching. For instance, here's a function that checks if a list is a singleton:</p><pre><code class="active haskell">data List = Cons Int List | Empty

singleton :: List -&gt; Bool
singleton (Cons _ Empty) = True
singleton _ = False

main = do
   print $ singleton Empty
   print $ singleton $ Cons 2 Empty
   print $ singleton $ Cons 3 $ Cons 4 Empty</code></pre><p>In this example, I made use of a wildcard pattern <code>_</code>. Let me remind you that his pattern matches anything (without evaluating it). For instance, in the first clause of <code>singleton</code> I'm discarding the integer stored in the list. In the second clause I'm ignoring the whole list, because I know that the first clause, which catches one-element lists, is tried first.</p><p>Most importantly, because list is defined recursively, it's easy to implement recursive algorithms for it. For instance, to calculate the sum of all list elements it's enough to say that the sum is equal to the first element plus the sum of the rest. And, of course, the sum of an empty list is zero. So here we go:</p><pre><code class="active haskell">data List = Cons Int List | Empty

sumLst :: List -&gt; Int
sumLst (Cons i rest) = i + sumLst rest
sumLst Empty = 0

lst = Cons 2 (Cons 4 (Cons 6 Empty))

main = do
   print (sumLst lst)
   print (sumLst Empty)</code></pre><p>But you don't want to be defining a new list type for each possible element type. Fortunately, static polymorphism in Haskell is embarassingly easy. No need for the verbose <code>template&lt;typename T&gt;</code> ugliness. You just parameterize types by specifying a type argument. You may define a generic list by replacing <code>Int</code> by a type parameter <code>a</code> (type parameters must start with lower case and are typically taken from the beginning of the alphabet):</p><pre><code class="haskell">data List a = Cons a (List a) | Empty</code></pre><p><code>List a</code> in this definition is a <i>generic type</i>; <code>List</code> itself is called a <i>type constructor</i>, because you can use it to construct a new type by providing a type argument, as in <code>List Int</code>, or <code>List (List Char)</code> (a list of lists of characters). To avoid confusion, the constructors on the right hand side of a <code>data</code> definition are often called <i>data constructors</i>, as opposed to the <i>type constructor</i> on the left.</p><p>In reality, you don't need to define a list type -- its definition is built into the language, and it's syntax is very convenient. The type name for a list consists of a pair of square brackets with the type varaible between them; <code>Cons</code> is replaced by an infix colon, <code>:</code>; and the <code>Empty</code> list is an empty pair of square brackets, <code>[]</code>. You may think of the built-in list type as defined by this equation:</p><pre><code class="haskell">data [a] = a : [a] | []</code></pre><p>Let me rewrite the previous example with this new notation:</p><pre><code class="active haskell">sumLst :: [Int] -&gt; Int
sumLst (i : rest) = i + sumLst rest
sumLst [] = 0

lst = [2, 4, 6]

main = do
   print (sumLst lst)
   print (sumLst [])</code></pre><p>There is another convenient feature: special syntax for list literals. Instead of writing a series of constructors, <code>2:8:64:[]</code>, you can write <code>[2, 8, 64]</code>.</p><p>Pattern matching may be <i>nested</i>. For instance, you may match the first three elements of a list with the pattern <code>(a : (b : (c : rest)))</code> or, taking advantage of the right associativity of <code>:</code>, simply <code>(a : b : c : rest)</code>.</p><p>Finally, this is the definition of <code>String</code>:</p><pre><code class="haskell">type String = [Char]</code></pre><p><code>String</code> comes with some syntactic sugar of its own: When defining string literals, you can write <code>&quot;Hello&quot;</code> instead of the more verbose <code>['H', 'e', 'l', 'l', 'o']</code> .</p><p>Here, the <code>type</code> keyword introduces a <i>type synonym</i> (like the <code>typedef</code> in C). You can always go back and treat a <code>String</code> as a list of <code>Char</code> -- in particular, you may pattern match it like a list. We'll be doing a lot of this in the implementation of <code>tokenize</code>. Type synonyms increase the readability of code and lead to better error messages, but they don't create new types.</p><p>In the <a href="https://www.fpcomplete.com/user/bartosz/basics-of-haskell/6-tokenizer-function-types">next tutorial</a> we'll continue to work on the tokenizer and learn about guards and touch upon currying.</p><h2 id="exercises"><a href="#exercises">Exercises</a></h2><p><b>Ex 4</b>. Implement <code>norm</code> that takes a list of <code>Double</code>s and returns the square root (<code>sqrt</code>) of the sum of squares of its elements.</p><pre><code class="active haskell">norm :: [Double] -&gt; Double
norm lst = undefined

main = print (norm [1.1, 2.2, 3.3])</code></pre><div class="hidden" title="Show solution"><pre><code class="active haskell">norm :: [Double] -&gt; Double
norm lst = sqrt (squares lst)

squares :: [Double] -&gt; Double
squares [] = 0.0
squares (x : xs) = x * x + squares xs

main = print (norm [1.1, 2.2, 3.3])</code></pre></div><p><b>Ex 5</b>. Implement the function <code>decimate</code> that skips every other element of a list.</p><pre><code class="active haskell">decimate :: [a] -&gt; [a]
decimate = undefined

-- should print [1, 3, 5]
main = print (decimate [1, 2, 3, 4, 5])</code></pre><div class="hidden" title="Show solution"><pre><code class="active haskell">decimate :: [a] -&gt; [a]
decimate (a:_:rest) = a : decimate rest
decimate (a:_) = [a]
decimate _ = []

main = print (decimate [1, 2, 3, 4, 5])</code></pre></div><p><b>Ex 6</b>. Implement a function that takes a pair of lists and returns a list of pairs. For instance <code>([1, 2, 3, 4], [1, 4, 9])</code> should produce <code>[(1, 1), (2, 4), (3, 9)]</code>. Notice that the longer of the two lists is truncated if necessary. Use nested patterns.</p><pre><code class="active haskell">zipLst :: ([a], [b]) -&gt; [(a, b)]
zipLst = undefined

main = print $ zipLst ([1, 2, 3, 4], &quot;Hello&quot;)</code></pre><div class="hidden" title="Show solution"><pre><code class="active haskell">zipLst :: ([a], [b]) -&gt; [(a, b)]
zipLst ((x : xs), (y: ys)) = (x, y) : zipLst (xs, ys)
zipLst (_, _) = []

main = print $ zipLst ([1, 2, 3, 4], &quot;Hello&quot;)</code></pre><p>Incidentally, there is a two-argument function <code>zip</code> in the Prelude that does the same thing:</p><pre><code class="active haskell">main = print $ zip [1, 2, 3, 4] &quot;Hello&quot;</code></pre></div></article>

<div id="disqus_thread"><script>var disqus_shortname = "fpcomplete"; (function() { var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true; dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq); })();</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">comments powered by <span class="logo-disqus">Disqus</span></a></a>
</div>

</div>
</div>
<div class="row article-footer"><div class="span7 meta"><span class="sociallinksunicode social">
<a href="https://twitter.com/home?status=$url$" target="_blank"><i class="icon-twitter"></i></a>&nbsp;
<a href="http://www.facebook.com/sharer/sharer.php?u=$url$" target="_blank"><i class="icon-facebook"></i></a>&nbsp;
<a href="https://plus.google.com/share?url=$url$" target="_blank"><i class="icon-google-plus"></i></a></span>
</div>
</div>
</div>
<div class="footer"><div class="container"><div class="row"><div class="span12"><ul class="menu"><li><a href="https://www.schoolofhaskell.com/">School</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user">Users</a>
</li>

<li><a class="brand" href="https://fpcomplete.com">Sponsored by:
<img src="/static/img/logo.png" title="FPComplete">
</a>
</li>
</ul>
</div>
</div>
<div class="row"><div class="span12"></div>
</div>
</div>
</div>
<link rel="stylesheet" type="text/css" href="/static/bootstrap/css/bootstrap-responsive.css" />
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script><script src="https://www.schoolofhaskell.com/static/combined/Y-3k9_tW.js"></script><script>$(function(){
  $("a.logout").click(function(){
    var form = $("<form method='post'/>");
    form.attr("action", $(this).attr("href"));
    $("body").append(form);
    form.submit();
    return false;
  });
});

$(function(){
    $('.sociallinksunicode a').each(function(){
        $(this).attr('href',$(this).attr('href').replace('$url$',document.location));
    });
});

$(function(){
  // If we need to select a user/select a password then show the
  // details confirmation form, otherwise enable the getting started
  // section.
  if($('.alert-block a').text().match(/(selected a username|change your password)/)) {
    $("#confirm-details").show();
    $("#confirm-details #inputUsername").focus();
  } else {
    $("#get-started").removeClass('disabled').addClass('enabled');
  }

  // For lack of a plain HTML validation story this will do.
  $('.welcome-page').each(function(){
    $('form').submit(check);
  });
  function check(){
    setTimeout(check,500);
    var error = false;
    $('.error').removeClass('error');
    $('#enter-details input').each(function(){
      if($(this).val() == '') {
        $(this).parent().parent().addClass('error');
        error = true;
      }
    });
    if(error) return false;
    if($('[name=password]').val() == $('[name=confirm]').val()) {
      $('#confirm').removeClass('error');
      return true;
    } else {
      $('#confirm').addClass('error');
      return false;
    }
  }
});

$(function(){
  // When scrolling over a snippet editor, activate the "clone in IDE" popovers
  $('article').each(function(){
    var n = 100;
    var wait = 10000;
    function check(){
      if($('.clone').length == 0) {
        setTimeout(check,n);
        return;
      }
      var activated = $.cookie('clone-popover');
      if (activated) return;
      var activate = false;
      $('.controlsRun:onScreen').each(function(){
        $.cookie('clone-popover', 'true', { expires: 30, path: '/' });
        activate = true;
        return false;
      });
      if(activate) {
          $('.clone').each(function(){
              // The bootstrap API is rather unreasonable to say the
              // least.
              next = $(this).parent();
              var title = next.attr('title');
              next.attr('data-content',$(this).attr('data-content'));
              next.attr('title',$(this).attr('title'));
              next.popover('show',{
                  title: $(this).attr('title')
              });
              next.attr('title',title);
          });
          setTimeout(function(){
              $('.clone').each(function(){
                  $(this).parent().popover('hide');
              });
          },wait);
      } else {
        setTimeout(check,n);
      }
    }
    setTimeout(check,n);
  });
});

// onScreen jQuery plugin v0.2.1
// (c) 2011-2013 Ben Pickles
//
// http://benpickles.github.com/onScreen
//
// Released under MIT license.
(function(a){a.expr[":"].onScreen=function(b){var c=a(window),d=c.scrollTop(),e=c.height(),f=d+e,g=a(b),h=g.offset().top,i=g.height(),j=h+i;return h>=d&&h<f||j>d&&j<=f||i>e&&h<=d&&j>=f}})(jQuery);

/*!
 * jQuery Cookie Plugin v1.1
 * https://github.com/carhartl/jquery-cookie
 *
 * Copyright 2011, Klaus Hartl
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.opensource.org/licenses/GPL-2.0
 */
(function($, document) {

  var pluses = /\+/g;
  function raw(s) {
    return s;
  }
  function decoded(s) {
    return decodeURIComponent(s.replace(pluses, ' '));
  }

  $.cookie = function(key, value, options) {

    // key and at least value given, set cookie...
    if (arguments.length > 1 && (!/Object/.test(Object.prototype.toString.call(value)) || value == null)) {
      options = $.extend({}, $.cookie.defaults, options);

      if (value == null) {
	options.expires = -1;
      }

      if (typeof options.expires === 'number') {
	var days = options.expires, t = options.expires = new Date();
	t.setDate(t.getDate() + days);
      }

      value = String(value);

      return (document.cookie = [
	encodeURIComponent(key), '=', options.raw ? value : encodeURIComponent(value),
	options.expires ? '; expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE
	options.path    ? '; path=' + options.path : '',
	options.domain  ? '; domain=' + options.domain : '',
	options.secure  ? '; secure' : ''
      ].join(''));
    }

    // key and possibly options given, get cookie...
    options = value || $.cookie.defaults || {};
    var decode = options.raw ? raw : decoded;
    var cookies = document.cookie.split('; ');
    for (var i = 0, parts; (parts = cookies[i] && cookies[i].split('=')); i++) {
      if (decode(parts.shift()) === key) {
	return decode(parts.join('='));
      }
    }
    return null;
  };
  $.cookie.defaults = {};})(jQuery, document);
</script><!--[if lt IE 10]><script src="https://www.schoolofhaskell.com/static/design/js/ie.js?etag=ayV2DuJ0"></script><![endif]--><script>if(!window.location.href.match(/localhost/)){var track = '/tutorial/school/starting-with-haskell/basics-of-haskell/5-tokenizer-data-types';
window._gaq = [['_setAccount','UA-36928035-1'],track != ''? ['_trackPageview',track] : ['_trackPageview']
,['_trackPageLoadTime']];window._gaq.push(['_setCustomVar',1,'Section','School of Haskell',3]);
window._gaq.push(['_setCustomVar',2,'User Type','Visitor',1]);
(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);

})();}</script>
<!-- Prompt IE 6 users to install Chrome Frame. Remove this if you want to support IE 6.  chromium.org/developers/how-tos/chrome-frame-getting-started --><!--[if lt IE 7 ]><script src="//ajax.googleapis.com/ajax/libs/chrome-frame/1.0.3/CFInstall.min.js"></script><script>window.attachEvent('onload',function(){CFInstall.check({mode:'overlay'})})</script><![endif]--></body></html>