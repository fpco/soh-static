<!DOCTYPE html>
<html><head><title>Mónadas - School of Haskell | School of Haskell</title><meta http-equiv="x-ua-compatible" content="IE=9"><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="google-site-verification" content="Rfxk2TdeMMXEXHgJ2_OO8Rt3hPbQSDao0OXQV_n6z_s" /><link href="//fonts.googleapis.com/css?family=Merriweather" rel="stylesheet" type="text/css"><link href="https://www.schoolofhaskell.com/recent-content/feed" type="application/rss+xml" rel="alternate" title="Recently published content">
<link rel="stylesheet" href="https://www.schoolofhaskell.com/static/combined/UlwEHVcM.css"><style>.social{margin-right:1em}h1{font-family:Merriweather !important}article{font-family:Merriweather !important}article li{font-family:Merriweather !important;line-height:1.6em}h1,h2,h3,h4,h4,h5{font-family:Merriweather !important}.editor p{font-family:Frutiger, "Frutiger Linotype", Univers, Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans Condensed", "Liberation Sans", "Nimbus Sans L", Tahoma, Geneva, "Helvetica Neue", Helvetica, Arial, sans-serif}.article-footer{border-top:1px solid #ddd;padding-top:1em;margin-top:1em}body{font-size:16px !important}.navbar .navbar-inner{background:#3c3f41}.navbar .brand{font-size:14px}.navbar .brand img{width:6em}.navbar .icon-wrench{margin:0 -0.5em 0 -0.5em;padding:0 1em 0 1em;height:20px}.navbar-inverse .nav .active a{background:#333638}.navbar-inverse .nav > li > a{color:#a7a7a7
}.navbar-inverse .btn-navbar{background:#333638}.navbar-inverse .nav > li a:hover,.navbar-inverse .btn{background:#333537 !important}@media (max-width: 979px) {.icon-wrench{padding-left:1em !important}}.breadcrumb{border-top-left-radius:0;border-top-right-radius:0}h1{margin-top:20px}.breadcrumb-container + .main-content h1{margin-top:0}.footer{padding:30px 0;margin-top:70px;border-top:1px solid #e5e5e5;background-color:#f5f5f5}.footer ul.footer-menu{list-style-type:none}.footer ul.footer-menu li{display:inline-block}.footer ul.footer-menu li + li{margin-left:0.5em}.footer ul.footer-menu li + li:before{margin-right:0.5em;content:"·";color:#999}.footer ul.menu li{display:inline-block}.footer ul.menu li + li{margin-left:0.5em}.footer .copyright{margin-left:25px}.main-content{min-height:100%}.gravatar{width:80px;height:80px;border-radius:2px;background:#eee}.empty-gravatar{width:0}.container{font-family:"Segoe UI", Candara, "Bitstream Vera Sans", "DejaVu Sans", "Bitstream Vera Sans", "Trebuchet MS", Verdana, "Verdana Ref", sans-serif}.container h1,.container h2,.container h4,.container h4,.container h5{font-family:"Segoe UI", Candara, "Bitstream Vera Sans", "DejaVu Sans", "Bitstream Vera Sans", "Trebuchet MS", Verdana, "Verdana Ref", sans-serif}article{font-family:Merriweather !important}article h1{font-family:Merriweather !important}article li{font-family:Merriweather !important;line-height:1.6em}article li + li{margin-top:0.5em}article div.code{background:#f9f9f9;border:1px solid #d1d1d1;position:relative;border-radius:0.2em;margin:0.25em 0 0.75em 0;min-height:2.5em}article code{color:#005580;font-size:14px;white-space:pre}article a.hoogle > code{color:#0088cc;font-size:14px;white-space:pre;border:0}article .expand-code{display:none}article pre{overflow:auto;word-wrap:normal}article code.active{display:block;max-height:430px}article h1{font-size:31.5px}article h3{font-size:17.5px}article h4{font-size:14px}article h5,article h6{font-size:11.9px}article p{line-height:1.7em}article h1 code,article h2 code,article h3 code,article h4 code,article h5 code,article h6 code{font-size:inherit !important}article h1 a,article h2 a,article h3 a,article h4 a,article h5 a,article h6 a{color:#444}article h1 a:before,article h2 a:before,article h3 a:before,article h4 a:before,article h5 a:before,article h6 a:before{margin-left:-1.5em;padding-right:0.5em;font-family:fontawesome;content:"\f0c1";font-size:20px;color:#fff}article h1 a:hover,article h2 a:hover,article h3 a:hover,article h4 a:hover,article h5 a:hover,article h6 a:hover{text-decoration:none;color:#0088cc}article h1 a:hover:before,article h2 a:hover:before,article h3 a:hover:before,article h4 a:hover:before,article h5 a:hover:before,article h6 a:hover:before{color:#888}article h2{font-size:24.5px}article .popover{font-family:actor}article .popover h3.popover-title{font-family:actor !important;font-size:1em}article .popover .popover-content{width:15em;font-size:1em}article .controlsRun{display:block;padding:0.5em;text-align:right;background:#f2f2f2}article .controlsRun a.clone{margin-right:1em;font-family:actor;text-decoration:none}article .controlsRun a.clone span{padding-left:0.5em}article .controlsRun a.run,article .controlsRun a.reset,article .controlsRun a.show-code{font-size:16px}article .controlsRun a.run span,article .controlsRun a.reset span,article .controlsRun a.show-code span{display:none}article .controlsRun a.reset{margin-left:0.5em;color:#a2becc}article .controlsRun a.reset{display:none}article .controlsRun a.show-code{margin-right:0.75em}article .controlsRun a.run:hover,article .controlsRun a.show-code:hover{text-decoration:none}article .controlsRun a.show-code.active{color:#DC0D0D}article .controlsRun a[disabled]{color:#a2becc;cursor:default}article .collapse-area .collapse-header{background:#0088cc;color:#fff;padding:0.3em;cursor:pointer}article .collapse-area .hidden-toggle:before{content:"\f0d7";font-family:fontawesome;margin-right:0.5em;margin-left:0.25em}article .collapse-area .collapsed-files{overflow:auto;height:auto}article .collapse-area.collapse-disabled{display:none}article .collapse-area.collapse-area-off .collapsed-files{height:0px;overflow:hidden}article .collapse-area.collapse-area-off .hidden-toggle:before{content:"\f0da"}article .snippet-stdio .stdout{margin:0.5em;padding-right:2em;position:relative;word-wrap:break-word}article .snippet-stdio .stdin{-webkit-box-shadow:none;-moz-box-shadow:none;box-shadow:none;-webkit-transition:none;-moz-transition:none;-o-transition:none;transition:none;padding:0;margin:0}article .hoogle-results{margin:0.25em}article .hoogle-results .hoogle-inner{background:#fff;padding:0.5em;border-radius:3px;border:1px solid #ddd}article .hoogle-results .hoogle-inner .close-link{position:relative;float:right;margin-top:-0.5em;margin-right:-0.5em}article .snippet-output-errors{margin:1em 0.5em 0.5em 0.5em;position:relative}article .snippet-output-errors ul{list-style-type:none;margin:0;position:relative}article .snippet-output-errors pre{border:0;border-radius:0;padding:0.25em;margin:0;background:inherit;color:inherit}article .snippet-output-errors .close-link{color:inherit;background:inherit}article .snippet-editors{z-index:0;padding:0.25em}article .close-link{padding:0.5em;background:#eaeaea;border-bottom-left-radius:0.2em;border-top-right-radius:0.2em;position:absolute;top:0;right:0}article .close-link:hover{text-decoration:none}article .snippet-title{padding:0.5em 0 0 0.5em}article .snippet-title .snippet-icon{font-family:FontAwesome;display:inline-block;margin-right:0.5em}article .fullModuleCode + div .snippet-title{margin-top:0.5em;border-top:1px solid #ccc;padding-top:0.5em}article .CodeMirror{height:auto;min-height:1em;line-height:1.5em;background:transparent;font-size:14px !important}article .CodeMirror .highlighted{background:rgba(250, 210, 0, 0.45) !important}article .CodeMirror-widget{margin-left:2em;line-height:1.8}article .CodeMirror.collapsed{height:10em !important}article .editor .expander{text-align:center;display:block;padding:0.5em;text-decoration:none;border-bottom-left-radius:2px;border-bottom-right-radius:2px}article .editor .expander .ellipsis{background:white;border:1px solid #ccc;padding:0 0.5em;height:1em;line-height:0.5em;display:inline-block;color:#555;cursor:pointer}article .editor .expander .ellipsis:hover{background:#ddd;color:#333}article .web-runner{margin:0.5em;padding:0.5em;border:1px solid #ccc;border-radius:3px;background:#f5f5f5}article .web-runner iframe{border:0;margin-top:0.5em;margin-bottom:0;background:white}article .web-runner .controls i{cursor:pointer;color:#0088cc}article .web-runner .controls i:hover{color:#222}article .web-runner .controls i + i{margin-left:0.5em}article .web-runner .controls .icon-remove{float:right}article .hidden{display:block;visibility:visible}article .controlsShowHide{margin-bottom:0.5em}.tutorial-body{float:left !important}.tutorial-nav{float:right !important}@media (max-width: 979px) {.related-content{float:right}.author-name{display:block;margin-left:20px !important;padding-left:5px;margin-top:5px}article h1 a:hover:before,article h2 a:hover:before,article h3 a:hover:before,article h4 a:hover:before,article h5 a:hover:before,article h6 a:hover:before{color:#fff}.tutorial-nav{float:none !important;width:auto !important}.tutorial-body{float:none !important;width:auto !important}}@media (min-width: 980px) and (max-width: 1199px) {.navbar-search{display:none}.tutorial-nav{width:200px}.tutorial-body{width:720px}}#accountPage h1{margin:20px 0 0 0}#accountPage h2{font-size:20px}.group-contents .span8{float:left}.group-contents .span4{float:right}.container > .alert-block{margin-top:1em}.alert{color:#aa874a
}.social{margin-bottom:.8em;display:block}.social a{text-decoration:none}.social i{font-size:1.1em;color:#fff;padding:0.25em;border-radius:0.25em;width:1em;display:inline-block;text-align:center}.social i.icon-twitter{background:#0088cc}.social i.icon-facebook{background:#3b5998
  }.social i.icon-google-plus{background:#dd4b39
  }.well pre{background:#fcfcfc}.well h2{margin-top:0}code{color:#005580;font-size:14px;white-space:pre}</style><!--[if lt IE 8]><link rel="stylesheet" href="https://www.schoolofhaskell.com/static/design/css/ie7.css?etag=TSMl9x1V"><![endif]--><!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]--></head><body class="not-logged-in" itemscope itemtype="http://schema.org/Product"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-H62P" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-H62P');</script><div class="navbar navbar-inverse navbar-static-top"><div class="navbar-inner"><div class="container"><a class="btn btn-navbar" type="button" data-toggle="collapse" data-target=".nav-collapse"><span class="icon-bar"></span>
<span class="icon-bar"></span>
<span class="icon-bar"></span>
</a>
<a class="brand" href="/"><img src="/static/img/haskell-logo-wide.png" title="School of Haskell">
</a>
<div class="nav-collapse collapse"><ul class="nav"><li><a href="https://www.schoolofhaskell.com/">School</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user">Users</a>
</li>
</ul>
<form class="navbar-search pull-left" action="https://www.schoolofhaskell.com/search"><input class="search-query" type="text" placeholder="Search" name="search">
</form>
</div>
</div>
</div>
</div>
<div class="container breadcrumb-container"><div class="row"><div class="span12"><ul class="breadcrumb"><li><a href="https://www.schoolofhaskell.com/user/XookDo">Xook &amp; Do</a>
<span class="divider">/</span>
</li>
<li><a href="https://www.schoolofhaskell.com/user/XookDo/introduccion-a-la-programacion-funcional">Introducción a la Programación Funcional</a>
<span class="divider">/</span>
</li>
<li><a href="https://www.schoolofhaskell.com/user/XookDo/introduccion-a-la-programacion-funcional/parte-7">Parte 7</a>
<span class="divider">/</span>
</li>
<li><a href="https://www.schoolofhaskell.com/user/XookDo/introduccion-a-la-programacion-funcional/parte-7/tutorial">Mónadas</a>
</li>
</ul>
</div>
</div>
</div>
<div class="container main-content"><div class="row"><div class="span12"><h1 itemprop="name">Mónadas</h1>
</div>
</div>
<div class="row"><div class="span7 meta"><p><span class="date">29 Sep 2015</span>
<span class="author"><a href="https://www.schoolofhaskell.com/user/XookDo">Xook &amp; Do</a>
</span>
<span class="view-edit-link pull-right"><a class="view-source-link" href="https://www.schoolofhaskell.com/tutorial-raw/20078/23ff40ef8d178411cba3953bf050104b19d9f8ef">View Markdown source</a>
</span>
</p>
<p class="tags"></p>
</div>
</div>
<div class="row"><div class="span7 meta"><span class="sociallinksunicode social">
<a href="https://twitter.com/home?status=$url$" target="_blank"><i class="icon-twitter"></i></a>&nbsp;
<a href="http://www.facebook.com/sharer/sharer.php?u=$url$" target="_blank"><i class="icon-facebook"></i></a>&nbsp;
<a href="https://plus.google.com/share?url=$url$" target="_blank"><i class="icon-google-plus"></i></a></span>
</div>
</div>
<p class="alert">As of March 2020, School of Haskell has been switched to read-only mode.</p>
<div class="row" itemprop="desc"><div class="span4 tutorial-nav"><div class="related-content"><ul class="nav nav-tabs nav-stacked"><li><script>reddit_target='fpcomplete'</script>
<script src="https://redditstatic.s3.amazonaws.com/button/button1.js"></script>
</li>
<li><a href="https://www.schoolofhaskell.com/user/XookDo/introduccion-a-la-programacion-funcional/parte-7">Go up to: Parte 7</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user/XookDo">See all content by Xook &amp; Do</a>
</li>
</ul>

</div>
<div class="aside"><h3>Sections</h3>
<ul><li><a href="#m-nadas">Mónadas</a><ul><li><a href="#leyes-de-los-m-nadas">Leyes de los mónadas</a><ul><li><a href="#leyes-de-los-m-nadas-en-t-rminos-de------">Leyes de los mónadas en términos de (&gt;=&gt;)</a></li><li><a href="#leyes-de-los-m-nadas-en-t-rminos-simples">Leyes de los mónadas en términos simples</a></li><li><a href="#relaci-n-entre----------y-return">Relación entre &gt;=&gt;, &gt;&gt;= y return</a></li></ul></li><li><a href="#maybe-como-m-nada">Maybe como mónada</a></li><li><a href="#notaci-n-do">Notación do</a></li><li><a href="#listas-como-m-nadas">Listas como mónadas</a></li><li><a href="#el-m-nada-io">El mónada IO</a></li><li><a href="#excepciones">Excepciones</a></li><li><a href="#ejercicios">Ejercicios</a></li><li><a href="#siguiente-tutorial">Siguiente tutorial</a></li></ul></li></ul></div>
</div>
<div class="span8 tutorial-body" data-environment="def">
<article><p>En este tutorial, nos enfocaremos en el estudio de la clase <code>Monad</code>; esta clase es especial en Haskell por dos razones:</p><ul><li>Existe azúcar sintáctico que nos facilita su uso, la notación <code>do</code>, que de hecho ya hemos utilizando sin una buena explicación.</li><li>Se utiliza para interactuar con el mundo real, cosa que ya hemos estado haciendo cada vez que imprimimos en consola igual sin una buena explicación.</li></ul><p>En este tutorial daremos esas buenas explicaciones.</p><h1 id="m-nadas"><a href="#m-nadas">Mónadas</a></h1><p>De la definición del funtor applicativo a la del mónada sólo hay una función adicional de diferencia, <code>join :: m (m a) -&gt; m a</code>; su función es la de &quot;eliminar&quot; un contenedor cuando hay dos anidados.</p><p>Para la lista, la definición de <code>join</code> es simplemente <code>concat</code> (concatenación de listas):</p><pre><code class="active haskell">join = concat

aListOfLists :: [[Int]]
aListOfLists = [[1,2],[3,4]]

joinedLists :: [Int]
joinedLists = join aListOfLists

main =
  do
    print aListOfLists
    print $ join joinedLists</code></pre><p>La definición de <code>join</code> para <code>Maybe</code> sería esta:</p><pre><code class="haskell">join (Just (Just x)) = Just x -- From two anidated containers to one
join (Just Nothing) = Nothing -- From two anidated containers to one</code></pre><p>La definición completa de la clase mónada podría ser entonces:</p><pre><code class="haskell">class Applicative m =&gt; Monad m where
  join  :: m (m a) -&gt; m a

  (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b
  m &gt;&gt;= f = join (fmap f m)

  (&gt;&gt;)  :: m a -&gt; m b -&gt; m b
  m &gt;&gt; n = m &gt;&gt;= \_ -&gt; n</code></pre><p><code>&gt;&gt;=</code> es un operador llamado &quot;bind&quot; y podemos ver que su definición se deriva de <code>join</code> y de <code>fmap</code> por lo que es correcto afirmar que un mónada es un funtor aplicativo con la operación adicional de <code>join</code>.</p><p>Sin embargo, por razones históricas, la verdadera definición de la clase <code>Monad</code> es esta otra:</p><pre><code class="haskell">class Applicative m =&gt; Monad m where
  return :: a -&gt; m a
  return = pure -- pure comes with m being also an applicative functor. return and pure do exactly the same thing!

  (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b

  (&gt;&gt;)  :: m a -&gt; m b -&gt; m b
  m &gt;&gt; n = m &gt;&gt;= \_ -&gt; n</code></pre><p>En esta definición no se nos pide implementar <code>join</code> y en su lugar, tenemos que implementar <code>&gt;&gt;=</code>. Teniendo <code>&gt;&gt;=</code>, podríamos derivar para todo mónada la definición de <code>join</code> pues así como <code>m &gt;&gt;= f = join (fmap f m)</code>, <code>join m = m &gt;&gt;= id</code> (<code>id</code> es la función identidad' <code>id x = x</code>). Dado <code>&gt;&gt;=</code>, igual podríamos derivar para todo mónada la definición de <code>fmap</code>, pues <code>fmap f x = x &gt;&gt;= (return.f)</code>.</p><h2 id="leyes-de-los-m-nadas"><a href="#leyes-de-los-m-nadas">Leyes de los mónadas</a></h2><p>Hay dos maneras de expresar las leyes de los mónadas:</p><ul><li>En términos de <code>&gt;&gt;=</code> y <code>return</code>. Al ser estas funciones parte de la definición de la clase <code>Monad</code>, me referiré a esta manera como &quot;en términos simples&quot;.</li><li>En términos de <code>&gt;=&gt;</code>. La función <code>&gt;=&gt;</code> (llamada &quot;composición de Kleisli&quot; o &quot;pescado&quot;) está definida en términos de <code>&gt;&gt;=</code> y <code>return</code> por lo que esta manera de de expresar las leyes de los mónadas es teórica mente más compleja, pero visualmente e intuitivamente más sencilla de comprender.</li></ul><p>En las secciones <b>Leyes de los mónadas en términos de (&gt;=&gt;)</b> y <b>Leyes de los mónadas en términos simples</b> veremos las leyes en términos de (<code>&gt;=&gt;</code>) y <code>&gt;&gt;= &amp; return</code> respectivamente. Entender solo una sección es suficiente. En la sección <b>Relación entre &gt;=&gt;, &gt;&gt;= y return</b> comprobaremos que ambas maneras son equivalentes; está sección podría ser ignorada siempre y cuando se entienda alguna de las dos maneras de expresar las leyes de los mónadas.</p><h3 id="leyes-de-los-m-nadas-en-t-rminos-de------"><a href="#leyes-de-los-m-nadas-en-t-rminos-de------">Leyes de los mónadas en términos de (&gt;=&gt;)</a></h3><p><code>(&gt;=&gt;)</code> es como composición de funciones, <code>(.)</code>, pero para funciones de este tipo: <code>a -&gt; m b</code>, donde <code>m</code> es el contenedor de un mónada; el tipo de <code>(&gt;=&gt;)</code> es <code>(a -&gt; m b) -&gt; (b -&gt; m c) -&gt; (a -&gt; m c)</code>. Usando <code>(&gt;=&gt;)</code> se pueden definir las 3 leyes de los mónadas de esta manera:</p><ul><li><p><b>Identidad por la izquierda:</b></p></li></ul><p><code>(return &gt;=&gt; f) = f</code>
Que significa que <code>return</code> a la izquierda de <code>&gt;=&gt;</code> forma la función identidad.</p><ul><li><p><b>Identidad por la derecha:</b></p></li></ul><p><code>(f &gt;=&gt; return) = f</code>
Que significa que <code>return</code> a la derecha de <code>&gt;=&gt;</code> forma la función identidad.</p><ul><li><p><b>Asociatividad:</b></p></li></ul><p><code>(f &gt;=&gt; g) &gt;=&gt; h = f &gt;=&gt; (g &gt;=&gt; h)</code>
Que simplemnete significa que el operador <code>&gt;=&gt;</code> es asociativo.</p><h3 id="leyes-de-los-m-nadas-en-t-rminos-simples"><a href="#leyes-de-los-m-nadas-en-t-rminos-simples">Leyes de los mónadas en términos simples</a></h3><p>A continuación formularemos las leyes de los mónadas en términos de <code>return</code> y <code>&gt;&gt;=</code>; es un poco más verbosa que la forma de expresar las leyes en términos de <code>&gt;=&gt;</code>, pero también es más directa.</p><ul><li><p><b>Identidad por la izquierda:</b>
<code>return a &gt;&gt;= f = f a</code></p></li><li><p><b>Identidad por la derecha:</b>
<code>m &gt;&gt;= return = m</code></p></li><li><p><b>Asociatividad:</b>
<code>(m &gt;&gt;= f) &gt;&gt;= g = m &gt;&gt;= (\x -&gt; f x &gt;&gt;= g)</code></p></li></ul><h3 id="relaci-n-entre----------y-return"><a href="#relaci-n-entre----------y-return">Relación entre &gt;=&gt;, &gt;&gt;= y return</a></h3><p>Para poder argumentar que basta con seguir las leyes basadas en <code>&gt;=&gt;</code>, es necesario comprobar su relación con la formulación de las leyes basadas en <code>&gt;&gt;=</code> y <code>return</code>.</p><p>Primero veamos la definición de <code>(&gt;=&gt;)</code>:</p><pre><code class="haskell">(&gt;=&gt;) :: (a -&gt; m b) -&gt; (b -&gt; m c) -&gt; a -&gt; m c
-- or as I find clearer that (&gt;=&gt;) is a kind of function composition:
(&gt;=&gt;) :: (a -&gt; m b) -&gt; (b -&gt; m c) -&gt; {-hi-}({-/hi-}a -&gt; m c{-hi-}){-/hi-}
f &gt;=&gt; g = \x -&gt; f x &gt;&gt;= g</code></pre><p>Con esto queda claro que <code>(&gt;=&gt;)</code> está definida en términos de <code>&gt;&gt;=</code>. A continuación transformaremos cada una de las leyes en términos de <code>(&gt;=&gt;)</code> a términos de <code>&gt;&gt;=</code> y <code>return</code> hasta llegar a la formulación de las leyes en términos de <code>&gt;&gt;=</code> y <code>return</code>; así quedará demostrado que las dos maneras de expresar las leyes son equivalentes.</p><p>Iniciemos con la primer ley: <code>return &gt;=&gt; f = f</code></p><pre><code class="haskell">-- Substituting &gt;=&gt; by its definition:
-- before:
(return {-hi-}&gt;=&gt;{-/hi-} f) = f

-- after:
\x -&gt; return x {-hi-}&gt;&gt;={-/hi-} f = f
-- and applying an x to both sides:
return x &gt;&gt;= f = f x -- which equals to the first rule in simple terms</code></pre><p>Similar con la segunda ley:</p><pre><code class="haskell">-- before:
(f {-hi-}&gt;=&gt;{-/hi-} return) x = f x

-- after:
\x -&gt; f x {-hi-}&gt;&gt;={-/hi-} return = f
-- and applying an x to both sides:
f x &gt;&gt;= return = f x -- which equals to the second rule in simple terms</code></pre><p>Y por último, la tercera ley:</p><pre><code class="haskell">-- let's do first the left hand side of the law: `(f &gt;=&gt; g) &gt;=&gt; h`
-- substituting `(f &gt;=&gt; g)` by the definition of &gt;=&gt;: 
\x -&gt; (f x &gt;&gt;= g) &gt;=&gt; h

-- then, substituting (\x -&gt; f x &gt;&gt;= g) {-hi-}&gt;=&gt;{-/hi-} h by the definition of &gt;=&gt;:
\y -&gt; \x -&gt; (f x &gt;&gt;= g) y &gt;&gt;= h

-- which is obviously equal to simply:
\x -&gt; (f x &gt;&gt;= g) &gt;&gt;= h

-- now the right hand side of the law: f &gt;=&gt; (g &gt;=&gt; h)
-- substituting `(g &gt;=&gt; h)` by the definition of &gt;=&gt;:
f &gt;=&gt; (\y -&gt; g y &gt;&gt;= h)

-- then, substituting `f {-hi-}&gt;=&gt;{-/hi-} (\y -&gt; g x &gt;&gt;= h)` by the definition of &gt;=&gt;:
\x -&gt; f x &gt;&gt;= (\y -&gt; g y &gt;&gt;= h)

-- now we can put result1 and result2 side by side in an equation:
\x -&gt; (f x &gt;&gt;= g) &gt;&gt;= h   =   \x -&gt; f x &gt;&gt;= (\y -&gt; g y &gt;&gt;= h)

-- and applying an x to both sides:
(f x &gt;&gt;= g) &gt;&gt;= h   =   f x &gt;&gt;= (\y -&gt; g y &gt;&gt;= h)
-- which equals to the third law in simple terms</code></pre><h2 id="maybe-como-m-nada"><a href="#maybe-como-m-nada">Maybe como mónada</a></h2><p><code>Maybe</code> además de ser miembro de la clase <code>Functor</code> y de la clase <code>Applicative</code>, también es miembro de la clase <code>Monad</code>. Veamos algunos ejemplos y luego los explicaremos con detalle.</p><pre><code class="active haskell">import Control.Applicative
main =
  do
    print ((Just 1) &gt;&gt;= (\x -&gt; Just (x + 1))) -- case 1.1
    print ((Just 1) &gt;&gt;= (return.(+ 1)))       -- case 1.2
    print ((Just 1) &gt;&gt;= (pure.(+ 1)))         -- case 1.3

    print (Nothing &gt;&gt;= return.(+ 1))          -- case 2</code></pre><p>Los casos 1.1, 1.2 y 1.3 son equivalentes, así que sólo expandiremos el caso 1.1:</p><pre><code class="haskell">(Just 1) &gt;&gt;= (\x -&gt; Just (x + 1))
-- using this definition: m &gt;&gt;= f = join (fmap f m), it equals to:
join (fmap (\x -&gt; Just (x + 1)) (Just 1))
-- by the definition of fmap for Maybe
join (Just (Just 2))
-- which by the definition of join, it equals to:
Just 2</code></pre><p>Ahora el caso 2:</p><pre><code class="active haskell">Nothing &gt;&gt;= return.(+ 1)
-- by the definition of &gt;&gt;= for Maybe
join (fmap (\x -&gt; Just (x + 1)) Nothing)
-- by the definition of fmap for Maybe
join (Just Nothing)
-- by the definition of join for Maybe
Nothing</code></pre><p>Con suerte, tu pensamiento crítico se esté preguntando: ¿Por qué <code>join (Just (Just x)) = Just x</code>? o ¿Por qué <code>join (Just (Nothing))</code> no es igual a <code>Just 0</code> en vez de <code>Nothing</code>?, pero la respuesta no es mas que: porque así es la definición del &quot;contexto&quot; de <code>Maybe</code>. Por otro lado, esta implementación de <code>Monad</code> es bastante útil, pues ataca el error de <a href="http://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare">mil millones de dólares</a>; a continuación un ejemplo:</p><pre><code class="active haskell">add m1 m2 =
  m1 &gt;&gt;= (\x1 -&gt; m2 &gt;&gt;= (\x2 -&gt; return (x1 + x2)))

main =
  do
    print $ add (Just 1) (Just 2)
    print $ add {-hi-}Nothing{-/hi-} (Just 2)             -- first value is &quot;absent&quot;
    print $ add (Just 1) {-hi-}Nothing{-/hi-}             -- second value is &quot;absent&quot;
    print $ add {-hi-}Nothing{-/hi-} {-hi-}Nothing{-/hi-} -- both values are &quot;absent&quot;</code></pre><p>En otros lenguajes, la ausencia de un valor se trata con un <code>null</code> (o <code>nil</code>) y eso nos obliga a checar que cada argumento no sea <code>null</code>; en Haskell, todos esos errores se detectan en tiempo de compilación, pues si un valor puede no estar presente, se tiene que declarar de forma explícita rodeando su tipo de un <code>Maybe</code>.</p><h2 id="notaci-n-do"><a href="#notaci-n-do">Notación do</a></h2><p>Como ya habíamos mencionado, una de las razones por la que los mónadas son especiales en Haskell es porque ofrecen azúcar sintáctico para el operador <code>&gt;&gt;=</code>. Antes de explicarlo con detenimiento, veámoslo en acción:</p><pre><code class="active haskell">add m1 m2 =
-- previously: m1 &gt;&gt;= (\x1 -&gt; m2 &gt;&gt;= (\x2 -&gt; return (x1 + x2)))
  do
    x1 &lt;- m1
    x2 &lt;- m2
    return $ x1 + x2

main =
  do
    print $ add (Just 1) (Just 2)
    print $ add Nothing (Just 2)
    print $ add (Just 1) Nothing
    print $ add Nothing Nothing</code></pre><p>Después de estar usando la notación <code>do</code> por todos lados, ahora sí va una explicación detallada. Cada bloque <code>do</code> corresponde a esta expresión: <code>m1 &gt;&gt;= (\x1 -&gt; (m2 &gt;&gt;= (\x2 -&gt; (... (mn &gt;&gt;= (\xn -&gt; exp))))))</code>, donde <code>x1</code> representa un valor extraído de su contexto <code>m1</code>, <code>x2</code> representa un valor extraído de su contexto <code>m2</code>, <code>xn</code> algún valor extraido de su contexto <code>mn</code> y <code>exp</code> una expresión que regresa algún valor dentro de un mónada.</p><p>Poniéndolos lado a lado:</p><pre><code class="haskell">add m1 m2 =          |add m1 m2 = 
  do                 |
    x1 &lt;- m1         |  m1 &gt;&gt;= (\x1 -&gt;
    x2 &lt;- m2         |    m2 &gt;&gt;= (\x2 -&gt;
    return $ x1 + x2 |      return $ x1 + x2))</code></pre><p>Así queda claro que aunque la notación <code>do</code> puede parecer programación imperativa, cada línea dentro de un bloque <code>do</code> corresponde a una parte de una sola expresión.</p><p>El operador <code>&gt;&gt;</code> se utiliza para realizar los efectos secundarios de extraer un valor de su contexto sin importar realmente el valor extraido, de ahí que su definición sea esta: <code>m &gt;&gt; n = m &gt;&gt;= \{-hi-}_{-/hi-} -&gt; n</code> donde el guión bajo significa que se ignora el valor extraido de <code>m</code>. Imprimir dos veces en consola es un caso de uso simple para este operador:</p><pre><code class="active haskell">main = putStr &quot;Hello&quot; &gt;&gt; putStr &quot;, world!&quot;</code></pre><p>El tipo de <code>putStr</code> es <code>:: String -&gt; IO ()</code>, donde <code>IO</code> es un mónada y <code>()</code> es <b><i>unit</i></b>, el único valor carente de información en Haskell. Al <code>putStr</code> producir un <code>IO ()</code> es obvio que no nos importa lo que contiene el contenedor de <code>IO</code>, sino sólo el efecto secundario de extraer <code>()</code> de <code>IO</code> el cual es imprimir en consola. Para el operador <code>&gt;&gt;</code> la notación <code>do</code> también ofrece azúcar sintáctico. Dado que <code>&gt;&gt;</code> ignora el valor extraido de su contenedor, no hay necesidad de capturarlo en un patrón, por lo que simplemente se omite <code>xn &lt;- </code> de <code>xn &lt;- mn</code> quedando de esta manera:</p><pre><code class="active haskell">main =
  do
    putStr &quot;Hello&quot;
    putStr &quot;, world!&quot;</code></pre><p>Podríamos capturar los valores extraidos de <code>IO ()</code>, pero no podríamos hacer mucho con ellos:</p><pre><code class="active haskell">main =
  do
    x1 &lt;- putStr &quot;Hello&quot;
    x2 &lt;- putStrLn &quot;, world!&quot;
    print x1
    print x2</code></pre><p>Hubiésemos podido simplemente hacer:</p><pre><code class="active haskell">main =
  do
    putStr &quot;Hello&quot;
    putStrLn &quot;, world!&quot;
    print ()
    print ()</code></pre><h2 id="listas-como-m-nadas"><a href="#listas-como-m-nadas">Listas como mónadas</a></h2><p>Las listas también son mónadas en Haskell y su implementación de <code>join</code> es simplemente <code>concat</code>. Veámoslo en acción:</p><pre><code class="active haskell">x = do
  x1 &lt;- [1,2,3]
  x2 &lt;- [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]
  return (show x1 ++ x2)

main = print x</code></pre><p>Analicemos con detalle que sucede en <code>x</code>.
Primero, eliminemos el azúcar sintáctico de la notación <code>do</code>.</p><pre><code class="active haskell">x =
  [1,2,3] &gt;&gt;= (\x1 -&gt;
    [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;] &gt;&gt;= (\x2 -&gt;
      return (show x1 ++ x2)))

main = print x</code></pre><p>Después separemos <code>x</code> en tres expresiones <code>e1</code>, <code>e2</code> y <code>e3</code> para mantener la claridad. <code>e1</code> representa la subexpresión más anidada en <code>x</code> y <code>e3</code> la subexpresión menos anidada.</p><pre><code class="active haskell">e1 x1 x2 = return (show x1 ++ x2)
e2 x1 = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;] &gt;&gt;= e1 x1
e3 = [1,2,3] &gt;&gt;= e2


main = print e3</code></pre><p>Y finalmente, sustituyamos el operador <code>&gt;&gt;=</code>. Utilizaré esta definición de bind: <code>m &gt;&gt;= f = (join.fmap f) m</code>, recordando que la implementación de <code>join</code> para las listas es simplemente <code>join = concat</code>.</p><pre><code class="active haskell">join = concat

e1 x1 x2 = return (show x1 ++ x2)
e2 x1 = (join.fmap (e1 x1)) [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]
e3 = (join.fmap e2) [1,2,3]

main = print e3</code></pre><p>O si es más facil de entender en una sola expresión:</p><pre><code class="active haskell">join = concat

e1 x1 x2 = return (show x1 ++ x2)
e2 x1 = (join.fmap (e1 x1)) [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]
e3 = (join.fmap e2) [1,2,3]

main = print e3</code></pre><h2 id="el-m-nada-io"><a href="#el-m-nada-io">El mónada IO</a></h2><p>Finalmente llegamos al punto en que podemos explicar con detalle como funciona la interacción con el mundo real la ejecución de un programa de Haskell mediante el <b><i>mónada de IO</i></b> (*** IO monad).</p><blockquote><p>IO viene de I/O que a su vez viene del inglés &quot;Input/Output&quot;. Input/Output hace referencia a la comunicación entre el hardware y el software. &quot;Input&quot; viene de la introducción de información a un sistema; &quot;Output&quot; viene de la acción de un sistema de externalizar información. Por ejemplo, un teclado es un periférico que sirve para introducir información, mientras que un monitor es un periférico que sirve para externalizar información a un usuario; pero en general, el I/O sucede entre sistemas que no involucran a humanos de por medio, como en las redes de comunicación.</p></blockquote><p>Veamos algunas funciones básicas para interactuar con la consola y lo que nos dicen sus tipos:</p><ul><li><p><code>putStr :: String -&gt; IO ()</code>
Dado un <code>String</code>, esta función genera un mónada de IO que no contiene información útil, por que el tipo del mónada generado es <code>IO ()</code> donde <code>()</code> es el tipo <b><i>unit</i></b>, un tipo carente de información, pues su único valor posible es <code>()</code>.</p></li><li><p><code>putStrLn :: String -&gt; IO ()</code>
Como <code>putStr</code>, pero adem´ås de imprir el <code>String</code>, también imprime un salto de línea.</p></li><li><p><code>getLine :: IO String</code>
<code>getLine</code> lee un <code>String</code> de la consola. Esta función no recibe parámetros, por la que más que ser una función, es una expresión; su tipo es <code>IO String</code>, pues a diferencia de <code>putStr</code> y <code>putStrLn</code>, la ejecución de <code>getLine</code> sí contiene información, dicha información es el <code>String</code> leído de la consola.</p></li><li><p><code>readLn :: Read a =&gt; IO a</code>
El tipo de clase <code>Read</code> se puede implementar por todos aquellos tipos que se puedan formar a partir de un <code>String</code>. Por ejemplo, el tipo <code>Int</code> puede y es miembro de la clase <code>Read</code>, pues un <code>String</code> como <code>&quot;123123&quot;</code> se puede <i>parsear</i> a un entero <code>123123</code>.
Entonces, <code>readLn</code> lee un <code>Read</code> de la consola y ese es el valor que carga el mónada <code>IO a</code>.</p></li></ul><p>Para leer un Int se puede hacer algo así:</p><pre><code class="active haskell">plusOne :: Int -&gt; Int
plusOne = (+ 1)

main =
  do
    x &lt;- readLn
    print $ plusOne x</code></pre><p>Aquí, <code>plusOne x</code> hace que la inferencia de tipos de Haskell infiera que el tipo de <code>readLn</code> es <code>IO Int</code>, pues <code>plusOne x</code> implica que <code>x</code> es un Int.</p><pre><code class="active haskell">plusOne :: Float -&gt; Float
plusOne = (+ 1)

main =
  do
    x &lt;- readLn
    print $ plusOne x</code></pre><p>En este caso se infiere que el tipo de <code>readLn</code> es <code>IO Float</code> pues <code>plusOne x</code> implica que <code>x</code> es un <code>Float</code>.</p><p>Sin azucar sintáctico, se podría escribir de esta manera:</p><pre><code class="active haskell">plusOne :: Float -&gt; Float
plusOne = (+ 1)

main = readLn &gt;&gt;= \x -&gt; print $ plusOne x</code></pre><p>Es importante recalcar que las expresiones de tipo <code>IO a</code> no son sentencias, no se va a realizar ninguna operación de I/O fuera de la función <code>main</code>. Por ejemplo:</p><pre><code class="active haskell">anIO :: IO ()
anIO = print &quot;this never happens&quot;

main = putStrLn &quot;Hi!&quot;</code></pre><p>Incluso aunque <code>anIO</code> fuera parte de una expresión que sí se encuentra dentro de main, no quiere decir que el I/O sucedería, pues Haskell es lazy y no evalua sus parámetros a no ser necesario:</p><pre><code class="active haskell">anIO :: IO ()
anIO = print &quot;this will not happen&quot;

anotherIO :: IO ()
anotherIO = print &quot;this will happen&quot;

f a b True = a
f a b False = b

main = f anIO anotherIO False</code></pre><h2 id="excepciones"><a href="#excepciones">Excepciones</a></h2><p>Aunque nuestro código sea correcto, cuando interactua con el mundo real, las cosas pueden salir mal: se perdió la conexión a internet, el usuario conectó un periférico dañado, el usuario introdujo datos inválidos a los parámetros de nuestro programa, etc.</p><p>Las funciones que interactuan con el mundo real son las que pueden provocar dichas excepciones; a estas funciones se les conoce como <b><i><a href="http://stackoverflow.com/posts/32804182/revisions">inseguras</a></i></b> (<b><i>unsafe</i></b>).</p><p><code>readLn</code> es una función insegura, pues aunque su tipo es <code>Read a =&gt; IO a</code>, puede no regresar un valor y arrojar una excepción. Por ejemplo, si espera leer un <code>Int</code> (<code>IO Int</code>) y escribimos en la consola un <code>String</code> que no se puede parsear a un <code>Int</code>, no queda de otra más que reportar la excepción y terminar la ejecución. Intenta escribir un <code>String</code> que no es un <code>Int</code>, por ejemplo, <code>12ab</code> o un <code>Float</code>, por ejemplo <code>1.0</code>:</p><pre><code class="active haskell">main =
  do
    x &lt;- readLn :: IO Int
    print x</code></pre><p>Por eso es necesario proteger el código de producción de todas las posibles excepciones y usar funciones inseguras lo menos posible. Una manera de reescribir el ejemplo pasado para hacerlo seguro es usando la función <code>readMaybe</code>, definida en el paquete <code>Text.Read</code>. El tipo de <code>readMaybe</code> es <code>Read a =&gt; String -&gt; Maybe a</code> y lo que hace es que dado un <code>String</code>, lo &quot;parsea&quot; a un <code>Just a</code> si todo salió bien o regresa <code>Nothing</code> si algo salió mal. Pero <code>readMaybe</code> no lee nada de la consola, por lo que primero se tiene que usar <code>getLine</code> para obtener el <code>String</code>.</p><pre><code class="active haskell">import Text.Read
main =
  do
    x &lt;- getLine
    case (readMaybe x) :: Maybe Int of
      Nothing -&gt; print &quot;not an Int&quot;
      Just i  -&gt; print $ &quot;the introduced Int is: &quot; ++ (show i)</code></pre><p>Ahora intenta introducir un <code>Int</code> (e.g. <code>1324</code>) y algo que no se pueda parsear como un <code>Int</code> (e.g. <code>13y4j</code>) y verás que ningún caso genera una excepción haciendo nuestro código <i>seguro</i>.</p><p>¿Y si quisieramos definir una función que lee un <code>String</code>, lo intenta parsear a un <code>Int</code> y si falla lo vuelve a intentar hasta lograrlo? En <code>Haskell</code> no hay ciclos, pero hay recursión y es lo que utilizaremos para definir esta función:</p><pre><code class="active haskell">import Text.Read

readAnIntOrRetry :: IO Int
readAnIntOrRetry =
  do
    print &quot;Introduce an Int&quot;
    x &lt;- getLine
    case (readMaybe x) :: Maybe Int of
      Just i -&gt; return i  -- wrap the Int in the IO monad
      Nothing -&gt;
        do
          print &quot;That wasn't an Int&quot;
          readAnIntOrRetry  -- here happens the recursion

main =
  do
    x &lt;- readAnIntOrRetry
    print $ &quot;the introduced Int is: &quot; ++ (show x)</code></pre><p>Hay varias cosas que vale la pena resaltar de este ejemplo:</p><ul><li><code>readAnIntOrRetry</code> tiene el tipo <code>IO Int</code>; una vez que se &quot;entra&quot; a un mónada, no hay salida y dado que <code>readAnIntOrRetry</code> requiere leer de la consola, necesita &quot;entrar&quot; al mónada de <code>IO</code>.</li><li>Hay un <code>do</code> adentro de otro <code>do</code>. No tiene nada de especial, sólo es la primer vez que se ve en estos tutoriales. Si no usáramos el azucar sintáctico, se vería algo como: <code>... &gt;&gt;= {-hi-}(... &gt;&gt;= ...){-/hi-} &gt;&gt;= ...</code>, donde la parte resaltada podría ser un <code>do</code> anidado.</li><li><code>readAnIntOrRetry</code> utiliza funciones que retornan valores monádicos de distinto tipo, e.i. <code>getLine :: IO String</code> y <code>print :: IO ()</code>, esto es completamente válido, pues <code>&gt;&gt;=</code> nos permite cambiar el tipo contenido por el mónada (recordando su tipo: <code>m a -&gt; (a -&gt; m b) -&gt; m b</code> podemos ver que podemos iniciar con un <code>m a</code> (e.g. <code>IO ()</code>) y terminar con un <code>m b</code> (e.g. <code>IO String</code>) (<code>IO () -&gt; (() -&gt; IO String) -&gt; IO String</code>). Lo que no se puede hacer es cambiar el tipo del contenedor, por ejemplo, no se puede cambiar de <code>IO</code> a <code>Maybe</code> así: <code>IO String -&gt; (String -&gt; Maybe String) -&gt; Maybe String</code>, o en código:</li></ul><pre><code class="active haskell">f :: Maybe String -&gt; Maybe String
f maybeAString =
  do
    x &lt;- getLine      -- :: {-hi-}IO{-/hi-} String
    y &lt;- maybeAString -- :: {-hi-}Maybe{-/hi-} String
    return (x ++ y)   -- this would be unclear, return into a the Maybe monad or into the IO monad?

main = print $ f (Just &quot;hi&quot;)</code></pre><p>El error es bastante claro: <b>Couldn't match type IO with Maybe</b>. Para poder combinar mónadas se utilizan los transformadores de mónadas (monads transformers), pero ese es tema de otro tutorial.</p><h2 id="ejercicios"><a href="#ejercicios">Ejercicios</a></h2><p><a href="https://www.fpcomplete.com/user/XookDo/introduccion-a-la-programacion-funcional/parte-7/ejercicios">Ejercicios</a></p><p><a href="https://www.fpcomplete.com/user/XookDo/introduccion-a-la-programacion-funcional/parte-7/soluciones">Soluciones</a></p><h2 id="siguiente-tutorial"><a href="#siguiente-tutorial">Siguiente tutorial</a></h2><p><a href="http://i.dailymail.co.uk/i/pix/2012/12/04/article-2242634-16584CBA000005DC-112_634x501.jpg">Work in progress</a>.</p></article>


</div>
</div>
<div class="row article-footer"><div class="span7 meta"><span class="sociallinksunicode social">
<a href="https://twitter.com/home?status=$url$" target="_blank"><i class="icon-twitter"></i></a>&nbsp;
<a href="http://www.facebook.com/sharer/sharer.php?u=$url$" target="_blank"><i class="icon-facebook"></i></a>&nbsp;
<a href="https://plus.google.com/share?url=$url$" target="_blank"><i class="icon-google-plus"></i></a></span>
</div>
</div>
</div>
<div class="footer"><div class="container"><div class="row"><div class="span12"><ul class="menu"><li><a href="https://www.schoolofhaskell.com/">School</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user">Users</a>
</li>

<li><a class="brand" href="https://fpcomplete.com">Sponsored by:
<img src="/static/img/logo.png" title="FPComplete">
</a>
</li>
</ul>
</div>
</div>
<div class="row"><div class="span12"></div>
</div>
</div>
</div>
<link rel="stylesheet" type="text/css" href="/static/bootstrap/css/bootstrap-responsive.css" />
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script><script src="https://www.schoolofhaskell.com/static/combined/Y-3k9_tW.js"></script><script>$(function(){
  $("a.logout").click(function(){
    var form = $("<form method='post'/>");
    form.attr("action", $(this).attr("href"));
    $("body").append(form);
    form.submit();
    return false;
  });
});

$(function(){
    $('.sociallinksunicode a').each(function(){
        $(this).attr('href',$(this).attr('href').replace('$url$',document.location));
    });
});

$(function(){
  // If we need to select a user/select a password then show the
  // details confirmation form, otherwise enable the getting started
  // section.
  if($('.alert-block a').text().match(/(selected a username|change your password)/)) {
    $("#confirm-details").show();
    $("#confirm-details #inputUsername").focus();
  } else {
    $("#get-started").removeClass('disabled').addClass('enabled');
  }

  // For lack of a plain HTML validation story this will do.
  $('.welcome-page').each(function(){
    $('form').submit(check);
  });
  function check(){
    setTimeout(check,500);
    var error = false;
    $('.error').removeClass('error');
    $('#enter-details input').each(function(){
      if($(this).val() == '') {
        $(this).parent().parent().addClass('error');
        error = true;
      }
    });
    if(error) return false;
    if($('[name=password]').val() == $('[name=confirm]').val()) {
      $('#confirm').removeClass('error');
      return true;
    } else {
      $('#confirm').addClass('error');
      return false;
    }
  }
});

$(function(){
  // When scrolling over a snippet editor, activate the "clone in IDE" popovers
  $('article').each(function(){
    var n = 100;
    var wait = 10000;
    function check(){
      if($('.clone').length == 0) {
        setTimeout(check,n);
        return;
      }
      var activated = $.cookie('clone-popover');
      if (activated) return;
      var activate = false;
      $('.controlsRun:onScreen').each(function(){
        $.cookie('clone-popover', 'true', { expires: 30, path: '/' });
        activate = true;
        return false;
      });
      if(activate) {
          $('.clone').each(function(){
              // The bootstrap API is rather unreasonable to say the
              // least.
              next = $(this).parent();
              var title = next.attr('title');
              next.attr('data-content',$(this).attr('data-content'));
              next.attr('title',$(this).attr('title'));
              next.popover('show',{
                  title: $(this).attr('title')
              });
              next.attr('title',title);
          });
          setTimeout(function(){
              $('.clone').each(function(){
                  $(this).parent().popover('hide');
              });
          },wait);
      } else {
        setTimeout(check,n);
      }
    }
    setTimeout(check,n);
  });
});

// onScreen jQuery plugin v0.2.1
// (c) 2011-2013 Ben Pickles
//
// http://benpickles.github.com/onScreen
//
// Released under MIT license.
(function(a){a.expr[":"].onScreen=function(b){var c=a(window),d=c.scrollTop(),e=c.height(),f=d+e,g=a(b),h=g.offset().top,i=g.height(),j=h+i;return h>=d&&h<f||j>d&&j<=f||i>e&&h<=d&&j>=f}})(jQuery);

/*!
 * jQuery Cookie Plugin v1.1
 * https://github.com/carhartl/jquery-cookie
 *
 * Copyright 2011, Klaus Hartl
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.opensource.org/licenses/GPL-2.0
 */
(function($, document) {

  var pluses = /\+/g;
  function raw(s) {
    return s;
  }
  function decoded(s) {
    return decodeURIComponent(s.replace(pluses, ' '));
  }

  $.cookie = function(key, value, options) {

    // key and at least value given, set cookie...
    if (arguments.length > 1 && (!/Object/.test(Object.prototype.toString.call(value)) || value == null)) {
      options = $.extend({}, $.cookie.defaults, options);

      if (value == null) {
	options.expires = -1;
      }

      if (typeof options.expires === 'number') {
	var days = options.expires, t = options.expires = new Date();
	t.setDate(t.getDate() + days);
      }

      value = String(value);

      return (document.cookie = [
	encodeURIComponent(key), '=', options.raw ? value : encodeURIComponent(value),
	options.expires ? '; expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE
	options.path    ? '; path=' + options.path : '',
	options.domain  ? '; domain=' + options.domain : '',
	options.secure  ? '; secure' : ''
      ].join(''));
    }

    // key and possibly options given, get cookie...
    options = value || $.cookie.defaults || {};
    var decode = options.raw ? raw : decoded;
    var cookies = document.cookie.split('; ');
    for (var i = 0, parts; (parts = cookies[i] && cookies[i].split('=')); i++) {
      if (decode(parts.shift()) === key) {
	return decode(parts.join('='));
      }
    }
    return null;
  };
  $.cookie.defaults = {};})(jQuery, document);
</script><!--[if lt IE 10]><script src="https://www.schoolofhaskell.com/static/design/js/ie.js?etag=ayV2DuJ0"></script><![endif]--><script>if(!window.location.href.match(/localhost/)){var track = '/tutorial/user/XookDo/introduccion-a-la-programacion-funcional/parte-7/tutorial';
window._gaq = [['_setAccount','UA-36928035-1'],track != ''? ['_trackPageview',track] : ['_trackPageview']
,['_trackPageLoadTime']];window._gaq.push(['_setCustomVar',1,'Section','School of Haskell',3]);
window._gaq.push(['_setCustomVar',2,'User Type','Visitor',1]);
(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);

})();}</script>
<!-- Prompt IE 6 users to install Chrome Frame. Remove this if you want to support IE 6.  chromium.org/developers/how-tos/chrome-frame-getting-started --><!--[if lt IE 7 ]><script src="//ajax.googleapis.com/ajax/libs/chrome-frame/1.0.3/CFInstall.min.js"></script><script>window.attachEvent('onload',function(){CFInstall.check({mode:'overlay'})})</script><![endif]--></body></html>