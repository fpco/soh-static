<!DOCTYPE html>
<html><head><title>Easier lenses, Profunctor based, with the Mezzolens library - School of Haskell | School of Haskell</title><meta http-equiv="x-ua-compatible" content="IE=9"><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="google-site-verification" content="Rfxk2TdeMMXEXHgJ2_OO8Rt3hPbQSDao0OXQV_n6z_s" /><link href="//fonts.googleapis.com/css?family=Merriweather" rel="stylesheet" type="text/css"><link href="https://www.schoolofhaskell.com/recent-content/feed" type="application/rss+xml" rel="alternate" title="Recently published content">
<link rel="stylesheet" href="https://www.schoolofhaskell.com/static/combined/UlwEHVcM.css"><style>.social{margin-right:1em}h1{font-family:Merriweather !important}article{font-family:Merriweather !important}article li{font-family:Merriweather !important;line-height:1.6em}h1,h2,h3,h4,h4,h5{font-family:Merriweather !important}.editor p{font-family:Frutiger, "Frutiger Linotype", Univers, Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans Condensed", "Liberation Sans", "Nimbus Sans L", Tahoma, Geneva, "Helvetica Neue", Helvetica, Arial, sans-serif}.article-footer{border-top:1px solid #ddd;padding-top:1em;margin-top:1em}body{font-size:16px !important}.navbar .navbar-inner{background:#3c3f41}.navbar .brand{font-size:14px}.navbar .brand img{width:6em}.navbar .icon-wrench{margin:0 -0.5em 0 -0.5em;padding:0 1em 0 1em;height:20px}.navbar-inverse .nav .active a{background:#333638}.navbar-inverse .nav > li > a{color:#a7a7a7
}.navbar-inverse .btn-navbar{background:#333638}.navbar-inverse .nav > li a:hover,.navbar-inverse .btn{background:#333537 !important}@media (max-width: 979px) {.icon-wrench{padding-left:1em !important}}.breadcrumb{border-top-left-radius:0;border-top-right-radius:0}h1{margin-top:20px}.breadcrumb-container + .main-content h1{margin-top:0}.footer{padding:30px 0;margin-top:70px;border-top:1px solid #e5e5e5;background-color:#f5f5f5}.footer ul.footer-menu{list-style-type:none}.footer ul.footer-menu li{display:inline-block}.footer ul.footer-menu li + li{margin-left:0.5em}.footer ul.footer-menu li + li:before{margin-right:0.5em;content:"Â·";color:#999}.footer ul.menu li{display:inline-block}.footer ul.menu li + li{margin-left:0.5em}.footer .copyright{margin-left:25px}.main-content{min-height:100%}.gravatar{width:80px;height:80px;border-radius:2px;background:#eee}.empty-gravatar{width:0}.container{font-family:"Segoe UI", Candara, "Bitstream Vera Sans", "DejaVu Sans", "Bitstream Vera Sans", "Trebuchet MS", Verdana, "Verdana Ref", sans-serif}.container h1,.container h2,.container h4,.container h4,.container h5{font-family:"Segoe UI", Candara, "Bitstream Vera Sans", "DejaVu Sans", "Bitstream Vera Sans", "Trebuchet MS", Verdana, "Verdana Ref", sans-serif}article{font-family:Merriweather !important}article h1{font-family:Merriweather !important}article li{font-family:Merriweather !important;line-height:1.6em}article li + li{margin-top:0.5em}article div.code{background:#f9f9f9;border:1px solid #d1d1d1;position:relative;border-radius:0.2em;margin:0.25em 0 0.75em 0;min-height:2.5em}article code{color:#005580;font-size:14px;white-space:pre}article a.hoogle > code{color:#0088cc;font-size:14px;white-space:pre;border:0}article .expand-code{display:none}article pre{overflow:auto;word-wrap:normal}article code.active{display:block;max-height:430px}article h1{font-size:31.5px}article h3{font-size:17.5px}article h4{font-size:14px}article h5,article h6{font-size:11.9px}article p{line-height:1.7em}article h1 code,article h2 code,article h3 code,article h4 code,article h5 code,article h6 code{font-size:inherit !important}article h1 a,article h2 a,article h3 a,article h4 a,article h5 a,article h6 a{color:#444}article h1 a:before,article h2 a:before,article h3 a:before,article h4 a:before,article h5 a:before,article h6 a:before{margin-left:-1.5em;padding-right:0.5em;font-family:fontawesome;content:"\f0c1";font-size:20px;color:#fff}article h1 a:hover,article h2 a:hover,article h3 a:hover,article h4 a:hover,article h5 a:hover,article h6 a:hover{text-decoration:none;color:#0088cc}article h1 a:hover:before,article h2 a:hover:before,article h3 a:hover:before,article h4 a:hover:before,article h5 a:hover:before,article h6 a:hover:before{color:#888}article h2{font-size:24.5px}article .popover{font-family:actor}article .popover h3.popover-title{font-family:actor !important;font-size:1em}article .popover .popover-content{width:15em;font-size:1em}article .controlsRun{display:block;padding:0.5em;text-align:right;background:#f2f2f2}article .controlsRun a.clone{margin-right:1em;font-family:actor;text-decoration:none}article .controlsRun a.clone span{padding-left:0.5em}article .controlsRun a.run,article .controlsRun a.reset,article .controlsRun a.show-code{font-size:16px}article .controlsRun a.run span,article .controlsRun a.reset span,article .controlsRun a.show-code span{display:none}article .controlsRun a.reset{margin-left:0.5em;color:#a2becc}article .controlsRun a.reset{display:none}article .controlsRun a.show-code{margin-right:0.75em}article .controlsRun a.run:hover,article .controlsRun a.show-code:hover{text-decoration:none}article .controlsRun a.show-code.active{color:#DC0D0D}article .controlsRun a[disabled]{color:#a2becc;cursor:default}article .collapse-area .collapse-header{background:#0088cc;color:#fff;padding:0.3em;cursor:pointer}article .collapse-area .hidden-toggle:before{content:"\f0d7";font-family:fontawesome;margin-right:0.5em;margin-left:0.25em}article .collapse-area .collapsed-files{overflow:auto;height:auto}article .collapse-area.collapse-disabled{display:none}article .collapse-area.collapse-area-off .collapsed-files{height:0px;overflow:hidden}article .collapse-area.collapse-area-off .hidden-toggle:before{content:"\f0da"}article .snippet-stdio .stdout{margin:0.5em;padding-right:2em;position:relative;word-wrap:break-word}article .snippet-stdio .stdin{-webkit-box-shadow:none;-moz-box-shadow:none;box-shadow:none;-webkit-transition:none;-moz-transition:none;-o-transition:none;transition:none;padding:0;margin:0}article .hoogle-results{margin:0.25em}article .hoogle-results .hoogle-inner{background:#fff;padding:0.5em;border-radius:3px;border:1px solid #ddd}article .hoogle-results .hoogle-inner .close-link{position:relative;float:right;margin-top:-0.5em;margin-right:-0.5em}article .snippet-output-errors{margin:1em 0.5em 0.5em 0.5em;position:relative}article .snippet-output-errors ul{list-style-type:none;margin:0;position:relative}article .snippet-output-errors pre{border:0;border-radius:0;padding:0.25em;margin:0;background:inherit;color:inherit}article .snippet-output-errors .close-link{color:inherit;background:inherit}article .snippet-editors{z-index:0;padding:0.25em}article .close-link{padding:0.5em;background:#eaeaea;border-bottom-left-radius:0.2em;border-top-right-radius:0.2em;position:absolute;top:0;right:0}article .close-link:hover{text-decoration:none}article .snippet-title{padding:0.5em 0 0 0.5em}article .snippet-title .snippet-icon{font-family:FontAwesome;display:inline-block;margin-right:0.5em}article .fullModuleCode + div .snippet-title{margin-top:0.5em;border-top:1px solid #ccc;padding-top:0.5em}article .CodeMirror{height:auto;min-height:1em;line-height:1.5em;background:transparent;font-size:14px !important}article .CodeMirror .highlighted{background:rgba(250, 210, 0, 0.45) !important}article .CodeMirror-widget{margin-left:2em;line-height:1.8}article .CodeMirror.collapsed{height:10em !important}article .editor .expander{text-align:center;display:block;padding:0.5em;text-decoration:none;border-bottom-left-radius:2px;border-bottom-right-radius:2px}article .editor .expander .ellipsis{background:white;border:1px solid #ccc;padding:0 0.5em;height:1em;line-height:0.5em;display:inline-block;color:#555;cursor:pointer}article .editor .expander .ellipsis:hover{background:#ddd;color:#333}article .web-runner{margin:0.5em;padding:0.5em;border:1px solid #ccc;border-radius:3px;background:#f5f5f5}article .web-runner iframe{border:0;margin-top:0.5em;margin-bottom:0;background:white}article .web-runner .controls i{cursor:pointer;color:#0088cc}article .web-runner .controls i:hover{color:#222}article .web-runner .controls i + i{margin-left:0.5em}article .web-runner .controls .icon-remove{float:right}article .hidden{display:block;visibility:visible}article .controlsShowHide{margin-bottom:0.5em}.tutorial-body{float:left !important}.tutorial-nav{float:right !important}@media (max-width: 979px) {.related-content{float:right}.author-name{display:block;margin-left:20px !important;padding-left:5px;margin-top:5px}article h1 a:hover:before,article h2 a:hover:before,article h3 a:hover:before,article h4 a:hover:before,article h5 a:hover:before,article h6 a:hover:before{color:#fff}.tutorial-nav{float:none !important;width:auto !important}.tutorial-body{float:none !important;width:auto !important}}@media (min-width: 980px) and (max-width: 1199px) {.navbar-search{display:none}.tutorial-nav{width:200px}.tutorial-body{width:720px}}#accountPage h1{margin:20px 0 0 0}#accountPage h2{font-size:20px}.group-contents .span8{float:left}.group-contents .span4{float:right}.container > .alert-block{margin-top:1em}.alert{color:#aa874a
}.social{margin-bottom:.8em;display:block}.social a{text-decoration:none}.social i{font-size:1.1em;color:#fff;padding:0.25em;border-radius:0.25em;width:1em;display:inline-block;text-align:center}.social i.icon-twitter{background:#0088cc}.social i.icon-facebook{background:#3b5998
  }.social i.icon-google-plus{background:#dd4b39
  }.well pre{background:#fcfcfc}.well h2{margin-top:0}code{color:#005580;font-size:14px;white-space:pre}</style><!--[if lt IE 8]><link rel="stylesheet" href="https://www.schoolofhaskell.com/static/design/css/ie7.css?etag=TSMl9x1V"><![endif]--><!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]--></head><body class="not-logged-in" itemscope itemtype="http://schema.org/Product"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-H62P" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-H62P');</script><div class="navbar navbar-inverse navbar-static-top"><div class="navbar-inner"><div class="container"><a class="btn btn-navbar" type="button" data-toggle="collapse" data-target=".nav-collapse"><span class="icon-bar"></span>
<span class="icon-bar"></span>
<span class="icon-bar"></span>
</a>
<a class="brand" href="/"><img src="/static/img/haskell-logo-wide.png" title="School of Haskell">
</a>
<div class="nav-collapse collapse"><ul class="nav"><li><a href="https://www.schoolofhaskell.com/">School</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user">Users</a>
</li>
</ul>
<form class="navbar-search pull-left" action="https://www.schoolofhaskell.com/search"><input class="search-query" type="text" placeholder="Search" name="search">
</form>
</div>
</div>
</div>
</div>
<div class="container breadcrumb-container"><div class="row"><div class="span12"><ul class="breadcrumb"><li><a href="https://www.schoolofhaskell.com/user/griba">Gabriel Riba Faura</a>
<span class="divider">/</span>
</li>
<li><a href="https://www.schoolofhaskell.com/user/griba/easier_lenses_profunctor_based_with_mezzolens">Easier lenses, Profunctor based, with the Mezzolens library</a>
</li>
</ul>
</div>
</div>
</div>
<div class="container main-content"><div class="row"><div class="span12"><h1 itemprop="name">Easier lenses, Profunctor based, with the Mezzolens library</h1>
</div>
</div>
<div class="row"><div class="span7 meta"><p><span class="date">11 Jan 2019</span>
<span class="author"><a href="https://www.schoolofhaskell.com/user/griba">Gabriel Riba Faura</a>
</span>
<span class="view-edit-link pull-right"><a class="view-source-link" href="https://www.schoolofhaskell.com/tutorial-raw/4225/a3b745e4b976ffef11f0fba211f4b7e73722b058">View Markdown source</a>
</span>
</p>
<p class="tags"></p>
</div>
</div>
<div class="row"><div class="span7 meta"><span class="sociallinksunicode social">
<a href="https://twitter.com/home?status=$url$" target="_blank"><i class="icon-twitter"></i></a>&nbsp;
<a href="http://www.facebook.com/sharer/sharer.php?u=$url$" target="_blank"><i class="icon-facebook"></i></a>&nbsp;
<a href="https://plus.google.com/share?url=$url$" target="_blank"><i class="icon-google-plus"></i></a></span>
</div>
</div>
<p class="alert">As of March 2020, School of Haskell has been switched to read-only mode.</p>
<div class="row" itemprop="desc"><div class="span4 tutorial-nav"><div class="related-content"><ul class="nav nav-tabs nav-stacked"><li><script>reddit_target='fpcomplete'</script>
<script src="https://redditstatic.s3.amazonaws.com/button/button1.js"></script>
</li>
<li><a href="https://www.schoolofhaskell.com/user/griba/The_preferences_problem_varying_global_state">Previous content: The Preferences problem. Varying global state</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user/griba/quick-check-generator-of-pair-List-index-where-index-within-list-range">Next content: QuickCheck generator of (List, Index) where index within list range</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user/griba">See all content by Gabriel Riba Faura</a>
</li>
</ul>

</div>
<div class="aside"><h3>Sections</h3>
<ul><li><a href="#profunctors">Profunctors</a></li><li><a href="#profunctor-based-lenses-with-mezzolens">Profunctor based lenses with Mezzolens</a><ul><li><a href="#prisms">Prisms</a></li><li><a href="#traverses-and-folds">Traverses and folds</a></li><li><a href="#understanding-folds-like-sumof">Understanding folds like sumOf</a></li><li><a href="#some-generators">Some generators</a><ul><li><a href="#the-lens-generator">The lens generator</a></li><li><a href="#the-prism-generator">The prism generator</a></li><li><a href="#isos">Isos</a></li></ul></li></ul></li></ul></div>
</div>
<div class="span8 tutorial-body" data-environment="def">
<article><h2 id="profunctors"><a href="#profunctors">Profunctors</a></h2><p>A profunctor, -- type <code>(p a b)</code>, is a generalisation of a mapping between two domains, <a href="https://en.wikipedia.org/wiki/Covariance_and_contravariance_%28computer_science%29">contravariant</a> on the first (the input <code>a</code>) and covariant on the second (the output <code>b</code>)</p><pre><code class="haskell">-- here we pass to `dimap` a contramap to the first type parameter of the profunctor (p b c)
-- and a map to the second one

class Profunctor p where
  dimap :: (a -&gt; b) -&gt; (c -&gt; d) -&gt; p b c -&gt; p a d
  </code></pre><p>So <code>dimap (contramap :: a -&gt; b) (map :: c -&gt; d)</code> offers a transformation from the input <code>a</code> to the output <code>d</code>, as function of, a transformation from <code>b</code> to <code>c</code>.</p><p>Applying <code>dimap (contramap :: a -&gt; b) (map :: c -&gt; d)</code> to an instance of <code>p b c</code> gives <code>p a d</code> : an instance of the same type <code>p</code> transforming the input <code>a</code> to the output <code>d</code>.</p><p>Some <a href="https://hackage.haskell.org/package/mezzolens/docs/Mezzolens-Profunctor.html#t:Profunctor">instances</a> of profunctors are</p><ul><li>Functions: <code>Profunctor (-&gt;)</code></li><li><a href="http://hackage.haskell.org/package/base/docs/Control-Arrow.html#t:Kleisli"><i>Kleisli</i></a> arrows: <code>Functor f =&gt; Profunctor (Kleisli f)</code></li></ul><p>Note: An <a href="https://www.haskell.org/arrows/"><i>Arrow</i></a> is a generalisation of a computation with an input and an unrelated output. Monads can be lifted to arrows with the <a href="https://wiki.haskell.org/Arrow_tutorial#Kleisli_Arrows"><i>Kleisli</i></a> datatype.</p><p>For a more detailed introduction check</p><ul><li><p>the video <a href="https://www.youtube.com/watch?v=JZPXzJ5tp9w">&quot;The Extended Functor Family&quot; by George Wilson</a></p></li><li><p>the School of Haskell article <a href="https://www.schoolofhaskell.com/user/liyang/profunctors">&quot;I love profunctors. They're so easy&quot;</a></p></li></ul><h2 id="profunctor-based-lenses-with-mezzolens"><a href="#profunctor-based-lenses-with-mezzolens">Profunctor based lenses with Mezzolens</a></h2><p><a href="https://hackage.haskell.org/package/mezzolens" title="The Mezzolens package">Mezzolens</a> is a library written by Russell O'Connor.</p><p>A lens is defined here as a means to transform a structure, as function of, a transformation on one of its components. So you may combine the focused component mapping and the lens, over the initial structure, giving a transformed structure or a query result.</p><p>It takes the shape of a function of a profunctor on the component, giving a profunctor on the structure.</p><p>To characterize a lens (<a href="#the-lens-generator">lens generation</a>) you need a component selection function, and a structure update or query function from the image of the selected component transformation.</p><p>Since uncurrying is needed for lens generators, we add the <i>Strong</i> class lenses over pairs, defined below, as requirement.</p><pre><code class="haskell">-- given 'a' the type of the target component of an input structure of type 'ta'
-- and 'b' the type of a transformed 'a', from which you produce 'tb'

type Optical p ta tb a b = p a b -&gt; p ta tb   

type Lens ta tb a b = forall p. Strong p =&gt; p a b -&gt; p ta tb

-- where
class Profunctor p =&gt; Strong p where
  _1 :: p a b -&gt; p (a, c) (b, c)
  _2 :: p a b -&gt; p (c, a) (c, b)
  
-- simple lenses:
-- Lens' is the type of lenses that don't change the types of component and structure.  
type Lens' ta a = Lens ta ta a a 
</code></pre><p>The methods of a <i>Strong profunctor</i> can be seen as lenses that provide a transformation of a Pair, as function of, the transformation of one of its components.</p><p>Since a function is an instance of it, applying its lens to a function, gives as result a function over pairs:</p><pre><code class="haskell">Prelude&gt; import Mezzolens as M
Prelude M&gt; import Mezzolens.Profunctor as MP
Prelude M MP&gt; import Data.Function ((&amp;))       -- (&amp;): backwards application

Prelude M MP&gt;:t _1 (f :: a -&gt; b) 
:: (a, c) -&gt; (b, c)

Prelude M MP&gt;:t _2 (f :: a -&gt; b) 
:: (c, a) -&gt; (c, b)

-- focusing with a lens and the function (+2), gets the structure updated
Prelude M MP&gt; (1, 2) &amp; _1 (+2)  
(3, 2)

-- the function `M.get` with a lens, queries the focused component
Prelude M MP&gt; (1, 2) &amp; M.get _1
1
</code></pre><p>Lens generation:</p><pre><code class="haskell">-- from Mezzolens.Unchecked

-- lens :: (ta -&gt; a) {- component selection -}
        -&gt; (b -&gt; ta -&gt; tb) {- struct. transf. with component image -}
        -&gt; Lens ta tb a b
-- ^ lens getter updater 
</code></pre><p>As lenses are functions, they can compose, giving you access to items deep in a complex structure.</p><pre><code class="haskell">{-| file test-mezzo.hs -}
{-# LANGUAGE PackageImports #-}

import &quot;mezzolens&quot; Mezzolens (Lens', (^.), get, set)
import &quot;mezzolens&quot; Mezzolens.Unchecked (lens)
import Data.Function ((&amp;))       -- (&amp;): backwards application

data Arc = Arc {_degree, _minute, _second :: Int} deriving (Show)
data Location = Location {_latitude, _longitude :: Arc} deriving (Show)

-- structure to play with
locBcn = Location (arcFromDecimal 41.399423) (arcFromDecimal 2.128037)

-- decimal to sexagesimal latitude/longitude
arcFromDecimal :: Double -&gt; Arc
arcFromDecimal v = Arc intPart mins secs
  where
     (intPart, fraction) = properFraction v
     -- divide negative lat/lon fractions towards 0 with quotRem
     (mins, secs) = truncate (fraction * 3600) `quotRem` 60

-- lens generators 

degree, minute, second :: Lens' Arc Int
degree = lens _degree (\v arc -&gt; arc {_degree = v})
minute = lens _minute (\v arc -&gt; arc {_minute = v})
second = lens _second (\v arc -&gt; arc {_second = v})

latitude :: Lens' Location Arc
latitude = lens _latitude (\v loc -&gt; loc {_latitude = v})

-- composing lenses
lensDegreesFromLatitude, lensMinutesFromLatitude, lensSecondsFromLatitude :: Lens' Location Int
lensDegreesFromLatitude = latitude . degree
lensMinutesFromLatitude = latitude . minute
lensSecondsFromLatitude = latitude . second

-- get the focused component
degreeLat = locBcn &amp; get lensDegreesFromLatitude

-- (^.) is an infix version of 'get'

-- update the focused component:
-- (+2) is a unary function (unary functions are instances of ''Profunctor'')
-- applying the lens to the Profunctor value (+2) will give us a profunctor of the same type (a function) on the structure

locTwoDegreesNordOfBcn = locBcn &amp; lensDegreesFromLatitude (+2)

-- 'set' applies the lens to a constant function
-- set lens v = lens (const v)
</code></pre><p>With Ghci</p><pre><code class="haskell">$ ghci
GHCi, version 7.10.3: http://www.haskell.org/ghc/  :? for help
Prelude&gt; :l test-mezzo
[1 of 1] Compiling Main             ( test-mezzo.hs, interpreted )
Ok, modules loaded: Main.

*Main&gt; import Mezzolens as M

*Main M&gt; :t M.get lensDegreesFromLatitude
M.get lensDegreesFromLatitude :: Location -&gt; Int

*Main M&gt; :t lensDegreesFromLatitude (+2)
lensDegreesFromLatitude (+2) :: Location -&gt; Location
</code></pre><p>If you want a monadic transformation, wrap the monadic computation as a <a href="http://hackage.haskell.org/package/base/docs/Control-Arrow.html#t:Kleisli"><i>Kleisli arrow</i></a>. Mezzolens brings an instance of Profunctor for Kleisli arrows.</p><p>Applying the lens to an <i>arrow</i> on the component returns an <i>arrow</i> on the structure, where you can get the monadic function inside with the Kleisli accessor <i>runKleisli</i>.</p><pre><code class="haskell">*Main M&gt; import Control.Arrow as A

*Main M A&gt; :{
*Main M A| let myMonadicCompoTransf :: Monad m =&gt; Int -&gt; m Int
*Main M A|     myMonadicCompoTransf = return . (+2)
*Main M A| :}
*Main M A&gt; :t runKleisli . lensDegreesFromLatitude . Kleisli $ myMonadicCompoTransf
runKleisli . lensDegreesFromLatitude . Kleisli $ myMonadicCompoTransf
  :: Monad m =&gt; Location -&gt; m Location</code></pre><p>But a monadic use is questionable unless you use <a href="https://hackage.haskell.org/package/mezzolens/docs/Mezzolens-State-Lazy.html">state lenses</a> which I will not cover here.</p><h3 id="prisms"><a href="#prisms">Prisms</a></h3><p>Prisms are lenses where the component selection may not succeed, as they target parts of <i>sum types</i>.</p><p>Since the component selection results in an Either, we will require profunctors with the <i>Choice</i> class lenses over <i>Either</i>, needed in <a href="#the-prism-generator">prism generators</a></p><pre><code class="haskell">type Prism ta tb a b = forall p. Choice p =&gt; p a b -&gt; p ta tb

-- where
class Profunctor p =&gt; Choice p where
  _Left :: p a b -&gt; p (Either a c) (Either b c)
  _Right :: p a b -&gt; p (Either c a) (Either c b)
</code></pre><p>A Choice profunctor is one that brings lenses methods that let you transform an Either variant content with the input profunctor.</p><pre><code class="haskell">-- a Prism generator from Mezzolens.Unchecked
prism :: (ta -&gt; Either tb a) {- component selection match -}
      -&gt; (b -&gt; tb)           {- struct. build up from component image -}
      -&gt; Prism ta tb a b
-- ^ prism match build</code></pre><ul><li><p>the first <i>prism</i> generator parameter (component selection) should give either the component in case of success, or a result structure in case of fail.</p></li><li><p>the second (final structure from component image) builds a sum type variant of <i>tb</i> from the image (type <i>b</i>) of the selected component</p></li></ul><p>Example on the <i>head</i> of a List.</p><pre><code class="haskell">*Main&gt; import Mezzolens as M
*Main M&gt; import Mezzolens.Unchecked as MU
*Main M MU&gt; :set -XLambdaCase

*Main M MU&gt; :{
*Main M MU| let headMatch :: [a] -&gt; Either [a] a
*Main M MU|     headMatch = \case
*Main M MU|                    x : _ -&gt; Right x  -- target variant
*Main M MU|                    [] -&gt; Left []     -- fail case giving a zero/empty structure

*Main M MU| let headBuild = \x -&gt; [x]

*Main M MU| let _Head = MU.prism headMatch headBuild
*Main M MU| :}
            
-- Prism query (optional result)
*Main M MU&gt; [locBcn] ^? (_Head . lensDegreesFromLatitude)
Just 41         

-- Update on a target variant
*Main M MU&gt; [locBcn] &amp; (_Head . lensDegreesFromLatitude) (+2)
[Location {_latitude = Arc {_degree = 43, _minute = 23, _second = 57}, _longitude = Arc {_degree = 2, _minute = 7, _second = 40}}]

-- Update on the non target variant
*Main M MU&gt; [] &amp; (_Head . lensDegreesFromLatitude) (+2)
[]</code></pre><h3 id="traverses-and-folds"><a href="#traverses-and-folds">Traverses and folds</a></h3><p>The <i>Wandering</i> class and the function <i>gets</i>:</p><ul><li><p><i>wander</i> offers a lens that let you traverse a <i>Traversable</i>, transforming its elements with the input profunctor.</p></li><li><p>The <i>gets</i> function offers a means to get a fold of the <a href="https://en.wikipedia.org/wiki/Codomain">codomain</a> (target set) of mapping the items focused by a traversal to a Monoid.</p></li></ul><pre><code class="haskell">-- from Mezzolens.Profunctor
class (Strong p, Choice p) =&gt; Wandering p where
  wander :: Traversable f =&gt; p a b -&gt; p (f a) (f b)
  
-- from Mezzolens
gets :: Monoid r =&gt; Fold ta tb a b -&gt; (a -&gt; r) -&gt; ta -&gt; r 

-- from Mezzolens.Optics
type Fold ta tb a b = forall p. (OutPhantom p, Wandering p) =&gt; Optical p ta tb a b
-- (OutPhantom p) means that the profunctor output type is coercible
</code></pre><p>with Ghci and the test code loaded</p><pre><code class="haskell">*Main&gt; import Mezzolens as M
*Main M&gt; import Mezzolens.Profunctor as MP

-- traverse a list, updating its elements

*Main M MP&gt; [locBcn, locTwoDegreesNordOfBcn] &amp; (MP.wander . lensDegreesFromLatitude) (+3)
[Location {_latitude = Arc {_degree = 44, _minute = 23, _second = 57}, _longitude = Arc {_degree = 2, _minute = 7, _second = 40}},Location {_latitude = Arc {_degree = 46, _minute = 23, _second = 57}, _longitude = Arc {_degree = 2, _minute = 7, _second = 40}}]


-- (toListOf): {toListOf lens = gets lens pure} it uses 'pure' to map the focused elements to a generic Applicative that when constraint to a List gives List singletons, folded with the List Monoid instance into a concatenation.

*Main M MP&gt; [locBcn, locTwoDegreesNordOfBcn] &amp; M.toListOf (MP.wander . lensDegreesFromLatitude) :: [Int]  
[41,43]

-- (^..) is an infix version of toListOf

*Main M MP&gt; [locBcn, locTwoDegreesNordOfBcn] ^.. (MP.wander . lensDegreesFromLatitude) :: [Int]
[41,43]

-- (sumOf): maps the focused elements to the Monoid Sum and combine. See next section.

*Main M MP&gt; [locBcn, locTwoDegreesNordOfBcn] &amp; M.sumOf (MP.wander . lensDegreesFromLatitude)
84
</code></pre><h3 id="understanding-folds-like-sumof"><a href="#understanding-folds-like-sumof">Understanding folds like <i>sumOf</i></a></h3><p>We take <i>Sum</i> as the <i>gets</i> mapping function, fetching the result with its  accessor <i>getSum</i>:</p><pre><code class="haskell">sumOf lens = getSum . gets lens Sum

gets :: Optical (SubStar (Constant r)) ta tb a b -&gt; (a -&gt; r) -&gt; ta -&gt; r
gets lens f = getConstant . h
 where
  Kleisli h = lens (Kleisli (Constant . f))
  
-- type SubStar = Kleisli      -- from Mezzolens.Profunctor

-- substituting ''h'' extracting it with ''runKleisli''

gets lens f = getConstant . (runKleisli (lens (Kleisli (Constant . f))))
  </code></pre><p>using <i>wander</i> as <i>lens</i> in the <i>gets</i> expression, then reducing <i>wander</i> on a Kleisli arrow:</p><pre><code class="haskell">Prelude ...&gt; let g f =  getConstant . (runKleisli (wander (Kleisli (Constant . f))))

-- from Mezzolens code:

instance Applicative f =&gt; Wandering (Kleisli f) where
  wander (Kleisli h) = Kleisli (traverse h)

-- since there is an Applicative instance for Constant 

Prelude ...&gt; let g f = getConstant . (runKleisli (Kleisli (traverse (Constant . f))))

-- since {runKleisli . Kleisli == id}

Prelude ...&gt; let g f = getConstant . (traverse (Constant . f))

Prelude ...&gt; g Sum [1,2,3]
Sum {getSum = 6}</code></pre><p>understanding <i>Constant</i> from Data.Functor.Constant</p><pre><code class="haskell">-- Constant has a phantom type parameter, so (Constant a) can be seen as a structure:
newtype Constant a b = Constant { getConstant :: a }

-- the (Constant a) instance for Applicative is defined only for 'a' Monoid
instance (Monoid a) =&gt; Applicative (Constant a) where
    pure _ = Constant mempty       -- applicative combinators will be ignored !!
    Constant x &lt;*&gt; Constant y = Constant (x `mappend` y)

Prelude ...&gt; :t traverse
traverse
  :: (Applicative f, Traversable t) =&gt; (a -&gt; f b) -&gt; t a -&gt; f (t b)</code></pre><p>Since Constant is the Applicative type in the traversal, because in its instance <i>&quot;pure&quot;</i> ignores the combinator, whatever the traversable instance, you will get the Monoid composition instead, folding left to right as the container is traversed.</p><pre><code class="haskell">Prelude ...&gt; :t traverse Constant
traverse Constant
  :: (Traversable t, Monoid a) =&gt; t a -&gt; Constant a (t b)

-- you will not get (t b) inside Constant
-- but ''mempty'' from (''pure'' traversable_combinator), ''mappend''ed to all a's

Prelude ...&gt; traverse Constant [Sum 1, Sum 2, Sum 3]
Constant (Sum {getSum = 6})</code></pre><p>as summary:</p><pre><code class="haskell">Prelude ...&gt; :t gets wander
gets wander :: (Traversable f, Monoid r) =&gt; (a -&gt; r) -&gt; f a -&gt; r

Prelude ...&gt; :t gets wander Sum
gets wander Sum :: (Num a, Traversable f) =&gt; f a -&gt; Sum a

Prelude ...&gt; gets wander Sum [1,2,3]
Sum {getSum = 6}</code></pre><h3 id="some-generators"><a href="#some-generators">Some generators</a></h3><h4 id="the-lens-generator"><a href="#the-lens-generator">The <i>lens</i> generator</a></h4><pre><code class="haskell">type Optical p ta tb a b = p a b -&gt; p ta tb

type Lens ta tb a b = forall p. Strong p =&gt; Optical p ta tb a b

lens :: (ta -&gt; a) {- getter: component selection -} 
     -&gt; (b -&gt; ta -&gt; tb) {- setter: struct. transf. with component image -} 
     -&gt; Lens ta tb a b

-- we need to find parameters for ''dimap''

-- let's obtain an output map for our lens, pairing the setter parameters
&gt; :t uncurry setter
:: (b, ta) -&gt; tb

-- a matching contramap changing the component woud be
-- :: ta -&gt; (a, ta)

-- with (&amp;&amp;&amp;) from Arrow -- it pairs the results of two arrows of the same input type

-- from Control.Arrow.Arrow class
-- (&amp;&amp;&amp;) :: Arrow a =&gt; a b c -&gt; a b c' -&gt; a b (c, c')

&gt; :t getter &amp;&amp;&amp; id  -- since functions are instances of Arrow
:: ta -&gt; (a, ta)

&gt; :t dimap \ 
      (getter &amp;&amp;&amp; id)  {- :: ta -&gt; (a, ta) -} \
      (uncurry setter) {- :: (b, ta) -&gt; tb -}
:: Profunctor p =&gt; p (a, ta) (b, ta) -&gt; p ta tb
</code></pre><p>With <code>dimap (getter &amp;&amp;&amp; id) (uncurry setter)</code> you have a lens from the structure to a pair.</p><p>Composing it with <code>_1</code> (the lens on the first item of a pair) we further put the focus on the component transformation <code>p a b</code>, adding the requirement that the profunctor should implement the class Strong where <code>_1</code> is defined.</p><pre><code class="haskell">import Control.Arrow ((&amp;&amp;&amp;), (|||))

type Optical p ta tb a b = p a b -&gt; p ta tb

type Lens ta tb a b = forall p. Strong p =&gt; Optical p ta tb a b

-- the generator:

lens :: (ta -&gt; a)  {- component selection -}
     -&gt; (b -&gt; ta -&gt; tb) {- structure transf. with component image -}
     -&gt; Lens ta tb a b
lens getter setter = lensStructFromPair . _1
   where
      lensStructFromPair :: Profunctor p 
                         =&gt; p (a, ta) (b, ta) 
                         -&gt; p ta tb
      lensStructFromPair = dimap (getter &amp;&amp;&amp; id) (uncurry setter)

-- _1 is a lens on the first component of a pair
-- _1 :: Strong p =&gt; p a b -&gt; p (a, c) (b, c)
</code></pre><h4 id="the-prism-generator"><a href="#the-prism-generator">The <i>prism</i> generator</a></h4><p>Prisms target sum type variants</p><pre><code class="haskell">
type Prism ta tb a b = forall p. Choice p =&gt; Optical p ta tb a b

prism :: (ta -&gt; Either tb a) {- component selection match -} 
      -&gt; (b -&gt; tb)        {- build final struct. from component image -} 
      -&gt; Prism ta tb a b

-- `match` should give an (Either tb a) which means a component `a` in case of success or a zero result structure of type `tb` in case of fail

-- `build` should wrap the transformed component `b` in a variant of the sum type structure of type `tb` 

-- we need to find parameters for ''dimap''

-- we take ''(match :: ta -&gt; Either tb a)'' as the contramap operation

-- a matching map switching the comp. type with its image 
--    would be ''(Either tb b -&gt; tb)''

-- we have ''(build :: b -&gt; tb)''

-- (|||) from ArrowChoice, splices the input types of two arrows of the same result type in an Either

-- from Control.Arrow.ArrowChoice class
-- (|||) :: ArrowChoice a =&gt; a b d -&gt; a c d -&gt; a (Either b c) d

&gt; :t id ||| build  -- since functions are instances of ArrowChoice
:: Either tb b -&gt; tb

&gt; :t dimap \
        match          {- :: ta -&gt; Either tb a -} \
        (id ||| build) {- :: Either tb b -&gt; tb -}
:: Profunctor p =&gt; p (Either tb a) (Either tb b) -&gt; p ta tb

prism match build = lensStructFromEither . _Right
    where 
      lensStructFromEither :: Profunctor p 
                              =&gt; p (Either tb a) (Either tb b)
                              -&gt; p ta tb
      lensStructFromEither = dimap match (id ||| build)

-- _Right is a lens on the second domain of an Either
-- _Right :: Choice p =&gt; p a b -&gt; p (Either c a) (Either c b)</code></pre><p>With <code>dimap match (id ||| build)</code> you have a lens from the Structure to an Either having the component as Right or a Left <code>tb</code> structure in case of mismatch.</p><p>Composing it with the lens <i>_Right</i>, will make possible to focus on the component, adding the requirement that the profunctor should also implement the class Choice where <i>_Right</i> is defined.</p><h4 id="isos"><a href="#isos">Isos</a></h4><p>Iso's are lenses that convert a profunctor on structures, on one over an Isomorphic representation</p><pre><code class="haskell">type Iso ta tb a b = forall p. Profunctor p =&gt; Optical p ta tb a b

-- the generator:

iso :: (ta -&gt; a) -&gt; (b -&gt; tb) -&gt; Iso ta tb a b
iso = dimap

-- as example, the lens _swap converts a profunctor on pairs into a profunctor over its swapped type
_swap :: Iso (a,b) (c,d) (b,a) (d,c)
_swap = iso swap swap</code></pre></article>


</div>
</div>
<div class="row article-footer"><div class="span7 meta"><span class="sociallinksunicode social">
<a href="https://twitter.com/home?status=$url$" target="_blank"><i class="icon-twitter"></i></a>&nbsp;
<a href="http://www.facebook.com/sharer/sharer.php?u=$url$" target="_blank"><i class="icon-facebook"></i></a>&nbsp;
<a href="https://plus.google.com/share?url=$url$" target="_blank"><i class="icon-google-plus"></i></a></span>
</div>
</div>
</div>
<div class="footer"><div class="container"><div class="row"><div class="span12"><ul class="menu"><li><a href="https://www.schoolofhaskell.com/">School</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user">Users</a>
</li>

<li><a class="brand" href="https://fpcomplete.com">Sponsored by:
<img src="/static/img/logo.png" title="FPComplete">
</a>
</li>
</ul>
</div>
</div>
<div class="row"><div class="span12"></div>
</div>
</div>
</div>
<link rel="stylesheet" type="text/css" href="/static/bootstrap/css/bootstrap-responsive.css" />
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script><script src="https://www.schoolofhaskell.com/static/combined/Y-3k9_tW.js"></script><script>$(function(){
  $("a.logout").click(function(){
    var form = $("<form method='post'/>");
    form.attr("action", $(this).attr("href"));
    $("body").append(form);
    form.submit();
    return false;
  });
});

$(function(){
    $('.sociallinksunicode a').each(function(){
        $(this).attr('href',$(this).attr('href').replace('$url$',document.location));
    });
});

$(function(){
  // If we need to select a user/select a password then show the
  // details confirmation form, otherwise enable the getting started
  // section.
  if($('.alert-block a').text().match(/(selected a username|change your password)/)) {
    $("#confirm-details").show();
    $("#confirm-details #inputUsername").focus();
  } else {
    $("#get-started").removeClass('disabled').addClass('enabled');
  }

  // For lack of a plain HTML validation story this will do.
  $('.welcome-page').each(function(){
    $('form').submit(check);
  });
  function check(){
    setTimeout(check,500);
    var error = false;
    $('.error').removeClass('error');
    $('#enter-details input').each(function(){
      if($(this).val() == '') {
        $(this).parent().parent().addClass('error');
        error = true;
      }
    });
    if(error) return false;
    if($('[name=password]').val() == $('[name=confirm]').val()) {
      $('#confirm').removeClass('error');
      return true;
    } else {
      $('#confirm').addClass('error');
      return false;
    }
  }
});

$(function(){
  // When scrolling over a snippet editor, activate the "clone in IDE" popovers
  $('article').each(function(){
    var n = 100;
    var wait = 10000;
    function check(){
      if($('.clone').length == 0) {
        setTimeout(check,n);
        return;
      }
      var activated = $.cookie('clone-popover');
      if (activated) return;
      var activate = false;
      $('.controlsRun:onScreen').each(function(){
        $.cookie('clone-popover', 'true', { expires: 30, path: '/' });
        activate = true;
        return false;
      });
      if(activate) {
          $('.clone').each(function(){
              // The bootstrap API is rather unreasonable to say the
              // least.
              next = $(this).parent();
              var title = next.attr('title');
              next.attr('data-content',$(this).attr('data-content'));
              next.attr('title',$(this).attr('title'));
              next.popover('show',{
                  title: $(this).attr('title')
              });
              next.attr('title',title);
          });
          setTimeout(function(){
              $('.clone').each(function(){
                  $(this).parent().popover('hide');
              });
          },wait);
      } else {
        setTimeout(check,n);
      }
    }
    setTimeout(check,n);
  });
});

// onScreen jQuery plugin v0.2.1
// (c) 2011-2013 Ben Pickles
//
// http://benpickles.github.com/onScreen
//
// Released under MIT license.
(function(a){a.expr[":"].onScreen=function(b){var c=a(window),d=c.scrollTop(),e=c.height(),f=d+e,g=a(b),h=g.offset().top,i=g.height(),j=h+i;return h>=d&&h<f||j>d&&j<=f||i>e&&h<=d&&j>=f}})(jQuery);

/*!
 * jQuery Cookie Plugin v1.1
 * https://github.com/carhartl/jquery-cookie
 *
 * Copyright 2011, Klaus Hartl
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.opensource.org/licenses/GPL-2.0
 */
(function($, document) {

  var pluses = /\+/g;
  function raw(s) {
    return s;
  }
  function decoded(s) {
    return decodeURIComponent(s.replace(pluses, ' '));
  }

  $.cookie = function(key, value, options) {

    // key and at least value given, set cookie...
    if (arguments.length > 1 && (!/Object/.test(Object.prototype.toString.call(value)) || value == null)) {
      options = $.extend({}, $.cookie.defaults, options);

      if (value == null) {
	options.expires = -1;
      }

      if (typeof options.expires === 'number') {
	var days = options.expires, t = options.expires = new Date();
	t.setDate(t.getDate() + days);
      }

      value = String(value);

      return (document.cookie = [
	encodeURIComponent(key), '=', options.raw ? value : encodeURIComponent(value),
	options.expires ? '; expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE
	options.path    ? '; path=' + options.path : '',
	options.domain  ? '; domain=' + options.domain : '',
	options.secure  ? '; secure' : ''
      ].join(''));
    }

    // key and possibly options given, get cookie...
    options = value || $.cookie.defaults || {};
    var decode = options.raw ? raw : decoded;
    var cookies = document.cookie.split('; ');
    for (var i = 0, parts; (parts = cookies[i] && cookies[i].split('=')); i++) {
      if (decode(parts.shift()) === key) {
	return decode(parts.join('='));
      }
    }
    return null;
  };
  $.cookie.defaults = {};})(jQuery, document);
</script><!--[if lt IE 10]><script src="https://www.schoolofhaskell.com/static/design/js/ie.js?etag=ayV2DuJ0"></script><![endif]--><script>if(!window.location.href.match(/localhost/)){var track = '/tutorial/user/griba/easier_lenses_profunctor_based_with_mezzolens';
window._gaq = [['_setAccount','UA-36928035-1'],track != ''? ['_trackPageview',track] : ['_trackPageview']
,['_trackPageLoadTime']];window._gaq.push(['_setCustomVar',1,'Section','School of Haskell',3]);
window._gaq.push(['_setCustomVar',2,'User Type','Visitor',1]);
(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);

})();}</script>
<!-- Prompt IE 6 users to install Chrome Frame. Remove this if you want to support IE 6.  chromium.org/developers/how-tos/chrome-frame-getting-started --><!--[if lt IE 7 ]><script src="//ajax.googleapis.com/ajax/libs/chrome-frame/1.0.3/CFInstall.min.js"></script><script>window.attachEvent('onload',function(){CFInstall.check({mode:'overlay'})})</script><![endif]--></body></html>