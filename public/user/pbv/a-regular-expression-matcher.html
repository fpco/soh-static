<!DOCTYPE html>
<html><head><title>A regular expression matcher - School of Haskell | School of Haskell</title><meta http-equiv="x-ua-compatible" content="IE=9"><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="google-site-verification" content="Rfxk2TdeMMXEXHgJ2_OO8Rt3hPbQSDao0OXQV_n6z_s" /><link href="//fonts.googleapis.com/css?family=Merriweather" rel="stylesheet" type="text/css"><link href="https://www.schoolofhaskell.com/recent-content/feed" type="application/rss+xml" rel="alternate" title="Recently published content">
<link rel="stylesheet" href="https://www.schoolofhaskell.com/static/combined/UlwEHVcM.css"><style>.social{margin-right:1em}h1{font-family:Merriweather !important}article{font-family:Merriweather !important}article li{font-family:Merriweather !important;line-height:1.6em}h1,h2,h3,h4,h4,h5{font-family:Merriweather !important}.editor p{font-family:Frutiger, "Frutiger Linotype", Univers, Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans Condensed", "Liberation Sans", "Nimbus Sans L", Tahoma, Geneva, "Helvetica Neue", Helvetica, Arial, sans-serif}.article-footer{border-top:1px solid #ddd;padding-top:1em;margin-top:1em}body{font-size:16px !important}.navbar .navbar-inner{background:#3c3f41}.navbar .brand{font-size:14px}.navbar .brand img{width:6em}.navbar .icon-wrench{margin:0 -0.5em 0 -0.5em;padding:0 1em 0 1em;height:20px}.navbar-inverse .nav .active a{background:#333638}.navbar-inverse .nav > li > a{color:#a7a7a7
}.navbar-inverse .btn-navbar{background:#333638}.navbar-inverse .nav > li a:hover,.navbar-inverse .btn{background:#333537 !important}@media (max-width: 979px) {.icon-wrench{padding-left:1em !important}}.breadcrumb{border-top-left-radius:0;border-top-right-radius:0}h1{margin-top:20px}.breadcrumb-container + .main-content h1{margin-top:0}.footer{padding:30px 0;margin-top:70px;border-top:1px solid #e5e5e5;background-color:#f5f5f5}.footer ul.footer-menu{list-style-type:none}.footer ul.footer-menu li{display:inline-block}.footer ul.footer-menu li + li{margin-left:0.5em}.footer ul.footer-menu li + li:before{margin-right:0.5em;content:"Â·";color:#999}.footer ul.menu li{display:inline-block}.footer ul.menu li + li{margin-left:0.5em}.footer .copyright{margin-left:25px}.main-content{min-height:100%}.gravatar{width:80px;height:80px;border-radius:2px;background:#eee}.empty-gravatar{width:0}.container{font-family:"Segoe UI", Candara, "Bitstream Vera Sans", "DejaVu Sans", "Bitstream Vera Sans", "Trebuchet MS", Verdana, "Verdana Ref", sans-serif}.container h1,.container h2,.container h4,.container h4,.container h5{font-family:"Segoe UI", Candara, "Bitstream Vera Sans", "DejaVu Sans", "Bitstream Vera Sans", "Trebuchet MS", Verdana, "Verdana Ref", sans-serif}article{font-family:Merriweather !important}article h1{font-family:Merriweather !important}article li{font-family:Merriweather !important;line-height:1.6em}article li + li{margin-top:0.5em}article div.code{background:#f9f9f9;border:1px solid #d1d1d1;position:relative;border-radius:0.2em;margin:0.25em 0 0.75em 0;min-height:2.5em}article code{color:#005580;font-size:14px;white-space:pre}article a.hoogle > code{color:#0088cc;font-size:14px;white-space:pre;border:0}article .expand-code{display:none}article pre{overflow:auto;word-wrap:normal}article code.active{display:block;max-height:430px}article h1{font-size:31.5px}article h3{font-size:17.5px}article h4{font-size:14px}article h5,article h6{font-size:11.9px}article p{line-height:1.7em}article h1 code,article h2 code,article h3 code,article h4 code,article h5 code,article h6 code{font-size:inherit !important}article h1 a,article h2 a,article h3 a,article h4 a,article h5 a,article h6 a{color:#444}article h1 a:before,article h2 a:before,article h3 a:before,article h4 a:before,article h5 a:before,article h6 a:before{margin-left:-1.5em;padding-right:0.5em;font-family:fontawesome;content:"\f0c1";font-size:20px;color:#fff}article h1 a:hover,article h2 a:hover,article h3 a:hover,article h4 a:hover,article h5 a:hover,article h6 a:hover{text-decoration:none;color:#0088cc}article h1 a:hover:before,article h2 a:hover:before,article h3 a:hover:before,article h4 a:hover:before,article h5 a:hover:before,article h6 a:hover:before{color:#888}article h2{font-size:24.5px}article .popover{font-family:actor}article .popover h3.popover-title{font-family:actor !important;font-size:1em}article .popover .popover-content{width:15em;font-size:1em}article .controlsRun{display:block;padding:0.5em;text-align:right;background:#f2f2f2}article .controlsRun a.clone{margin-right:1em;font-family:actor;text-decoration:none}article .controlsRun a.clone span{padding-left:0.5em}article .controlsRun a.run,article .controlsRun a.reset,article .controlsRun a.show-code{font-size:16px}article .controlsRun a.run span,article .controlsRun a.reset span,article .controlsRun a.show-code span{display:none}article .controlsRun a.reset{margin-left:0.5em;color:#a2becc}article .controlsRun a.reset{display:none}article .controlsRun a.show-code{margin-right:0.75em}article .controlsRun a.run:hover,article .controlsRun a.show-code:hover{text-decoration:none}article .controlsRun a.show-code.active{color:#DC0D0D}article .controlsRun a[disabled]{color:#a2becc;cursor:default}article .collapse-area .collapse-header{background:#0088cc;color:#fff;padding:0.3em;cursor:pointer}article .collapse-area .hidden-toggle:before{content:"\f0d7";font-family:fontawesome;margin-right:0.5em;margin-left:0.25em}article .collapse-area .collapsed-files{overflow:auto;height:auto}article .collapse-area.collapse-disabled{display:none}article .collapse-area.collapse-area-off .collapsed-files{height:0px;overflow:hidden}article .collapse-area.collapse-area-off .hidden-toggle:before{content:"\f0da"}article .snippet-stdio .stdout{margin:0.5em;padding-right:2em;position:relative;word-wrap:break-word}article .snippet-stdio .stdin{-webkit-box-shadow:none;-moz-box-shadow:none;box-shadow:none;-webkit-transition:none;-moz-transition:none;-o-transition:none;transition:none;padding:0;margin:0}article .hoogle-results{margin:0.25em}article .hoogle-results .hoogle-inner{background:#fff;padding:0.5em;border-radius:3px;border:1px solid #ddd}article .hoogle-results .hoogle-inner .close-link{position:relative;float:right;margin-top:-0.5em;margin-right:-0.5em}article .snippet-output-errors{margin:1em 0.5em 0.5em 0.5em;position:relative}article .snippet-output-errors ul{list-style-type:none;margin:0;position:relative}article .snippet-output-errors pre{border:0;border-radius:0;padding:0.25em;margin:0;background:inherit;color:inherit}article .snippet-output-errors .close-link{color:inherit;background:inherit}article .snippet-editors{z-index:0;padding:0.25em}article .close-link{padding:0.5em;background:#eaeaea;border-bottom-left-radius:0.2em;border-top-right-radius:0.2em;position:absolute;top:0;right:0}article .close-link:hover{text-decoration:none}article .snippet-title{padding:0.5em 0 0 0.5em}article .snippet-title .snippet-icon{font-family:FontAwesome;display:inline-block;margin-right:0.5em}article .fullModuleCode + div .snippet-title{margin-top:0.5em;border-top:1px solid #ccc;padding-top:0.5em}article .CodeMirror{height:auto;min-height:1em;line-height:1.5em;background:transparent;font-size:14px !important}article .CodeMirror .highlighted{background:rgba(250, 210, 0, 0.45) !important}article .CodeMirror-widget{margin-left:2em;line-height:1.8}article .CodeMirror.collapsed{height:10em !important}article .editor .expander{text-align:center;display:block;padding:0.5em;text-decoration:none;border-bottom-left-radius:2px;border-bottom-right-radius:2px}article .editor .expander .ellipsis{background:white;border:1px solid #ccc;padding:0 0.5em;height:1em;line-height:0.5em;display:inline-block;color:#555;cursor:pointer}article .editor .expander .ellipsis:hover{background:#ddd;color:#333}article .web-runner{margin:0.5em;padding:0.5em;border:1px solid #ccc;border-radius:3px;background:#f5f5f5}article .web-runner iframe{border:0;margin-top:0.5em;margin-bottom:0;background:white}article .web-runner .controls i{cursor:pointer;color:#0088cc}article .web-runner .controls i:hover{color:#222}article .web-runner .controls i + i{margin-left:0.5em}article .web-runner .controls .icon-remove{float:right}article .hidden{display:block;visibility:visible}article .controlsShowHide{margin-bottom:0.5em}.tutorial-body{float:left !important}.tutorial-nav{float:right !important}@media (max-width: 979px) {.related-content{float:right}.author-name{display:block;margin-left:20px !important;padding-left:5px;margin-top:5px}article h1 a:hover:before,article h2 a:hover:before,article h3 a:hover:before,article h4 a:hover:before,article h5 a:hover:before,article h6 a:hover:before{color:#fff}.tutorial-nav{float:none !important;width:auto !important}.tutorial-body{float:none !important;width:auto !important}}@media (min-width: 980px) and (max-width: 1199px) {.navbar-search{display:none}.tutorial-nav{width:200px}.tutorial-body{width:720px}}#accountPage h1{margin:20px 0 0 0}#accountPage h2{font-size:20px}.group-contents .span8{float:left}.group-contents .span4{float:right}.container > .alert-block{margin-top:1em}.alert{color:#aa874a
}.social{margin-bottom:.8em;display:block}.social a{text-decoration:none}.social i{font-size:1.1em;color:#fff;padding:0.25em;border-radius:0.25em;width:1em;display:inline-block;text-align:center}.social i.icon-twitter{background:#0088cc}.social i.icon-facebook{background:#3b5998
  }.social i.icon-google-plus{background:#dd4b39
  }.well pre{background:#fcfcfc}.well h2{margin-top:0}code{color:#005580;font-size:14px;white-space:pre}</style><!--[if lt IE 8]><link rel="stylesheet" href="https://www.schoolofhaskell.com/static/design/css/ie7.css?etag=TSMl9x1V"><![endif]--><!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]--></head><body class="not-logged-in" itemscope itemtype="http://schema.org/Product"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-H62P" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-H62P');</script><div class="navbar navbar-inverse navbar-static-top"><div class="navbar-inner"><div class="container"><a class="btn btn-navbar" type="button" data-toggle="collapse" data-target=".nav-collapse"><span class="icon-bar"></span>
<span class="icon-bar"></span>
<span class="icon-bar"></span>
</a>
<a class="brand" href="/"><img src="/static/img/haskell-logo-wide.png" title="School of Haskell">
</a>
<div class="nav-collapse collapse"><ul class="nav"><li><a href="https://www.schoolofhaskell.com/">School</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user">Users</a>
</li>
</ul>
<form class="navbar-search pull-left" action="https://www.schoolofhaskell.com/search"><input class="search-query" type="text" placeholder="Search" name="search">
</form>
</div>
</div>
</div>
</div>
<div class="container breadcrumb-container"><div class="row"><div class="span12"><ul class="breadcrumb"><li><a href="https://www.schoolofhaskell.com/user/pbv">Pedro Vasconcelos</a>
<span class="divider">/</span>
</li>
<li><a href="https://www.schoolofhaskell.com/user/pbv/a-regular-expression-matcher">A regular expression matcher</a>
</li>
</ul>
</div>
</div>
</div>
<div class="container main-content"><div class="row"><div class="span12"><h1 itemprop="name">A regular expression matcher</h1>
</div>
</div>
<div class="row"><div class="span7 meta"><p><span class="date">15 Feb 2017</span>
<span class="author"><a href="https://www.schoolofhaskell.com/user/pbv">Pedro Vasconcelos</a>
</span>
<span class="view-edit-link pull-right"><a class="view-source-link" href="https://www.schoolofhaskell.com/tutorial-raw/2424/0ac7c3c8382ff2ac33f74111319e9963aee1a432">View Markdown source</a>
</span>
</p>
<p class="tags"></p>
</div>
</div>
<div class="row"><div class="span7 meta"><span class="sociallinksunicode social">
<a href="https://twitter.com/home?status=$url$" target="_blank"><i class="icon-twitter"></i></a>&nbsp;
<a href="http://www.facebook.com/sharer/sharer.php?u=$url$" target="_blank"><i class="icon-facebook"></i></a>&nbsp;
<a href="https://plus.google.com/share?url=$url$" target="_blank"><i class="icon-google-plus"></i></a></span>
</div>
</div>
<p class="alert">As of March 2020, School of Haskell has been switched to read-only mode.</p>
<div class="row" itemprop="desc"><div class="span4 tutorial-nav"><div class="related-content"><ul class="nav nav-tabs nav-stacked"><li><script>reddit_target='fpcomplete'</script>
<script src="https://redditstatic.s3.amazonaws.com/button/button1.js"></script>
</li>
<li><a href="https://www.schoolofhaskell.com/user/pbv/an-introduction-to-quickcheck-testing">Previous content: An introduction to QuickCheck testing</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user/pbv">See all content by Pedro Vasconcelos</a>
</li>
</ul>

</div>
<div class="aside"><h3>Sections</h3>
<ul><li><a href="#regular-expressions">Regular expressions</a></li><li><a href="#matching">Matching</a></li><li><a href="#exercises">Exercises</a></li></ul></div>
</div>
<div class="span8 tutorial-body" data-environment="ghc-7.8-stable-14.09">
<article><p><i>Regular expressions</i> (regexps) are a both a theoretical model of
computation and a practical basis for language processing (e.g. the
Unix command-line tools <code>grep</code> and <code>awk</code>, scripting languages such as
<code>bash</code> and <code>perl</code> and the <code>lex</code> and <code>alex</code> compiler-building tools).</p><p>This tutorial we are going to build a simple regexp matcher in
Haskell. The key to expressing matching in an elegant and compositional
way is to use a combination of <i>algebraic datatypes</i> and programming
with <i>continuations</i>. 
Note, however, that the emphasis of this tutorial is on clarity, <i>not</i> optimization;
real-world code should rely on an industrial-strengh<br />library such as <code>regexp-pcre</code>.</p><p>This tutorial was inspired by Olivier Danvy's
<a href="http://www.brics.dk/RS/01/23">Defunctionalization at Work</a>
(a BRICS technical report).</p><h2 id="regular-expressions"><a href="#regular-expressions">Regular expressions</a></h2><blockquote><p>I define UNIX as &quot;30 definitions of regular expressions living under
one roof.&quot; --- Don Knuth</p></blockquote><p>Although practical tools adopt extended definitions of regular
expressions, we will consider only simple <i>regexps</i> built as follows:</p><ul><li>0 that matches nothing (the empty language);</li><li>1 (or <i>epsilon</i>) that matches the empty string;</li><li>a single character <i>c</i> matching itself;</li><li>the union (+) of two <i>regexp</i>s;</li><li>the concatenation (.) of two <i>regexp</i>s;</li><li>the zero-or-more repetition (*) of a <i>regexp</i> (also called <i>Kleene closure</i>).</li></ul><p>Concatenation, union and repetition are standard in practical 
tools such as <code>grep</code>. Constants 0 and 1 are necessary to ensure 
good algebraic properties (every language recognized by an automaton
can be represented by a regexp) and sometimes ommitted in practice:
e.g. in <code>grep</code> the empty string
is represented by <code>^$</code> but there is no representation for the empty language.</p><p>Instead of re-using some existing type to encode regexps (e.g. strings) we
begin by defining a custom recursive datatype.
This will make it easier to process regexps and define the matching algorithm.</p><pre><code class="haskell">data Regexp = Zero                  -- empty
            | One                   -- epsilon
            | Lit Char              -- single character
            | Plus Regexp Regexp    -- union (+)
            | Cat  Regexp Regexp    -- concatenation (.)
            | Many Regexp           -- repetition (*)</code></pre><p>Some examples of regexp together with a description of what they match:</p><pre><code class="haskell">Lit 'a'                        -- an 'a'
Plus (Lit 'a') (Lit 'b')       -- an 'a' or a 'b'
Cat (Many (Lit 'a')) (Lit 'b') -- b, ab, aab, aaab, ...</code></pre><p>Note that <i>any</i> value of the <code>Regexp</code> data type (except for non-terminating ones)
corresponds to a valid regular expression. This means
that ill-formed regexps are avoided simply by type checking!</p><p>However, writting complex regexps this way is verbose and
error-prone. We therefore introduce some shortcuts.</p><p>First, we define two infix operators for 
union and concatenation of regexps. 
We can also use some algebraic properties 
such as <code>0+e = e+0 = e</code> and <code>1.e = 1.e = e</code>
to do some automatic simplification.
We also define a &quot;smart&quot; constructor for repetition.</p><pre><code class="haskell">infixl 6 &lt;+&gt;
infixl 7 &lt;&gt;

(&lt;+&gt;) :: Regexp -&gt; Regexp -&gt; Regexp
Zero &lt;+&gt; e = e
e &lt;+&gt; Zero = e
e1 &lt;+&gt; e2  = Plus e1 e2

(&lt;&gt;) :: Regexp -&gt; Regexp -&gt; Regexp
Zero &lt;&gt; _   = Zero
_ &lt;&gt; Zero   = Zero
One &lt;&gt; e    = e
e &lt;&gt; One    = e
e1 &lt;&gt; e2    = Cat e1 e2

many :: Regexp -&gt; Regexp 
many Zero     = One
many One       = One
many (Many e)  = Many e
many e         = Many e</code></pre><p>Second, we employ the <code>OverloadedStrings</code> GHC extension to automatically 
convert any string literal to a regexp.
For example, the string <code>&quot;abc&quot;</code> is 
converted to a concatenation of characters:</p><pre><code class="haskell">Cat (Lit 'a') (Cat (Lit 'b') (Lit 'c'))</code></pre><p>(<i>To see how this is achived open the full code window on the runnable 
example at the end.</i>)</p><p>Using these operators we can write regexps quite succintly:</p><pre><code class="haskell">&quot;ab&quot; 
&quot;a&quot;&lt;+&gt;&quot;b&quot;
&quot;ab&quot; &lt;&gt; many (&quot;a&quot;&lt;+&gt;&quot;b&quot;)</code></pre><h2 id="matching"><a href="#matching">Matching</a></h2><p>Our objective is to define a matching function, i.e. a function that
takes a regexp and a string and yields a boolean.</p><pre><code class="haskell">match :: Regexp -&gt; String -&gt; Bool</code></pre><p>However, if we try to define the <code>match</code> function directly
by recursion on the <code>Regexp</code> data type we run into
problems. 
For example, to match the concatenation of two
regexps, we would have to split the input string:</p><pre><code class="haskell">match (Cat e1 e2) cs = match e1 cs1 &amp;&amp; match e2 cs2
    -- incomplete: missing some cs1, cs2 such that cs=cs1++cs2</code></pre><p>The problem is that <code>match</code> does not yield how much of the input
string was matched.</p><p>One solution would be to have <code>match</code> yield a pair e.g. of
a boolean and a string.
But another more elegant solution is to define a &quot;worker&quot; function
taking an extra parameter called the <i>continuation</i> 
that specifies what to do with the non-matched part of
the string; in this case, the continuation is a function from 
strings to booleans (the result of matching). 
For redability we define a type synomym for continuations;</p><pre><code class="haskell">type Cont = String -&gt; Bool   -- type for continuations</code></pre><p>We can now define the worker function <code>accept</code> by case-analysis on the regexp;
note that <code>accept</code> (unlike <code>match</code>) is higher-order because the 
continuation argument <code>k</code> is a function.
The top-level function <code>match</code> simply calls <code>accept</code> with a continuation that checks
for the empty string (i.e. the <code>null</code> function from the standard Prelude).</p><pre><code class="haskell">accept :: Regexp -&gt; String -&gt; Cont -&gt; Bool  -- worker function
accept Zero    cs      k = False
accept One     cs      k = k cs
accept (Lit c) (c':cs) k = c==c' &amp;&amp; k cs
accept (Lit c) []      k = False
accept (Cat e1 e2) cs  k = accept e1 cs (\cs' -&gt; accept e2 cs' k)
accept (Plus e1 e2) cs k = accept e1 cs k || accept e2 cs k
accept (Many e) cs k     = acceptMany e cs k
  where 
     acceptMany e cs k 
       = k cs || accept e cs (\cs' -&gt; cs'/=cs &amp;&amp; acceptMany e cs' k)</code></pre><p>The case of <code>Zero</code> always fails while <code>One</code> success and applies the continuation
to the remaining string. The case for single character checks the start of the
string and applies the continuation. The case for union is trivial.
Concatenation is more interesting: we simply call <code>accept</code> for the first regexp
<i>e1</i> with a continuation that calls <code>accept</code> for <i>e2</i> (and then proceeds to
the original continuation).
Finally, we use an auxiliary definition <code>acceptMany</code> for matching the repetition.</p><p>The following example allows experimenting with the matcher;
try changing the string or the regexp and re-running the program.</p><pre><code class="active haskell">{-# LANGUAGE OverloadedStrings #-}
import GHC.Exts (IsString(..))

data Regexp = Zero                  -- empty
            | One                   -- epsilon
            | Lit Char              -- single character
            | Plus Regexp Regexp    -- union (+)
            | Cat  Regexp Regexp    -- concatenation (.)
            | Many Regexp           -- repetition (*)
            deriving Show

infixl 6 &lt;+&gt;
infixl 7 &lt;&gt;

(&lt;+&gt;) :: Regexp -&gt; Regexp -&gt; Regexp
Zero &lt;+&gt; e = e
e &lt;+&gt; Zero = e
e1 &lt;+&gt; e2  = Plus e1 e2

(&lt;&gt;) :: Regexp -&gt; Regexp -&gt; Regexp
Zero &lt;&gt; _   = Zero
_ &lt;&gt; Zero   = Zero
One &lt;&gt; e    = e
e &lt;&gt; One    = e
e1 &lt;&gt; e2    = Cat e1 e2

many :: Regexp -&gt; Regexp 
many Zero     = One
many One       = One
many (Many e)  = Many e
many e         = Many e

type Cont= String -&gt; Bool

accept :: Regexp -&gt; String -&gt; Cont -&gt; Bool  -- worker function
accept Zero    cs      k = False
accept One     cs      k = k cs
accept (Lit c) (c':cs) k = c==c' &amp;&amp; k cs
accept (Lit c) []      k = False
accept (Cat e1 e2) cs  k = accept e1 cs (\cs' -&gt; accept e2 cs' k)
accept (Plus e1 e2) cs k = accept e1 cs k || accept e2 cs k
accept (Many e) cs k     = acceptMany e cs k
  where 
     acceptMany e cs k 
       = k cs || accept e cs (\cs' -&gt; cs'/=cs &amp;&amp; acceptMany e cs' k)


match :: Regexp -&gt; String -&gt; Bool
match re s = accept re s null

instance IsString Regexp where
  fromString cs = foldr ((&lt;&gt;) . Lit) One cs

-- show
main = print (match (&quot;ab&quot; &lt;&gt; many &quot;ba&quot;) &quot;abbaba&quot;)
-- /show</code></pre><h2 id="exercises"><a href="#exercises">Exercises</a></h2><ol><li><p>Define auxiliary functions <code>plus</code> and <code>option</code>
for the <code>+</code> and <code>?</code> operators in <code>grep</code>, i.e. one-or-more times 
repetition and optional matching.</p><div class="hidden"><p>Here are one-line solutions that re-use the previous functions.</p><pre><code class="haskell">plus, option :: Regexp -&gt; Regexp
plus e = e &lt;&gt; many e
option e = &quot;&quot; &lt;+&gt; e</code></pre></div></li><li><p>The function <code>acceptMany</code> for handling repetition includes a condition 
<code>cs'/=cs</code> to check that characters are consumed in the recursive case. 
However, checking list inequality requires traversing the full list
in the worst-case. Find a way to avoid this inefficient check.</p><div class="hidden"><p>It is sufficient to pair each character with its <i>index</i>
and replace the check that the inequality on indices rather than string.
The type of continuations and the worker function need to be modified;
the relevant change is the case of the repetition operator:</p><pre><code class="haskell">type Cont = [(Int,Char)] -&gt; Bool   -- new type for continuations

accept :: Regexp -&gt; [(Int,Char)] -&gt; Cont -&gt; Bool
accept (Many e) ics k  = acceptMany e ics k
   where 
     acceptMany e ics k 
        = k ics || accept e ics (\ics' -&gt; fst ics'/=fst ics &amp;&amp; acceptMany e ics' k)
-- other cases are straightforward

match :: Regexp -&gt; String -&gt; Bool
match re cs = accept re (zip [0..] cs) null</code></pre></div></li></ol></article>

<div id="disqus_thread"><script>var disqus_shortname = "fpcomplete"; (function() { var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true; dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq); })();</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">comments powered by <span class="logo-disqus">Disqus</span></a></a>
</div>

</div>
</div>
<div class="row article-footer"><div class="span7 meta"><span class="sociallinksunicode social">
<a href="https://twitter.com/home?status=$url$" target="_blank"><i class="icon-twitter"></i></a>&nbsp;
<a href="http://www.facebook.com/sharer/sharer.php?u=$url$" target="_blank"><i class="icon-facebook"></i></a>&nbsp;
<a href="https://plus.google.com/share?url=$url$" target="_blank"><i class="icon-google-plus"></i></a></span>
</div>
</div>
</div>
<div class="footer"><div class="container"><div class="row"><div class="span12"><ul class="menu"><li><a href="https://www.schoolofhaskell.com/">School</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user">Users</a>
</li>

<li><a class="brand" href="https://fpcomplete.com">Sponsored by:
<img src="/static/img/logo.png" title="FPComplete">
</a>
</li>
</ul>
</div>
</div>
<div class="row"><div class="span12"></div>
</div>
</div>
</div>
<link rel="stylesheet" type="text/css" href="/static/bootstrap/css/bootstrap-responsive.css" />
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script><script src="https://www.schoolofhaskell.com/static/combined/Y-3k9_tW.js"></script><script>$(function(){
  $("a.logout").click(function(){
    var form = $("<form method='post'/>");
    form.attr("action", $(this).attr("href"));
    $("body").append(form);
    form.submit();
    return false;
  });
});

$(function(){
    $('.sociallinksunicode a').each(function(){
        $(this).attr('href',$(this).attr('href').replace('$url$',document.location));
    });
});

$(function(){
  // If we need to select a user/select a password then show the
  // details confirmation form, otherwise enable the getting started
  // section.
  if($('.alert-block a').text().match(/(selected a username|change your password)/)) {
    $("#confirm-details").show();
    $("#confirm-details #inputUsername").focus();
  } else {
    $("#get-started").removeClass('disabled').addClass('enabled');
  }

  // For lack of a plain HTML validation story this will do.
  $('.welcome-page').each(function(){
    $('form').submit(check);
  });
  function check(){
    setTimeout(check,500);
    var error = false;
    $('.error').removeClass('error');
    $('#enter-details input').each(function(){
      if($(this).val() == '') {
        $(this).parent().parent().addClass('error');
        error = true;
      }
    });
    if(error) return false;
    if($('[name=password]').val() == $('[name=confirm]').val()) {
      $('#confirm').removeClass('error');
      return true;
    } else {
      $('#confirm').addClass('error');
      return false;
    }
  }
});

$(function(){
  // When scrolling over a snippet editor, activate the "clone in IDE" popovers
  $('article').each(function(){
    var n = 100;
    var wait = 10000;
    function check(){
      if($('.clone').length == 0) {
        setTimeout(check,n);
        return;
      }
      var activated = $.cookie('clone-popover');
      if (activated) return;
      var activate = false;
      $('.controlsRun:onScreen').each(function(){
        $.cookie('clone-popover', 'true', { expires: 30, path: '/' });
        activate = true;
        return false;
      });
      if(activate) {
          $('.clone').each(function(){
              // The bootstrap API is rather unreasonable to say the
              // least.
              next = $(this).parent();
              var title = next.attr('title');
              next.attr('data-content',$(this).attr('data-content'));
              next.attr('title',$(this).attr('title'));
              next.popover('show',{
                  title: $(this).attr('title')
              });
              next.attr('title',title);
          });
          setTimeout(function(){
              $('.clone').each(function(){
                  $(this).parent().popover('hide');
              });
          },wait);
      } else {
        setTimeout(check,n);
      }
    }
    setTimeout(check,n);
  });
});

// onScreen jQuery plugin v0.2.1
// (c) 2011-2013 Ben Pickles
//
// http://benpickles.github.com/onScreen
//
// Released under MIT license.
(function(a){a.expr[":"].onScreen=function(b){var c=a(window),d=c.scrollTop(),e=c.height(),f=d+e,g=a(b),h=g.offset().top,i=g.height(),j=h+i;return h>=d&&h<f||j>d&&j<=f||i>e&&h<=d&&j>=f}})(jQuery);

/*!
 * jQuery Cookie Plugin v1.1
 * https://github.com/carhartl/jquery-cookie
 *
 * Copyright 2011, Klaus Hartl
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.opensource.org/licenses/GPL-2.0
 */
(function($, document) {

  var pluses = /\+/g;
  function raw(s) {
    return s;
  }
  function decoded(s) {
    return decodeURIComponent(s.replace(pluses, ' '));
  }

  $.cookie = function(key, value, options) {

    // key and at least value given, set cookie...
    if (arguments.length > 1 && (!/Object/.test(Object.prototype.toString.call(value)) || value == null)) {
      options = $.extend({}, $.cookie.defaults, options);

      if (value == null) {
	options.expires = -1;
      }

      if (typeof options.expires === 'number') {
	var days = options.expires, t = options.expires = new Date();
	t.setDate(t.getDate() + days);
      }

      value = String(value);

      return (document.cookie = [
	encodeURIComponent(key), '=', options.raw ? value : encodeURIComponent(value),
	options.expires ? '; expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE
	options.path    ? '; path=' + options.path : '',
	options.domain  ? '; domain=' + options.domain : '',
	options.secure  ? '; secure' : ''
      ].join(''));
    }

    // key and possibly options given, get cookie...
    options = value || $.cookie.defaults || {};
    var decode = options.raw ? raw : decoded;
    var cookies = document.cookie.split('; ');
    for (var i = 0, parts; (parts = cookies[i] && cookies[i].split('=')); i++) {
      if (decode(parts.shift()) === key) {
	return decode(parts.join('='));
      }
    }
    return null;
  };
  $.cookie.defaults = {};})(jQuery, document);
</script><!--[if lt IE 10]><script src="https://www.schoolofhaskell.com/static/design/js/ie.js?etag=ayV2DuJ0"></script><![endif]--><script>if(!window.location.href.match(/localhost/)){var track = '/tutorial/user/pbv/a-regular-expression-matcher';
window._gaq = [['_setAccount','UA-36928035-1'],track != ''? ['_trackPageview',track] : ['_trackPageview']
,['_trackPageLoadTime']];window._gaq.push(['_setCustomVar',1,'Section','School of Haskell',3]);
window._gaq.push(['_setCustomVar',2,'User Type','Visitor',1]);
(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);

})();}</script>
<!-- Prompt IE 6 users to install Chrome Frame. Remove this if you want to support IE 6.  chromium.org/developers/how-tos/chrome-frame-getting-started --><!--[if lt IE 7 ]><script src="//ajax.googleapis.com/ajax/libs/chrome-frame/1.0.3/CFInstall.min.js"></script><script>window.attachEvent('onload',function(){CFInstall.check({mode:'overlay'})})</script><![endif]--></body></html>