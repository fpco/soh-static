<!DOCTYPE html>
<html><head><title>Haskell in Spanish 1 - School of Haskell | School of Haskell</title><meta http-equiv="x-ua-compatible" content="IE=9"><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="google-site-verification" content="Rfxk2TdeMMXEXHgJ2_OO8Rt3hPbQSDao0OXQV_n6z_s" /><link href="//fonts.googleapis.com/css?family=Merriweather" rel="stylesheet" type="text/css"><link href="https://www.schoolofhaskell.com/recent-content/feed" type="application/rss+xml" rel="alternate" title="Recently published content">
<link rel="stylesheet" href="https://www.schoolofhaskell.com/static/combined/UlwEHVcM.css"><style>.social{margin-right:1em}h1{font-family:Merriweather !important}article{font-family:Merriweather !important}article li{font-family:Merriweather !important;line-height:1.6em}h1,h2,h3,h4,h4,h5{font-family:Merriweather !important}.editor p{font-family:Frutiger, "Frutiger Linotype", Univers, Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans Condensed", "Liberation Sans", "Nimbus Sans L", Tahoma, Geneva, "Helvetica Neue", Helvetica, Arial, sans-serif}.article-footer{border-top:1px solid #ddd;padding-top:1em;margin-top:1em}body{font-size:16px !important}.navbar .navbar-inner{background:#3c3f41}.navbar .brand{font-size:14px}.navbar .brand img{width:6em}.navbar .icon-wrench{margin:0 -0.5em 0 -0.5em;padding:0 1em 0 1em;height:20px}.navbar-inverse .nav .active a{background:#333638}.navbar-inverse .nav > li > a{color:#a7a7a7
}.navbar-inverse .btn-navbar{background:#333638}.navbar-inverse .nav > li a:hover,.navbar-inverse .btn{background:#333537 !important}@media (max-width: 979px) {.icon-wrench{padding-left:1em !important}}.breadcrumb{border-top-left-radius:0;border-top-right-radius:0}h1{margin-top:20px}.breadcrumb-container + .main-content h1{margin-top:0}.footer{padding:30px 0;margin-top:70px;border-top:1px solid #e5e5e5;background-color:#f5f5f5}.footer ul.footer-menu{list-style-type:none}.footer ul.footer-menu li{display:inline-block}.footer ul.footer-menu li + li{margin-left:0.5em}.footer ul.footer-menu li + li:before{margin-right:0.5em;content:"Â·";color:#999}.footer ul.menu li{display:inline-block}.footer ul.menu li + li{margin-left:0.5em}.footer .copyright{margin-left:25px}.main-content{min-height:100%}.gravatar{width:80px;height:80px;border-radius:2px;background:#eee}.empty-gravatar{width:0}.container{font-family:"Segoe UI", Candara, "Bitstream Vera Sans", "DejaVu Sans", "Bitstream Vera Sans", "Trebuchet MS", Verdana, "Verdana Ref", sans-serif}.container h1,.container h2,.container h4,.container h4,.container h5{font-family:"Segoe UI", Candara, "Bitstream Vera Sans", "DejaVu Sans", "Bitstream Vera Sans", "Trebuchet MS", Verdana, "Verdana Ref", sans-serif}article{font-family:Merriweather !important}article h1{font-family:Merriweather !important}article li{font-family:Merriweather !important;line-height:1.6em}article li + li{margin-top:0.5em}article div.code{background:#f9f9f9;border:1px solid #d1d1d1;position:relative;border-radius:0.2em;margin:0.25em 0 0.75em 0;min-height:2.5em}article code{color:#005580;font-size:14px;white-space:pre}article a.hoogle > code{color:#0088cc;font-size:14px;white-space:pre;border:0}article .expand-code{display:none}article pre{overflow:auto;word-wrap:normal}article code.active{display:block;max-height:430px}article h1{font-size:31.5px}article h3{font-size:17.5px}article h4{font-size:14px}article h5,article h6{font-size:11.9px}article p{line-height:1.7em}article h1 code,article h2 code,article h3 code,article h4 code,article h5 code,article h6 code{font-size:inherit !important}article h1 a,article h2 a,article h3 a,article h4 a,article h5 a,article h6 a{color:#444}article h1 a:before,article h2 a:before,article h3 a:before,article h4 a:before,article h5 a:before,article h6 a:before{margin-left:-1.5em;padding-right:0.5em;font-family:fontawesome;content:"\f0c1";font-size:20px;color:#fff}article h1 a:hover,article h2 a:hover,article h3 a:hover,article h4 a:hover,article h5 a:hover,article h6 a:hover{text-decoration:none;color:#0088cc}article h1 a:hover:before,article h2 a:hover:before,article h3 a:hover:before,article h4 a:hover:before,article h5 a:hover:before,article h6 a:hover:before{color:#888}article h2{font-size:24.5px}article .popover{font-family:actor}article .popover h3.popover-title{font-family:actor !important;font-size:1em}article .popover .popover-content{width:15em;font-size:1em}article .controlsRun{display:block;padding:0.5em;text-align:right;background:#f2f2f2}article .controlsRun a.clone{margin-right:1em;font-family:actor;text-decoration:none}article .controlsRun a.clone span{padding-left:0.5em}article .controlsRun a.run,article .controlsRun a.reset,article .controlsRun a.show-code{font-size:16px}article .controlsRun a.run span,article .controlsRun a.reset span,article .controlsRun a.show-code span{display:none}article .controlsRun a.reset{margin-left:0.5em;color:#a2becc}article .controlsRun a.reset{display:none}article .controlsRun a.show-code{margin-right:0.75em}article .controlsRun a.run:hover,article .controlsRun a.show-code:hover{text-decoration:none}article .controlsRun a.show-code.active{color:#DC0D0D}article .controlsRun a[disabled]{color:#a2becc;cursor:default}article .collapse-area .collapse-header{background:#0088cc;color:#fff;padding:0.3em;cursor:pointer}article .collapse-area .hidden-toggle:before{content:"\f0d7";font-family:fontawesome;margin-right:0.5em;margin-left:0.25em}article .collapse-area .collapsed-files{overflow:auto;height:auto}article .collapse-area.collapse-disabled{display:none}article .collapse-area.collapse-area-off .collapsed-files{height:0px;overflow:hidden}article .collapse-area.collapse-area-off .hidden-toggle:before{content:"\f0da"}article .snippet-stdio .stdout{margin:0.5em;padding-right:2em;position:relative;word-wrap:break-word}article .snippet-stdio .stdin{-webkit-box-shadow:none;-moz-box-shadow:none;box-shadow:none;-webkit-transition:none;-moz-transition:none;-o-transition:none;transition:none;padding:0;margin:0}article .hoogle-results{margin:0.25em}article .hoogle-results .hoogle-inner{background:#fff;padding:0.5em;border-radius:3px;border:1px solid #ddd}article .hoogle-results .hoogle-inner .close-link{position:relative;float:right;margin-top:-0.5em;margin-right:-0.5em}article .snippet-output-errors{margin:1em 0.5em 0.5em 0.5em;position:relative}article .snippet-output-errors ul{list-style-type:none;margin:0;position:relative}article .snippet-output-errors pre{border:0;border-radius:0;padding:0.25em;margin:0;background:inherit;color:inherit}article .snippet-output-errors .close-link{color:inherit;background:inherit}article .snippet-editors{z-index:0;padding:0.25em}article .close-link{padding:0.5em;background:#eaeaea;border-bottom-left-radius:0.2em;border-top-right-radius:0.2em;position:absolute;top:0;right:0}article .close-link:hover{text-decoration:none}article .snippet-title{padding:0.5em 0 0 0.5em}article .snippet-title .snippet-icon{font-family:FontAwesome;display:inline-block;margin-right:0.5em}article .fullModuleCode + div .snippet-title{margin-top:0.5em;border-top:1px solid #ccc;padding-top:0.5em}article .CodeMirror{height:auto;min-height:1em;line-height:1.5em;background:transparent;font-size:14px !important}article .CodeMirror .highlighted{background:rgba(250, 210, 0, 0.45) !important}article .CodeMirror-widget{margin-left:2em;line-height:1.8}article .CodeMirror.collapsed{height:10em !important}article .editor .expander{text-align:center;display:block;padding:0.5em;text-decoration:none;border-bottom-left-radius:2px;border-bottom-right-radius:2px}article .editor .expander .ellipsis{background:white;border:1px solid #ccc;padding:0 0.5em;height:1em;line-height:0.5em;display:inline-block;color:#555;cursor:pointer}article .editor .expander .ellipsis:hover{background:#ddd;color:#333}article .web-runner{margin:0.5em;padding:0.5em;border:1px solid #ccc;border-radius:3px;background:#f5f5f5}article .web-runner iframe{border:0;margin-top:0.5em;margin-bottom:0;background:white}article .web-runner .controls i{cursor:pointer;color:#0088cc}article .web-runner .controls i:hover{color:#222}article .web-runner .controls i + i{margin-left:0.5em}article .web-runner .controls .icon-remove{float:right}article .hidden{display:block;visibility:visible}article .controlsShowHide{margin-bottom:0.5em}.tutorial-body{float:left !important}.tutorial-nav{float:right !important}@media (max-width: 979px) {.related-content{float:right}.author-name{display:block;margin-left:20px !important;padding-left:5px;margin-top:5px}article h1 a:hover:before,article h2 a:hover:before,article h3 a:hover:before,article h4 a:hover:before,article h5 a:hover:before,article h6 a:hover:before{color:#fff}.tutorial-nav{float:none !important;width:auto !important}.tutorial-body{float:none !important;width:auto !important}}@media (min-width: 980px) and (max-width: 1199px) {.navbar-search{display:none}.tutorial-nav{width:200px}.tutorial-body{width:720px}}#accountPage h1{margin:20px 0 0 0}#accountPage h2{font-size:20px}.group-contents .span8{float:left}.group-contents .span4{float:right}.container > .alert-block{margin-top:1em}.alert{color:#aa874a
}.social{margin-bottom:.8em;display:block}.social a{text-decoration:none}.social i{font-size:1.1em;color:#fff;padding:0.25em;border-radius:0.25em;width:1em;display:inline-block;text-align:center}.social i.icon-twitter{background:#0088cc}.social i.icon-facebook{background:#3b5998
  }.social i.icon-google-plus{background:#dd4b39
  }.well pre{background:#fcfcfc}.well h2{margin-top:0}code{color:#005580;font-size:14px;white-space:pre}</style><!--[if lt IE 8]><link rel="stylesheet" href="https://www.schoolofhaskell.com/static/design/css/ie7.css?etag=TSMl9x1V"><![endif]--><!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]--></head><body class="not-logged-in" itemscope itemtype="http://schema.org/Product"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-H62P" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-H62P');</script><div class="navbar navbar-inverse navbar-static-top"><div class="navbar-inner"><div class="container"><a class="btn btn-navbar" type="button" data-toggle="collapse" data-target=".nav-collapse"><span class="icon-bar"></span>
<span class="icon-bar"></span>
<span class="icon-bar"></span>
</a>
<a class="brand" href="/"><img src="/static/img/haskell-logo-wide.png" title="School of Haskell">
</a>
<div class="nav-collapse collapse"><ul class="nav"><li><a href="https://www.schoolofhaskell.com/">School</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user">Users</a>
</li>
</ul>
<form class="navbar-search pull-left" action="https://www.schoolofhaskell.com/search"><input class="search-query" type="text" placeholder="Search" name="search">
</form>
</div>
</div>
</div>
</div>
<div class="container breadcrumb-container"><div class="row"><div class="span12"><ul class="breadcrumb"><li><a href="https://www.schoolofhaskell.com/user/mariopal">mariopal</a>
<span class="divider">/</span>
</li>
<li><a href="https://www.schoolofhaskell.com/user/mariopal/haskell-in-spanish-1">Haskell in Spanish 1</a>
</li>
</ul>
</div>
</div>
</div>
<div class="container main-content"><div class="row"><div class="span12"><h1 itemprop="name">Haskell in Spanish 1</h1>
</div>
</div>
<div class="row"><div class="span7 meta"><p><span class="date">26 Dec 2013</span>
<span class="author"><a href="https://www.schoolofhaskell.com/user/mariopal">mariopal</a>
</span>
<span class="view-edit-link pull-right"><a class="view-source-link" href="https://www.schoolofhaskell.com/tutorial-raw/3657/786144bf186a57575ea5fd009d024ca02b109216">View Markdown source</a>
</span>
</p>
<p class="tags"></p>
</div>
</div>
<div class="row"><div class="span7 meta"><span class="sociallinksunicode social">
<a href="https://twitter.com/home?status=$url$" target="_blank"><i class="icon-twitter"></i></a>&nbsp;
<a href="http://www.facebook.com/sharer/sharer.php?u=$url$" target="_blank"><i class="icon-facebook"></i></a>&nbsp;
<a href="https://plus.google.com/share?url=$url$" target="_blank"><i class="icon-google-plus"></i></a></span>
</div>
</div>
<p class="alert">As of March 2020, School of Haskell has been switched to read-only mode.</p>
<div class="row" itemprop="desc"><div class="span4 tutorial-nav"><div class="related-content"><ul class="nav nav-tabs nav-stacked"><li><script>reddit_target='fpcomplete'</script>
<script src="https://redditstatic.s3.amazonaws.com/button/button1.js"></script>
</li>
<li><a href="https://www.schoolofhaskell.com/user/mariopal">See all content by mariopal</a>
</li>
</ul>

</div>
<div class="aside"><h3>Sections</h3>
<ul><li><a href="#haskell-in-spanish-1">Haskell in Spanish 1</a><ul><li><a href="#hechos-interesantes-sobre-haskell">Hechos interesantes sobre Haskell</a></li><li><a href="#software-importante-escrito-en-haskell">Software importante escrito en Haskell</a></li></ul></li></ul></div>
</div>
<div class="span8 tutorial-body" data-environment="ghc-7.8-stable-14.09">
<article><h1 id="haskell-in-spanish-1"><a href="#haskell-in-spanish-1">Haskell in Spanish 1</a></h1><p><i>I've seen very few tutorials or introductions to Haskell written in Spanish, so I decided to write some text in my native language about this great programming language, even though I consider myself still a newbie in Haskell, and therefore the content will be very basic. I also hope to learn more on the way, thanks to the corrections that make others about what I write, and by the fact that I will have to further study in order to write properly on some issues</i>. Now in Spanish.</p><p>He visto pocos tutoriales o introducciones sobre Haskell escritos en espaÃ±ol, asÃ­ que he decidido escribir algunas entradas en mi lengua nativa sobre este genial lenguaje de programaciÃ³n, a pesar de que me considero aÃºn un novato en Haskell, y por tanto el contenido en principio serÃ¡ muy bÃ¡sico. Con esto espero tambiÃ©n aprender mÃ¡s por el camino, gracias a las correciones que puedan hacer otros sobre lo que escribo, y al hecho de que tendrÃ© que estudiar mÃ¡s a fondo para poder escribir con propiedad sobre algunos temas.</p><p>Voy a comenzar con una lista de cosas que me han sorprendido de Haskell cuando empecÃ© a interesarme por Ã©l. Puesto que estoy ilusionado con lo que he visto, puede que mi estilo en esta primera entrada sea demasiado optimista y positivo, sin ser capaz de indicar las debilidades de Haskell, y Ãºnicamente ser capaz de resaltar sus fortalezas y ventajas. Pero por otro lado no hay nada mejor que un poco de pasiÃ³n para convencer a alguien a adentrarse en un tema nuevo e interesante. Espero que disculpen mis imprecisiones debido a mi euforia a la hora de hablar de estos hechos.</p><h2 id="hechos-interesantes-sobre-haskell"><a href="#hechos-interesantes-sobre-haskell">Hechos interesantes sobre Haskell</a></h2><ul><li><p>La primera vez que vi cÃ³digo en Haskell fue en los primeros puestos de la &quot;Google Code Jam&quot;. Â¡Â¡Los que ganaban el concurso escribÃ­an sus programas en Haskell!! Recuerdo que no entendÃ­a nada del cÃ³digo, y que me sorprendiÃ³ que los programas eran muy cortos, sobre todo comparados con mis soluciones en Python. Me daba la impresiÃ³n como que no estaban terminados. Pero estaban perfectamente cerrados y solucionaban bien los retos de programaciÃ³n del concurso en el tiempo establecido.</p></li><li><p>En Haskell no importa el orden de declaraciÃ³n de las funciones: todas se ven con todas (puedes poner la funciÃ³n &quot;main&quot; donde quieras).</p></li><li><p>El nÃºmero de palabras reservadas en Haskell es aprox. 2/3 del nÃºmero de palabras reservadas en C (unas 22 frente a unas 33). Con esto quiero decir que tiene un nÃºcleo muy simple y reducido.</p></li><li><p>En Haskell no hay palabras reservadas para hacer bucles de ningÃºn tipo (ni for, ni while, ni siquiera algo como goto para emularlo). El truco estÃ¡ en utilizar recursividad y el pattern-matching para conseguir iterar sobre algo muchas veces (hasta que se cumpla alguna condiciÃ³n). Cuando sabes mÃ¡s del lenguaje te das cuenta que el 95% de las veces puedes usar funciones genÃ©ricas en vez de bucles (ej: map, fold). Es curioso que ahora es esto lo que se aconseja en las versiones mÃ¡s modernas de lenguajes como C++: siempre que se pueda, utilizar funciones de alto nivel para las iteraciones en vez de bucles explÃ­citos.</p></li><li><p>Todas las &quot;variables&quot; (o definiciones, o expresiones) en Haskell son inmutables, lo que significa que todas son constantes y no se pueden modificar. Para un programador imperativo esto parece una limitaciÃ³n gigantesca... hasta que te das cuenta de que es una ventaja. Como curiosidad, si escribes <code>x = x + 1</code> no estas incrementando x en uno mÃ¡s del nÃºmero que tenÃ­a (si &quot;x&quot; estÃ¡ definido, es inmutable, es decir, constante, y ya no se puede modificar), sino que normalmente estÃ¡s escribiendo una definiciÃ³n recursiva: <code>x = ((..x.. + 1) + 1) + 1) + 1</code> (bÃ¡sicamente esta definiciÃ³n es un bucle infinito). No hay que complicarse: si quieres almacenar el siguiente valor de &quot;x&quot; sÃ³lo hay que escribir &quot;y = x + 1&quot; Â¿no?.</p></li><li><p>Aunque Haskell tiene tipado estÃ¡tico, en la prÃ¡ctica no es necesario declarar ningÃºn tipo, y el lenguaje encuentra automÃ¡ticamente los mejores tipos para cualquier expresiÃ³n, pues internamente implementa el mÃ¡s potente sistema de inferencia de tipos que existe (algoritmo de Hindley-Milner). Esto te da la facilidad de uso del tipado dinÃ¡mico con las ventajas del tipado estÃ¡tico. Otros lenguajes tienen algo parecido, o empiezan a tenerlo (ej: &quot;auto&quot; en C++), pero no suele estar tan integrado en el lenguaje.</p></li><li><p>Haskell permite escribir cÃ³digo siguiendo &quot;reglas de identado&quot; similares a las de Python (alineando en la misma columna expresiones dentro del mismo bloque), pero tambiÃ©n tiene un modo &quot;layout&quot; o de &quot;escritura libre&quot; sin reglas de identado, que utiliza llaves y puntos y coma (a lo C) para escribir expresiones, que permitirÃ­a escribir cualquier programa entero en una Ãºnica lÃ­nea. Ambos sistemas estÃ¡n activos simultÃ¡neamente, y se pueden mezclar (siempre que se haga entre bloques de cÃ³digo distintos).</p></li><li><p>Haskell acepta tambiÃ©n el formato llamado &quot;literate haskell&quot;, que consiste en escribir en el fichero del cÃ³digo cualquier texto libre (normalmente formateado como Markdown o ReStructuredText, pero puede ser cualquier cosa) y sÃ³lo se considera como texto del programa el cÃ³digo que sigue al carÃ¡cter '&gt;', cuando dicho carÃ¡cter es el primero que aparece en una lÃ­nea (se admiten espacios antes y despuÃ©s). Unido a que las funciones se pueden declarar en cualquier orden y siempre tienen visibilidad en todo el fichero, esto permite escribir una documentaciÃ³n textual muy elaborada, e intercalar el cÃ³digo Haskell en el fichero de texto con dicha documentaciÃ³n. Hay muchas entradas de Blog en Internet escritas en &quot;literate haskell&quot;, como ficheros con la extensiÃ³n &quot;*.lhs&quot;, que el compilador acepta exactamente igual que los ficheros que Ãºnicamente contienen cÃ³digo Haskell (extensiÃ³n &quot;*.hs&quot;).</p></li><li><p>Se dice de los programas de Haskell que &quot;si compilan, entonces funcionan&quot;, remarcando el hecho de que es uno de los lenguajes de programaciÃ³n que es capaz de encontrar el mayor nÃºmero de errores de un programa en tiempo de compilaciÃ³n (muchos de los errores que otros lenguajes sÃ³lo encuentran en tiempo de ejecuciÃ³n). El tipado estÃ¡tico y estricto, junto con el potente sistema de tipos paramÃ©tricos y polimÃ³rficos, sobre el que se tiene que basar todo el cÃ³digo que se escribe, es lo que hace esto posible. En muchos casos es capaz de proveer garantÃ­as estÃ¡ticas (es decir, demostradas de manera teÃ³rica, y no sÃ³lo con una baterÃ­a de tests) para partes del programa que normalmente suelen ser fuente de errores y difÃ­ciles de testar, como las que pueden provocar &quot;condiciones de carrera&quot;.</p></li><li><p>Se dice de Haskell que es &quot;el mejor lenguaje imperativo&quot;. No es una broma, pues gracias a la sintaxis de la palabra reservada &quot;do&quot;, el cÃ³digo escrito dentro de la Monad IO tiene aspecto totalmente imperativo, pero al no serlo realmente, tiene toda la fiabilidad, seguridad y ventajas del cÃ³digo escrito directamente en el paradigma funcional. Aunque se podrÃ­an escribir programas enteros dentro de la Monad IO y trabajar como si Haskell fuera un lenguaje de programaciÃ³n imperativo, la idea es precisamente la contraria: escribir el mÃ­nimo cÃ³digo posible dentro de IO y sacar lo mÃ¡ximo posible hacia funciones &quot;puras&quot;, con todas las ventajas directas del cÃ³digo funcional puro que ello conlleva. SÃ³lo las funciones con &quot;efectos laterales&quot; ineludibles deben estar dentro de la Monad IO.</p></li><li><p>El hecho de que Haskell sea funcional &quot;puro&quot; (sin efectos laterales) a la vez que no-estricto (implementado como &quot;lazy&quot; o perezoso) por defecto, lo hace ideal para crear programas concurrentes, que aprovechen al mÃ¡ximo los mÃºltiples procesadores de las arquitecturas actuales. Esto ocurre ademÃ¡s de manera natural, pues las funciones puras son thread-safe siempre, y el funcionamiento no-estricto (lazy) permite una planificaciÃ³n implicita de operaciones en paralelo. Esto quizÃ¡s sea unas de las caracterÃ­sticas mÃ¡s potentes de Haskell, y probablemente el hecho de que en los Ãºltimos tiempos tenga mÃ¡s visibilidad e importancia como lenguaje de programaciÃ³n.</p></li><li><p>La librerÃ­a STM de Haskell (Software Transactional Memory) se considera la mÃ¡s potente que existe en este campo, aprovechando al mÃ¡ximo el paralelismo y la concurrencia de los procesadores actuales, utilizando un paradigma de programaciÃ³n concurrente muy fÃ¡cil e intuitivo, sin tener que escribir cÃ³digo difÃ­cil de razonar, como el que hay que escribir dentro del infierno de los threads y los mutex, con sus problemas de deadlocks, livelocks, inversiÃ³n de prioridad, etc... asociados (y sin tener que recurrir de manera explÃ­cita a cÃ³digo lock-free aÃºn mÃ¡s complejo y difÃ­cil, y aunque en su implementaciÃ³n interna la STM lo utilice, nunca lo expone al usuario de la librerÃ­a). Por su facilidad, prestaciones y la seguridad que aporta para este tipo de cÃ³digo, la STM se considera el paradigma del futuro para escribir cÃ³digo concurrente. Aunque se puede usar STM en otros lenguajes (hay librerÃ­as STM para muchos) es en Haskell donde se integra de manera natural con el lenguaje y donde mejor brilla su potencial y facilidad de uso. La Ãºltima hornada de procesadores empiezan a implementar Memoria Transaccional por Hardware, mediante extensiones en el juego de instrucciones, lo que portado y aprovechado por esta librerÃ­a la harÃ­a realmente potente, y sin competencia en la creaciÃ³n de programas concurrentes fÃ¡ciles de escribir y realmente eficientes.</p><p>Incluso en la entrada de la Wikipedia sobre la STM (al menos en la inglesa), al final del apartado sobre &quot;ventajas y desventajas conceptuales&quot;, se habla de que Haskell estÃ¡ mejor preparado que otros lenguajes al resolver los problemas de la STM en tiempo de compilaciÃ³n: <a href="http://goo.gl/cgOrDT">http://goo.gl/cgOrDT</a>, y el apartado siguiente (&quot;Composable operations&quot;) es prÃ¡cticamente exclusivo sobre Haskell.</p></li><li><p>Como negativo, se dice que la curva de aprendizaje de Haskell es larga y empinada, sobre todo para programadores que provienen del paradigma imperativo y apenas han trabajado con el paradigma funcional. TambiÃ©n se dice que si no te rindes y superas esa barrera de entrada, las ventajas son evidentes luego. Por ejemplo, se dice que un programador imperativo tarda en dominar Haskell de manera bastante completa en torno a 1 aÃ±o de media, siempre que se proponga en serio aprender a manejarlo y no se rinda.</p></li><li><p>No sÃ³lo de Haskell, sino del paradigma de programaciÃ³n funcional en general, se dice que cuando lo dominas, tus programas imperativos son mejores, y tienes mÃ¡s herramientas y abstracciones con las que trabajar a la hora de escribir cÃ³digo de cualquier tipo, incluso aunque sea en un lenguaje que no es principalmente funcional.</p></li><li><p>Haskell es compilado a cÃ³digo nativo, con lo que es todo lo eficiente en ejecuciÃ³n que puede ser un programa con paradigma funcional (creo que nadie me corregirÃ­a si dijera que es el lenguaje funcional que genera el cÃ³digo mÃ¡s eficiente). Pero tambiÃ©n tiene un intÃ©rprete muy similar al intÃ©rprete de Python, que te permite escribir pruebas muy fÃ¡cilmente, e incluso scripts. Aunque el cÃ³digo interpretado es mucho menos eficiente, esta posibilidad es muy cÃ³moda durante el desarrollo.</p></li><li><p>Haskell utiliza un recolector de basura: como Java, como C#, como Javascript y como Python. TambiÃ©n como lenguajes aÃºn mÃ¡s modernos: como D y como Go. El recolector de basura estÃ¡ integrado en el runtime de Haskell, y por tanto acompaÃ±a al cÃ³digo compilado en formato nativo. Esto no podÃ­a ser de otra forma: es un lenguaje funcional muy potente, no hay punteros ni elementos de bajo nivel similares, su ejecuciÃ³n no-estricta se implementa como lazy (perezosa) la mayor parte del tiempo, planifica la ejecuciÃ³n concurrente y paralela desde dentro, y todo eso no podrÃ­a hacerse sin un potente recolector de basura. Podemos pensar que esto crearÃ¡ ejecutables menos eficientes, y puede que sea asÃ­, pero debe ser uno de los recolectores de basura mÃ¡s eficientes que existen, cuando muchos de sus ejecutables compiten en eficiencia con ejecutables de cÃ³digo escrito en C. Si ademÃ¡s estamos en un entorno multiprocesador y se aprovechan las caracterÃ­sticas de concurrencia de Haskell, el recolector de basura es necesario, y convierte al cÃ³digo en mÃ¡s eficiente, pues se aprovecha su infraestructura para hacer cosas en paralelo y de bajo nivel de manera implÃ­cita, que hace que el cÃ³digo escrito apenas tenga que tener en cuenta la concurrencia porque el recolector de basura, y el runtime de Haskell en general, ya se encarga de esas cosas de manera automÃ¡tica internamente. Por cierto, se dice tambiÃ©n que cualquier programa lo suficientemente complejo implementa internamente algÃºn tipo primitivo de recolector de basura sin darse demasiado cuenta de ello, y probablemente no de la forma mÃ¡s eficiente que podrÃ­a hacerse.</p></li><li><p>Su principal compilador, el GHC (Glasgow Haskell Compiler, que es libre), estÃ¡ escrito tambiÃ©n en Haskell (algo raro, pues la mayorÃ­a de los compiladores de casi cualquier lenguaje estÃ¡n escritos en C o C++), y lleva dÃ©cadas desarrollÃ¡ndose. Por supuesto, hay partes de bajo nivel y enganches con el Sistema Operativo escritos en C. Se considera uno de los compiladores mÃ¡s complejos que existen, y durante los Ãºltimos aÃ±os, tanto Haskell en general como GHC en particular se han obsesionado con generar cÃ³digo eficiente para demostrar que los programas compilados de lenguajes funcionales tambiÃ©n pueden ser rÃ¡pidos. El objetivo en su comunidad es el de &quot;batir&quot; a C (ni siquiera a C++), el rey invicto de los ejecutables super-Ã³ptimos (y el rey de los lenguajes imperativos). Aunque no lo consigan, es un listÃ³n muy alto para un lenguaje funcional, de tan alto nivel y con gran capacidad de abstracciÃ³n y flexibilidad. Y en el mundo de la programaciÃ³n concurrente y paralela, sobre mÃ¡quinas multiprocesador, probablemente ya ha conseguido este objetivo. El compilador GHC, ademÃ¡s de compilar a cÃ³digo nativo, tambiÃ©n puede compilar a cÃ³digo en C.</p></li><li><p>Es una broma repetida a lo largo de los aÃ±os de Haskell el decir en sus cÃ­rculos que debemos tratar de que Haskell permanezca siendo inÃºtil, y que &quot;hay que evitar su Ã©xito a toda costa&quot;, porque no querÃ­an que la pureza de Haskell se contaminase al introducirse en el mundo real. De hecho, es tambiÃ©n relativamente comÃºn que algunos de los artÃ­culos de Haskell (sobre todo de los principales programadores y desarrolladores del compilador principal) tengan tÃ­tulos negativos, del tipo: &quot;Haskell es inÃºtil&quot;. Hoy en dÃ­a se comenta en los foros que esto ya no aleja a Haskell del mundo real, sino todo lo contrario: sus fans leen los artÃ­culos porque ya saben que el tÃ­tulo es una broma, y los despistados lo leen al principio un poco con recelo para luego descubrir que dentro no se critica al lenguaje sino todo lo contrario. Los detractores tambiÃ©n van corriendo a leerlo para tener argumentos contra este &quot;lenguaje tan complicado y distinto&quot;, para descubrir muchas veces que el artÃ­culo les gusta y hasta los &quot;convierte&quot; a favor de Haskell.</p></li><li><p>El lenguaje tuvo un punto de inflexiÃ³n cuando se introdujo como base para sus librerÃ­as (sobre todo para la parte no-pura de sus librerÃ­as mÃ¡s bÃ¡sicas, como la librerÃ­a estÃ¡ndar IO) principios de la TeorÃ­a de CategorÃ­as (supuestamente una de las ramas mÃ¡s complejas de las matemÃ¡ticas, que trata de desplazar a la TeorÃ­a de Conjuntos como teorÃ­a de base para todas las matemÃ¡ticas). Esto llevÃ³ a usar el concepto de Monad (o mÃ³nada) como uno de los patrones de diseÃ±o mÃ¡s potentes del lenguaje, y que prÃ¡cticamente lo convirtiÃ³ en un lenguaje nuevo (la base estaba bien y casi cualquier lenguaje funcional puede usar y aprovecharse del concepto de Monad, pero a Haskell 98 ademÃ¡s le aÃ±adieron una palabra reservada, &quot;do&quot;, como &quot;sintaxis sugar&quot; para trabajar con Monads siguiendo un estilo que podrÃ­amos llamar de &quot;programaciÃ³n imperativa&quot; y que lo hacÃ­a todo increÃ­blemente mÃ¡s fÃ¡cil).</p></li><li><p>Se dice que lo primero que un aprendiz de Haskell hace cuando empieza a entender el lenguaje es escribir en un blog un artÃ­culo (otro mÃ¡s de cientos o miles que ya hay) o tutorial explicando al mundo lo que son las Monads y cÃ³mo funcionan. Normalmente no sirve mucho como tutorial para terceros, sino mÃ¡s bien para que el propio autor y aprendiz de Haskell asiente sus ideas.</p></li><li><p>Haskell es el segundo lenguaje de la historia que implementÃ³ evaluaciÃ³n perezosa generalizada y presente por defecto en todo el lenguaje (el primero fue Miranda, que fue un prototipo de lenguaje creado para una investigaciÃ³n sobre este tema y del que Haskell tomÃ³ ideas). Y es el primer lenguaje de la historia en utilizar entrada/salida mediante mÃ³nadas (Monadic IO), que es su abstracciÃ³n mÃ¡s potente.</p></li><li><p>El hecho de ser &quot;perezoso&quot; o &quot;lazy&quot; hace que en Haskell se puedan definir estructuras de datos &quot;infinitas&quot;, como por ejemplo una lista con todos los nÃºmeros del 1 hasta el infinito (o un Ã¡rbol infinito, o un grafo infinito), y trabajar normalmente con ellas. Haskell sÃ³lo evaluarÃ¡ la parte que necesite de la lista (por eso es &quot;perezoso&quot;) y si al final de las operaciones el resultado es finito, no tendrÃ¡ problemas en mostrarlo. Esto es una abstraciÃ³n muy Ãºtil para determinado tipo de problemas.</p></li><li><p>Por lo que yo he visto, su Ãºnica desventaja con Lisp es que no tiene integrado lo que se denomina &quot;las macros de Lisp&quot; (que no tienen nada que ver con las macros de C). Para ello hay una extensiÃ³n (ya bastante madura, y perfectamente soportada por GHC, el compilador principal) denominada Template Haskell, que permite hacer lo mismo y mÃ¡s (parseo de texto libre y generaciÃ³n de cÃ³digo Haskell en tiempo de compilaciÃ³n, que luego vuelve a compilarse en una segunda fase), pero hay que reconocer que el manejo es un poco mÃ¡s feo y menos elegante que en Lisp (donde las macros tienen el mismo aspecto que el cÃ³digo normal de Lisp: las S-expression). Pero el formato del cÃ³digo normal de Lisp estÃ¡ a su vez limitado y es menos elegante que en Haskell precisamente para poder soportar las macros utilizando el mismo formato del lenguaje (es decir, para conseguir que datos y programas tengan el mismo formato). Con Template Haskell tambiÃ©n puedes tratar un programa como si fueran datos, y se creÃ³ para cubrir esa deficiencia original respecto a Lisp.</p></li><li><p>Hay muchos conceptos de programaciÃ³n que normalmente se asocian o implementan como parte intrÃ­nseca de los lenguajes de programaciÃ³n que en Haskell se implementan como simples librerÃ­as que Ãºnicamente utilizan el &quot;core&quot; del lenguaje, demostrando que estas abstracciones o conceptos no son de tan bajo nivel, y que con un lenguaje con una base adecuada, como Haskell, se pueden implementar utilizando sÃ³lo unos elementos bÃ¡sicos. Algunos ejemplos de estos conceptos de los que hablo:</p><ul><li><p>Bucles: Bueno, ya he hablado de esto, pero el caso es que basta con tener una capacidad de recursividad potente en el lenguaje, unido a cosas como el pattern-matching, para no necesitar bucles de ningÃºn tipo como elementos intrÃ­nsecos del lenguaje.</p></li><li><p>ProgramaciÃ³n Imperativa y secuencial: como ya he dicho, mediante el concepto de Monad, y sobre todo con la Monad IO.</p></li><li><p>Excepciones: SÃ­, en Haskell existen excepciones, pero no estÃ¡n implementadas como un componente dentro del lenguaje, sino como una librerÃ­a, por lo que el utilizarlas o no es decisiÃ³n del programador. Hay que tener en cuenta que algunas librerÃ­as base del lenguaje sÃ­ las utilizan.</p></li><li><p>OrientaciÃ³n a Objetos: Aunque es un paradigma distinto y en la programaciÃ³n funcional no encaja, se pueden utilizar conceptos de este paradigma en Haskell (ej: he llegado a leer que las Comonads y la OOP son bÃ¡sicamente lo mismo). Esto no es nada nuevo, pues ya sabemos que hasta en lenguaje C (que no es orientado a objetos) se puede trabajar con este paradigma.</p></li><li><p>Funciones con parÃ¡metros opcionales o con un nÃºmero de parÃ¡metros variable (variadic functions): En Haskell las funciones tienen un nÃºmero de parÃ¡metros fijo (bueno, en realidad tienen un Ãºnico parÃ¡metro y devuelven otra funciÃ³n que coje el siguiente parÃ¡metro, y asÃ­ hasta el Ãºltimo), pero gracias al polimorfismo y las typeclass es posible implementar funciones que &quot;parecen&quot; que tienen un nÃºmero de parÃ¡metros variable. Un ejemplo claro estÃ¡ en la librerÃ­a &quot;Printf&quot;, que implementa una funciÃ³n &quot;printf&quot; al estilo de C (y por tanto con un nÃºmero de parÃ¡metros variable). Es curioso y esclarecedor estudiar cÃ³mo se consigue esto, pues no se utiliza ninguna extensiÃ³n del lenguaje, sino que Ãºnicamente con las herramientas que ya tenemos (clases de tipos y tipos paramÃ©tricos y polimÃ³rficos) es posible que una funciÃ³n con un parÃ¡metro de cualquier tipo devuelva a su vez otra funciÃ³n que de nuevo acepta un parÃ¡metro de cualquier tipo, y asÃ­ llegar hasta la funciÃ³n principal que las ejecuta a todas en cadena emulando asÃ­ la ejecuciÃ³n de una Ãºnica funciÃ³n multiparÃ¡metro. El concepto se asemeja a clases de C++ con funciones que devuelven al propio objeto, de manera que pueden anidarse llamadas a funciones miembro todas las veces que queramos (tambiÃ©n muy utilizado en Javascript, en librerÃ­as como jQuery). Solo que en Haskell el aspecto externo final es exactamente el mismo que el de una llamada a funciÃ³n con tantos parÃ¡metros como hagan falta.</p></li></ul></li></ul><h2 id="software-importante-escrito-en-haskell"><a href="#software-importante-escrito-en-haskell">Software importante escrito en Haskell</a></h2><ul><li><p><b>ghc</b>: El Glasgow Haskell Compiler es el compilador de Haskell mÃ¡s desarrollado, y probablemente el proyecto de software mÃ¡s grande escrito en Haskell.</p></li><li><p><b>pandoc</b>: Es una librerÃ­a para convertir de un formato de marcas a otro, y una utilidad en lÃ­nea de comandos que utiliza esta librerÃ­a. En sistemas con LaTeX instalado puede generar salida en PDF.</p><ul><li><p>Puede leer:<br />Markdown y (subconjuntos de) Textile, reStructuredText, HTML, LaTeX, MediaWiki y DocBook XML.</p></li><li><p>Puede escribir:<br />Texto plano, Markdown, reStructuredText, XHTML, HTML5, LaTeX (incluidas presentaciones beamer), ConTeXt, RTF, DocBook XML, OpenDocument XML, ODT, Word docx, GNU Texinfo, MediaWiki, EPUB (v2 o v3), FictionBook2, Textile, pÃ¡ginas man, Emacs Org-Mode, AsciiDoc, Slidy, Slideous, DZSlides y S5 HTML.</p></li></ul></li><li><p><b>darcs</b>: Es un sistema de control de versiones distribuido. Como ventaja tiene que estÃ¡ basado en la &quot;teorÃ­a de parches&quot; lo que le permite hacer mÃ¡s cosas de manera automÃ¡tica y correcta que otros sistemas como Mercurial o Git (su interfaz por tanto es mÃ¡s sencilla, con menos comandos necesarios). En concreto su sistema de fusionado es el mÃ¡s potente, pero tambiÃ©n es su punto dÃ©bil, pues como desventaja estÃ¡ el rendimiento, ya que su completo sistema de fusionado puede llegar a requerir tiempos exponenciales: mejorar esto es el principal desarrollo que se hace actualmente en este software. Hay que decir que el problema de rendimiento es por diseÃ±o, y no por elegir a Haskell. De hecho las primeras versiones de Darcs se escribieron en C++ y tenÃ­an el mismo problema.</p></li><li><p><b>xmonad</b>: Es un completo gestor de ventanas de tipo mosaico para el sistema de ventanas &quot;X Window System&quot;, escrito en menos de 1200 lÃ­neas de cÃ³digo. Sus ventajas son que ordena y dimensiona las ventanas automÃ¡ticamente segÃºn varias reglas y criterios, que se pueden configurar e incluso &quot;programar&quot; por el usuario. La idea es que no haga falta el ratÃ³n para la gestiÃ³n de las ventanas. TambiÃ©n se considera muy estable, lo que viene por estar escrito en Haskell (dicen que te garantizan que es &quot;crash-free&quot;). Soporta los Ãºltimos estÃ¡ndares relacionados con el escritorio en Linux (incluyendo xinerama real, espacios de trabajo distintos para cada pantalla, bandeja del sistema) y es fÃ¡cilmente extensible. Por ejemplo, sigue los estÃ¡ndares de manera que puede usarse como gestor de ventanas de un escritorio completo como es KDE, sustituyendo a KWin de manera compatible.</p></li><li><p><b>snap</b>: Una completa infraestructura de desarrollo web que incluye un servidor web, librerÃ­as de apoyo y plantillas para HTML.</p></li><li><p><b>yesod</b>: La infraestructura de desarrollo web mÃ¡s avanzada de Haskell. Se la podrÃ­a comparar con Django o Rails. El servidor web que incluye (warp) es tan rÃ¡pido como nginx (y a veces incluso mÃ¡s rÃ¡pido en algunos benchmarks). Hace un uso intensivo de Template Haskell, lo que le permite validar en tiempo de compilaciÃ³n hasta el HTML, CSS y Javascript de las plantillas. TambiÃ©n incluye una librerÃ­a genÃ©rica de acceso a bases de datos, que se puede utilizar de manera aislada, sin necesidad de tener todo Yesod instalado.</p></li><li><p><b>dfsbuild</b>: Herramienta oficial de Debian para generar los discos de rescate llamados &quot;Debian From Scratch&quot;.</p></li><li><p><b>pugs</b>: Una implementaciÃ³n completa del lenguaje Perl 6 en Haskell. Con esto se demuestra que se puede utilizar para implementar otros lenguajes.</p></li></ul></article>


</div>
</div>
<div class="row article-footer"><div class="span7 meta"><span class="sociallinksunicode social">
<a href="https://twitter.com/home?status=$url$" target="_blank"><i class="icon-twitter"></i></a>&nbsp;
<a href="http://www.facebook.com/sharer/sharer.php?u=$url$" target="_blank"><i class="icon-facebook"></i></a>&nbsp;
<a href="https://plus.google.com/share?url=$url$" target="_blank"><i class="icon-google-plus"></i></a></span>
</div>
</div>
</div>
<div class="footer"><div class="container"><div class="row"><div class="span12"><ul class="menu"><li><a href="https://www.schoolofhaskell.com/">School</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user">Users</a>
</li>

<li><a class="brand" href="https://fpcomplete.com">Sponsored by:
<img src="/static/img/logo.png" title="FPComplete">
</a>
</li>
</ul>
</div>
</div>
<div class="row"><div class="span12"></div>
</div>
</div>
</div>
<link rel="stylesheet" type="text/css" href="/static/bootstrap/css/bootstrap-responsive.css" />
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script><script src="https://www.schoolofhaskell.com/static/combined/Y-3k9_tW.js"></script><script>$(function(){
  $("a.logout").click(function(){
    var form = $("<form method='post'/>");
    form.attr("action", $(this).attr("href"));
    $("body").append(form);
    form.submit();
    return false;
  });
});

$(function(){
    $('.sociallinksunicode a').each(function(){
        $(this).attr('href',$(this).attr('href').replace('$url$',document.location));
    });
});

$(function(){
  // If we need to select a user/select a password then show the
  // details confirmation form, otherwise enable the getting started
  // section.
  if($('.alert-block a').text().match(/(selected a username|change your password)/)) {
    $("#confirm-details").show();
    $("#confirm-details #inputUsername").focus();
  } else {
    $("#get-started").removeClass('disabled').addClass('enabled');
  }

  // For lack of a plain HTML validation story this will do.
  $('.welcome-page').each(function(){
    $('form').submit(check);
  });
  function check(){
    setTimeout(check,500);
    var error = false;
    $('.error').removeClass('error');
    $('#enter-details input').each(function(){
      if($(this).val() == '') {
        $(this).parent().parent().addClass('error');
        error = true;
      }
    });
    if(error) return false;
    if($('[name=password]').val() == $('[name=confirm]').val()) {
      $('#confirm').removeClass('error');
      return true;
    } else {
      $('#confirm').addClass('error');
      return false;
    }
  }
});

$(function(){
  // When scrolling over a snippet editor, activate the "clone in IDE" popovers
  $('article').each(function(){
    var n = 100;
    var wait = 10000;
    function check(){
      if($('.clone').length == 0) {
        setTimeout(check,n);
        return;
      }
      var activated = $.cookie('clone-popover');
      if (activated) return;
      var activate = false;
      $('.controlsRun:onScreen').each(function(){
        $.cookie('clone-popover', 'true', { expires: 30, path: '/' });
        activate = true;
        return false;
      });
      if(activate) {
          $('.clone').each(function(){
              // The bootstrap API is rather unreasonable to say the
              // least.
              next = $(this).parent();
              var title = next.attr('title');
              next.attr('data-content',$(this).attr('data-content'));
              next.attr('title',$(this).attr('title'));
              next.popover('show',{
                  title: $(this).attr('title')
              });
              next.attr('title',title);
          });
          setTimeout(function(){
              $('.clone').each(function(){
                  $(this).parent().popover('hide');
              });
          },wait);
      } else {
        setTimeout(check,n);
      }
    }
    setTimeout(check,n);
  });
});

// onScreen jQuery plugin v0.2.1
// (c) 2011-2013 Ben Pickles
//
// http://benpickles.github.com/onScreen
//
// Released under MIT license.
(function(a){a.expr[":"].onScreen=function(b){var c=a(window),d=c.scrollTop(),e=c.height(),f=d+e,g=a(b),h=g.offset().top,i=g.height(),j=h+i;return h>=d&&h<f||j>d&&j<=f||i>e&&h<=d&&j>=f}})(jQuery);

/*!
 * jQuery Cookie Plugin v1.1
 * https://github.com/carhartl/jquery-cookie
 *
 * Copyright 2011, Klaus Hartl
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.opensource.org/licenses/GPL-2.0
 */
(function($, document) {

  var pluses = /\+/g;
  function raw(s) {
    return s;
  }
  function decoded(s) {
    return decodeURIComponent(s.replace(pluses, ' '));
  }

  $.cookie = function(key, value, options) {

    // key and at least value given, set cookie...
    if (arguments.length > 1 && (!/Object/.test(Object.prototype.toString.call(value)) || value == null)) {
      options = $.extend({}, $.cookie.defaults, options);

      if (value == null) {
	options.expires = -1;
      }

      if (typeof options.expires === 'number') {
	var days = options.expires, t = options.expires = new Date();
	t.setDate(t.getDate() + days);
      }

      value = String(value);

      return (document.cookie = [
	encodeURIComponent(key), '=', options.raw ? value : encodeURIComponent(value),
	options.expires ? '; expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE
	options.path    ? '; path=' + options.path : '',
	options.domain  ? '; domain=' + options.domain : '',
	options.secure  ? '; secure' : ''
      ].join(''));
    }

    // key and possibly options given, get cookie...
    options = value || $.cookie.defaults || {};
    var decode = options.raw ? raw : decoded;
    var cookies = document.cookie.split('; ');
    for (var i = 0, parts; (parts = cookies[i] && cookies[i].split('=')); i++) {
      if (decode(parts.shift()) === key) {
	return decode(parts.join('='));
      }
    }
    return null;
  };
  $.cookie.defaults = {};})(jQuery, document);
</script><!--[if lt IE 10]><script src="https://www.schoolofhaskell.com/static/design/js/ie.js?etag=ayV2DuJ0"></script><![endif]--><script>if(!window.location.href.match(/localhost/)){var track = '/tutorial/user/mariopal/haskell-in-spanish-1';
window._gaq = [['_setAccount','UA-36928035-1'],track != ''? ['_trackPageview',track] : ['_trackPageview']
,['_trackPageLoadTime']];window._gaq.push(['_setCustomVar',1,'Section','School of Haskell',3]);
window._gaq.push(['_setCustomVar',2,'User Type','Visitor',1]);
(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);

})();}</script>
<!-- Prompt IE 6 users to install Chrome Frame. Remove this if you want to support IE 6.  chromium.org/developers/how-tos/chrome-frame-getting-started --><!--[if lt IE 7 ]><script src="//ajax.googleapis.com/ajax/libs/chrome-frame/1.0.3/CFInstall.min.js"></script><script>window.attachEvent('onload',function(){CFInstall.check({mode:'overlay'})})</script><![endif]--></body></html>