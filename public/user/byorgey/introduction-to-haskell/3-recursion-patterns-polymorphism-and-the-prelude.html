<!DOCTYPE html>
<html><head><title>3: Recursion Patterns, Polymorphism, and the Prelude - School of Haskell | School of Haskell</title><meta http-equiv="x-ua-compatible" content="IE=9"><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="google-site-verification" content="Rfxk2TdeMMXEXHgJ2_OO8Rt3hPbQSDao0OXQV_n6z_s" /><link href="//fonts.googleapis.com/css?family=Merriweather" rel="stylesheet" type="text/css"><link href="https://www.schoolofhaskell.com/recent-content/feed" type="application/rss+xml" rel="alternate" title="Recently published content">
<link rel="stylesheet" href="https://www.schoolofhaskell.com/static/combined/UlwEHVcM.css"><style>.social{margin-right:1em}h1{font-family:Merriweather !important}article{font-family:Merriweather !important}article li{font-family:Merriweather !important;line-height:1.6em}h1,h2,h3,h4,h4,h5{font-family:Merriweather !important}.editor p{font-family:Frutiger, "Frutiger Linotype", Univers, Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans Condensed", "Liberation Sans", "Nimbus Sans L", Tahoma, Geneva, "Helvetica Neue", Helvetica, Arial, sans-serif}.article-footer{border-top:1px solid #ddd;padding-top:1em;margin-top:1em}body{font-size:16px !important}.navbar .navbar-inner{background:#3c3f41}.navbar .brand{font-size:14px}.navbar .brand img{width:6em}.navbar .icon-wrench{margin:0 -0.5em 0 -0.5em;padding:0 1em 0 1em;height:20px}.navbar-inverse .nav .active a{background:#333638}.navbar-inverse .nav > li > a{color:#a7a7a7
}.navbar-inverse .btn-navbar{background:#333638}.navbar-inverse .nav > li a:hover,.navbar-inverse .btn{background:#333537 !important}@media (max-width: 979px) {.icon-wrench{padding-left:1em !important}}.breadcrumb{border-top-left-radius:0;border-top-right-radius:0}h1{margin-top:20px}.breadcrumb-container + .main-content h1{margin-top:0}.footer{padding:30px 0;margin-top:70px;border-top:1px solid #e5e5e5;background-color:#f5f5f5}.footer ul.footer-menu{list-style-type:none}.footer ul.footer-menu li{display:inline-block}.footer ul.footer-menu li + li{margin-left:0.5em}.footer ul.footer-menu li + li:before{margin-right:0.5em;content:"·";color:#999}.footer ul.menu li{display:inline-block}.footer ul.menu li + li{margin-left:0.5em}.footer .copyright{margin-left:25px}.main-content{min-height:100%}.gravatar{width:80px;height:80px;border-radius:2px;background:#eee}.empty-gravatar{width:0}.container{font-family:"Segoe UI", Candara, "Bitstream Vera Sans", "DejaVu Sans", "Bitstream Vera Sans", "Trebuchet MS", Verdana, "Verdana Ref", sans-serif}.container h1,.container h2,.container h4,.container h4,.container h5{font-family:"Segoe UI", Candara, "Bitstream Vera Sans", "DejaVu Sans", "Bitstream Vera Sans", "Trebuchet MS", Verdana, "Verdana Ref", sans-serif}article{font-family:Merriweather !important}article h1{font-family:Merriweather !important}article li{font-family:Merriweather !important;line-height:1.6em}article li + li{margin-top:0.5em}article div.code{background:#f9f9f9;border:1px solid #d1d1d1;position:relative;border-radius:0.2em;margin:0.25em 0 0.75em 0;min-height:2.5em}article code{color:#005580;font-size:14px;white-space:pre}article a.hoogle > code{color:#0088cc;font-size:14px;white-space:pre;border:0}article .expand-code{display:none}article pre{overflow:auto;word-wrap:normal}article code.active{display:block;max-height:430px}article h1{font-size:31.5px}article h3{font-size:17.5px}article h4{font-size:14px}article h5,article h6{font-size:11.9px}article p{line-height:1.7em}article h1 code,article h2 code,article h3 code,article h4 code,article h5 code,article h6 code{font-size:inherit !important}article h1 a,article h2 a,article h3 a,article h4 a,article h5 a,article h6 a{color:#444}article h1 a:before,article h2 a:before,article h3 a:before,article h4 a:before,article h5 a:before,article h6 a:before{margin-left:-1.5em;padding-right:0.5em;font-family:fontawesome;content:"\f0c1";font-size:20px;color:#fff}article h1 a:hover,article h2 a:hover,article h3 a:hover,article h4 a:hover,article h5 a:hover,article h6 a:hover{text-decoration:none;color:#0088cc}article h1 a:hover:before,article h2 a:hover:before,article h3 a:hover:before,article h4 a:hover:before,article h5 a:hover:before,article h6 a:hover:before{color:#888}article h2{font-size:24.5px}article .popover{font-family:actor}article .popover h3.popover-title{font-family:actor !important;font-size:1em}article .popover .popover-content{width:15em;font-size:1em}article .controlsRun{display:block;padding:0.5em;text-align:right;background:#f2f2f2}article .controlsRun a.clone{margin-right:1em;font-family:actor;text-decoration:none}article .controlsRun a.clone span{padding-left:0.5em}article .controlsRun a.run,article .controlsRun a.reset,article .controlsRun a.show-code{font-size:16px}article .controlsRun a.run span,article .controlsRun a.reset span,article .controlsRun a.show-code span{display:none}article .controlsRun a.reset{margin-left:0.5em;color:#a2becc}article .controlsRun a.reset{display:none}article .controlsRun a.show-code{margin-right:0.75em}article .controlsRun a.run:hover,article .controlsRun a.show-code:hover{text-decoration:none}article .controlsRun a.show-code.active{color:#DC0D0D}article .controlsRun a[disabled]{color:#a2becc;cursor:default}article .collapse-area .collapse-header{background:#0088cc;color:#fff;padding:0.3em;cursor:pointer}article .collapse-area .hidden-toggle:before{content:"\f0d7";font-family:fontawesome;margin-right:0.5em;margin-left:0.25em}article .collapse-area .collapsed-files{overflow:auto;height:auto}article .collapse-area.collapse-disabled{display:none}article .collapse-area.collapse-area-off .collapsed-files{height:0px;overflow:hidden}article .collapse-area.collapse-area-off .hidden-toggle:before{content:"\f0da"}article .snippet-stdio .stdout{margin:0.5em;padding-right:2em;position:relative;word-wrap:break-word}article .snippet-stdio .stdin{-webkit-box-shadow:none;-moz-box-shadow:none;box-shadow:none;-webkit-transition:none;-moz-transition:none;-o-transition:none;transition:none;padding:0;margin:0}article .hoogle-results{margin:0.25em}article .hoogle-results .hoogle-inner{background:#fff;padding:0.5em;border-radius:3px;border:1px solid #ddd}article .hoogle-results .hoogle-inner .close-link{position:relative;float:right;margin-top:-0.5em;margin-right:-0.5em}article .snippet-output-errors{margin:1em 0.5em 0.5em 0.5em;position:relative}article .snippet-output-errors ul{list-style-type:none;margin:0;position:relative}article .snippet-output-errors pre{border:0;border-radius:0;padding:0.25em;margin:0;background:inherit;color:inherit}article .snippet-output-errors .close-link{color:inherit;background:inherit}article .snippet-editors{z-index:0;padding:0.25em}article .close-link{padding:0.5em;background:#eaeaea;border-bottom-left-radius:0.2em;border-top-right-radius:0.2em;position:absolute;top:0;right:0}article .close-link:hover{text-decoration:none}article .snippet-title{padding:0.5em 0 0 0.5em}article .snippet-title .snippet-icon{font-family:FontAwesome;display:inline-block;margin-right:0.5em}article .fullModuleCode + div .snippet-title{margin-top:0.5em;border-top:1px solid #ccc;padding-top:0.5em}article .CodeMirror{height:auto;min-height:1em;line-height:1.5em;background:transparent;font-size:14px !important}article .CodeMirror .highlighted{background:rgba(250, 210, 0, 0.45) !important}article .CodeMirror-widget{margin-left:2em;line-height:1.8}article .CodeMirror.collapsed{height:10em !important}article .editor .expander{text-align:center;display:block;padding:0.5em;text-decoration:none;border-bottom-left-radius:2px;border-bottom-right-radius:2px}article .editor .expander .ellipsis{background:white;border:1px solid #ccc;padding:0 0.5em;height:1em;line-height:0.5em;display:inline-block;color:#555;cursor:pointer}article .editor .expander .ellipsis:hover{background:#ddd;color:#333}article .web-runner{margin:0.5em;padding:0.5em;border:1px solid #ccc;border-radius:3px;background:#f5f5f5}article .web-runner iframe{border:0;margin-top:0.5em;margin-bottom:0;background:white}article .web-runner .controls i{cursor:pointer;color:#0088cc}article .web-runner .controls i:hover{color:#222}article .web-runner .controls i + i{margin-left:0.5em}article .web-runner .controls .icon-remove{float:right}article .hidden{display:block;visibility:visible}article .controlsShowHide{margin-bottom:0.5em}.tutorial-body{float:left !important}.tutorial-nav{float:right !important}@media (max-width: 979px) {.related-content{float:right}.author-name{display:block;margin-left:20px !important;padding-left:5px;margin-top:5px}article h1 a:hover:before,article h2 a:hover:before,article h3 a:hover:before,article h4 a:hover:before,article h5 a:hover:before,article h6 a:hover:before{color:#fff}.tutorial-nav{float:none !important;width:auto !important}.tutorial-body{float:none !important;width:auto !important}}@media (min-width: 980px) and (max-width: 1199px) {.navbar-search{display:none}.tutorial-nav{width:200px}.tutorial-body{width:720px}}#accountPage h1{margin:20px 0 0 0}#accountPage h2{font-size:20px}.group-contents .span8{float:left}.group-contents .span4{float:right}.container > .alert-block{margin-top:1em}.alert{color:#aa874a
}.social{margin-bottom:.8em;display:block}.social a{text-decoration:none}.social i{font-size:1.1em;color:#fff;padding:0.25em;border-radius:0.25em;width:1em;display:inline-block;text-align:center}.social i.icon-twitter{background:#0088cc}.social i.icon-facebook{background:#3b5998
  }.social i.icon-google-plus{background:#dd4b39
  }.well pre{background:#fcfcfc}.well h2{margin-top:0}code{color:#005580;font-size:14px;white-space:pre}</style><!--[if lt IE 8]><link rel="stylesheet" href="https://www.schoolofhaskell.com/static/design/css/ie7.css?etag=TSMl9x1V"><![endif]--><!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]--></head><body class="not-logged-in" itemscope itemtype="http://schema.org/Product"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-H62P" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-H62P');</script><div class="navbar navbar-inverse navbar-static-top"><div class="navbar-inner"><div class="container"><a class="btn btn-navbar" type="button" data-toggle="collapse" data-target=".nav-collapse"><span class="icon-bar"></span>
<span class="icon-bar"></span>
<span class="icon-bar"></span>
</a>
<a class="brand" href="/"><img src="/static/img/haskell-logo-wide.png" title="School of Haskell">
</a>
<div class="nav-collapse collapse"><ul class="nav"><li><a href="https://www.schoolofhaskell.com/">School</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user">Users</a>
</li>
</ul>
<form class="navbar-search pull-left" action="https://www.schoolofhaskell.com/search"><input class="search-query" type="text" placeholder="Search" name="search">
</form>
</div>
</div>
</div>
</div>
<div class="container breadcrumb-container"><div class="row"><div class="span12"><ul class="breadcrumb"><li><a href="https://www.schoolofhaskell.com/user/byorgey">Brent Yorgey</a>
<span class="divider">/</span>
</li>
<li><a href="https://www.schoolofhaskell.com/user/byorgey/introduction-to-haskell">Introduction to Haskell</a>
<span class="divider">/</span>
</li>
<li><a href="https://www.schoolofhaskell.com/user/byorgey/introduction-to-haskell/3-recursion-patterns-polymorphism-and-the-prelude">3: Recursion Patterns, Polymorphism, and the Prelude</a>
</li>
</ul>
</div>
</div>
</div>
<div class="container main-content"><div class="row"><div class="span12"><h1 itemprop="name">3: Recursion Patterns, Polymorphism, and the Prelude</h1>
</div>
</div>
<div class="row"><div class="span7 meta"><p><span class="date">14 Jul 2014</span>
<span class="author"><a href="https://www.schoolofhaskell.com/user/byorgey">Brent Yorgey</a>
</span>
<span class="view-edit-link pull-right"><a class="view-source-link" href="https://www.schoolofhaskell.com/tutorial-raw/32/01a9a106cedd97428d3b8a2271f9da7cf1cad0bf">View Markdown source</a>
</span>
</p>
<p class="tags"></p>
</div>
</div>
<div class="row"><div class="span7 meta"><span class="sociallinksunicode social">
<a href="https://twitter.com/home?status=$url$" target="_blank"><i class="icon-twitter"></i></a>&nbsp;
<a href="http://www.facebook.com/sharer/sharer.php?u=$url$" target="_blank"><i class="icon-facebook"></i></a>&nbsp;
<a href="https://plus.google.com/share?url=$url$" target="_blank"><i class="icon-google-plus"></i></a></span>
</div>
</div>
<p class="alert">As of March 2020, School of Haskell has been switched to read-only mode.</p>
<div class="row" itemprop="desc"><div class="span4 tutorial-nav"><div class="related-content"><ul class="nav nav-tabs nav-stacked"><li><script>reddit_target='fpcomplete'</script>
<script src="https://redditstatic.s3.amazonaws.com/button/button1.js"></script>
</li>
<li><a href="https://www.schoolofhaskell.com/user/byorgey/introduction-to-haskell/2-algebraic-data-types">Previous content: 2: Algebraic Data Types</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user/byorgey/introduction-to-haskell/4-higher-order-programming-and-type-inference">Next content: 4: Higher-order programming and type inference</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user/byorgey/introduction-to-haskell">Go up to: Introduction to Haskell</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user/byorgey">See all content by Brent Yorgey</a>
</li>
</ul>

</div>
<div class="aside"><h3>Sections</h3>
<ul><li><a href="#recursion-patterns">Recursion Patterns</a><ul><li><a href="#map">Map</a></li><li><a href="#filter">Filter</a></li><li><a href="#fold">Fold</a></li></ul></li><li><a href="#polymorphism">Polymorphism</a><ul><li><a href="#polymorphic-data-types">Polymorphic data types</a></li></ul></li><li><a href="#polymorphic-functions">Polymorphic functions</a></li><li><a href="#the-prelude">The Prelude</a></li><li><a href="#total-and-partial-functions">Total and Partial Functions</a><ul><li><a href="#replacing-partial-functions">Replacing partial functions</a></li><li><a href="#writing-partial-functions">Writing partial functions</a></li></ul></li></ul></div>
</div>
<div class="span8 tutorial-body" data-environment="ghc-7.8-stable-14.09">
<article><p>At this point, you might think Haskell programmers spend most of their time writing recursive functions. In fact, they <i>hardly ever</i> do!</p><p>How is this possible? The key is to notice that although recursive functions can theoretically do pretty much anything, in practice there are certain common patterns that come up over and over again. By abstracting out these patterns into library functions, programmers can leave the low-level details of actually doing recursion to these functions, and think about problems at a higher level—that’s the goal of <i>wholemeal programming</i>.</p><h1 id="recursion-patterns"><a href="#recursion-patterns">Recursion Patterns</a></h1><p>Recall our simple definition of lists of <code>Int</code> values:</p><pre><code class="haskell">data IntList = Empty | Cons Int IntList
  deriving Show</code></pre><p>What sorts of things might we want to do with an <code>IntList</code>? Here are a few common possibilities:</p><ul><li>Perform some operation on every element of the list</li><li>Keep only some elements of the list, and throw others away, based on a test</li><li>&quot;Summarize&quot; the elements of the list somehow (find their sum, product, maximum...).</li><li>You can probably think of others!</li></ul><h2 id="map"><a href="#map">Map</a></h2><p>Let’s think about the first one (“perform some operation on every element of the list”). For example, we could add one to every element in a list:</p><pre><code class="active haskell">-- /show
data IntList = Empty | Cons Int IntList
  deriving Show
-- show
addOneToAll :: IntList -&gt; IntList
addOneToAll Empty = Empty
addOneToAll (Cons x xs) = Cons (x + 1) (addOneToAll xs)

myIntList = Cons 2 (Cons (-3) (Cons 5 Empty))

main = print (addOneToAll myIntList)</code></pre><p>Or we could ensure that every element in a list is nonnegative by taking the absolute value:</p><pre><code class="active haskell">-- /show
data IntList = Empty | Cons Int IntList
  deriving Show
-- show
absAll :: IntList -&gt; IntList
absAll Empty = Empty
absAll (Cons x xs) = Cons (abs x) (absAll xs)

myIntList = Cons 2 (Cons (-3) (Cons 5 Empty))

main = print (absAll myIntList)</code></pre><p>Or we could square every element:</p><pre><code class="active haskell">-- /show
data IntList = Empty | Cons Int IntList
  deriving Show
-- show
squareAll :: IntList -&gt; IntList
squareAll Empty = Empty
squareAll (Cons x xs) = Cons (x * x) (squareAll xs)

myIntList = Cons 2 (Cons (-3) (Cons 5 Empty))

main = print (squareAll myIntList)</code></pre><p>At this point, big flashing red lights and warning bells should be going off in your head. These three functions look way too similar. There ought to be some way to abstract out the commonality so we don’t have to repeat ourselves!</p><p>There is indeed a way—can you figure it out? Which parts are the same in all three examples and which
parts change?</p><p>The thing that changes, of course, is the operation we want to perform on each element of the list. We can specify this operation as a <i>function</i> of type <code>Int-&gt; Int</code>. Here is where we begin to see how incredibly useful it is to be able to pass functions as inputs to other functions!</p><pre><code class="haskell">-- /show
data IntList = Empty | Cons Int IntList
  deriving Show
-- show
mapIntList :: (Int -&gt; Int) -&gt; IntList -&gt; IntList
mapIntList _ Empty       = Empty
mapIntList f (Cons x xs) = Cons (f x) (mapIntList f xs)</code></pre><p>We can now use <code>mapIntList</code> to implement <code>addOneToAll</code>, <code>absAll</code>, and <code>squareAll</code>:</p><pre><code class="active haskell">-- /show
data IntList = Empty | Cons Int IntList
  deriving Show

mapIntList :: (Int -&gt; Int) -&gt; IntList -&gt; IntList
mapIntList _ Empty       = Empty
mapIntList f (Cons x xs) = Cons (f x) (mapIntList f xs)
-- show

addOne x = x + 1
square x = x * x

addOneToAll xs = mapIntList addOne xs

absAll xs = mapIntList abs xs

squareAll xs   = mapIntList square xs

myIntList = Cons 2 (Cons (-3) (Cons 5 Empty))

main = print (absAll myIntList)</code></pre><h2 id="filter"><a href="#filter">Filter</a></h2><p>Another common pattern is when we want to keep only some elements of a list, and throw others away,
based on a test. For example, we might want to keep only the even numbers:</p><pre><code class="active haskell">-- /show
data IntList = Empty | Cons Int IntList
  deriving Show
-- show
keepOnlyEven :: IntList -&gt; IntList
keepOnlyEven Empty = Empty
keepOnlyEven (Cons x xs) 
  | even x    = Cons x (keepOnlyEven xs)
  | otherwise = keepOnlyEven xs
  
myIntList = Cons 2 (Cons (-3) (Cons 5 Empty))

main = print (keepOnlyEven myIntList)</code></pre><p>How can we generalize this pattern? What stays the same, and what do we need to abstract out?
The thing to abstract out is the test (or predicate) used to determine which values to keep. A predicate is a
function of type <code>Int -&gt; Bool</code> which returns <code>True</code> for those elements which should be kept, and <code>False</code> for those which should be discarded. So we can write <code>filterIntList</code> as follows:</p><pre><code class="active haskell">-- /show
data IntList = Empty | Cons Int IntList
  deriving Show
-- show
filterIntList :: (Int -&gt; Bool) -&gt; IntList -&gt; IntList
filterIntList _ Empty = Empty
filterIntList p (Cons x xs)
  | p x       = Cons x (filterIntList p xs)
  | otherwise = filterIntList p xs

myIntList = Cons 2 (Cons (-3) (Cons 5 Empty))

main = print (filterIntList even myIntList)</code></pre><h2 id="fold"><a href="#fold">Fold</a></h2><p>The final pattern we mentioned was to “summarize” the elements of the list; this is also variously known as a “fold” or “reduce” operation. We’ll come back to this in the next lesson. In the meantime, you might want to think about how to abstract out this pattern!</p><h1 id="polymorphism"><a href="#polymorphism">Polymorphism</a></h1><p>We've now written some nice, general functions for mapping and filtering over lists of <code>Int</code>s. But we’re not done generalizing! What if we wanted to filter lists of <code>Integer</code>s? or <code>Bool</code>s? Or lists of lists of trees of stacks of <code>String</code>s? We’d have to make a new data type and a new function for each of these cases. Even worse, the code would be exactly the same; the only thing that would be different is the type signatures. Can’t Haskell help us out here?</p><p>Of course it can! Haskell supports polymorphism for both data types and functions. The word “polymorphic” comes from Greek (πολύμορφος) and means “having many forms”: something which is polymorphic works for multiple types.</p><h2 id="polymorphic-data-types"><a href="#polymorphic-data-types">Polymorphic data types</a></h2><p>First, let's see how to declare a polymorphic data type.</p><pre><code class="haskell">data List t = E | C t (List t)</code></pre><p>(using abbreviated forms of the previous <code>Empty</code> and <code>Cons</code> constructors)</p><p>Whereas before we had <code>data IntList = ...</code>, we now have <code>data List t = ...</code> The <code>t</code> is a type variable which can stand for any type. (Type variables must start with a lowercase letter, whereas types must start with uppercase.) <code>data List t = ...</code> means that the <code>List</code> type is parameterized by a type, in much the same way that a function can be parameterized by some input.</p><p>Given a type <code>t</code>, a <code>List t</code> consists of either the constructor <code>E</code>, or the constructor <code>C</code> along with a value of type <code>t</code> and another <code>List t</code>. Here are some examples:</p><pre><code class="haskell">lst1 :: List Int
lst1 = C 3 (C 5 (C 2 E))

lst2 :: List Char
lst2 = C 'x' (C 'y' (C 'z' E))

lst3 :: List Bool
lst3 = C True (C False E)</code></pre><h1 id="polymorphic-functions"><a href="#polymorphic-functions">Polymorphic functions</a></h1><p>Now, let’s generalize <code>filterIntList</code> to work over our new polymorphic <code>List</code>s. We can just take code of <code>filterIntList</code> and replace <code>Empty</code> by <code>E</code> and <code>Cons</code> by <code>C</code>:</p><pre><code class="active haskell">-- /show
data List t = E | C t (List t)
  deriving Show
-- show
filterList _ E = E
filterList p (C x xs)
  | p x       = C x (filterList p xs)
  | otherwise = filterList p xs
  
myList = C 2 (C (-3) (C 5 E))

main = print (filterList even myList)</code></pre><p>Now, what is the type of <code>filterList</code>? Let’s see what type GHCi infers for it:</p><pre><code class="haskell">*Main&gt; :t filterList
filterList :: (t -&gt; Bool) -&gt; List t -&gt; List t</code></pre><p>We can read this as: “for any type <code>t</code>, <code>filterList</code> takes a function from <code>t</code> to <code>Bool</code>, and a list of <code>t</code>s, and returns a list of <code>t</code>s.”</p><p>What about generalizing <code>mapIntList</code>? What type should we give to a function <code>mapList</code> that applies a
function to every element in a <code>List t</code>?</p><p>Our first idea might be to give it the type</p><pre><code class="haskell">mapList :: (t -&gt; t) -&gt; List t -&gt; List t</code></pre><p>This works, but it means that when applying <code>mapList</code>, we always get a list with the same type of elements as the list we started with. This is overly restrictive: we’d like to be able to do things like <code>mapList show</code> in order to convert, say, a list of <code>Int</code>s into a list of <code>String</code>s. Here, then, is the most general possible type for <code>mapList</code>, along with an implementation:</p><pre><code class="active haskell">-- /show
data List t = E | C t (List t)
  deriving Show
-- show
mapList :: (a -&gt; b) -&gt; List a -&gt; List b
mapList f (C x xs) = C (f x) (mapList f xs)
mapList f E        = E

myList = C 2 (C (-3) (C 5 E))

double x = 2 * x

main = print (mapList double myList)</code></pre><p>One important thing to remember about polymorphic functions is that <b>the caller gets to pick the types</b>.
When you write a polymorphic function, it must work for every possible input type. This—together with the
fact that Haskell has no way to directly make make decisions based on what type something is—has some
interesting implications which we’ll explore later.</p><h1 id="the-prelude"><a href="#the-prelude">The Prelude</a></h1><p>The <code>Prelude</code> is a module with a bunch of standard definitions that gets implicitly imported into every Haskell
program. It’s worth spending some time skimming through its documentation to familiarize oneself with
the tools that are available.</p><p>Of course, polymorphic lists are defined in the <code>Prelude</code>, along with <b>many useful polymorphic functions
for working with them</b>. For example, <code>filter</code> and <code>map</code> are the counterparts to our <code>filterList</code> and <code>mapList</code>. In fact, the <b><code>Data.List</code> module contains many more list functions still</b>.</p><p>Another useful polymorphic type to know is <code>Maybe</code>, defined as</p><pre><code class="haskell">data Maybe a = Nothing | Just a</code></pre><p>A value of type <code>Maybe a</code> either contains a value of type <code>a</code> (wrapped in the <code>Just</code> constructor), or it is <code>Nothing</code> (representing some sort of failure or error). <b>The <code>Data.Maybe</code> module has functions for working with <code>Maybe</code> values</b>.</p><h1 id="total-and-partial-functions"><a href="#total-and-partial-functions">Total and Partial Functions</a></h1><p>Consider the polymorphic type <code>[a] -&gt; a</code>.</p><p>What functions could have such a type? The type says that given a list of things of type <code>a</code>, the function must produce some value of type <code>a</code>. For example, the Prelude function <code>head</code> has this type.</p><p>...But what happens if <code>head</code> is given an empty list as input? The source code for <code>head</code> looks something like this:</p><pre><code class="active haskell">-- /show
import Prelude hiding (head)
-- show
head :: [a] -&gt; a
head (x:_) =  x
head []    =  error &quot;head&quot;

emptyStringList :: [String]
emptyStringList = []

main = print (head emptyStringList)</code></pre><p>It crashes! There’s nothing else it possibly could do, since it must work for <i>all</i> types. There’s no way to make
up an element of an arbitrary type out of thin air.</p><p><code>head</code> is what is known as a partial function: there are certain inputs for which <code>head</code> will crash. Functions which have certain inputs that will make them recurse infinitely are also called partial. Functions which are well-defined on <i>all</i> possible inputs are known as <i>total functions</i>.</p><p>It is good Haskell practice to avoid partial functions as much as possible. Actually, avoiding partial functions is good practice in <i>any</i> programming language—but in most of them it’s ridiculously annoying. Haskell tends to make it quite easy and sensible.</p><p><code>head</code> is a mistake! It should not be in the <code>Prelude</code>. Other partial <code>Prelude</code> functions you should almost never use include <code>tail</code>, <code>init</code>, <code>last</code>, and <code>(!!)</code>.</p><p>What to do instead?</p><h2 id="replacing-partial-functions"><a href="#replacing-partial-functions">Replacing partial functions</a></h2><p>Often partial functions like <code>head</code>, <code>tail</code>, and so on can be replaced by pattern-matching. Consider the following two definitions:</p><pre><code class="haskell">doStuff1 :: [Int] -&gt; Int
doStuff1 []  = 0
doStuff1 [_] = 0
doStuff1 xs  = head xs + head (tail xs)

doStuff2 :: [Int] -&gt; Int
doStuff2 []        = 0
doStuff2 [_]       = 0
doStuff2 (x1:x2:_) = x1 + x2</code></pre><p>These functions compute exactly the same result, and they are both total. But only the second one is
<i>obviously</i> total, and it is much easier to read anyway.</p><h2 id="writing-partial-functions"><a href="#writing-partial-functions">Writing partial functions</a></h2><p>What if you find yourself <i>writing</i> a partial function? There are two approaches to take. The first is to change the output type of the function to indicate the possible failure. Recall the definition of <code>Maybe</code>:</p><pre><code class="haskell">data Maybe a = Nothing | Just a</code></pre><p>Now, suppose we were writing <code>head</code>. We could rewrite it safely like this:</p><pre><code class="active haskell">-- /show
emptyStringList :: [String]
emptyStringList = []
-- show
safeHead :: [a] -&gt; Maybe a
safeHead []    = Nothing
safeHead (x:_) = Just x

main = print (safeHead emptyStringList, safeHead [&quot;hello&quot;])</code></pre><p>Indeed, there is exactly such a function defined in the <code>safe</code> package.</p><p>Why is this a good idea?</p><ol><li><code>safeHead</code> will never crash.</li><li>The type of <code>safeHead</code> makes it obvious that it may fail for some inputs.</li><li>The type system ensures that users of <code>safeHead</code> must appropriately check the return value of <code>safeHead</code> to see whether they got a value or <code>Nothing</code>.</li></ol><p>In some cases, <code>safeHead</code> is still &quot;partial&quot; but we have reflected the partiality in the type system, so it is now safe. The goal is to have the types tell us as much as possible about the behavior of functions.</p><p>OK, but what if we know that we will only use <code>head</code> in situations where we are guaranteed to have a non-empty list? In such a situation, it is really annoying to get back a <code>Maybe a</code>, since we have to expend effort dealing with a case which we “know” cannot actually happen.</p><p>The answer is that if some condition is really guaranteed, then the types ought to reflect the guarantee! Then the compiler can enforce your guarantees for you. For example:</p><pre><code class="haskell">data NonEmptyList a = NEL a [a]

nelToList :: NonEmptyList a -&gt; [a]
nelToList (NEL x xs) = x:xs

listToNEL :: [a] -&gt; Maybe (NonEmptyList a)
listToNEL []     = Nothing
listToNEL (x:xs) = Just (NEL x xs)

headNEL :: NonEmptyList a -&gt; a
headNEL (NEL x _) = x

tailNEL :: NonEmptyList a -&gt; [a]
tailNEL (NEL _ xs) = xs</code></pre><p>You might think doing such things is only for chumps who are not coding super-geniuses like you. Of course, you would never make a mistake like passing an empty list to a function which expects only non-empty ones. Right? Well, there’s definitely a chump involved, but it’s not who you think.</p></article>


</div>
</div>
<div class="row article-footer"><div class="span7 meta"><span class="sociallinksunicode social">
<a href="https://twitter.com/home?status=$url$" target="_blank"><i class="icon-twitter"></i></a>&nbsp;
<a href="http://www.facebook.com/sharer/sharer.php?u=$url$" target="_blank"><i class="icon-facebook"></i></a>&nbsp;
<a href="https://plus.google.com/share?url=$url$" target="_blank"><i class="icon-google-plus"></i></a></span>
</div>
</div>
</div>
<div class="footer"><div class="container"><div class="row"><div class="span12"><ul class="menu"><li><a href="https://www.schoolofhaskell.com/">School</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user">Users</a>
</li>

<li><a class="brand" href="https://fpcomplete.com">Sponsored by:
<img src="/static/img/logo.png" title="FPComplete">
</a>
</li>
</ul>
</div>
</div>
<div class="row"><div class="span12"></div>
</div>
</div>
</div>
<link rel="stylesheet" type="text/css" href="/static/bootstrap/css/bootstrap-responsive.css" />
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script><script src="https://www.schoolofhaskell.com/static/combined/Y-3k9_tW.js"></script><script>$(function(){
  $("a.logout").click(function(){
    var form = $("<form method='post'/>");
    form.attr("action", $(this).attr("href"));
    $("body").append(form);
    form.submit();
    return false;
  });
});

$(function(){
    $('.sociallinksunicode a').each(function(){
        $(this).attr('href',$(this).attr('href').replace('$url$',document.location));
    });
});

$(function(){
  // If we need to select a user/select a password then show the
  // details confirmation form, otherwise enable the getting started
  // section.
  if($('.alert-block a').text().match(/(selected a username|change your password)/)) {
    $("#confirm-details").show();
    $("#confirm-details #inputUsername").focus();
  } else {
    $("#get-started").removeClass('disabled').addClass('enabled');
  }

  // For lack of a plain HTML validation story this will do.
  $('.welcome-page').each(function(){
    $('form').submit(check);
  });
  function check(){
    setTimeout(check,500);
    var error = false;
    $('.error').removeClass('error');
    $('#enter-details input').each(function(){
      if($(this).val() == '') {
        $(this).parent().parent().addClass('error');
        error = true;
      }
    });
    if(error) return false;
    if($('[name=password]').val() == $('[name=confirm]').val()) {
      $('#confirm').removeClass('error');
      return true;
    } else {
      $('#confirm').addClass('error');
      return false;
    }
  }
});

$(function(){
  // When scrolling over a snippet editor, activate the "clone in IDE" popovers
  $('article').each(function(){
    var n = 100;
    var wait = 10000;
    function check(){
      if($('.clone').length == 0) {
        setTimeout(check,n);
        return;
      }
      var activated = $.cookie('clone-popover');
      if (activated) return;
      var activate = false;
      $('.controlsRun:onScreen').each(function(){
        $.cookie('clone-popover', 'true', { expires: 30, path: '/' });
        activate = true;
        return false;
      });
      if(activate) {
          $('.clone').each(function(){
              // The bootstrap API is rather unreasonable to say the
              // least.
              next = $(this).parent();
              var title = next.attr('title');
              next.attr('data-content',$(this).attr('data-content'));
              next.attr('title',$(this).attr('title'));
              next.popover('show',{
                  title: $(this).attr('title')
              });
              next.attr('title',title);
          });
          setTimeout(function(){
              $('.clone').each(function(){
                  $(this).parent().popover('hide');
              });
          },wait);
      } else {
        setTimeout(check,n);
      }
    }
    setTimeout(check,n);
  });
});

// onScreen jQuery plugin v0.2.1
// (c) 2011-2013 Ben Pickles
//
// http://benpickles.github.com/onScreen
//
// Released under MIT license.
(function(a){a.expr[":"].onScreen=function(b){var c=a(window),d=c.scrollTop(),e=c.height(),f=d+e,g=a(b),h=g.offset().top,i=g.height(),j=h+i;return h>=d&&h<f||j>d&&j<=f||i>e&&h<=d&&j>=f}})(jQuery);

/*!
 * jQuery Cookie Plugin v1.1
 * https://github.com/carhartl/jquery-cookie
 *
 * Copyright 2011, Klaus Hartl
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.opensource.org/licenses/GPL-2.0
 */
(function($, document) {

  var pluses = /\+/g;
  function raw(s) {
    return s;
  }
  function decoded(s) {
    return decodeURIComponent(s.replace(pluses, ' '));
  }

  $.cookie = function(key, value, options) {

    // key and at least value given, set cookie...
    if (arguments.length > 1 && (!/Object/.test(Object.prototype.toString.call(value)) || value == null)) {
      options = $.extend({}, $.cookie.defaults, options);

      if (value == null) {
	options.expires = -1;
      }

      if (typeof options.expires === 'number') {
	var days = options.expires, t = options.expires = new Date();
	t.setDate(t.getDate() + days);
      }

      value = String(value);

      return (document.cookie = [
	encodeURIComponent(key), '=', options.raw ? value : encodeURIComponent(value),
	options.expires ? '; expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE
	options.path    ? '; path=' + options.path : '',
	options.domain  ? '; domain=' + options.domain : '',
	options.secure  ? '; secure' : ''
      ].join(''));
    }

    // key and possibly options given, get cookie...
    options = value || $.cookie.defaults || {};
    var decode = options.raw ? raw : decoded;
    var cookies = document.cookie.split('; ');
    for (var i = 0, parts; (parts = cookies[i] && cookies[i].split('=')); i++) {
      if (decode(parts.shift()) === key) {
	return decode(parts.join('='));
      }
    }
    return null;
  };
  $.cookie.defaults = {};})(jQuery, document);
</script><!--[if lt IE 10]><script src="https://www.schoolofhaskell.com/static/design/js/ie.js?etag=ayV2DuJ0"></script><![endif]--><script>if(!window.location.href.match(/localhost/)){var track = '/tutorial/user/byorgey/introduction-to-haskell/3-recursion-patterns-polymorphism-and-the-prelude';
window._gaq = [['_setAccount','UA-36928035-1'],track != ''? ['_trackPageview',track] : ['_trackPageview']
,['_trackPageLoadTime']];window._gaq.push(['_setCustomVar',1,'Section','School of Haskell',3]);
window._gaq.push(['_setCustomVar',2,'User Type','Visitor',1]);
(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);

})();}</script>
<!-- Prompt IE 6 users to install Chrome Frame. Remove this if you want to support IE 6.  chromium.org/developers/how-tos/chrome-frame-getting-started --><!--[if lt IE 7 ]><script src="//ajax.googleapis.com/ajax/libs/chrome-frame/1.0.3/CFInstall.min.js"></script><script>window.attachEvent('onload',function(){CFInstall.check({mode:'overlay'})})</script><![endif]--></body></html>