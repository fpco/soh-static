<!DOCTYPE html>
<html><head><title>6: Laziness - School of Haskell | School of Haskell</title><meta http-equiv="x-ua-compatible" content="IE=9"><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="google-site-verification" content="Rfxk2TdeMMXEXHgJ2_OO8Rt3hPbQSDao0OXQV_n6z_s" /><link href="//fonts.googleapis.com/css?family=Merriweather" rel="stylesheet" type="text/css"><link href="https://www.schoolofhaskell.com/recent-content/feed" type="application/rss+xml" rel="alternate" title="Recently published content">
<link rel="stylesheet" href="https://www.schoolofhaskell.com/static/combined/UlwEHVcM.css"><style>.social{margin-right:1em}h1{font-family:Merriweather !important}article{font-family:Merriweather !important}article li{font-family:Merriweather !important;line-height:1.6em}h1,h2,h3,h4,h4,h5{font-family:Merriweather !important}.editor p{font-family:Frutiger, "Frutiger Linotype", Univers, Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans Condensed", "Liberation Sans", "Nimbus Sans L", Tahoma, Geneva, "Helvetica Neue", Helvetica, Arial, sans-serif}.article-footer{border-top:1px solid #ddd;padding-top:1em;margin-top:1em}body{font-size:16px !important}.navbar .navbar-inner{background:#3c3f41}.navbar .brand{font-size:14px}.navbar .brand img{width:6em}.navbar .icon-wrench{margin:0 -0.5em 0 -0.5em;padding:0 1em 0 1em;height:20px}.navbar-inverse .nav .active a{background:#333638}.navbar-inverse .nav > li > a{color:#a7a7a7
}.navbar-inverse .btn-navbar{background:#333638}.navbar-inverse .nav > li a:hover,.navbar-inverse .btn{background:#333537 !important}@media (max-width: 979px) {.icon-wrench{padding-left:1em !important}}.breadcrumb{border-top-left-radius:0;border-top-right-radius:0}h1{margin-top:20px}.breadcrumb-container + .main-content h1{margin-top:0}.footer{padding:30px 0;margin-top:70px;border-top:1px solid #e5e5e5;background-color:#f5f5f5}.footer ul.footer-menu{list-style-type:none}.footer ul.footer-menu li{display:inline-block}.footer ul.footer-menu li + li{margin-left:0.5em}.footer ul.footer-menu li + li:before{margin-right:0.5em;content:"Â·";color:#999}.footer ul.menu li{display:inline-block}.footer ul.menu li + li{margin-left:0.5em}.footer .copyright{margin-left:25px}.main-content{min-height:100%}.gravatar{width:80px;height:80px;border-radius:2px;background:#eee}.empty-gravatar{width:0}.container{font-family:"Segoe UI", Candara, "Bitstream Vera Sans", "DejaVu Sans", "Bitstream Vera Sans", "Trebuchet MS", Verdana, "Verdana Ref", sans-serif}.container h1,.container h2,.container h4,.container h4,.container h5{font-family:"Segoe UI", Candara, "Bitstream Vera Sans", "DejaVu Sans", "Bitstream Vera Sans", "Trebuchet MS", Verdana, "Verdana Ref", sans-serif}article{font-family:Merriweather !important}article h1{font-family:Merriweather !important}article li{font-family:Merriweather !important;line-height:1.6em}article li + li{margin-top:0.5em}article div.code{background:#f9f9f9;border:1px solid #d1d1d1;position:relative;border-radius:0.2em;margin:0.25em 0 0.75em 0;min-height:2.5em}article code{color:#005580;font-size:14px;white-space:pre}article a.hoogle > code{color:#0088cc;font-size:14px;white-space:pre;border:0}article .expand-code{display:none}article pre{overflow:auto;word-wrap:normal}article code.active{display:block;max-height:430px}article h1{font-size:31.5px}article h3{font-size:17.5px}article h4{font-size:14px}article h5,article h6{font-size:11.9px}article p{line-height:1.7em}article h1 code,article h2 code,article h3 code,article h4 code,article h5 code,article h6 code{font-size:inherit !important}article h1 a,article h2 a,article h3 a,article h4 a,article h5 a,article h6 a{color:#444}article h1 a:before,article h2 a:before,article h3 a:before,article h4 a:before,article h5 a:before,article h6 a:before{margin-left:-1.5em;padding-right:0.5em;font-family:fontawesome;content:"\f0c1";font-size:20px;color:#fff}article h1 a:hover,article h2 a:hover,article h3 a:hover,article h4 a:hover,article h5 a:hover,article h6 a:hover{text-decoration:none;color:#0088cc}article h1 a:hover:before,article h2 a:hover:before,article h3 a:hover:before,article h4 a:hover:before,article h5 a:hover:before,article h6 a:hover:before{color:#888}article h2{font-size:24.5px}article .popover{font-family:actor}article .popover h3.popover-title{font-family:actor !important;font-size:1em}article .popover .popover-content{width:15em;font-size:1em}article .controlsRun{display:block;padding:0.5em;text-align:right;background:#f2f2f2}article .controlsRun a.clone{margin-right:1em;font-family:actor;text-decoration:none}article .controlsRun a.clone span{padding-left:0.5em}article .controlsRun a.run,article .controlsRun a.reset,article .controlsRun a.show-code{font-size:16px}article .controlsRun a.run span,article .controlsRun a.reset span,article .controlsRun a.show-code span{display:none}article .controlsRun a.reset{margin-left:0.5em;color:#a2becc}article .controlsRun a.reset{display:none}article .controlsRun a.show-code{margin-right:0.75em}article .controlsRun a.run:hover,article .controlsRun a.show-code:hover{text-decoration:none}article .controlsRun a.show-code.active{color:#DC0D0D}article .controlsRun a[disabled]{color:#a2becc;cursor:default}article .collapse-area .collapse-header{background:#0088cc;color:#fff;padding:0.3em;cursor:pointer}article .collapse-area .hidden-toggle:before{content:"\f0d7";font-family:fontawesome;margin-right:0.5em;margin-left:0.25em}article .collapse-area .collapsed-files{overflow:auto;height:auto}article .collapse-area.collapse-disabled{display:none}article .collapse-area.collapse-area-off .collapsed-files{height:0px;overflow:hidden}article .collapse-area.collapse-area-off .hidden-toggle:before{content:"\f0da"}article .snippet-stdio .stdout{margin:0.5em;padding-right:2em;position:relative;word-wrap:break-word}article .snippet-stdio .stdin{-webkit-box-shadow:none;-moz-box-shadow:none;box-shadow:none;-webkit-transition:none;-moz-transition:none;-o-transition:none;transition:none;padding:0;margin:0}article .hoogle-results{margin:0.25em}article .hoogle-results .hoogle-inner{background:#fff;padding:0.5em;border-radius:3px;border:1px solid #ddd}article .hoogle-results .hoogle-inner .close-link{position:relative;float:right;margin-top:-0.5em;margin-right:-0.5em}article .snippet-output-errors{margin:1em 0.5em 0.5em 0.5em;position:relative}article .snippet-output-errors ul{list-style-type:none;margin:0;position:relative}article .snippet-output-errors pre{border:0;border-radius:0;padding:0.25em;margin:0;background:inherit;color:inherit}article .snippet-output-errors .close-link{color:inherit;background:inherit}article .snippet-editors{z-index:0;padding:0.25em}article .close-link{padding:0.5em;background:#eaeaea;border-bottom-left-radius:0.2em;border-top-right-radius:0.2em;position:absolute;top:0;right:0}article .close-link:hover{text-decoration:none}article .snippet-title{padding:0.5em 0 0 0.5em}article .snippet-title .snippet-icon{font-family:FontAwesome;display:inline-block;margin-right:0.5em}article .fullModuleCode + div .snippet-title{margin-top:0.5em;border-top:1px solid #ccc;padding-top:0.5em}article .CodeMirror{height:auto;min-height:1em;line-height:1.5em;background:transparent;font-size:14px !important}article .CodeMirror .highlighted{background:rgba(250, 210, 0, 0.45) !important}article .CodeMirror-widget{margin-left:2em;line-height:1.8}article .CodeMirror.collapsed{height:10em !important}article .editor .expander{text-align:center;display:block;padding:0.5em;text-decoration:none;border-bottom-left-radius:2px;border-bottom-right-radius:2px}article .editor .expander .ellipsis{background:white;border:1px solid #ccc;padding:0 0.5em;height:1em;line-height:0.5em;display:inline-block;color:#555;cursor:pointer}article .editor .expander .ellipsis:hover{background:#ddd;color:#333}article .web-runner{margin:0.5em;padding:0.5em;border:1px solid #ccc;border-radius:3px;background:#f5f5f5}article .web-runner iframe{border:0;margin-top:0.5em;margin-bottom:0;background:white}article .web-runner .controls i{cursor:pointer;color:#0088cc}article .web-runner .controls i:hover{color:#222}article .web-runner .controls i + i{margin-left:0.5em}article .web-runner .controls .icon-remove{float:right}article .hidden{display:block;visibility:visible}article .controlsShowHide{margin-bottom:0.5em}.tutorial-body{float:left !important}.tutorial-nav{float:right !important}@media (max-width: 979px) {.related-content{float:right}.author-name{display:block;margin-left:20px !important;padding-left:5px;margin-top:5px}article h1 a:hover:before,article h2 a:hover:before,article h3 a:hover:before,article h4 a:hover:before,article h5 a:hover:before,article h6 a:hover:before{color:#fff}.tutorial-nav{float:none !important;width:auto !important}.tutorial-body{float:none !important;width:auto !important}}@media (min-width: 980px) and (max-width: 1199px) {.navbar-search{display:none}.tutorial-nav{width:200px}.tutorial-body{width:720px}}#accountPage h1{margin:20px 0 0 0}#accountPage h2{font-size:20px}.group-contents .span8{float:left}.group-contents .span4{float:right}.container > .alert-block{margin-top:1em}.alert{color:#aa874a
}.social{margin-bottom:.8em;display:block}.social a{text-decoration:none}.social i{font-size:1.1em;color:#fff;padding:0.25em;border-radius:0.25em;width:1em;display:inline-block;text-align:center}.social i.icon-twitter{background:#0088cc}.social i.icon-facebook{background:#3b5998
  }.social i.icon-google-plus{background:#dd4b39
  }.well pre{background:#fcfcfc}.well h2{margin-top:0}code{color:#005580;font-size:14px;white-space:pre}</style><!--[if lt IE 8]><link rel="stylesheet" href="https://www.schoolofhaskell.com/static/design/css/ie7.css?etag=TSMl9x1V"><![endif]--><!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]--></head><body class="not-logged-in" itemscope itemtype="http://schema.org/Product"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-H62P" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-H62P');</script><div class="navbar navbar-inverse navbar-static-top"><div class="navbar-inner"><div class="container"><a class="btn btn-navbar" type="button" data-toggle="collapse" data-target=".nav-collapse"><span class="icon-bar"></span>
<span class="icon-bar"></span>
<span class="icon-bar"></span>
</a>
<a class="brand" href="/"><img src="/static/img/haskell-logo-wide.png" title="School of Haskell">
</a>
<div class="nav-collapse collapse"><ul class="nav"><li><a href="https://www.schoolofhaskell.com/">School</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user">Users</a>
</li>
</ul>
<form class="navbar-search pull-left" action="https://www.schoolofhaskell.com/search"><input class="search-query" type="text" placeholder="Search" name="search">
</form>
</div>
</div>
</div>
</div>
<div class="container breadcrumb-container"><div class="row"><div class="span12"><ul class="breadcrumb"><li><a href="https://www.schoolofhaskell.com/user/byorgey">Brent Yorgey</a>
<span class="divider">/</span>
</li>
<li><a href="https://www.schoolofhaskell.com/user/byorgey/introduction-to-haskell">Introduction to Haskell</a>
<span class="divider">/</span>
</li>
<li><a href="https://www.schoolofhaskell.com/user/byorgey/introduction-to-haskell/6-laziness">6: Laziness</a>
</li>
</ul>
</div>
</div>
</div>
<div class="container main-content"><div class="row"><div class="span12"><h1 itemprop="name">6: Laziness</h1>
</div>
</div>
<div class="row"><div class="span7 meta"><p><span class="date"> 8 Nov 2013</span>
<span class="author"><a href="https://www.schoolofhaskell.com/user/byorgey">Brent Yorgey</a>
</span>
<span class="view-edit-link pull-right"><a class="view-source-link" href="https://www.schoolofhaskell.com/tutorial-raw/32/3a6442c77a3bf88590ed56b610883e75e313295c">View Markdown source</a>
</span>
</p>
<p class="tags"></p>
</div>
</div>
<div class="row"><div class="span7 meta"><span class="sociallinksunicode social">
<a href="https://twitter.com/home?status=$url$" target="_blank"><i class="icon-twitter"></i></a>&nbsp;
<a href="http://www.facebook.com/sharer/sharer.php?u=$url$" target="_blank"><i class="icon-facebook"></i></a>&nbsp;
<a href="https://plus.google.com/share?url=$url$" target="_blank"><i class="icon-google-plus"></i></a></span>
</div>
</div>
<p class="alert">As of March 2020, School of Haskell has been switched to read-only mode.</p>
<div class="row" itemprop="desc"><div class="span4 tutorial-nav"><div class="related-content"><ul class="nav nav-tabs nav-stacked"><li><script>reddit_target='fpcomplete'</script>
<script src="https://redditstatic.s3.amazonaws.com/button/button1.js"></script>
</li>
<li><a href="https://www.schoolofhaskell.com/user/byorgey/introduction-to-haskell/5-type-classes">Previous content: 5: Type Classes</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user/byorgey/introduction-to-haskell">Go up to: Introduction to Haskell</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user/byorgey">See all content by Brent Yorgey</a>
</li>
</ul>

</div>
<div class="aside"><h3>Sections</h3>
<ul><li><a href="#strict-evaluation">Strict evaluation</a></li><li><a href="#side-effects-and-purity">Side effects and purity</a></li><li><a href="#lazy-evaluation">Lazy evaluation</a></li><li><a href="#pattern-matching-drives-evaluation">Pattern matching drives evaluation</a></li><li><a href="#consequences">Consequences</a></li></ul></div>
</div>
<div class="span8 tutorial-body" data-environment="ghc-7.8-stable-14.09">
<article><p>Suggested reading:</p><ul><li><p><a href="http://haskell.org/haskellwiki/Foldr_Foldl_Foldl'">foldr foldl foldl'</a> from the Haskell wiki</p></li></ul><p>In the first lesson, I mentioned that Haskell is <i>lazy</i>, and
promised to eventually explain in more detail what this means.  The
time has come!</p><h2 id="strict-evaluation"><a href="#strict-evaluation">Strict evaluation</a></h2><p>Before we talk about <i>lazy evaluation</i> it will be useful to look at
some examples of its opposite, <i>strict evaluation</i>.</p><p>Under a strict evaluation strategy, function arguments are completely
evaluated <i>before</i> passing them to the function. For example, suppose
we have defined</p><pre><code class="haskell">f x y = x + 2</code></pre><p>In a strict language, evaluating <code>f 5 (29^35792)</code> will first
completely evaluate <code>5</code> (already done) and <code>29^35792</code> (which is a lot
of work) before passing the results to <code>f</code>.</p><p>Of course, in this <i>particular</i> example, this is silly, since <code>f</code>
ignores its second argument, so all the work to compute <code>29^35792</code> was
wasted.  So why would we want this?</p><p>The benefit of strict evaluation is that it is easy to predict <i>when</i>
and <i>in what order</i> things will happen.  Usually languages with
strict evaluation will even specify the order in which function
arguments should be evaluated (<i>e.g.</i> from left to right).</p><p>For example, in Java if we write</p><pre><code>f (release_monkeys(), increment_counter())</code></pre><p>we know that the monkeys will be released, and then the counter will
be incremented, and then the results of doing those things will be
passed to <code>f</code>, and it does not matter whether <code>f</code> actually ends up
using those results.</p><p>If the releasing of monkeys and incrementing of the counter could
independently happen, or not, in either order, depending on whether
<code>f</code> happens to use their results, it would be extremely
confusing. When such &quot;side effects&quot; are allowed, strict evaluation is
really what you want.</p><h2 id="side-effects-and-purity"><a href="#side-effects-and-purity">Side effects and purity</a></h2><p>So, what's really at issue here is the presence or absence of <i>side
effects</i>.  By &quot;side effect&quot; we mean <i>anything that causes evaluation
of an expression to interact with something outside itself</i>.  The root
issue is that such outside interactions are time-sensitive.  For
example:</p><ul><li>Modifying a global variable â it matters when this happens since
it may affect the evaluation of other expressions</li><li>Printing to the screen â it matters when this happens since it may
need to be in a certain order with respect to other writes to the
screen</li><li>Reading from a file or the network â it matters when this happens
since the contents of the file can affect the outcome of the
expression</li></ul><p>As we have seen, lazy evaluation makes it hard to reason about when
things will be evaluated; hence including side effects in a lazy
language would be extremely unintuitive. Historically, this is the
reason Haskell is pure: initially, the designers of Haskell wanted to
make a <i>lazy</i> functional language, and quickly realized it would be
impossible unless it also disallowed side effects.</p><p>But... a language with <i>no</i> side effects would not be very useful.
The only thing you could do with such a language would be to load up
your programs in an interpreter and evaluate expressions. (Hmm... that
sounds familiar...) You would not be able to get any input from the
user, or print anything to the screen, or read from a file.  The
challenge facing the Haskell designers was to come up with a way to
allow such effects in a principled, restricted way that did not
interfere with the essential purity of the language.  They finally did
come up with something (namely, the <code>IO</code> monad) which we'll talk about
in a few weeks.</p><h2 id="lazy-evaluation"><a href="#lazy-evaluation">Lazy evaluation</a></h2><p><img alt="relax" src="https://www.schoolofhaskell.com/content-proxy?src=http%3A%2F%2Fwww.cis.upenn.edu%2F~cis194%2Fstatic%2Frelax.jpg" /></p><p>So now that we understand strict evaluation, let's see what lazy
evaluation actually looks like. Under a lazy evaluation strategy,
evaluation of function arguments is <i>delayed as long as possible</i>:
they are not evaluated until it actually becomes necessary to do so.
When some expression is given as an argument to a function, it is
simply packaged up as an <i>unevaluated expression</i> (called a &quot;thunk&quot;,
don't ask me why) without doing any actual work.</p><p>For example, when evaluating <code>f 5 (29^35792)</code>, the second argument
will simply be packaged up into a thunk without doing any actual
computation, and <code>f</code> will be called immediately.  Since <code>f</code> never uses
its second argument the thunk will just be thrown away by the garbage
collector.</p><h2 id="pattern-matching-drives-evaluation"><a href="#pattern-matching-drives-evaluation">Pattern matching drives evaluation</a></h2><p>So, when is it &quot;necessary&quot; to evaluate an expression? The examples
above concentrated on whether a function <i>used</i> its arguments, but
this is actually not the most important distinction. Consider the
following examples:</p><pre><code class="haskell">f1 :: Maybe a -&gt; [Maybe a]
f1 m = [m,m]

f2 :: Maybe a -&gt; [a]
f2 Nothing  = []
f2 (Just x) = [x]</code></pre><p><code>f1</code> and <code>f2</code> both <i>use</i> their argument.  But there is still a big
difference between them.  Although <code>f1</code> uses its argument <code>m</code>, it does
not need to know anything about it.  <code>m</code> can remain completely
unevaluated, and the unevaluated expression is simply put in a list.
Put another way, the result of <code>f1 e</code> does not depend on the shape of
<code>e</code>.</p><p><code>f2</code>, on the other hand, needs to know something about its argument in
order to proceed: was it constructed with <code>Nothing</code> or <code>Just</code>?  That
is, in order to evaluate <code>f2 e</code>, we must first evaluate <code>e</code>, because
the result of <code>f2</code> depends on the shape of <code>e</code>.</p><p>The other important thing to note is that thunks are evaluated <i>only
enough</i> to allow a pattern match to proceed, and no further!  For
example, suppose we wanted to evaluate <code>f2 (safeHead [3^500, 49])</code>.
<code>f2</code> would force evaluation of the call to <code>safeHead [3^500, 49]</code>,
which would evaluate to <code>Just (3^500)</code>---note that the <code>3^500</code> is
<i>not</i> evaluated, since <code>safeHead</code> does not need to look at it, and
neither does <code>f2</code>.  Whether the <code>3^500</code> gets evaluated later depends
on how the result of <code>f2</code> is used.</p><p>The slogan to remember is &quot;<i>pattern matching drives evaluation</i>&quot;.  To
reiterate the important points:</p><ul><li><p>Expressions are only evaluated when pattern-matched</p></li><li><p>...only as far as necessary for the match to proceed, and no farther!</p></li></ul><p>Let's do a slightly more interesting example: we'll evaluate <code>take 3 (repeat 7)</code>.  For reference, here are the definitions of <code>repeat</code> and
<code>take</code>:</p><pre><code class="haskell">repeat :: a -&gt; [a]
repeat x = x : repeat x

take :: Int -&gt; [a] -&gt; [a]
take n _      | n &lt;= 0 =  []
take _ []              =  []
take n (x:xs)          =  x : take (n-1) xs</code></pre><p>Carrying out the evaluation step-by-step looks something like this:</p><pre><code class="haskell">      take 3 (repeat 7)
          { 3 &lt;= 0 is False, so we proceed to the second clause, which
        needs to match on the second argument. So we must expand
        repeat 7 one step. }
    = take 3 (7 : repeat 7)
          { the second clause does not match but the third clause
            does. Note that (3-1) does not get evaluated yet! }
    = 7 : take (3-1) (repeat 7)
          { In order to decide on the first clause, we must test (3-1)
            &lt;= 0 which requires evaluating (3-1). }
    = 7 : take 2 (repeat 7)
          { 2 &lt;= 0 is False, so we must expand repeat 7 again. }
    = 7 : take 2 (7 : repeat 7)
          { The rest is similar. }
    = 7 : 7 : take (2-1) (repeat 7)
    = 7 : 7 : take 1 (repeat 7)
    = 7 : 7 : take 1 (7 : repeat 7)
    = 7 : 7 : 7 : take (1-1) (repeat 7)
    = 7 : 7 : 7 : take 0 (repeat 7)
    = 7 : 7 : 7 : []</code></pre><p>(Note that although evaluation <i>could</i> be implemented exactly like the
above, most Haskell compilers will do something a bit more
sophisticated.  In particular, GHC uses a technique called <i>graph
reduction</i>, where the expression being evaluated is actually
represented as a <i>graph</i>, so that different parts of the expression
can share pointers to the same subexpression.  This ensures that work
is not duplicated unnecessarily.  For example, if <code>f x = [x,x]</code>,
evaluating <code>f (1+1)</code> will only do <i>one</i> addition, because the
subexpression <code>1+1</code> will be shared between the two occurrences of
<code>x</code>.)</p><h2 id="consequences"><a href="#consequences">Consequences</a></h2><p>Laziness has some very interesting, pervasive, and nonobvious
consequences.  Let's explore a few of them.</p><p><b>Purity</b></p><p>As we've already seen, choosing a lazy evaluation strategy essentially
<i>forces</i> you to also choose purity (assuming you don't want
programmers to go insane).</p><p><b>Understanding space usage</b></p><p>Laziness is not all roses.  One of the downsides is that it sometimes
becomes tricky to reason about the space usage of your programs.
Consider the following (innocuous-seeming) example:</p><pre><code class="haskell">-- Standard library function foldl, provided for reference
foldl :: (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; b
foldl _ z []     = z
foldl f z (x:xs) = foldl f (f z x) xs</code></pre><p>Let's consider how evaluation proceeds when we evaluate <code>foldl (+) 0 [1,2,3]</code> (which sums the numbers in a list):</p><pre><code class="haskell">      foldl (+) 0 [1,2,3]
    = foldl (+) (0+1) [2,3]
    = foldl (+) ((0+1)+2) [3]
    = foldl (+) (((0+1)+2)+3) []
    = (((0+1)+2)+3)
    = ((1+2)+3)
    = (3+3)
    = 6</code></pre><p>Since the value of the accumulator is not demanded until recursing
through the entire list, the accumulator simply builds up a big
unevaluated expression <code>(((0+1)+2)+3)</code>, which finally gets reduced to
a value at the end.  There are at least two problems with this.  One
is that it's simply inefficient: there's no point in transferring all
the numbers from the list into a different list-like thing (the
accumulator thunk) before actually adding them up.  The second problem
is more subtle, and more insidious: evaluating the expression
<code>(((0+1)+2)+3)</code> actually requires pushing the <code>3</code> and <code>2</code> onto a stack
before being able to compute <code>0+1</code> and then unwinding the stack,
adding along the way. This is not a problem for this small example,
but for very long lists it's a big problem: there is usually not as
much space available for the stack, so this can lead to a stack
overflow.</p><p>The solution in this case is to use the <code>foldl'</code> function instead of
<code>foldl</code>, which adds a bit of strictness: in particular, <code>foldl'</code>
requires its second argument (the accumulator) to be evaluated before
it proceeds, so a large thunk never builds up:</p><pre><code class="haskell">      foldl' (+) 0 [1,2,3]
    = foldl' (+) (0+1) [2,3]
    = foldl' (+) 1 [2,3]
    = foldl' (+) (1+2) [3]
    = foldl' (+) 3 [3]
    = foldl' (+) (3+3) []
    = foldl' (+) 6 []
    = 6</code></pre><p>As you can see, <code>foldl'</code> does the additions along the way, which is
what we really want.  But the point is that in this case laziness got
in the way and we had to make our program <i>less</i> lazy.</p><p>(If you're interested in learning about <i>how</i> <code>foldl'</code> achieves this,
you can
<a href="http://www.haskell.org/haskellwiki/Seq">read about <code>seq</code> on the Haskell wiki</a>.)</p><p><b>Short-circuiting operators</b></p><p>In some languages (Java, C++) the boolean operators <code>&amp;&amp;</code> and <code>||</code>
(logical AND and OR) are <i>short-circuiting</i>: for example, if the first
argument to <code>&amp;&amp;</code> evaluates to false, the whole expression will
immediately evaluate to false without touching the second argument.
However, this behavior has to be wired into the Java and C++ language
standards as a special case. Normally, in a strict langauge, both
arguments of a two-argument function are be evaluated before calling
the function.  So the short-circuiting behavior of <code>&amp;&amp;</code> and <code>||</code> is a
special exception to the usual strict semantics of the language.</p><p>In Haskell, however, we can define short-circuiting operators without
any special cases.  In fact, <code>(&amp;&amp;)</code> and <code>(||)</code> are just plan old
library functions!  For example, here's how <code>(&amp;&amp;)</code> is defined:</p><pre><code class="haskell">(&amp;&amp;) :: Bool -&gt; Bool -&gt; Bool
True  &amp;&amp; x = x
False &amp;&amp; _ = False</code></pre><p>Notice how this definition of <code>(&amp;&amp;)</code> does not pattern-match on its
second argument.  Moreover, if the first argument is <code>False</code>, the
second argument is entirely ignored. Since <code>(&amp;&amp;)</code> does not
pattern-match on its second argument at all, it is short-circuiting in
exactly the same way as the <code>&amp;&amp;</code> operator in Java or C++.</p><p>Notice that <code>(&amp;&amp;)</code> also could have been defined like this:</p><pre><code class="haskell">(&amp;&amp;!) :: Bool -&gt; Bool -&gt; Bool
True  &amp;&amp;! True  = True
True  &amp;&amp;! False = False
False &amp;&amp;! True  = False
False &amp;&amp;! False = False</code></pre><p>While this version takes on the same values as <code>(&amp;&amp;)</code>, it has
different behavior.  For example, consider the following:</p><pre><code class="active haskell">(&amp;&amp;!) :: Bool -&gt; Bool -&gt; Bool
True  &amp;&amp;! True  = True
True  &amp;&amp;! False = False
False &amp;&amp;! True  = False
False &amp;&amp;! False = False

-- show
main = print (False &amp;&amp;  (34^9784346 &gt; 34987345))</code></pre><p>Changing <code>(&amp;&amp;)</code> to <code>(&amp;&amp;')</code> produces the same result, but just takes a lot longer!  Or how about this:</p><pre><code class="active haskell">(&amp;&amp;!) :: Bool -&gt; Bool -&gt; Bool
True  &amp;&amp;! True  = True
True  &amp;&amp;! False = False
False &amp;&amp;! True  = False
False &amp;&amp;! False = False

-- show
main = print (False &amp;&amp;  (head [] == 'x'))</code></pre><p>This prints <code>False</code>, but if <code>(&amp;&amp;)</code> is replaced with <code>(&amp;&amp;')</code>, the program will crash.
Try it!</p><p>All of this points out that there are some interesting issues
surrounding laziness to be considered when defining a function.</p><p><b>User-defined control structures</b></p><p>Taking the idea of short-circuiting operators one step further, in
Haskell we can define our own <i>control structures</i>.</p><p>Most languages have some sort of special built-in <code>if</code> construct.
Some thought reveals why: in a way similar to short-circuiting Boolean
operators, <code>if</code> has special behavior.  Based on the value of the test,
it executes/evaluates only <i>one</i> of the two branches.  It would defeat
the whole purpose if both branches were evaluated every time!</p><p>In Haskell, however, we can define <code>if</code> as a library function!</p><pre><code class="active haskell">if' :: Bool -&gt; a -&gt; a -&gt; a
if' True  x _ = x
if' False _ y = y

result = if' (3 &lt; 5) &quot;yes&quot; &quot;no&quot;

main = print result</code></pre><p>Of course, Haskell <i>does</i> have special built-in <code>if</code>-expressions, but
I have never quite understood why.  Perhaps it is simply because the
language designers thought people would expect it.  &quot;What do you mean,
this language doesn't have <code>if</code>!?&quot;  In any case, <code>if</code> doesn't get used
that much in Haskell anyway; in most situations we prefer
pattern-matching or guards.</p><p>We can also define other control structures â we'll see other examples
when we discuss monads.</p><p><b>Infinite data structures</b></p><p>Lazy evaluation also means that we can work with <i>infinite data
structures</i>.  In fact, we've already seen a few examples, such as
<code>repeat 7</code>, which represents an infinite list containing nothing but
<code>7</code>.  Defining an infinite data structure actually only creates a
thunk, which we can think of as a &quot;seed&quot; out of which the entire data
structure can <i>potentially</i> grow, depending on what parts actually are
used/needed.</p><p>Another practical application area is &quot;effectively infinite&quot; data
structures, such as the trees that might arise as the state space of a
game (such as go or chess).  Although the tree is finite in theory, it
is so large as to be effectively infinite---it certainly would not fit
in memory.  Using Haskell, we can define the tree of all possible
moves, and then write a separate algorithm to explore the tree in
whatever way we want. Only the parts of the tree which are actually
explored will be computed.</p><p><b>Pipelining/wholemeal programming</b></p><p>As I have mentioned before, doing &quot;pipelined&quot; incremental
transformations of a large data structure can actually be
memory-efficient.  Now we can see why: due to laziness, each stage of
the pipeline can operate in lockstep, only generating each bit of the
result as it is demanded by the next stage in the pipeline.</p><p><b>Dynamic programming</b></p><p>As a more specific example of the cool things lazy evaluation buys us,
consider the technique of
<a href="http://en.wikipedia.org/wiki/Dynamic_programming"><i>dynamic programming</i></a>.
Usually, one must take great care to fill in entries of a dynamic
programming table in the proper order, so that every time we compute
the value of a cell, its dependencies have already been computed.  If
we get the order wrong, we get bogus results.</p><p>However, using lazy evaluation we can get the Haskell runtime to work
out the proper order of evaluation for us!  For example, here is some
Haskell code to solve the
<a href="http://en.wikipedia.org/wiki/Knapsack_problem">0-1 knapsack problem</a>.
Note how we simply define the array <code>m</code> in terms of itself, using the
standard recurrence, and let lazy evaluation work out the proper order
in which to compute its cells.</p><pre><code class="active haskell">import Data.Array

knapsack :: [Double]   -- values 
           -&gt; [Integer]  -- nonnegative weights
           -&gt; Integer    -- knapsack size
           -&gt; Double     -- max possible value
knapsack vs ws maxW = m!(numItems-1, maxW)
  where numItems = length vs
        m = array ((-1,0), (numItems-1, maxW)) $
              [((-1,w), 0) | w &lt;- [0 .. maxW]] ++
              [((i,0), 0) | i &lt;- [0 .. numItems-1]] ++
              [((i,w), best) 
                  | i &lt;- [0 .. numItems-1]
                  , w &lt;- [1 .. maxW]
                  , let best
                          | ws!!i &gt; w  = m!(i-1, w)
                          | otherwise = max (m!(i-1, w)) 
                                            (m!(i-1, w - ws!!i) + vs!!i)
              ]

example = knapsack [3,4,5,8,10] [2,3,4,5,9] 20

main = print example</code></pre></article>


</div>
</div>
<div class="row article-footer"><div class="span7 meta"><span class="sociallinksunicode social">
<a href="https://twitter.com/home?status=$url$" target="_blank"><i class="icon-twitter"></i></a>&nbsp;
<a href="http://www.facebook.com/sharer/sharer.php?u=$url$" target="_blank"><i class="icon-facebook"></i></a>&nbsp;
<a href="https://plus.google.com/share?url=$url$" target="_blank"><i class="icon-google-plus"></i></a></span>
</div>
</div>
</div>
<div class="footer"><div class="container"><div class="row"><div class="span12"><ul class="menu"><li><a href="https://www.schoolofhaskell.com/">School</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user">Users</a>
</li>

<li><a class="brand" href="https://fpcomplete.com">Sponsored by:
<img src="/static/img/logo.png" title="FPComplete">
</a>
</li>
</ul>
</div>
</div>
<div class="row"><div class="span12"></div>
</div>
</div>
</div>
<link rel="stylesheet" type="text/css" href="/static/bootstrap/css/bootstrap-responsive.css" />
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script><script src="https://www.schoolofhaskell.com/static/combined/Y-3k9_tW.js"></script><script>$(function(){
  $("a.logout").click(function(){
    var form = $("<form method='post'/>");
    form.attr("action", $(this).attr("href"));
    $("body").append(form);
    form.submit();
    return false;
  });
});

$(function(){
    $('.sociallinksunicode a').each(function(){
        $(this).attr('href',$(this).attr('href').replace('$url$',document.location));
    });
});

$(function(){
  // If we need to select a user/select a password then show the
  // details confirmation form, otherwise enable the getting started
  // section.
  if($('.alert-block a').text().match(/(selected a username|change your password)/)) {
    $("#confirm-details").show();
    $("#confirm-details #inputUsername").focus();
  } else {
    $("#get-started").removeClass('disabled').addClass('enabled');
  }

  // For lack of a plain HTML validation story this will do.
  $('.welcome-page').each(function(){
    $('form').submit(check);
  });
  function check(){
    setTimeout(check,500);
    var error = false;
    $('.error').removeClass('error');
    $('#enter-details input').each(function(){
      if($(this).val() == '') {
        $(this).parent().parent().addClass('error');
        error = true;
      }
    });
    if(error) return false;
    if($('[name=password]').val() == $('[name=confirm]').val()) {
      $('#confirm').removeClass('error');
      return true;
    } else {
      $('#confirm').addClass('error');
      return false;
    }
  }
});

$(function(){
  // When scrolling over a snippet editor, activate the "clone in IDE" popovers
  $('article').each(function(){
    var n = 100;
    var wait = 10000;
    function check(){
      if($('.clone').length == 0) {
        setTimeout(check,n);
        return;
      }
      var activated = $.cookie('clone-popover');
      if (activated) return;
      var activate = false;
      $('.controlsRun:onScreen').each(function(){
        $.cookie('clone-popover', 'true', { expires: 30, path: '/' });
        activate = true;
        return false;
      });
      if(activate) {
          $('.clone').each(function(){
              // The bootstrap API is rather unreasonable to say the
              // least.
              next = $(this).parent();
              var title = next.attr('title');
              next.attr('data-content',$(this).attr('data-content'));
              next.attr('title',$(this).attr('title'));
              next.popover('show',{
                  title: $(this).attr('title')
              });
              next.attr('title',title);
          });
          setTimeout(function(){
              $('.clone').each(function(){
                  $(this).parent().popover('hide');
              });
          },wait);
      } else {
        setTimeout(check,n);
      }
    }
    setTimeout(check,n);
  });
});

// onScreen jQuery plugin v0.2.1
// (c) 2011-2013 Ben Pickles
//
// http://benpickles.github.com/onScreen
//
// Released under MIT license.
(function(a){a.expr[":"].onScreen=function(b){var c=a(window),d=c.scrollTop(),e=c.height(),f=d+e,g=a(b),h=g.offset().top,i=g.height(),j=h+i;return h>=d&&h<f||j>d&&j<=f||i>e&&h<=d&&j>=f}})(jQuery);

/*!
 * jQuery Cookie Plugin v1.1
 * https://github.com/carhartl/jquery-cookie
 *
 * Copyright 2011, Klaus Hartl
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.opensource.org/licenses/GPL-2.0
 */
(function($, document) {

  var pluses = /\+/g;
  function raw(s) {
    return s;
  }
  function decoded(s) {
    return decodeURIComponent(s.replace(pluses, ' '));
  }

  $.cookie = function(key, value, options) {

    // key and at least value given, set cookie...
    if (arguments.length > 1 && (!/Object/.test(Object.prototype.toString.call(value)) || value == null)) {
      options = $.extend({}, $.cookie.defaults, options);

      if (value == null) {
	options.expires = -1;
      }

      if (typeof options.expires === 'number') {
	var days = options.expires, t = options.expires = new Date();
	t.setDate(t.getDate() + days);
      }

      value = String(value);

      return (document.cookie = [
	encodeURIComponent(key), '=', options.raw ? value : encodeURIComponent(value),
	options.expires ? '; expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE
	options.path    ? '; path=' + options.path : '',
	options.domain  ? '; domain=' + options.domain : '',
	options.secure  ? '; secure' : ''
      ].join(''));
    }

    // key and possibly options given, get cookie...
    options = value || $.cookie.defaults || {};
    var decode = options.raw ? raw : decoded;
    var cookies = document.cookie.split('; ');
    for (var i = 0, parts; (parts = cookies[i] && cookies[i].split('=')); i++) {
      if (decode(parts.shift()) === key) {
	return decode(parts.join('='));
      }
    }
    return null;
  };
  $.cookie.defaults = {};})(jQuery, document);
</script><!--[if lt IE 10]><script src="https://www.schoolofhaskell.com/static/design/js/ie.js?etag=ayV2DuJ0"></script><![endif]--><script>if(!window.location.href.match(/localhost/)){var track = '/tutorial/user/byorgey/introduction-to-haskell/6-laziness';
window._gaq = [['_setAccount','UA-36928035-1'],track != ''? ['_trackPageview',track] : ['_trackPageview']
,['_trackPageLoadTime']];window._gaq.push(['_setCustomVar',1,'Section','School of Haskell',3]);
window._gaq.push(['_setCustomVar',2,'User Type','Visitor',1]);
(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);

})();}</script>
<!-- Prompt IE 6 users to install Chrome Frame. Remove this if you want to support IE 6.  chromium.org/developers/how-tos/chrome-frame-getting-started --><!--[if lt IE 7 ]><script src="//ajax.googleapis.com/ajax/libs/chrome-frame/1.0.3/CFInstall.min.js"></script><script>window.attachEvent('onload',function(){CFInstall.check({mode:'overlay'})})</script><![endif]--></body></html>