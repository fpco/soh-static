<!DOCTYPE html>
<html><head><title>Lenses, Stores, and Yoneda - School of Haskell | School of Haskell</title><meta http-equiv="x-ua-compatible" content="IE=9"><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="google-site-verification" content="Rfxk2TdeMMXEXHgJ2_OO8Rt3hPbQSDao0OXQV_n6z_s" /><link href="//fonts.googleapis.com/css?family=Merriweather" rel="stylesheet" type="text/css"><link href="https://www.schoolofhaskell.com/recent-content/feed" type="application/rss+xml" rel="alternate" title="Recently published content">
<link rel="stylesheet" href="https://www.schoolofhaskell.com/static/combined/UlwEHVcM.css"><style>.social{margin-right:1em}h1{font-family:Merriweather !important}article{font-family:Merriweather !important}article li{font-family:Merriweather !important;line-height:1.6em}h1,h2,h3,h4,h4,h5{font-family:Merriweather !important}.editor p{font-family:Frutiger, "Frutiger Linotype", Univers, Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans Condensed", "Liberation Sans", "Nimbus Sans L", Tahoma, Geneva, "Helvetica Neue", Helvetica, Arial, sans-serif}.article-footer{border-top:1px solid #ddd;padding-top:1em;margin-top:1em}body{font-size:16px !important}.navbar .navbar-inner{background:#3c3f41}.navbar .brand{font-size:14px}.navbar .brand img{width:6em}.navbar .icon-wrench{margin:0 -0.5em 0 -0.5em;padding:0 1em 0 1em;height:20px}.navbar-inverse .nav .active a{background:#333638}.navbar-inverse .nav > li > a{color:#a7a7a7
}.navbar-inverse .btn-navbar{background:#333638}.navbar-inverse .nav > li a:hover,.navbar-inverse .btn{background:#333537 !important}@media (max-width: 979px) {.icon-wrench{padding-left:1em !important}}.breadcrumb{border-top-left-radius:0;border-top-right-radius:0}h1{margin-top:20px}.breadcrumb-container + .main-content h1{margin-top:0}.footer{padding:30px 0;margin-top:70px;border-top:1px solid #e5e5e5;background-color:#f5f5f5}.footer ul.footer-menu{list-style-type:none}.footer ul.footer-menu li{display:inline-block}.footer ul.footer-menu li + li{margin-left:0.5em}.footer ul.footer-menu li + li:before{margin-right:0.5em;content:"Â·";color:#999}.footer ul.menu li{display:inline-block}.footer ul.menu li + li{margin-left:0.5em}.footer .copyright{margin-left:25px}.main-content{min-height:100%}.gravatar{width:80px;height:80px;border-radius:2px;background:#eee}.empty-gravatar{width:0}.container{font-family:"Segoe UI", Candara, "Bitstream Vera Sans", "DejaVu Sans", "Bitstream Vera Sans", "Trebuchet MS", Verdana, "Verdana Ref", sans-serif}.container h1,.container h2,.container h4,.container h4,.container h5{font-family:"Segoe UI", Candara, "Bitstream Vera Sans", "DejaVu Sans", "Bitstream Vera Sans", "Trebuchet MS", Verdana, "Verdana Ref", sans-serif}article{font-family:Merriweather !important}article h1{font-family:Merriweather !important}article li{font-family:Merriweather !important;line-height:1.6em}article li + li{margin-top:0.5em}article div.code{background:#f9f9f9;border:1px solid #d1d1d1;position:relative;border-radius:0.2em;margin:0.25em 0 0.75em 0;min-height:2.5em}article code{color:#005580;font-size:14px;white-space:pre}article a.hoogle > code{color:#0088cc;font-size:14px;white-space:pre;border:0}article .expand-code{display:none}article pre{overflow:auto;word-wrap:normal}article code.active{display:block;max-height:430px}article h1{font-size:31.5px}article h3{font-size:17.5px}article h4{font-size:14px}article h5,article h6{font-size:11.9px}article p{line-height:1.7em}article h1 code,article h2 code,article h3 code,article h4 code,article h5 code,article h6 code{font-size:inherit !important}article h1 a,article h2 a,article h3 a,article h4 a,article h5 a,article h6 a{color:#444}article h1 a:before,article h2 a:before,article h3 a:before,article h4 a:before,article h5 a:before,article h6 a:before{margin-left:-1.5em;padding-right:0.5em;font-family:fontawesome;content:"\f0c1";font-size:20px;color:#fff}article h1 a:hover,article h2 a:hover,article h3 a:hover,article h4 a:hover,article h5 a:hover,article h6 a:hover{text-decoration:none;color:#0088cc}article h1 a:hover:before,article h2 a:hover:before,article h3 a:hover:before,article h4 a:hover:before,article h5 a:hover:before,article h6 a:hover:before{color:#888}article h2{font-size:24.5px}article .popover{font-family:actor}article .popover h3.popover-title{font-family:actor !important;font-size:1em}article .popover .popover-content{width:15em;font-size:1em}article .controlsRun{display:block;padding:0.5em;text-align:right;background:#f2f2f2}article .controlsRun a.clone{margin-right:1em;font-family:actor;text-decoration:none}article .controlsRun a.clone span{padding-left:0.5em}article .controlsRun a.run,article .controlsRun a.reset,article .controlsRun a.show-code{font-size:16px}article .controlsRun a.run span,article .controlsRun a.reset span,article .controlsRun a.show-code span{display:none}article .controlsRun a.reset{margin-left:0.5em;color:#a2becc}article .controlsRun a.reset{display:none}article .controlsRun a.show-code{margin-right:0.75em}article .controlsRun a.run:hover,article .controlsRun a.show-code:hover{text-decoration:none}article .controlsRun a.show-code.active{color:#DC0D0D}article .controlsRun a[disabled]{color:#a2becc;cursor:default}article .collapse-area .collapse-header{background:#0088cc;color:#fff;padding:0.3em;cursor:pointer}article .collapse-area .hidden-toggle:before{content:"\f0d7";font-family:fontawesome;margin-right:0.5em;margin-left:0.25em}article .collapse-area .collapsed-files{overflow:auto;height:auto}article .collapse-area.collapse-disabled{display:none}article .collapse-area.collapse-area-off .collapsed-files{height:0px;overflow:hidden}article .collapse-area.collapse-area-off .hidden-toggle:before{content:"\f0da"}article .snippet-stdio .stdout{margin:0.5em;padding-right:2em;position:relative;word-wrap:break-word}article .snippet-stdio .stdin{-webkit-box-shadow:none;-moz-box-shadow:none;box-shadow:none;-webkit-transition:none;-moz-transition:none;-o-transition:none;transition:none;padding:0;margin:0}article .hoogle-results{margin:0.25em}article .hoogle-results .hoogle-inner{background:#fff;padding:0.5em;border-radius:3px;border:1px solid #ddd}article .hoogle-results .hoogle-inner .close-link{position:relative;float:right;margin-top:-0.5em;margin-right:-0.5em}article .snippet-output-errors{margin:1em 0.5em 0.5em 0.5em;position:relative}article .snippet-output-errors ul{list-style-type:none;margin:0;position:relative}article .snippet-output-errors pre{border:0;border-radius:0;padding:0.25em;margin:0;background:inherit;color:inherit}article .snippet-output-errors .close-link{color:inherit;background:inherit}article .snippet-editors{z-index:0;padding:0.25em}article .close-link{padding:0.5em;background:#eaeaea;border-bottom-left-radius:0.2em;border-top-right-radius:0.2em;position:absolute;top:0;right:0}article .close-link:hover{text-decoration:none}article .snippet-title{padding:0.5em 0 0 0.5em}article .snippet-title .snippet-icon{font-family:FontAwesome;display:inline-block;margin-right:0.5em}article .fullModuleCode + div .snippet-title{margin-top:0.5em;border-top:1px solid #ccc;padding-top:0.5em}article .CodeMirror{height:auto;min-height:1em;line-height:1.5em;background:transparent;font-size:14px !important}article .CodeMirror .highlighted{background:rgba(250, 210, 0, 0.45) !important}article .CodeMirror-widget{margin-left:2em;line-height:1.8}article .CodeMirror.collapsed{height:10em !important}article .editor .expander{text-align:center;display:block;padding:0.5em;text-decoration:none;border-bottom-left-radius:2px;border-bottom-right-radius:2px}article .editor .expander .ellipsis{background:white;border:1px solid #ccc;padding:0 0.5em;height:1em;line-height:0.5em;display:inline-block;color:#555;cursor:pointer}article .editor .expander .ellipsis:hover{background:#ddd;color:#333}article .web-runner{margin:0.5em;padding:0.5em;border:1px solid #ccc;border-radius:3px;background:#f5f5f5}article .web-runner iframe{border:0;margin-top:0.5em;margin-bottom:0;background:white}article .web-runner .controls i{cursor:pointer;color:#0088cc}article .web-runner .controls i:hover{color:#222}article .web-runner .controls i + i{margin-left:0.5em}article .web-runner .controls .icon-remove{float:right}article .hidden{display:block;visibility:visible}article .controlsShowHide{margin-bottom:0.5em}.tutorial-body{float:left !important}.tutorial-nav{float:right !important}@media (max-width: 979px) {.related-content{float:right}.author-name{display:block;margin-left:20px !important;padding-left:5px;margin-top:5px}article h1 a:hover:before,article h2 a:hover:before,article h3 a:hover:before,article h4 a:hover:before,article h5 a:hover:before,article h6 a:hover:before{color:#fff}.tutorial-nav{float:none !important;width:auto !important}.tutorial-body{float:none !important;width:auto !important}}@media (min-width: 980px) and (max-width: 1199px) {.navbar-search{display:none}.tutorial-nav{width:200px}.tutorial-body{width:720px}}#accountPage h1{margin:20px 0 0 0}#accountPage h2{font-size:20px}.group-contents .span8{float:left}.group-contents .span4{float:right}.container > .alert-block{margin-top:1em}.alert{color:#aa874a
}.social{margin-bottom:.8em;display:block}.social a{text-decoration:none}.social i{font-size:1.1em;color:#fff;padding:0.25em;border-radius:0.25em;width:1em;display:inline-block;text-align:center}.social i.icon-twitter{background:#0088cc}.social i.icon-facebook{background:#3b5998
  }.social i.icon-google-plus{background:#dd4b39
  }.well pre{background:#fcfcfc}.well h2{margin-top:0}code{color:#005580;font-size:14px;white-space:pre}</style><!--[if lt IE 8]><link rel="stylesheet" href="https://www.schoolofhaskell.com/static/design/css/ie7.css?etag=TSMl9x1V"><![endif]--><!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]--></head><body class="not-logged-in" itemscope itemtype="http://schema.org/Product"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-H62P" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-H62P');</script><div class="navbar navbar-inverse navbar-static-top"><div class="navbar-inner"><div class="container"><a class="btn btn-navbar" type="button" data-toggle="collapse" data-target=".nav-collapse"><span class="icon-bar"></span>
<span class="icon-bar"></span>
<span class="icon-bar"></span>
</a>
<a class="brand" href="/"><img src="/static/img/haskell-logo-wide.png" title="School of Haskell">
</a>
<div class="nav-collapse collapse"><ul class="nav"><li><a href="https://www.schoolofhaskell.com/">School</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user">Users</a>
</li>
</ul>
<form class="navbar-search pull-left" action="https://www.schoolofhaskell.com/search"><input class="search-query" type="text" placeholder="Search" name="search">
</form>
</div>
</div>
</div>
</div>
<div class="container breadcrumb-container"><div class="row"><div class="span12"><ul class="breadcrumb"><li><a href="https://www.schoolofhaskell.com/user/bartosz">Bartosz Milewski</a>
<span class="divider">/</span>
</li>
<li><a href="https://www.schoolofhaskell.com/user/bartosz/lenses-stores-and-yoneda">Lenses, Stores, and Yoneda</a>
</li>
</ul>
</div>
</div>
</div>
<div class="container main-content"><div class="row"><div class="span12"><h1 itemprop="name">Lenses, Stores, and Yoneda</h1>
</div>
</div>
<div class="row"><div class="span7 meta"><p><span class="date"> 8 Jun 2014</span>
<span class="author"><a href="https://www.schoolofhaskell.com/user/bartosz">Bartosz Milewski</a>
</span>
<span class="view-edit-link pull-right"><a class="view-source-link" href="https://www.schoolofhaskell.com/tutorial-raw/4/66e69df0ea343517c44991106d021364087d37c6">View Markdown source</a>
</span>
</p>
<p class="tags"></p>
</div>
</div>
<div class="row"><div class="span7 meta"><span class="sociallinksunicode social">
<a href="https://twitter.com/home?status=$url$" target="_blank"><i class="icon-twitter"></i></a>&nbsp;
<a href="http://www.facebook.com/sharer/sharer.php?u=$url$" target="_blank"><i class="icon-facebook"></i></a>&nbsp;
<a href="https://plus.google.com/share?url=$url$" target="_blank"><i class="icon-google-plus"></i></a></span>
</div>
</div>
<p class="alert">As of March 2020, School of Haskell has been switched to read-only mode.</p>
<div class="row" itemprop="desc"><div class="span4 tutorial-nav"><div class="related-content"><ul class="nav nav-tabs nav-stacked"><li><script>reddit_target='fpcomplete'</script>
<script src="https://redditstatic.s3.amazonaws.com/button/button1.js"></script>
</li>
<li><a href="https://www.schoolofhaskell.com/user/bartosz/understanding-yoneda">Previous content: Understanding Yoneda</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user/bartosz/understanding-algebras">Next content: Understanding F-Algebras</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user/bartosz">See all content by Bartosz Milewski</a>
</li>
</ul>

</div>
<div class="aside"><h3>Sections</h3>
<ul><li><a href="#yoneda-on-functors">Yoneda on Functors</a></li><li><a href="#back-to-haskell">Back to Haskell</a></li><li><a href="#undoing-fmap">Undoing fmap</a></li><li><a href="#the-store-comonad-and-yoneda">The Store Comonad and Yoneda</a></li><li><a href="#conclusion">Conclusion</a></li><li><a href="#appendix--another-exercise">Appendix: Another Exercise</a></li><li><a href="#acknowledgment">Acknowledgment</a></li><li><a href="#update">Update</a></li><li><a href="#bibliography">Bibliography</a></li></ul></div>
</div>
<div class="span8 tutorial-body" data-environment="ghc-7.8-stable-14.09">
<article><p>Edward Kmett's lens library made lenses talk of the town. This is, however, not a lens tutorial (let's wait for the upcoming Simon Peyton Jones's intro to lenses -- edit: <a href="http://skillsmatter.com/podcast/scala/lenses-compositional-data-access-and-manipulation">here it is</a>. I'm going to concentrate on one aspect of lenses that I've found intriguing -- the van Laarhoven representation.</p><p>Quick introduction: A lens is a data structure with a getter and a setter.</p><pre><code class="haskell">get :: b -&gt; a
set :: b -&gt; a -&gt; b</code></pre><p>Given object of type <code>b</code>, the getter returns the value of type <code>a</code> of the substructure on which the lens is focused (say, a field of a record, or an element of a list). The setter takes the object and a new value and returns a modified object, with the focus substructure replaced by the new value.</p><p>A lens can also be represented as a single function that returns a <code>Store</code> structure. Given the object of type <code>b</code> the lens returns a pair of: old value at the focus, and a function to modify it. This pair represents the <code>Store</code> comonad (I followed the naming convention in Russell O'Connor's paper, see bibliography):</p><pre><code class="haskell">data Store a b = Store
  { pos  :: a
  , peek :: a -&gt; b
  }</code></pre><p>The two elements of <code>Store</code> are just like getter and setter except that the initial <code>b -&gt;</code> was factored out.</p><p>Here's the unexpected turn of events: Twan van Laarhoven came up with a totally different representation for a lens. Applied to the <code>Store</code> comonad it looks like this:</p><pre><code class="haskell">forall g . Functor g =&gt; (a -&gt; g a) -&gt; g b</code></pre><p>The <code>Store</code> with <code>pos</code> and <code>peek</code> is <i>equivalent</i> to this single polymorphic function. Notice that the polymorphism is in terms of the functor <code>g</code>, which means that the function may only use the functor-specific <code>fmap</code>, nothing else. Recall the signature of <code>fmap</code> -- for a given <code>g</code>:</p><pre><code class="haskell">fmap :: (a -&gt; b) -&gt; g a -&gt; g b</code></pre><p>The only way the van Laarhoven function could produce the result <code>g b</code> is if it has access to a function <code>a -&gt; b</code> and a value of type <code>a</code> (which is exactly the content of <code>Store</code>). It can apply the function <code>a -&gt; g a</code> to this value and <code>fmap</code> the function <code>a -&gt; b</code> over it. Russell O'Connor showed the isomorphism between the two representations of the <code>Store</code> comonad.</p><p>This is all hunky-dory, but what's the theory behind this equivalence? When is a data structure equivalent to a polymorphic function? I've seen this pattern in the Yoneda lemma (for a refresher, see my tutorial: <a href="https://www.fpcomplete.com/user/bartosz/understanding-yoneda">Understanding Yoneda</a>). In Haskell we usually see a slightly narrower application of Yoneda. It says that a certain set of polymorphic functions (natural transformations) is equivalent to a certain set of values in the image of the functor <code>g</code>:</p><pre><code class="haskell">forall t . (a -&gt; t) -&gt; g t
   â g a</code></pre><p>Here, <code>(a -&gt; t)</code> is a function, which is mapped to <code>g t</code> -- some functor <code>g</code> acting on type <code>t</code>. This mapping is defined once for all possible types <code>t</code> -- it's a natural transformation -- hence <code>forall t</code>. All such natural transformations are equivalent to (parameterized by, isomomophic to) a type (set of values) <code>g a</code>. I use the symbol <code>â</code> for type isomorphism.</p><p>There definitely is a pattern, but we have to look at the application of Yoneda not to Haskell types (the Hask category) but to Haskell functors.</p><h2 id="yoneda-on-functors"><a href="#yoneda-on-functors">Yoneda on Functors</a></h2><p>We are in luck because functors form a category. Objects in the <i>Functor Category</i> are functors between some underlying categories, and morphisms are natural transformations between those functors.</p><p>Here's the Yoneda construction in the Functor Category. Let's fix one functor <code>f</code> and consider all natural transformations of <code>f</code> to an arbitrary functor <code>g</code>. These transformations form a set, which is an object in the Set Category. For each choice of <code>g</code> we get a different set. Let's call this mapping from functors to sets a representation, <code>rep</code>. This mapping, the canonical Yoneda embedding, is actually a functor. I'll call this a second order functor, since it takes a functor as its argument. Being a functor, its action on morphisms in the Functor Category is also well defined -- morphisms being natural transformations in this case.</p><p><img alt="Yoneda on functors" src="https://www.schoolofhaskell.com/content-proxy?src=http%3A%2F%2Fwww.bartosz.com%2Fimages%2FYoneda%2FFunctorYoneda.png" /></p><p>Now let's consider an arbitrary mapping from functors to sets, let's call it <code>eta</code> and let's assume that it's also a 2nd order functor. We have now two such functors, <code>rep</code> and <code>eta</code>. The Yoneda lemma considers mappings between these 2nd order functors, but not just any mappings -- natural transformations. Since those transformations map 2nd order functors, I'll also call them 2nd order natural transformations (thick yellow arrow in the picture).</p><p>What does it mean for a transformation to be natural? Technically, it means that a certain diagram commutes (see my Yoneda tutorial), but the Haskell intuition is the following: A natural transformation must be polymorphic in its argument. It treats this argument generically, without considering its peculiarities. In our case the 2nd order natural transformation will be polymorphic in its functor argument <code>g</code>.</p><p>The Yoneda lemma tells us that all such 2nd order natural transformations from <code>rep</code> to <code>eta</code> are in one-to-one correspondence with the elements of <code>eta</code> acting on <code>f</code>. I didn't want to overcrowd the picture, but imagine another red arrow going from <code>f</code> to some set. That's the set that parameterizes these natural transformations.</p><h2 id="back-to-haskell"><a href="#back-to-haskell">Back to Haskell</a></h2><p>Let's get down to earth. We'll specialize the general Functor Category to the category of endofunctors in Hask and replace the Set Category with Hask (a category of Haskell types, which are treated as sets of values).</p><p>Elements of the Functor Category will be represented in Haskell through the <code>Functor</code> class. If <code>f</code> and <code>g</code> are two functors, a natural transformation between them can be defined pointwise (e.g., acting on actual types) as a polymorphic function.</p><pre><code class="haskell">forall t . f t -&gt; g t</code></pre><p>Another way of looking at this formula is that it describes a mapping from an arbitrary functor <code>g</code> to the Haskell type <code>forall t . f t -&gt; g t</code>, where <code>f</code> is some fixed functor. This mapping is the Yoneda embedding we were talking about in the previous section. We'll call it <code>RepF</code>:</p><pre><code class="active haskell">{-# LANGUAGE Rank2Types #-}

type RepF f g = (Functor f, Functor g) 
    =&gt; forall t . f t -&gt; g t

main = putStrLn &quot;types check&quot;</code></pre><p>The second ingredient we need is the mapping <code>Eta</code> that, just like <code>Rep</code> maps functors to types. Since the kind of the functor <code>g</code> is <code>* -&gt; *</code>, the kind of <code>Eta</code> is <code>(* -&gt; *) -&gt; *</code>.</p><pre><code class="haskell">type family Eta :: (* -&gt; *) -&gt; *</code></pre><p>Putting all this together, the Yoneda lemma tells us that the following types are equivalent:</p><pre><code class="active haskell">{-# LANGUAGE Rank2Types, TypeFamilies #-}

type family Eta :: (* -&gt; *) -&gt; *

type NatF f = Functor f  
    =&gt; forall g . Functor g 
    =&gt; forall t. (f t -&gt; g t) -&gt; Eta g

-- equivalent to 

type NatF' = Functor f =&gt; Eta f

main = putStrLn &quot;types check&quot;</code></pre><p>There are many mappings that we can substitute for <code>Eta</code>, but I'd like to concentrate on the simplest nontrivial one, parameterized by some type <code>b</code>. The action of this <code>EtaB</code> on a functor <code>g</code> is defined by the application of <code>g</code> to <code>b</code>.</p><pre><code class="active haskell">{-# LANGUAGE Rank2Types #-}

type EtaB b g = Functor g =&gt; g b

main = putStrLn &quot;types check&quot;</code></pre><p>Now let's consider 2nd order natural transformations betwen <code>RepF</code> and <code>EtaB</code> or, more precisely, between <code>RepF f</code> and <code>EtaB b</code> for some fixed <code>f</code> and <code>b</code>. These transformations must be polymorphic in <code>g</code>:</p><pre><code class="active haskell">{-# LANGUAGE Rank2Types #-}

type EtaB b g = Functor g =&gt; g b
-- show
type NatFB f b = Functor f  
    =&gt; forall g . Functor g 
    =&gt; forall t. (f t -&gt; g t) -&gt; EtaB b g
-- /show
main = putStrLn &quot;types check&quot;</code></pre><p>This can be further simplified by applying <code>EtaB</code> to its arguments:</p><pre><code class="haskell">type NatFB f b = Functor f  
    =&gt; forall g . Functor g 
    =&gt; forall t. (f t -&gt; g t) -&gt; {-hi-}g b{-/hi-}</code></pre><p>The final step is to apply the Yoneda lemma which, in this case, tells us that the above type is equivalent to the type obtained by acting with <code>EtaB b</code> on <code>f</code>. This type is simply <code>f b</code>.</p><p>Do you see how close we are to the van Laarhoven equivalence?</p><pre><code class="haskell">forall g :: Functor g =&gt; (a -&gt; g a) -&gt; g b
    â (a, a -&gt; b)</code></pre><p>We just need to find the right <code>f</code>. But before we do that, one little exercise to get some familiarity with the Yoneda lemma for functors.</p><h2 id="undoing-fmap"><a href="#undoing-fmap">Undoing fmap</a></h2><p>Here's an interesting choice for the functor <code>f</code> -- function application. For a given type <code>a</code> the application <code>(-&gt;) a</code> is a functor. Indeed, it's easy to implement <code>fmap</code> for it:</p><pre><code class="active haskell">instance Functor ((-&gt;) a) where
    -- fmap :: (t -&gt; u) -&gt; (a -&gt; t) -&gt; (a -&gt; u)
    fmap f g = f . g

main = putStrLn &quot;It typechecks!&quot;</code></pre><p>Let's plug this functor in the place of <code>f</code> in our version of Yoneda:</p><pre><code class="haskell">type NatApA a b =   
    forall g . Functor g 
    =&gt; forall t. ({-hi-}(a -&gt; t){-/hi-} -&gt; g t) -&gt; g b

NatApA a b â {-hi-}a -&gt; b{-/hi-}</code></pre><p>Here, <code>f t</code> was replaced by <code>a -&gt; t</code> and <code>f b</code> by <code>a -&gt; b</code>. Now let's dig into this part of the formula:</p><pre><code class="haskell">forall t. ((a -&gt; t) -&gt; g t)</code></pre><p>Isn't this just the left hand side of the regular Yoneda? It's a natural transformation between the Yoneda embedding functor  <code>(-&gt;) a</code> and some functor <code>g</code>. The lemma tells us that this is equivalent to the type <code>g a</code>. So let's make the substitution:</p><pre><code class="haskell">type NatApA a b =   
    forall g . Functor g 
    =&gt; {-hi-}g a{-/hi-} -&gt; g b

NatApA a b â a -&gt; b</code></pre><p>On the one hand we have a function <code>g a -&gt; g b</code> which maps types lifted by the functor <code>g</code>. If this function is polymorphic in the functor <code>g</code> than it is equivalent to a function <code>a -&gt; b</code>. This equivalence shows that <code>fmap</code> can go both ways. In fact it's easy to show the isomorphism of the two types directly. Of course, given a function <code>a -&gt; b</code> and any functor <code>g</code>, we can construct a function <code>g a -&gt; g b</code> by applying <code>fmap</code>. Conversely, if we have a function <code>g a -&gt; g b</code> that works for any functor <code>g</code> then we can use it with the trivial identity functor <code>Identity</code> and recover <code>a -&gt; b</code>.</p><p>So this is not a big deal, but the surprise for me was that it followed from the Yoneda lemma.</p><h2 id="the-store-comonad-and-yoneda"><a href="#the-store-comonad-and-yoneda">The Store Comonad and Yoneda</a></h2><p>After this warmup exercise, I'm ready to unveil the functor <code>f</code> that, when plugged into the Yoneda lemma, will generate the van Laarhoven equivalence. This functor is:</p><pre><code class="haskell">Product (Const a) ((-&gt;) a)</code></pre><p>When acting on any type <code>b</code>, it produces:</p><pre><code class="haskell">(Const a b, a -&gt; b)</code></pre><p>The <code>Const</code> functor ignores its second argument and is equivalent to its first argument:</p><pre><code class="haskell">newtype Const a b = Const { getConst :: a }</code></pre><p>So the right hand side of the Yoneda lemma is equivalent to the <code>Store</code> comonad <code>(a, a -&gt; b)</code>.</p><p>Let's look at the left hand side of the Yoneda lemma:</p><pre><code class="haskell">type NatFB f b = Functor f  
    =&gt; forall g . Functor g 
    =&gt; forall t. (f t -&gt; g t) -&gt; g b</code></pre><p>and do the substitution:</p><pre><code class="haskell">forall g . Functor g 
  =&gt; forall t. ({-hi-}(a, a -&gt; t){-/hi-} -&gt; g t) -&gt; g b</code></pre><p>Here's the curried version of the function in parentheses:</p><pre><code class="haskell">forall t. (a -&gt; (a -&gt; t) -&gt; g t)</code></pre><p>Since the first argument <code>a</code> doesn't depend on <code>t</code>, we can move it in front of <code>forall</code>:</p><pre><code class="haskell">a -&gt; forall t . (a -&gt; t) -&gt; g t</code></pre><p>We are now free to apply the 1st order Yoneda</p><pre><code class="haskell">forall t . (a -&gt; t) -&gt; g t â g a</code></pre><p>Which gives us:</p><pre><code class="haskell">a -&gt; forall t . (a -&gt; t) -&gt; g t â a -&gt; g a</code></pre><p>Substituting it back to our formula, we get:</p><pre><code class="haskell">forall g . Functor g =&gt; (a -&gt; g a) -&gt; g b
  â (a, a -&gt; b)</code></pre><p>Which is exactly the van Laarhoven equivalence.</p><h2 id="conclusion"><a href="#conclusion">Conclusion</a></h2><p>I have shown that the equivalence of the two formulations of the <code>Store</code> comonad and, consequently, the <code>Lens</code>, follows from the Yoneda lemma applied to the Functor Category. This equivalence is a special case of the more general formula for functor-polymorphic representations:</p><pre><code class="haskell">type family Eta :: (* -&gt; *) -&gt; *

Functor f  
    =&gt; forall g . Functor g 
    =&gt; forall t. (f t -&gt; g t) -&gt; Eta g
  â Functor f =&gt; Eta f</code></pre><p>This formula is parameterized by two entities: a functor <code>f</code> and a 2nd order functor <code>Eta</code>.</p><p>In this article I restricted myself to one particular 2nd order functor, <code>EtaB b</code>, but it would be interesting to see if more complex <code>Eta</code>s lead to more interesting results.</p><p>In the choice of the functor <code>f</code> I also restricted myself to just a few simple examples. It would be interesting to try, for instance, functors that generate recursive data structures and try to reproduce some of the biplate and multiplate results of Russell O'Connor's.</p><h2 id="appendix--another-exercise"><a href="#appendix--another-exercise">Appendix: Another Exercise</a></h2><p>Just for the fun of it, let's try substituting <code>Const a</code> for <code>f</code>:</p><p>The naive substitution would give us this:</p><pre><code class="haskell">forall g . Functor g 
    =&gt; (forall t . Const a t -&gt; g t) -&gt; g b 
  â Const a b</code></pre><p>But the natural transformation on the left:</p><pre><code class="haskell">forall t . Const a t -&gt; g t</code></pre><p>cannot be defined for all <code>g</code>s. <code>Const a t</code> doesn't depend on <code>t</code>, so the co-domain of the natural transformation can only include functors that don't depend on their argument -- constant functors. So we are really only looking for <code>g</code>s that are <code>Const c</code> for any choice of <code>c</code>. All the allowed variation in <code>g</code> can be parameterized by type <code>c</code>:</p><pre><code class="haskell">forall c . (Const a t -&gt; Const c t) -&gt; Const c b 
  â Const a b</code></pre><p>If you remove the <code>Const</code> noise, the conclusion turns out to be pretty trivial:</p><pre><code class="haskell">forall c . (a -&gt; c) -&gt; c â a</code></pre><p>It says that a polymorphic function that takes a function <code>a -&gt; c</code> and returns a <code>c</code> must have some fixed <code>a</code> inside. This is pretty obvious, but it's nice to know that it can be derived from the Yoneda lemma.</p><h2 id="acknowledgment"><a href="#acknowledgment">Acknowledgment</a></h2><p>Special thanks go to the folks on the Lens IRC channel for correcting my Haskell errors and for helpful advice.</p><h2 id="update"><a href="#update">Update</a></h2><p>After I finished writing this blog, I contacted Russel O'Connor asking him for comments. It turned out that he and Mauro Jaskelioff had been working on a paper in which they independently came up with almost exactly the same derivation of the van Laarhoven representation for the lens starting from the Yoneda lemma. They later published the paper, <a href="http://arxiv.org/pdf/1402.1699.pdf">A Representation Theorem for Second-Order Functionals</a>, including the link to this blog. It contains a much more rigorous proof of the equivalence.</p><h2 id="bibliography"><a href="#bibliography">Bibliography</a></h2><ol><li>Twan van Laarhoven, <a href="http://twanvl.nl/blog/haskell/cps-functional-references">CPS based functional references</a></li><li>Russell O'Connor, <a href="http://arxiv.org/pdf/1103.2841v2.pdf">Functor is to Lens as Applicative is to Biplate</a></li></ol></article>

<div id="disqus_thread"><script>var disqus_shortname = "bartosz_milewski"; (function() { var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true; dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq); })();</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">comments powered by <span class="logo-disqus">Disqus</span></a></a>
</div>

</div>
</div>
<div class="row article-footer"><div class="span7 meta"><span class="sociallinksunicode social">
<a href="https://twitter.com/home?status=$url$" target="_blank"><i class="icon-twitter"></i></a>&nbsp;
<a href="http://www.facebook.com/sharer/sharer.php?u=$url$" target="_blank"><i class="icon-facebook"></i></a>&nbsp;
<a href="https://plus.google.com/share?url=$url$" target="_blank"><i class="icon-google-plus"></i></a></span>
</div>
</div>
</div>
<div class="footer"><div class="container"><div class="row"><div class="span12"><ul class="menu"><li><a href="https://www.schoolofhaskell.com/">School</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user">Users</a>
</li>

<li><a class="brand" href="https://fpcomplete.com">Sponsored by:
<img src="/static/img/logo.png" title="FPComplete">
</a>
</li>
</ul>
</div>
</div>
<div class="row"><div class="span12"></div>
</div>
</div>
</div>
<link rel="stylesheet" type="text/css" href="/static/bootstrap/css/bootstrap-responsive.css" />
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script><script src="https://www.schoolofhaskell.com/static/combined/Y-3k9_tW.js"></script><script>$(function(){
  $("a.logout").click(function(){
    var form = $("<form method='post'/>");
    form.attr("action", $(this).attr("href"));
    $("body").append(form);
    form.submit();
    return false;
  });
});

$(function(){
    $('.sociallinksunicode a').each(function(){
        $(this).attr('href',$(this).attr('href').replace('$url$',document.location));
    });
});

$(function(){
  // If we need to select a user/select a password then show the
  // details confirmation form, otherwise enable the getting started
  // section.
  if($('.alert-block a').text().match(/(selected a username|change your password)/)) {
    $("#confirm-details").show();
    $("#confirm-details #inputUsername").focus();
  } else {
    $("#get-started").removeClass('disabled').addClass('enabled');
  }

  // For lack of a plain HTML validation story this will do.
  $('.welcome-page').each(function(){
    $('form').submit(check);
  });
  function check(){
    setTimeout(check,500);
    var error = false;
    $('.error').removeClass('error');
    $('#enter-details input').each(function(){
      if($(this).val() == '') {
        $(this).parent().parent().addClass('error');
        error = true;
      }
    });
    if(error) return false;
    if($('[name=password]').val() == $('[name=confirm]').val()) {
      $('#confirm').removeClass('error');
      return true;
    } else {
      $('#confirm').addClass('error');
      return false;
    }
  }
});

$(function(){
  // When scrolling over a snippet editor, activate the "clone in IDE" popovers
  $('article').each(function(){
    var n = 100;
    var wait = 10000;
    function check(){
      if($('.clone').length == 0) {
        setTimeout(check,n);
        return;
      }
      var activated = $.cookie('clone-popover');
      if (activated) return;
      var activate = false;
      $('.controlsRun:onScreen').each(function(){
        $.cookie('clone-popover', 'true', { expires: 30, path: '/' });
        activate = true;
        return false;
      });
      if(activate) {
          $('.clone').each(function(){
              // The bootstrap API is rather unreasonable to say the
              // least.
              next = $(this).parent();
              var title = next.attr('title');
              next.attr('data-content',$(this).attr('data-content'));
              next.attr('title',$(this).attr('title'));
              next.popover('show',{
                  title: $(this).attr('title')
              });
              next.attr('title',title);
          });
          setTimeout(function(){
              $('.clone').each(function(){
                  $(this).parent().popover('hide');
              });
          },wait);
      } else {
        setTimeout(check,n);
      }
    }
    setTimeout(check,n);
  });
});

// onScreen jQuery plugin v0.2.1
// (c) 2011-2013 Ben Pickles
//
// http://benpickles.github.com/onScreen
//
// Released under MIT license.
(function(a){a.expr[":"].onScreen=function(b){var c=a(window),d=c.scrollTop(),e=c.height(),f=d+e,g=a(b),h=g.offset().top,i=g.height(),j=h+i;return h>=d&&h<f||j>d&&j<=f||i>e&&h<=d&&j>=f}})(jQuery);

/*!
 * jQuery Cookie Plugin v1.1
 * https://github.com/carhartl/jquery-cookie
 *
 * Copyright 2011, Klaus Hartl
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.opensource.org/licenses/GPL-2.0
 */
(function($, document) {

  var pluses = /\+/g;
  function raw(s) {
    return s;
  }
  function decoded(s) {
    return decodeURIComponent(s.replace(pluses, ' '));
  }

  $.cookie = function(key, value, options) {

    // key and at least value given, set cookie...
    if (arguments.length > 1 && (!/Object/.test(Object.prototype.toString.call(value)) || value == null)) {
      options = $.extend({}, $.cookie.defaults, options);

      if (value == null) {
	options.expires = -1;
      }

      if (typeof options.expires === 'number') {
	var days = options.expires, t = options.expires = new Date();
	t.setDate(t.getDate() + days);
      }

      value = String(value);

      return (document.cookie = [
	encodeURIComponent(key), '=', options.raw ? value : encodeURIComponent(value),
	options.expires ? '; expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE
	options.path    ? '; path=' + options.path : '',
	options.domain  ? '; domain=' + options.domain : '',
	options.secure  ? '; secure' : ''
      ].join(''));
    }

    // key and possibly options given, get cookie...
    options = value || $.cookie.defaults || {};
    var decode = options.raw ? raw : decoded;
    var cookies = document.cookie.split('; ');
    for (var i = 0, parts; (parts = cookies[i] && cookies[i].split('=')); i++) {
      if (decode(parts.shift()) === key) {
	return decode(parts.join('='));
      }
    }
    return null;
  };
  $.cookie.defaults = {};})(jQuery, document);
</script><!--[if lt IE 10]><script src="https://www.schoolofhaskell.com/static/design/js/ie.js?etag=ayV2DuJ0"></script><![endif]--><script>if(!window.location.href.match(/localhost/)){var track = '/tutorial/user/bartosz/lenses-stores-and-yoneda';
window._gaq = [['_setAccount','UA-36928035-1'],track != ''? ['_trackPageview',track] : ['_trackPageview']
,['_trackPageLoadTime']];window._gaq.push(['_setCustomVar',1,'Section','School of Haskell',3]);
window._gaq.push(['_setCustomVar',2,'User Type','Visitor',1]);
(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);

})();}</script>
<!-- Prompt IE 6 users to install Chrome Frame. Remove this if you want to support IE 6.  chromium.org/developers/how-tos/chrome-frame-getting-started --><!--[if lt IE 7 ]><script src="//ajax.googleapis.com/ajax/libs/chrome-frame/1.0.3/CFInstall.min.js"></script><script>window.attachEvent('onload',function(){CFInstall.check({mode:'overlay'})})</script><![endif]--></body></html>