<!DOCTYPE html>
<html><head><title>8. Parser - School of Haskell | School of Haskell</title><meta http-equiv="x-ua-compatible" content="IE=9"><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="google-site-verification" content="Rfxk2TdeMMXEXHgJ2_OO8Rt3hPbQSDao0OXQV_n6z_s" /><link href="//fonts.googleapis.com/css?family=Merriweather" rel="stylesheet" type="text/css"><link href="https://www.schoolofhaskell.com/recent-content/feed" type="application/rss+xml" rel="alternate" title="Recently published content">
<link rel="stylesheet" href="https://www.schoolofhaskell.com/static/combined/UlwEHVcM.css"><style>.social{margin-right:1em}h1{font-family:Merriweather !important}article{font-family:Merriweather !important}article li{font-family:Merriweather !important;line-height:1.6em}h1,h2,h3,h4,h4,h5{font-family:Merriweather !important}.editor p{font-family:Frutiger, "Frutiger Linotype", Univers, Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans Condensed", "Liberation Sans", "Nimbus Sans L", Tahoma, Geneva, "Helvetica Neue", Helvetica, Arial, sans-serif}.article-footer{border-top:1px solid #ddd;padding-top:1em;margin-top:1em}body{font-size:16px !important}.navbar .navbar-inner{background:#3c3f41}.navbar .brand{font-size:14px}.navbar .brand img{width:6em}.navbar .icon-wrench{margin:0 -0.5em 0 -0.5em;padding:0 1em 0 1em;height:20px}.navbar-inverse .nav .active a{background:#333638}.navbar-inverse .nav > li > a{color:#a7a7a7
}.navbar-inverse .btn-navbar{background:#333638}.navbar-inverse .nav > li a:hover,.navbar-inverse .btn{background:#333537 !important}@media (max-width: 979px) {.icon-wrench{padding-left:1em !important}}.breadcrumb{border-top-left-radius:0;border-top-right-radius:0}h1{margin-top:20px}.breadcrumb-container + .main-content h1{margin-top:0}.footer{padding:30px 0;margin-top:70px;border-top:1px solid #e5e5e5;background-color:#f5f5f5}.footer ul.footer-menu{list-style-type:none}.footer ul.footer-menu li{display:inline-block}.footer ul.footer-menu li + li{margin-left:0.5em}.footer ul.footer-menu li + li:before{margin-right:0.5em;content:"Â·";color:#999}.footer ul.menu li{display:inline-block}.footer ul.menu li + li{margin-left:0.5em}.footer .copyright{margin-left:25px}.main-content{min-height:100%}.gravatar{width:80px;height:80px;border-radius:2px;background:#eee}.empty-gravatar{width:0}.container{font-family:"Segoe UI", Candara, "Bitstream Vera Sans", "DejaVu Sans", "Bitstream Vera Sans", "Trebuchet MS", Verdana, "Verdana Ref", sans-serif}.container h1,.container h2,.container h4,.container h4,.container h5{font-family:"Segoe UI", Candara, "Bitstream Vera Sans", "DejaVu Sans", "Bitstream Vera Sans", "Trebuchet MS", Verdana, "Verdana Ref", sans-serif}article{font-family:Merriweather !important}article h1{font-family:Merriweather !important}article li{font-family:Merriweather !important;line-height:1.6em}article li + li{margin-top:0.5em}article div.code{background:#f9f9f9;border:1px solid #d1d1d1;position:relative;border-radius:0.2em;margin:0.25em 0 0.75em 0;min-height:2.5em}article code{color:#005580;font-size:14px;white-space:pre}article a.hoogle > code{color:#0088cc;font-size:14px;white-space:pre;border:0}article .expand-code{display:none}article pre{overflow:auto;word-wrap:normal}article code.active{display:block;max-height:430px}article h1{font-size:31.5px}article h3{font-size:17.5px}article h4{font-size:14px}article h5,article h6{font-size:11.9px}article p{line-height:1.7em}article h1 code,article h2 code,article h3 code,article h4 code,article h5 code,article h6 code{font-size:inherit !important}article h1 a,article h2 a,article h3 a,article h4 a,article h5 a,article h6 a{color:#444}article h1 a:before,article h2 a:before,article h3 a:before,article h4 a:before,article h5 a:before,article h6 a:before{margin-left:-1.5em;padding-right:0.5em;font-family:fontawesome;content:"\f0c1";font-size:20px;color:#fff}article h1 a:hover,article h2 a:hover,article h3 a:hover,article h4 a:hover,article h5 a:hover,article h6 a:hover{text-decoration:none;color:#0088cc}article h1 a:hover:before,article h2 a:hover:before,article h3 a:hover:before,article h4 a:hover:before,article h5 a:hover:before,article h6 a:hover:before{color:#888}article h2{font-size:24.5px}article .popover{font-family:actor}article .popover h3.popover-title{font-family:actor !important;font-size:1em}article .popover .popover-content{width:15em;font-size:1em}article .controlsRun{display:block;padding:0.5em;text-align:right;background:#f2f2f2}article .controlsRun a.clone{margin-right:1em;font-family:actor;text-decoration:none}article .controlsRun a.clone span{padding-left:0.5em}article .controlsRun a.run,article .controlsRun a.reset,article .controlsRun a.show-code{font-size:16px}article .controlsRun a.run span,article .controlsRun a.reset span,article .controlsRun a.show-code span{display:none}article .controlsRun a.reset{margin-left:0.5em;color:#a2becc}article .controlsRun a.reset{display:none}article .controlsRun a.show-code{margin-right:0.75em}article .controlsRun a.run:hover,article .controlsRun a.show-code:hover{text-decoration:none}article .controlsRun a.show-code.active{color:#DC0D0D}article .controlsRun a[disabled]{color:#a2becc;cursor:default}article .collapse-area .collapse-header{background:#0088cc;color:#fff;padding:0.3em;cursor:pointer}article .collapse-area .hidden-toggle:before{content:"\f0d7";font-family:fontawesome;margin-right:0.5em;margin-left:0.25em}article .collapse-area .collapsed-files{overflow:auto;height:auto}article .collapse-area.collapse-disabled{display:none}article .collapse-area.collapse-area-off .collapsed-files{height:0px;overflow:hidden}article .collapse-area.collapse-area-off .hidden-toggle:before{content:"\f0da"}article .snippet-stdio .stdout{margin:0.5em;padding-right:2em;position:relative;word-wrap:break-word}article .snippet-stdio .stdin{-webkit-box-shadow:none;-moz-box-shadow:none;box-shadow:none;-webkit-transition:none;-moz-transition:none;-o-transition:none;transition:none;padding:0;margin:0}article .hoogle-results{margin:0.25em}article .hoogle-results .hoogle-inner{background:#fff;padding:0.5em;border-radius:3px;border:1px solid #ddd}article .hoogle-results .hoogle-inner .close-link{position:relative;float:right;margin-top:-0.5em;margin-right:-0.5em}article .snippet-output-errors{margin:1em 0.5em 0.5em 0.5em;position:relative}article .snippet-output-errors ul{list-style-type:none;margin:0;position:relative}article .snippet-output-errors pre{border:0;border-radius:0;padding:0.25em;margin:0;background:inherit;color:inherit}article .snippet-output-errors .close-link{color:inherit;background:inherit}article .snippet-editors{z-index:0;padding:0.25em}article .close-link{padding:0.5em;background:#eaeaea;border-bottom-left-radius:0.2em;border-top-right-radius:0.2em;position:absolute;top:0;right:0}article .close-link:hover{text-decoration:none}article .snippet-title{padding:0.5em 0 0 0.5em}article .snippet-title .snippet-icon{font-family:FontAwesome;display:inline-block;margin-right:0.5em}article .fullModuleCode + div .snippet-title{margin-top:0.5em;border-top:1px solid #ccc;padding-top:0.5em}article .CodeMirror{height:auto;min-height:1em;line-height:1.5em;background:transparent;font-size:14px !important}article .CodeMirror .highlighted{background:rgba(250, 210, 0, 0.45) !important}article .CodeMirror-widget{margin-left:2em;line-height:1.8}article .CodeMirror.collapsed{height:10em !important}article .editor .expander{text-align:center;display:block;padding:0.5em;text-decoration:none;border-bottom-left-radius:2px;border-bottom-right-radius:2px}article .editor .expander .ellipsis{background:white;border:1px solid #ccc;padding:0 0.5em;height:1em;line-height:0.5em;display:inline-block;color:#555;cursor:pointer}article .editor .expander .ellipsis:hover{background:#ddd;color:#333}article .web-runner{margin:0.5em;padding:0.5em;border:1px solid #ccc;border-radius:3px;background:#f5f5f5}article .web-runner iframe{border:0;margin-top:0.5em;margin-bottom:0;background:white}article .web-runner .controls i{cursor:pointer;color:#0088cc}article .web-runner .controls i:hover{color:#222}article .web-runner .controls i + i{margin-left:0.5em}article .web-runner .controls .icon-remove{float:right}article .hidden{display:block;visibility:visible}article .controlsShowHide{margin-bottom:0.5em}.tutorial-body{float:left !important}.tutorial-nav{float:right !important}@media (max-width: 979px) {.related-content{float:right}.author-name{display:block;margin-left:20px !important;padding-left:5px;margin-top:5px}article h1 a:hover:before,article h2 a:hover:before,article h3 a:hover:before,article h4 a:hover:before,article h5 a:hover:before,article h6 a:hover:before{color:#fff}.tutorial-nav{float:none !important;width:auto !important}.tutorial-body{float:none !important;width:auto !important}}@media (min-width: 980px) and (max-width: 1199px) {.navbar-search{display:none}.tutorial-nav{width:200px}.tutorial-body{width:720px}}#accountPage h1{margin:20px 0 0 0}#accountPage h2{font-size:20px}.group-contents .span8{float:left}.group-contents .span4{float:right}.container > .alert-block{margin-top:1em}.alert{color:#aa874a
}.social{margin-bottom:.8em;display:block}.social a{text-decoration:none}.social i{font-size:1.1em;color:#fff;padding:0.25em;border-radius:0.25em;width:1em;display:inline-block;text-align:center}.social i.icon-twitter{background:#0088cc}.social i.icon-facebook{background:#3b5998
  }.social i.icon-google-plus{background:#dd4b39
  }.well pre{background:#fcfcfc}.well h2{margin-top:0}code{color:#005580;font-size:14px;white-space:pre}</style><!--[if lt IE 8]><link rel="stylesheet" href="https://www.schoolofhaskell.com/static/design/css/ie7.css?etag=TSMl9x1V"><![endif]--><!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]--></head><body class="not-logged-in" itemscope itemtype="http://schema.org/Product"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-H62P" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-H62P');</script><div class="navbar navbar-inverse navbar-static-top"><div class="navbar-inner"><div class="container"><a class="btn btn-navbar" type="button" data-toggle="collapse" data-target=".nav-collapse"><span class="icon-bar"></span>
<span class="icon-bar"></span>
<span class="icon-bar"></span>
</a>
<a class="brand" href="/"><img src="/static/img/haskell-logo-wide.png" title="School of Haskell">
</a>
<div class="nav-collapse collapse"><ul class="nav"><li><a href="https://www.schoolofhaskell.com/">School</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user">Users</a>
</li>
</ul>
<form class="navbar-search pull-left" action="https://www.schoolofhaskell.com/search"><input class="search-query" type="text" placeholder="Search" name="search">
</form>
</div>
</div>
</div>
</div>
<div class="container breadcrumb-container"><div class="row"><div class="span12"><ul class="breadcrumb"><li><a href="https://www.schoolofhaskell.com/user/bartosz">Bartosz Milewski</a>
<span class="divider">/</span>
</li>
<li><a href="https://www.schoolofhaskell.com/user/bartosz/basics-of-haskell">Basics of Haskell</a>
<span class="divider">/</span>
</li>
<li><a href="https://www.schoolofhaskell.com/user/bartosz/basics-of-haskell/8_Parser">8. Parser</a>
</li>
</ul>
</div>
</div>
</div>
<div class="container main-content"><div class="row"><div class="span12"><h1 itemprop="name">8. Parser</h1>
</div>
</div>
<div class="row"><div class="span7 meta"><p><span class="date">28 Dec 2014</span>
<span class="author"><a href="https://www.schoolofhaskell.com/user/bartosz">Bartosz Milewski</a>
</span>
<span class="view-edit-link pull-right"><a class="view-source-link" href="https://www.schoolofhaskell.com/tutorial-raw/4/1de02d559f751b658a57ddeee6bf2b6dcaf8e1fe">View Markdown source</a>
</span>
</p>
<p class="tags"></p>
</div>
</div>
<div class="row"><div class="span7 meta"><span class="sociallinksunicode social">
<a href="https://twitter.com/home?status=$url$" target="_blank"><i class="icon-twitter"></i></a>&nbsp;
<a href="http://www.facebook.com/sharer/sharer.php?u=$url$" target="_blank"><i class="icon-facebook"></i></a>&nbsp;
<a href="https://plus.google.com/share?url=$url$" target="_blank"><i class="icon-google-plus"></i></a></span>
</div>
</div>
<p class="alert">As of March 2020, School of Haskell has been switched to read-only mode.</p>
<div class="row" itemprop="desc"><div class="span4 tutorial-nav"><div class="related-content"><ul class="nav nav-tabs nav-stacked"><li><script>reddit_target='fpcomplete'</script>
<script src="https://redditstatic.s3.amazonaws.com/button/button1.js"></script>
</li>
<li><a href="https://www.schoolofhaskell.com/user/bartosz/basics-of-haskell/7-tokenizer-higher-order-functions">Previous content: 7. Tokenizer: Higher Order Functions</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user/bartosz/basics-of-haskell/9_Evaluator">Next content: 9. Evaluator</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user/bartosz/basics-of-haskell">Go up to: Basics of Haskell</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user/bartosz">See all content by Bartosz Milewski</a>
</li>
</ul>

</div>
<div class="aside"><h3>Sections</h3>
<ul><li><a href="#the-grammar">The Grammar</a></li><li><a href="#the-parse-tree">The Parse Tree</a></li><li><a href="#top-down-recursive-parsing">Top-Down Recursive Parsing</a><ul><li><a href="#state-without-mutation">State without Mutation</a></li></ul></li><li><a href="#expression">Expression</a></li><li><a href="#term">Term</a></li><li><a href="#factor">Factor</a></li><li><a href="#parser">Parser</a></li><li><a href="#exercises">Exercises</a></li></ul></div>
</div>
<div class="span8 tutorial-body" data-environment="ghc-7.8-stable-14.09">
<article><p>I the <a href="https://www.fpcomplete.com/user/bartosz/basics-of-haskell/7-tokenizer-higher-order-functions">previous installment</a>, we finished implementing the tokenizer, a.k.a., the lexer. We implemented it as a (pure) function that takes a string of characters and produces a list of tokens. This list of tokens will now serve as the input to the next stage of our calculator, the parser, which applies the rules of grammar to tokens in order to create an expression tree. We already have the the signature for our parser:</p><pre><code class="haskell">parse :: [Token] -&gt; Expression</code></pre><p>What remains is to define the approapriate data structures and implement the parsing functions.</p><h2 id="the-grammar"><a href="#the-grammar">The Grammar</a></h2><p>Let's first define a simple grammar using some sort of BNF notation. We expect the result of parsing a line of user input to be an Expression. We'll consider three forms of expressions:</p><ol><li>An additive expression that starts with a Term followed by either plus or minus, followed by another expression. This is a typical recursive definition for parsing expressions of the type <code>Term + Term - Term ... etc.</code>. Example: <code>x - 5 + y</code>.</li><li>An assignment of the form: Identifier equals Expression. For simplicity, I chose to treat an assignment as an expression, as it is in C++, rather than a separate statement. Example: <code>x = 2 + 2</code></li><li>Finally, a lonely Term is also considered an expression. Example: <code>44</code>.</li></ol><p>Terms are more tightly bound than expressions, corresponding to higher precedence of multiplicative vs. additive operators. We'll consider two forms or terms:</p><ol><li>Factor followed by a multiplication or division sign, followed by another term. This production corresponds to terms of the form <code>Factor * Factor / Factor ...</code>. Example: <code>2 * x / 2</code>.</li><li>A Term could also be a lonely Factor. Example: <code>44</code>.</li></ol><p>Finally, the most tightly bound production is that of the Factor, which can be one of:</p><ol><li>A Number, like <code>147</code></li><li>An Identifier (variable name), like <code>x11</code></li><li>A unary plus or minus in front of a Factor, like <code>-x</code> or <code>+12</code>. You can convince yourself that there is no ambiguity between binary and unary uses of these operators.</li><li>A parenthesized Expression, like <code>(a + b/2)</code></li></ol><p>Here's the more formal description of this grammar:</p><pre><code>Expression &lt;- Term [+-] Expression 
            | Identifier '=' Expression
            | Term
Term       &lt;- Factor [*/] Term
            | Factor
Factor     &lt;- Number 
            | Identifier 
            | [+-] Factor 
            | '(' Expression ')' </code></pre><p>To be honest, there's a slight problem with this grammar: the associativity is wrong. Operators of the same precedence associate to the right rather than to the left so, for instance, <code>5 - 3 + 2</code> is interpreted as <code>5 - (3 + 2)</code>. There is a way to transform this grammar to the left-associative one, but it comes at a cost of making the parser slightly more complicated, so I'll leave it as an exercise to the reader.</p><h2 id="the-parse-tree"><a href="#the-parse-tree">The Parse Tree</a></h2><p>The productions of this grammar map nicely into the structure of a tree. For instance, the leaf nodes are either variables or numbers. Expressions generate binary addition/subtraction nodes. Terms produce binary multiplication/division nodes. There are also nodes for unary plus or minus, and the assignment node. We end up with this tree-like recursive data structure:</p><pre><code class="haskell">data Tree = SumNode Operator Tree Tree
          | ProdNode Operator Tree Tree
          | AssignNode String Tree
          | UnaryNode Operator Tree
          | NumNode Double
          | VarNode String
  deriving Show</code></pre><p>Our grammar will always produce parse trees of this type. The opposite is not true: some trees are invalid according to our grammar. (This kind of mismatch tells us that we have to be prepared to deal with runtime parsing errors.)</p><p>Let's have a look at a simple example. This input:</p><pre><code class="haskell">&quot;x1 = -15 / (2 + x2)&quot;</code></pre><p>should produce the following parse tree:</p><p><img alt="Parse Tree" src="https://www.schoolofhaskell.com/content-proxy?src=http%3A%2F%2Fbartosz.com%2Fimages%2FBasics%2FParseTree.PNG" /></p><h2 id="top-down-recursive-parsing"><a href="#top-down-recursive-parsing">Top-Down Recursive Parsing</a></h2><p>Our grammar is ideal for top-down recursive parsing. It doesn't use left recursion and every production requires only one lookahead token. If you're not familiar with the theory of parsing, all you need to know that there is an almost trivial mapping from grammar to implementation. Each production is translated into a function, and each function needs only to look at one token to decide which branch to take. We will need three parsing functions: <code>expression</code>, <code>term</code>, and <code>factor</code>, corresponding to the three productions of our grammar. These functions will consume tokens and produce nodes of the parse tree. In imperative languages, token consumption is implemented using some kind of mutable pointer or a call to a stateful function. Can we implement parsing using pure functions?</p><h3 id="state-without-mutation"><a href="#state-without-mutation">State without Mutation</a></h3><p>At this point I could tell you to use the State monad and be done with it. Instead I will show you how to solve this problem with pure functions and discover the State monad later in the process.</p><p>The trick is to make all the parsing functions not only take the token list as input, but also return the unconsumed part of the token list attached to the output. We've done this on a smaller scale before, with functions like <code>alnums</code>, <code>digits</code>, and their generalization, <code>span</code>. Except that now we'll apply this pattern across a whole family of functions.</p><p>Here are the type signatures for our (pure) parsing functions:</p><pre><code class="haskell">expression :: [Token] -&gt; (Tree, [Token])
term       :: [Token] -&gt; (Tree, [Token])
factor     :: [Token] -&gt; (Tree, [Token])</code></pre><p>It's usually a good idea to provide some helper functions to access tokens. Traditionally, you'd want to look one token ahead and, when you use it in a production, call <code>accept</code> to remove it from the list (actually, return the tail of the list).</p><pre><code class="haskell">lookAhead :: [Token] -&gt; Token
lookAhead [] = TokEnd
lookAhead (c:cs) = c

accept :: [Token] -&gt; [Token]
accept [] = error &quot;Nothing to accept&quot;
accept (t:ts) = ts</code></pre><p>I introduced a new sythesized token, <code>TokEnd</code>. The alternative would be to check for the end of input every time you access the token list, but that would complicate the code unnecessarily. Since we recognize tokens using pattern matching, <code>TokEnd</code> will usually be dealt with by the fallthrough wildcard pattern.</p><p>A word about performance: Behind the scenes, a list is implemented using pointers. Since the list is guaranteed never to be modified, accessing the tail of the list, as in <code>accept</code>, doesn't incur the overhead of copying. Instead it returns a pointer to the second element of the list (or null). If the original list is no longer accessible (goes out of scope), the garbage collector will eventually free the skipped element. In general, because of immutability, garbage collectors in Haskell can be more efficient and easily parallelized.</p><h2 id="expression"><a href="#expression">Expression</a></h2><p>As I mentioned earlier, translating a grammar to a top-down recursive parser is almost mechanical. Here's the production for Expression:</p><pre><code>Expression &lt;- Term [+-] Expression 
            | Identifier '=' Expression
            | Term</code></pre><p>And here's its translation into a parser: We'll first try to parse a Term by calling the function <code>term</code>. Then we'll look ahead at the next token. If it's a <code>TokOp</code> containing <code>Plus</code> or <code>Minus</code> we will create a <code>SumNode</code>. If it's a <code>TokAssign</code>, we'll create an <code>AssignNode</code>. Otherwise we'll just return the lonely Term.</p><p>With each node, we have to also return the remaining token list.</p><pre><code class="haskell">expression :: [Token] -&gt; (Tree, [Token])
expression toks = 
   let (termTree, toks') = term toks
   in
      case lookAhead toks' of
         -- Term [+-] Expression
         (TokOp op) | elem op [Plus, Minus] -&gt; 
            let (exTree, toks'') = expression (accept toks') 
            in (SumNode op termTree exTree, toks'')
         -- Identifier '=' Expression
         TokAssign -&gt;
            case termTree of
               VarNode str -&gt; 
                  let (exTree, toks'') = expression (accept toks') 
                  in (AssignNode str exTree, toks'')
               _ -&gt; error &quot;Only variables can be assigned to&quot;
         -- Term
         _ -&gt; (termTree, toks')</code></pre><p>A reminder: <code>TokAssign</code> was introduced in an exercise in the last tutorial.</p><p>I used the Haskell construct, <code>case</code>/<code>of</code> for pattern matching. It is analogous to the pattern matching used in defining multiple bodies for a function, but can be used as an expression anywhere in your code.</p><p>The code between <code>case</code> and <code>of</code> is an expression that is to be pattern matched. The block following <code>of</code> lists the patterns, each of them followed by an arrow <code>-&gt;</code> and an expression. All expressions have to be of the same type. The value of the whole <code>case</code>/<code>of</code> exrpession is the result of the first expression whose pattern was matched.</p><p>Notice that the assignment branch, <code>Identifier '=' Expression</code>, requires that the left hand side (the <code>termNode</code>) be a <code>VarNode</code>. This condition is checked at runtime and, if not met, results in an error.</p><h2 id="term"><a href="#term">Term</a></h2><p>This is the grammar rule:</p><pre><code>Term       &lt;- Factor [*/] Term
            | Factor</code></pre><p>and that's its straightforward translation into code:</p><pre><code class="haskell">term :: [Token] -&gt; (Tree, [Token])
term toks = 
   let (facTree, toks') = factor toks
   in
      case lookAhead toks' of
         (TokOp op) | elem op [Times, Div] -&gt;
            let (termTree, toks'') = term (accept toks') 
            in (ProdNode op facTree termTree, toks'')
         _ -&gt; (facTree, toks')</code></pre><h2 id="factor"><a href="#factor">Factor</a></h2><p>We proceed with the Factor production the same way:</p><pre><code>Factor     &lt;- Number 
            | Identifier 
            | [+-] Factor 
            | '(' Expression ')' </code></pre><p>Again, tokens <code>LParen</code> and <code>RParen</code> were introduced in an exercise in the previous tutorial.</p><pre><code class="haskell">factor :: [Token] -&gt; (Tree, [Token])
factor toks = 
   case lookAhead toks of
      (TokNum x)     -&gt; (NumNode x, accept toks)
      (TokIdent str) -&gt; (VarNode str, accept toks)
      (TokOp op) | elem op [Plus, Minus] -&gt; 
            let (facTree, toks') = factor (accept toks) 
            in (UnaryNode facTree, toks')
      TokLParen      -&gt; 
         let (expTree, toks') = expression (accept toks)
         in
            if lookAhead toks' /= TokRParen 
            then error &quot;Missing right parenthesis&quot;
            else (expTree, accept toks')
      _ -&gt; error $ &quot;Parse error on token: &quot; ++ show toks
</code></pre><h2 id="parser"><a href="#parser">Parser</a></h2><p>The parsing starts at the top. We are expecting an Expression at the top level, so we call <code>expression</code> and pattern match the result. The expression should exhaust all tokens -- if it doesn't, it's an error.</p><pre><code class="haskell">parse :: [Token] -&gt; Tree
parse toks = let (tree, toks') = expression toks
             in
               if null toks' 
               then tree
               else error $ &quot;Leftover tokens: &quot; ++ show toks'</code></pre><p>The function <code>null</code> returns <code>True</code> if the argument is an empty list.</p><p>Finally, here's the complete parser together with the (extended) tokenizer. The implementation is pretty straightforward but it contains a lot of boilerplate code. Simplifying it by learning common Haskell idioms will be the goal of the next few tutorials.</p><pre><code class="active haskell">import Data.Char

data Operator = Plus | Minus | Times | Div
    deriving (Show, Eq)

data Token = TokOp Operator
           | TokAssign
           | TokLParen
           | TokRParen
           | TokIdent String
           | TokNum Double
           | TokEnd
    deriving (Show, Eq)

operator :: Char -&gt; Operator
operator c | c == '+' = Plus
           | c == '-' = Minus
           | c == '*' = Times
           | c == '/' = Div
 
tokenize :: String -&gt; [Token]
tokenize [] = []
tokenize (c : cs) 
    | elem c &quot;+-*/&quot; = TokOp (operator c) : tokenize cs
    | c == '='  = TokAssign : tokenize cs
    | c == '('  = TokLParen : tokenize cs
    | c == ')'  = TokRParen : tokenize cs
    | isDigit c = number c cs
    | isAlpha c = identifier c cs
    | isSpace c = tokenize cs
    | otherwise = error $ &quot;Cannot tokenize &quot; ++ [c]

identifier :: Char -&gt; String -&gt; [Token]
identifier c cs = let (name, cs') = span isAlphaNum cs in
                  TokIdent (c:name) : tokenize cs'

number :: Char -&gt; String -&gt; [Token]
number c cs = 
   let (digs, cs') = span isDigit cs in
   TokNum (read (c : digs)) : tokenize cs'

---- parser ----

data Tree = SumNode Operator Tree Tree
          | ProdNode Operator Tree Tree
          | AssignNode String Tree
          | UnaryNode Operator Tree
          | NumNode Double
          | VarNode String
    deriving Show

lookAhead :: [Token] -&gt; Token
lookAhead [] = TokEnd
lookAhead (t:ts) = t

accept :: [Token] -&gt; [Token]
accept [] = error &quot;Nothing to accept&quot;
accept (t:ts) = ts

expression :: [Token] -&gt; (Tree, [Token])
expression toks = 
   let (termTree, toks') = term toks
   in
      case lookAhead toks' of
         (TokOp op) | elem op [Plus, Minus] -&gt; 
            let (exTree, toks'') = expression (accept toks') 
            in (SumNode op termTree exTree, toks'')
         TokAssign -&gt;
            case termTree of
               VarNode str -&gt; 
                  let (exTree, toks'') = expression (accept toks') 
                  in (AssignNode str exTree, toks'')
               _ -&gt; error &quot;Only variables can be assigned to&quot;
         _ -&gt; (termTree, toks')

term :: [Token] -&gt; (Tree, [Token])
term toks = 
   let (facTree, toks') = factor toks
   in
      case lookAhead toks' of
         (TokOp op) | elem op [Times, Div] -&gt;
            let (termTree, toks'') = term (accept toks') 
            in (ProdNode op facTree termTree, toks'')
         _ -&gt; (facTree, toks')

factor :: [Token] -&gt; (Tree, [Token])
factor toks = 
   case lookAhead toks of
      (TokNum x)     -&gt; (NumNode x, accept toks)
      (TokIdent str) -&gt; (VarNode str, accept toks)
      (TokOp op) | elem op [Plus, Minus] -&gt; 
            let (facTree, toks') = factor (accept toks) 
            in (UnaryNode op facTree, toks')
      TokLParen      -&gt; 
         let (expTree, toks') = expression (accept toks)
         in
            if lookAhead toks' /= TokRParen 
            then error &quot;Missing right parenthesis&quot;
            else (expTree, accept toks')
      _ -&gt; error $ &quot;Parse error on token: &quot; ++ show toks

parse :: [Token] -&gt; Tree
parse toks = let (tree, toks') = expression toks
             in
               if null toks' 
               then tree
               else error $ &quot;Leftover tokens: &quot; ++ show toks'

main = (print . parse . tokenize) &quot;x1 = -15 / (2 + x2)&quot;</code></pre><p>The output of the test program, after some manual formatting, should look like this (compare with the earlier picture):</p><pre><code>AssignNode &quot;x1&quot; 
  (ProdNode Div 
     (UnaryNode Minus 
        (NumNode 15.0)) 
     (SumNode Plus 
        (NumNode 2.0)
        (VarNode &quot;x2&quot;)))</code></pre><p>In the next installment, we'll implement the evaluator for our expression trees.</p><h2 id="exercises"><a href="#exercises">Exercises</a></h2><p><b>Ex 1.</b> The shape of a binary tree may be encoded using matching pairs of parentheses. The string of parentheses obtained this way matches the following grammar:</p><pre><code>Root  &lt;- Par
Expr  &lt;- Par Par
Par   &lt;- '(' Expr ')'
       | '(' ')'</code></pre><p>Write a parser based on this grammar:</p><pre><code class="active haskell">data Token = TokLParen | TokRParen | TokEnd
    deriving (Show, Eq)

lookAhead :: [Char] -&gt; Token
lookAhead [] = TokEnd
lookAhead (c:cs)| c == '(' = TokLParen
                | c == ')' = TokRParen
                | otherwise = error $ &quot;Bad input: &quot; ++ (c:cs)

accept :: [Char] -&gt; [Char]
accept [] = error &quot;Nothing to accept&quot;
accept (c:cs) = cs

data Tree = Node Tree Tree | Leaf
    deriving Show

root, expr, par :: [Char] -&gt; (Tree, [Char])

root = undefined
expr = undefined
par  = undefined

parse str = let (tree, str') = root str
            in
                if null str' 
                then tree 
                else error $ &quot;Unconsumed string &quot; ++ str'

main = print $ parse &quot;(()(()()))&quot;
        </code></pre><div class="hidden" title="Show solution"><pre><code class="active haskell">data Token = TokLParen | TokRParen | TokEnd
    deriving (Show, Eq)

lookAhead :: [Char] -&gt; Token
lookAhead [] = TokEnd
lookAhead (c:cs)| c == '(' = TokLParen
                | c == ')' = TokRParen
                | otherwise = error $ &quot;Bad input: &quot; ++ (c:cs)

accept :: [Char] -&gt; [Char]
accept [] = error &quot;Nothing to accept&quot;
accept (c:cs) = cs

data Tree = Node Tree Tree | Leaf
    deriving Show

root, expr, par :: [Char] -&gt; (Tree, [Char])

root = par

expr toks = 
    let (p, toks')   = par toks 
        (p', toks'') = par toks'
    in (Node p p', toks'')
    
par toks = 
    case lookAhead toks of
      TokLParen -&gt;
        case lookAhead (accept toks) of
          TokRParen -&gt; (Leaf, accept (accept toks))
          _ -&gt; let (e, toks') = expr (accept toks) 
               in  if lookAhead toks' == TokRParen
                   then (e, accept toks')
                   else error $ &quot;Missing closing paren in: &quot; ++ show toks'
      _ -&gt; error $ &quot;Bad expression: &quot; ++ show toks

parse str = let (tree, str') = root str
            in
                if null str' 
                then tree 
                else error $ &quot;Unconsumed string &quot; ++ str'

main = print $ parse &quot;(()(()()))&quot;
        </code></pre></div><p><b>Ex 2.</b> Write a parser that splits a string into a list of words using space characters as separators (use function <code>isSpace</code>).</p><pre><code class="active haskell">import Data.Char

type Word = String

sentence :: String -&gt; [Word]
sentence = undefined

-- returns a word and the rest of input
word :: String -&gt; (Word, String)
word = undefined
                          
main = print $ sentence &quot;Ceci n'est pas une phrase&quot;</code></pre><div class="hidden" title="Show solution"><pre><code class="active haskell">import Data.Char

type Word = String

sentence :: String -&gt; [Word]
sentence &quot;&quot; = []
sentence str = let (w, str') = word str
               in w : sentence str'

word :: String -&gt; (Word, String)
word &quot;&quot; = (&quot;&quot;, &quot;&quot;)
word (c:cs) | isSpace c = (&quot;&quot;, cs)
            | otherwise = let (w, cs') = word cs
                          in (c:w, cs')

main = print $ sentence &quot;Ceci n'est pas une phrase&quot;</code></pre><p>You can also implement <code>word</code> using <code>span</code>:</p><pre><code class="haskell">word str = let (w, str')  = span (not . isSpace) str
               (_, str'') = span isSpace str'
           in (w, str'')</code></pre></div><p><b>Ex 3.</b> Generalize the <code>sentence</code> parser from (Ex 2) to take a pluggable parser. The new function is called <code>several</code> and takes as an argument a generic function <code>String-&gt;(a, String)</code>, which is supposed to parse a string and return the result of type <code>a</code> together with the leftover string. Use it to split a string into a list of numbers.</p><pre><code class="active haskell">import Data.Char

type Parser a = String -&gt; (a, String)

several :: Parser a -&gt; String -&gt; [a]
several = undefined

num :: Parser Int
num str = undefined

main = print $ several num &quot;12 4 128&quot;</code></pre><div class="hidden" title="Show solution"><pre><code class="active haskell">import Data.Char

type Parser a = String -&gt; (a, String)

several :: Parser a -&gt; String -&gt; [a]
several p &quot;&quot; = []
several p str = let (a, str') = p str
                    as = several p str'
                in a:as

num :: Parser Int
num str = 
    let (digs, str') = span isDigit str
        (_, str'')   = span isSpace str'
    in (read digs, str'')

main = print $ several num &quot;12 4 128&quot;</code></pre></div></article>

<div id="disqus_thread"><script>var disqus_shortname = "bartosz_milewski"; (function() { var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true; dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq); })();</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">comments powered by <span class="logo-disqus">Disqus</span></a></a>
</div>

</div>
</div>
<div class="row article-footer"><div class="span7 meta"><span class="sociallinksunicode social">
<a href="https://twitter.com/home?status=$url$" target="_blank"><i class="icon-twitter"></i></a>&nbsp;
<a href="http://www.facebook.com/sharer/sharer.php?u=$url$" target="_blank"><i class="icon-facebook"></i></a>&nbsp;
<a href="https://plus.google.com/share?url=$url$" target="_blank"><i class="icon-google-plus"></i></a></span>
</div>
</div>
</div>
<div class="footer"><div class="container"><div class="row"><div class="span12"><ul class="menu"><li><a href="https://www.schoolofhaskell.com/">School</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user">Users</a>
</li>

<li><a class="brand" href="https://fpcomplete.com">Sponsored by:
<img src="/static/img/logo.png" title="FPComplete">
</a>
</li>
</ul>
</div>
</div>
<div class="row"><div class="span12"></div>
</div>
</div>
</div>
<link rel="stylesheet" type="text/css" href="/static/bootstrap/css/bootstrap-responsive.css" />
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script><script src="https://www.schoolofhaskell.com/static/combined/Y-3k9_tW.js"></script><script>$(function(){
  $("a.logout").click(function(){
    var form = $("<form method='post'/>");
    form.attr("action", $(this).attr("href"));
    $("body").append(form);
    form.submit();
    return false;
  });
});

$(function(){
    $('.sociallinksunicode a').each(function(){
        $(this).attr('href',$(this).attr('href').replace('$url$',document.location));
    });
});

$(function(){
  // If we need to select a user/select a password then show the
  // details confirmation form, otherwise enable the getting started
  // section.
  if($('.alert-block a').text().match(/(selected a username|change your password)/)) {
    $("#confirm-details").show();
    $("#confirm-details #inputUsername").focus();
  } else {
    $("#get-started").removeClass('disabled').addClass('enabled');
  }

  // For lack of a plain HTML validation story this will do.
  $('.welcome-page').each(function(){
    $('form').submit(check);
  });
  function check(){
    setTimeout(check,500);
    var error = false;
    $('.error').removeClass('error');
    $('#enter-details input').each(function(){
      if($(this).val() == '') {
        $(this).parent().parent().addClass('error');
        error = true;
      }
    });
    if(error) return false;
    if($('[name=password]').val() == $('[name=confirm]').val()) {
      $('#confirm').removeClass('error');
      return true;
    } else {
      $('#confirm').addClass('error');
      return false;
    }
  }
});

$(function(){
  // When scrolling over a snippet editor, activate the "clone in IDE" popovers
  $('article').each(function(){
    var n = 100;
    var wait = 10000;
    function check(){
      if($('.clone').length == 0) {
        setTimeout(check,n);
        return;
      }
      var activated = $.cookie('clone-popover');
      if (activated) return;
      var activate = false;
      $('.controlsRun:onScreen').each(function(){
        $.cookie('clone-popover', 'true', { expires: 30, path: '/' });
        activate = true;
        return false;
      });
      if(activate) {
          $('.clone').each(function(){
              // The bootstrap API is rather unreasonable to say the
              // least.
              next = $(this).parent();
              var title = next.attr('title');
              next.attr('data-content',$(this).attr('data-content'));
              next.attr('title',$(this).attr('title'));
              next.popover('show',{
                  title: $(this).attr('title')
              });
              next.attr('title',title);
          });
          setTimeout(function(){
              $('.clone').each(function(){
                  $(this).parent().popover('hide');
              });
          },wait);
      } else {
        setTimeout(check,n);
      }
    }
    setTimeout(check,n);
  });
});

// onScreen jQuery plugin v0.2.1
// (c) 2011-2013 Ben Pickles
//
// http://benpickles.github.com/onScreen
//
// Released under MIT license.
(function(a){a.expr[":"].onScreen=function(b){var c=a(window),d=c.scrollTop(),e=c.height(),f=d+e,g=a(b),h=g.offset().top,i=g.height(),j=h+i;return h>=d&&h<f||j>d&&j<=f||i>e&&h<=d&&j>=f}})(jQuery);

/*!
 * jQuery Cookie Plugin v1.1
 * https://github.com/carhartl/jquery-cookie
 *
 * Copyright 2011, Klaus Hartl
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.opensource.org/licenses/GPL-2.0
 */
(function($, document) {

  var pluses = /\+/g;
  function raw(s) {
    return s;
  }
  function decoded(s) {
    return decodeURIComponent(s.replace(pluses, ' '));
  }

  $.cookie = function(key, value, options) {

    // key and at least value given, set cookie...
    if (arguments.length > 1 && (!/Object/.test(Object.prototype.toString.call(value)) || value == null)) {
      options = $.extend({}, $.cookie.defaults, options);

      if (value == null) {
	options.expires = -1;
      }

      if (typeof options.expires === 'number') {
	var days = options.expires, t = options.expires = new Date();
	t.setDate(t.getDate() + days);
      }

      value = String(value);

      return (document.cookie = [
	encodeURIComponent(key), '=', options.raw ? value : encodeURIComponent(value),
	options.expires ? '; expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE
	options.path    ? '; path=' + options.path : '',
	options.domain  ? '; domain=' + options.domain : '',
	options.secure  ? '; secure' : ''
      ].join(''));
    }

    // key and possibly options given, get cookie...
    options = value || $.cookie.defaults || {};
    var decode = options.raw ? raw : decoded;
    var cookies = document.cookie.split('; ');
    for (var i = 0, parts; (parts = cookies[i] && cookies[i].split('=')); i++) {
      if (decode(parts.shift()) === key) {
	return decode(parts.join('='));
      }
    }
    return null;
  };
  $.cookie.defaults = {};})(jQuery, document);
</script><!--[if lt IE 10]><script src="https://www.schoolofhaskell.com/static/design/js/ie.js?etag=ayV2DuJ0"></script><![endif]--><script>if(!window.location.href.match(/localhost/)){var track = '/tutorial/user/bartosz/basics-of-haskell/8_Parser';
window._gaq = [['_setAccount','UA-36928035-1'],track != ''? ['_trackPageview',track] : ['_trackPageview']
,['_trackPageLoadTime']];window._gaq.push(['_setCustomVar',1,'Section','School of Haskell',3]);
window._gaq.push(['_setCustomVar',2,'User Type','Visitor',1]);
(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);

})();}</script>
<!-- Prompt IE 6 users to install Chrome Frame. Remove this if you want to support IE 6.  chromium.org/developers/how-tos/chrome-frame-getting-started --><!--[if lt IE 7 ]><script src="//ajax.googleapis.com/ajax/libs/chrome-frame/1.0.3/CFInstall.min.js"></script><script>window.attachEvent('onload',function(){CFInstall.check({mode:'overlay'})})</script><![endif]--></body></html>