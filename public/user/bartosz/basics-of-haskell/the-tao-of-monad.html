<!DOCTYPE html>
<html><head><title>3.a The Tao of Monad - School of Haskell | School of Haskell</title><meta http-equiv="x-ua-compatible" content="IE=9"><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="google-site-verification" content="Rfxk2TdeMMXEXHgJ2_OO8Rt3hPbQSDao0OXQV_n6z_s" /><link href="//fonts.googleapis.com/css?family=Merriweather" rel="stylesheet" type="text/css"><link href="https://www.schoolofhaskell.com/recent-content/feed" type="application/rss+xml" rel="alternate" title="Recently published content">
<link rel="stylesheet" href="https://www.schoolofhaskell.com/static/combined/UlwEHVcM.css"><style>.social{margin-right:1em}h1{font-family:Merriweather !important}article{font-family:Merriweather !important}article li{font-family:Merriweather !important;line-height:1.6em}h1,h2,h3,h4,h4,h5{font-family:Merriweather !important}.editor p{font-family:Frutiger, "Frutiger Linotype", Univers, Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans Condensed", "Liberation Sans", "Nimbus Sans L", Tahoma, Geneva, "Helvetica Neue", Helvetica, Arial, sans-serif}.article-footer{border-top:1px solid #ddd;padding-top:1em;margin-top:1em}body{font-size:16px !important}.navbar .navbar-inner{background:#3c3f41}.navbar .brand{font-size:14px}.navbar .brand img{width:6em}.navbar .icon-wrench{margin:0 -0.5em 0 -0.5em;padding:0 1em 0 1em;height:20px}.navbar-inverse .nav .active a{background:#333638}.navbar-inverse .nav > li > a{color:#a7a7a7
}.navbar-inverse .btn-navbar{background:#333638}.navbar-inverse .nav > li a:hover,.navbar-inverse .btn{background:#333537 !important}@media (max-width: 979px) {.icon-wrench{padding-left:1em !important}}.breadcrumb{border-top-left-radius:0;border-top-right-radius:0}h1{margin-top:20px}.breadcrumb-container + .main-content h1{margin-top:0}.footer{padding:30px 0;margin-top:70px;border-top:1px solid #e5e5e5;background-color:#f5f5f5}.footer ul.footer-menu{list-style-type:none}.footer ul.footer-menu li{display:inline-block}.footer ul.footer-menu li + li{margin-left:0.5em}.footer ul.footer-menu li + li:before{margin-right:0.5em;content:"·";color:#999}.footer ul.menu li{display:inline-block}.footer ul.menu li + li{margin-left:0.5em}.footer .copyright{margin-left:25px}.main-content{min-height:100%}.gravatar{width:80px;height:80px;border-radius:2px;background:#eee}.empty-gravatar{width:0}.container{font-family:"Segoe UI", Candara, "Bitstream Vera Sans", "DejaVu Sans", "Bitstream Vera Sans", "Trebuchet MS", Verdana, "Verdana Ref", sans-serif}.container h1,.container h2,.container h4,.container h4,.container h5{font-family:"Segoe UI", Candara, "Bitstream Vera Sans", "DejaVu Sans", "Bitstream Vera Sans", "Trebuchet MS", Verdana, "Verdana Ref", sans-serif}article{font-family:Merriweather !important}article h1{font-family:Merriweather !important}article li{font-family:Merriweather !important;line-height:1.6em}article li + li{margin-top:0.5em}article div.code{background:#f9f9f9;border:1px solid #d1d1d1;position:relative;border-radius:0.2em;margin:0.25em 0 0.75em 0;min-height:2.5em}article code{color:#005580;font-size:14px;white-space:pre}article a.hoogle > code{color:#0088cc;font-size:14px;white-space:pre;border:0}article .expand-code{display:none}article pre{overflow:auto;word-wrap:normal}article code.active{display:block;max-height:430px}article h1{font-size:31.5px}article h3{font-size:17.5px}article h4{font-size:14px}article h5,article h6{font-size:11.9px}article p{line-height:1.7em}article h1 code,article h2 code,article h3 code,article h4 code,article h5 code,article h6 code{font-size:inherit !important}article h1 a,article h2 a,article h3 a,article h4 a,article h5 a,article h6 a{color:#444}article h1 a:before,article h2 a:before,article h3 a:before,article h4 a:before,article h5 a:before,article h6 a:before{margin-left:-1.5em;padding-right:0.5em;font-family:fontawesome;content:"\f0c1";font-size:20px;color:#fff}article h1 a:hover,article h2 a:hover,article h3 a:hover,article h4 a:hover,article h5 a:hover,article h6 a:hover{text-decoration:none;color:#0088cc}article h1 a:hover:before,article h2 a:hover:before,article h3 a:hover:before,article h4 a:hover:before,article h5 a:hover:before,article h6 a:hover:before{color:#888}article h2{font-size:24.5px}article .popover{font-family:actor}article .popover h3.popover-title{font-family:actor !important;font-size:1em}article .popover .popover-content{width:15em;font-size:1em}article .controlsRun{display:block;padding:0.5em;text-align:right;background:#f2f2f2}article .controlsRun a.clone{margin-right:1em;font-family:actor;text-decoration:none}article .controlsRun a.clone span{padding-left:0.5em}article .controlsRun a.run,article .controlsRun a.reset,article .controlsRun a.show-code{font-size:16px}article .controlsRun a.run span,article .controlsRun a.reset span,article .controlsRun a.show-code span{display:none}article .controlsRun a.reset{margin-left:0.5em;color:#a2becc}article .controlsRun a.reset{display:none}article .controlsRun a.show-code{margin-right:0.75em}article .controlsRun a.run:hover,article .controlsRun a.show-code:hover{text-decoration:none}article .controlsRun a.show-code.active{color:#DC0D0D}article .controlsRun a[disabled]{color:#a2becc;cursor:default}article .collapse-area .collapse-header{background:#0088cc;color:#fff;padding:0.3em;cursor:pointer}article .collapse-area .hidden-toggle:before{content:"\f0d7";font-family:fontawesome;margin-right:0.5em;margin-left:0.25em}article .collapse-area .collapsed-files{overflow:auto;height:auto}article .collapse-area.collapse-disabled{display:none}article .collapse-area.collapse-area-off .collapsed-files{height:0px;overflow:hidden}article .collapse-area.collapse-area-off .hidden-toggle:before{content:"\f0da"}article .snippet-stdio .stdout{margin:0.5em;padding-right:2em;position:relative;word-wrap:break-word}article .snippet-stdio .stdin{-webkit-box-shadow:none;-moz-box-shadow:none;box-shadow:none;-webkit-transition:none;-moz-transition:none;-o-transition:none;transition:none;padding:0;margin:0}article .hoogle-results{margin:0.25em}article .hoogle-results .hoogle-inner{background:#fff;padding:0.5em;border-radius:3px;border:1px solid #ddd}article .hoogle-results .hoogle-inner .close-link{position:relative;float:right;margin-top:-0.5em;margin-right:-0.5em}article .snippet-output-errors{margin:1em 0.5em 0.5em 0.5em;position:relative}article .snippet-output-errors ul{list-style-type:none;margin:0;position:relative}article .snippet-output-errors pre{border:0;border-radius:0;padding:0.25em;margin:0;background:inherit;color:inherit}article .snippet-output-errors .close-link{color:inherit;background:inherit}article .snippet-editors{z-index:0;padding:0.25em}article .close-link{padding:0.5em;background:#eaeaea;border-bottom-left-radius:0.2em;border-top-right-radius:0.2em;position:absolute;top:0;right:0}article .close-link:hover{text-decoration:none}article .snippet-title{padding:0.5em 0 0 0.5em}article .snippet-title .snippet-icon{font-family:FontAwesome;display:inline-block;margin-right:0.5em}article .fullModuleCode + div .snippet-title{margin-top:0.5em;border-top:1px solid #ccc;padding-top:0.5em}article .CodeMirror{height:auto;min-height:1em;line-height:1.5em;background:transparent;font-size:14px !important}article .CodeMirror .highlighted{background:rgba(250, 210, 0, 0.45) !important}article .CodeMirror-widget{margin-left:2em;line-height:1.8}article .CodeMirror.collapsed{height:10em !important}article .editor .expander{text-align:center;display:block;padding:0.5em;text-decoration:none;border-bottom-left-radius:2px;border-bottom-right-radius:2px}article .editor .expander .ellipsis{background:white;border:1px solid #ccc;padding:0 0.5em;height:1em;line-height:0.5em;display:inline-block;color:#555;cursor:pointer}article .editor .expander .ellipsis:hover{background:#ddd;color:#333}article .web-runner{margin:0.5em;padding:0.5em;border:1px solid #ccc;border-radius:3px;background:#f5f5f5}article .web-runner iframe{border:0;margin-top:0.5em;margin-bottom:0;background:white}article .web-runner .controls i{cursor:pointer;color:#0088cc}article .web-runner .controls i:hover{color:#222}article .web-runner .controls i + i{margin-left:0.5em}article .web-runner .controls .icon-remove{float:right}article .hidden{display:block;visibility:visible}article .controlsShowHide{margin-bottom:0.5em}.tutorial-body{float:left !important}.tutorial-nav{float:right !important}@media (max-width: 979px) {.related-content{float:right}.author-name{display:block;margin-left:20px !important;padding-left:5px;margin-top:5px}article h1 a:hover:before,article h2 a:hover:before,article h3 a:hover:before,article h4 a:hover:before,article h5 a:hover:before,article h6 a:hover:before{color:#fff}.tutorial-nav{float:none !important;width:auto !important}.tutorial-body{float:none !important;width:auto !important}}@media (min-width: 980px) and (max-width: 1199px) {.navbar-search{display:none}.tutorial-nav{width:200px}.tutorial-body{width:720px}}#accountPage h1{margin:20px 0 0 0}#accountPage h2{font-size:20px}.group-contents .span8{float:left}.group-contents .span4{float:right}.container > .alert-block{margin-top:1em}.alert{color:#aa874a
}.social{margin-bottom:.8em;display:block}.social a{text-decoration:none}.social i{font-size:1.1em;color:#fff;padding:0.25em;border-radius:0.25em;width:1em;display:inline-block;text-align:center}.social i.icon-twitter{background:#0088cc}.social i.icon-facebook{background:#3b5998
  }.social i.icon-google-plus{background:#dd4b39
  }.well pre{background:#fcfcfc}.well h2{margin-top:0}code{color:#005580;font-size:14px;white-space:pre}</style><!--[if lt IE 8]><link rel="stylesheet" href="https://www.schoolofhaskell.com/static/design/css/ie7.css?etag=TSMl9x1V"><![endif]--><!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]--></head><body class="not-logged-in" itemscope itemtype="http://schema.org/Product"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-H62P" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-H62P');</script><div class="navbar navbar-inverse navbar-static-top"><div class="navbar-inner"><div class="container"><a class="btn btn-navbar" type="button" data-toggle="collapse" data-target=".nav-collapse"><span class="icon-bar"></span>
<span class="icon-bar"></span>
<span class="icon-bar"></span>
</a>
<a class="brand" href="/"><img src="/static/img/haskell-logo-wide.png" title="School of Haskell">
</a>
<div class="nav-collapse collapse"><ul class="nav"><li><a href="https://www.schoolofhaskell.com/">School</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user">Users</a>
</li>
</ul>
<form class="navbar-search pull-left" action="https://www.schoolofhaskell.com/search"><input class="search-query" type="text" placeholder="Search" name="search">
</form>
</div>
</div>
</div>
</div>
<div class="container breadcrumb-container"><div class="row"><div class="span12"><ul class="breadcrumb"><li><a href="https://www.schoolofhaskell.com/user/bartosz">Bartosz Milewski</a>
<span class="divider">/</span>
</li>
<li><a href="https://www.schoolofhaskell.com/user/bartosz/basics-of-haskell">Basics of Haskell</a>
<span class="divider">/</span>
</li>
<li><a href="https://www.schoolofhaskell.com/user/bartosz/basics-of-haskell/the-tao-of-monad">3.a The Tao of Monad</a>
</li>
</ul>
</div>
</div>
</div>
<div class="container main-content"><div class="row"><div class="span12"><h1 itemprop="name">3.a The Tao of Monad</h1>
</div>
</div>
<div class="row"><div class="span7 meta"><p><span class="date">27 Dec 2013</span>
<span class="author"><a href="https://www.schoolofhaskell.com/user/bartosz">Bartosz Milewski</a>
</span>
<span class="view-edit-link pull-right"><a class="view-source-link" href="https://www.schoolofhaskell.com/tutorial-raw/4/05e80b1b41e11475f57308a23e96b88aea1c469a">View Markdown source</a>
</span>
</p>
<p class="tags"></p>
</div>
</div>
<div class="row"><div class="span7 meta"><span class="sociallinksunicode social">
<a href="https://twitter.com/home?status=$url$" target="_blank"><i class="icon-twitter"></i></a>&nbsp;
<a href="http://www.facebook.com/sharer/sharer.php?u=$url$" target="_blank"><i class="icon-facebook"></i></a>&nbsp;
<a href="https://plus.google.com/share?url=$url$" target="_blank"><i class="icon-google-plus"></i></a></span>
</div>
</div>
<p class="alert">As of March 2020, School of Haskell has been switched to read-only mode.</p>
<div class="row" itemprop="desc"><div class="span4 tutorial-nav"><div class="related-content"><ul class="nav nav-tabs nav-stacked"><li><script>reddit_target='fpcomplete'</script>
<script src="https://redditstatic.s3.amazonaws.com/button/button1.js"></script>
</li>
<li><a href="https://www.schoolofhaskell.com/user/bartosz/basics-of-haskell/3-pure-functions-laziness-io">Previous content: 3. Pure Functions, Laziness, I/O, and Monads</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user/bartosz/basics-of-haskell/4-symbolic-calculator-recursion">Next content: 4. Symbolic Calculator: Recursion</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user/bartosz/basics-of-haskell">Go up to: Basics of Haskell</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user/bartosz">See all content by Bartosz Milewski</a>
</li>
</ul>

</div>
<div class="aside"><h3>Sections</h3>
<ul><li><a href="#the-tao-of-monad">The TAO of Monad</a></li><li><a href="#pure-functions">Pure Functions</a></li><li><a href="#simple-i-o">Simple I/O</a></li><li><a href="#the-te-of-laziness">The TE of Laziness</a></li><li><a href="#sequencing">Sequencing</a></li><li><a href="#conclusion">Conclusion</a></li><li><a href="#exercises">Exercises</a></li><li><a href="#bibliography">Bibliography</a></li></ul></div>
</div>
<div class="span8 tutorial-body" data-environment="ghc-7.8-stable-14.09">
<article><h2 id="the-tao-of-monad"><a href="#the-tao-of-monad">The TAO of Monad</a></h2><p>There comes a time in every Haskell tutorial when you have to have a serious talk about monads. If I wait too long, you'll get the impression that Haskell is only good for doing math -- especially after you read the section on pure functions. If I start too early, you may be put off by a lot of theoretical talk that makes no sense without proper context.</p><p>So far I've been trying to be truthful, even if I wasn't telling the whole truth. I could continue this way with monads and get into category theory, morphisms, functors, type theory, and all this theoretical stuff. But I know that not everybody loves higher math.</p><p>Or I could start lying. The problem with lying is that Haskell purists would notice and drive me out of town with pitchforks and torches.</p><p>But there is a third way: mystical rather than categorical. I can follow the ancient Chinese sage Lao Tzu who essentially wrote the first Haskell manual called Tao Te Ching. The Tao is supposed to be as elusive as the Monad:</p><pre><code>The TAO (Monad) that can be told is not the eternal TAO (Monad).</code></pre><p>The fact that Lao Tzu didn't stop writing after this opening gives me hope that I can do it too: Talk about the Monad without defining it. Starting with this caveat:</p><pre><code>However I describe the Monad to you, I'll be missing something important.
 -- Bartosz Milewski</code></pre><h2 id="pure-functions"><a href="#pure-functions">Pure Functions</a></h2><p>Unlike in imperative languages, a function in Haskell is <i>really</i> a function, just as mathematicians intended it to be. To distinguish it from cheap imitations, Haskell functions are sometimes called <i>pure</i> functions. Here are the fundamental properties of a pure function:</p><ol><li>A function returns exactly the same result every time it's called with the same set of arguments. In other words a function has no state, nor can it access any external state. Every time you call it, it behaves like a newborn baby with blank memory and no knowledge of the external world.</li><li>A function has no side effects. Calling a function once is the same as calling it twice and discarding the result of the first call. In fact if you discard the result of any function call, Haskell will spare itself the trouble and never call the function. No wonder Haskell has a reputation for laziness (more about it later).</li></ol><p>One of the major strengths of Haskell is that the execution of pure functions can be easily parallelized  because they have no side effects. With no side effects there are no data races -- the bane of parallel programming.</p><p>However and astute reader might at this point start doubting the sanity of programming in Haskell. How can a program built from pure functions do anything useful other than heat up the processor during cold winters in Siberia?</p><h2 id="simple-i-o"><a href="#simple-i-o">Simple I/O</a></h2><p>And yet, even the simplest program in Haskell does more than stir electrons in a CPU.</p><pre><code class="active haskell">main = putStrLn &quot;Hello World!&quot;</code></pre><p>Run this code and you'll see that it miraculously makes text appear on your screen. A pure function can't do that -- it can't have side effects!</p><p>Here's the somewhat mystical explanation of how this is possible:</p><ol><li>All functions in Haskell are pure, including <code>main</code></li><li>The runtime calls <code>main</code>, which produces a <i>monadic action</i>.</li><li>This monadic action, when given the Universe as input, produces a new modified Universe.</li><li>We continue living in this new Universe</li></ol><p>In the case of the Hello World program, the Universe is modified by displaying the text &quot;Hello World!&quot; on your screen.</p><p>So the Universe we are living in is being constantly modified by Haskell programs. That's why being a Haskell programmer feels like being the Master of the Universe.</p><p>I should probably mention that this is not how Haskell I/O is implemented in real life. But in most cases the implementation behaves just like this mystical ideal. And that's the conceptual model you should be using when reasoning about Haskell programs.</p><p>The monad that deals with actions operating on the Universe is called the <i>IO monad</i>. It's just one of many monads, but it's pretty important because of the special role of the <code>main</code> function. This function <i>must</i> evaluate to an IO monadic object. If you don't believe me, try this for instance:</p><pre><code class="active haskell">main = True</code></pre><p>Don't worry about the meaning of the compiler error message. Just notice that it contains the symbol <code>IO</code> -- that's the IO monad I've been talking about.</p><p>So how did my previous examples work? I just made sure that <code>main</code> called functions like <a class="hoogle" href="https://www.stackage.org/lts/hoogle?q=putStrLn" title="Hoogle search for: putStrLn"><code>putStrLn</code></a> or <a class="hoogle" href="https://www.stackage.org/lts/hoogle?q=print" title="Hoogle search for: print"><code>print</code></a>, which return monadic IO actions, which were then returned from <code>main</code>. These function are, in turn, built from simpler functions also returning IO actions. If you follow this chain, you'll find that there is only one source of IO actions: primitives built into the language. In Haskell, you can't create an IO action from scratch, no matter how hard you try. Also, you can't execute an IO action inside the program. For that you have to return it from <code>main</code>. So an IO action is truly indescribable.</p><p>Now you might be thinking that monads are about actions. So let me get the record straight:</p><pre><code>Monad that is about actions, is not the eternal Monad.
 -- Bartosz Milewski</code></pre><h2 id="the-te-of-laziness"><a href="#the-te-of-laziness">The TE of Laziness</a></h2><p>TE means <i>virtue</i>. We usually don't think of laziness as virtue. Spending hours in a couch in front of a TV drinking beer and munching junk food can hardly be considered a good thing. But let's see what Tao Te Ching has to say about it:</p><pre><code>Those highest in TE take no action
And don't need to act.</code></pre><p>Haskell takes laziness seriously. It will not calculate anything unless it's strictly necessary (of if forced by the programmer). Haskell is so lazy that it won't even evaluate arguments to a function before calling it. Unless proven otherwise, Haskell assumes that the arguments will not be used by the function, so why bother.</p><p>Let me demonstrate Haskell's laziness through a simple example. There are some expressions that, when evaluated, lead to a runtime error -- definitely not as many as in other languages but still, there are some. Division by zero comes to mind. There is also a built in object that, by definition, can never be evaluated. It's called <code>undefined</code>. It's sort of like <code>null</code> in Java. Try running this program:</p><pre><code class="active haskell">main = print $ undefined + 1</code></pre><p>Notice that the compiler doesn't complain that you're trying to add <code>undefined</code> to 1. I'll explain it this leniency later. But when this program is run, it terminates with a runtime error because it tries to evaluate <code>undefined</code>. But try this instead:</p><pre><code class="active haskell">foo x = 1
main = print $ (foo undefined) + 1</code></pre><p>Here, Haskell calls <code>foo</code> but never evaluates its argument. You might think that it's an optimization: The compiler sees the definition of <code>foo</code> and figures out that <code>foo</code> discards its argument <code>x</code>. But the result is the same if the definition of <code>foo</code> is hidden from view in another module. We haven't talked about modules, but just to make this point, here's the same example split between two files:</p><pre><code class="active haskell">{-# START_FILE Foo.hs #-}
-- show
module Foo (foo) where
foo x = 1
{-# START_FILE Main.hs #-}
-- show
import Foo
main = print $ (foo undefined) + 1</code></pre><p>Later you'll see that Haskell's laziness allows it also to deal with the Infinite, for instance, infinite list, or with the future that hasn't materialized yet.</p><p>Laziness or not, a program needs to be executed at some point.</p><pre><code>Teaching without words,
Benefit witout action --
Few in this world can attain this</code></pre><p>So what makes a program run? There are several reasons why an expression would have to be evaluated -- the fundamental one being that somebody wants to display its result. So, really, without I/O nothing would ever be evaluated (which would lead to tremendous energy savings).</p><h2 id="sequencing"><a href="#sequencing">Sequencing</a></h2><pre><code>Big things are built from smaller things. We call this composability.
 -- Bartosz Milewski</code></pre><p>As I mentioned earlier, larger IO actions are built from smaller IO actions. The composition of IO actions has one very important property: The order of composition matters. In the world of pure functions and lazy evaluation this is a significant requirement.</p><p>You have to be able to <i>sequence</i> IO actions.</p><p>Haskell has special syntax for sequencing monadic actions. It's called the <i>do notation</i>. Here's a simple example using the IO monad:</p><pre><code class="active haskell">main = do
    putStrLn &quot;The answer is: &quot;
    print 43</code></pre><p>Here we are sequencing two monadic actions, one returned by <code>putStrLn</code> and another returned by <code>print</code>. We do this by putting them inside the <code>do</code> block. The block is constructed using line breaks and proper indentation. In C-like languages blocks are usually delimited by braces and separated by semicolons. In fact, you can do the same in Haskell, although such notation is rarely used:</p><pre><code class="active haskell">main = do {
    putStrLn &quot;The answer is: &quot;;
    print 43;
}</code></pre><p>The &quot;input&quot; part of the I/O should also be easy, right? Whatever you receive from the user or from a file you just assign to a variable and use it later. Like this (you'll have to enter a line of text and press enter when you run this program):</p><pre><code class="active haskell">main = do 
    str &lt;- getLine
    putStrLn str</code></pre><p>Although this works as expected, <code>str</code> is not really a variable, and the assignment is not really an assignment. Remember, Haskell is a functional language. The line:</p><pre><code class="haskell">    str &lt;- getLine</code></pre><p>creates an action that, when executed will take the input from the user. It will then pass this input to the rest of the do block (which is also an action) when it (the rest) is executed. <code>str</code> is just a name we give this input, so we can use it in subsequent actions. In Haskell you never assign a variable, instead you <i>bind</i> a name to a value. When the action produced by the do block is executed, it binds the name <code>str</code> to the value returned by executing the action that was produced by <code>getLine</code>. You can safely ignore what I just said and imagine that an assignment is possible inside a <code>do</code> block. It won't hurt you. But I want you to know that, unlike in other functional languages, I/O in Haskell is not a hack that breaks the pure functional nature.</p><p>Monadic <code>do</code> blocks really look like chunks of imperative code! They also behave like imperative code: think of those lines of code as <i>statements</i> that are executed one after snother. This similarity is no coincidence -- all imperative programming <i>is</i> at its core monadic. An imperative programmer learning Haskell might be as shocked as Molière's Bourgeois Gentleman upon discovering that all his life he's been speaking prose. In Haskell this &quot;imperative prose&quot; is implemented using &quot;functional poetry.&quot; In the case of the IO monad, this is more of a Taoist statement, since IO action are &quot;pure&quot; functions operating on the Universe. The story passed from generation to generation goes like that:</p><ol><li>Each I/O function produces a monadic IO action that takes a Universe as input and returns another Universe as output (sometimes with a piece of data attached to it -- as with input actions).</li><li>The <code>do</code> block glues together these actions in such a way that the Universe produced by one action becomes the input to the next action.</li></ol><p>So the sequencing is a result of hidden data dependency -- data being the Universe in this case.</p><p>The way the actions are glued together is the essence of the Monad. Since the glueing happens between the lines, the Monad is sometimes described as an &quot;overloading of the semicolon.&quot; Different monads overload it differently.</p><h2 id="conclusion"><a href="#conclusion">Conclusion</a></h2><p>So is the Monad really about sequencing? Pretty much so, although it is wise to hedge one's bets:</p><pre><code>Monad that is about sequencing is not the eternal monad
 -- Bartosz Milewski</code></pre><p>You will learn much more about monads in the following tutorials. You'll also see many more examples and eventually you'll develop a very good intuition for it.</p><h2 id="exercises"><a href="#exercises">Exercises</a></h2><ol><li><p>Define a function <code>putStrLn'</code> using <code>putStr</code> and <code>putChar</code>; the latter to output the newline, <code>'\n'</code>. (Replace <code>undefined</code> with actual code).</p><pre><code class="active haskell">putStrLn' str = undefined

main = putStrLn' &quot;A whole line of text!&quot;</code></pre><div class="hidden" title="Show solution"><pre><code class="active haskell">putStrLn' str = do
    putStr str
    putChar '\n'

main = putStrLn' &quot;A whole line of text!&quot;</code></pre></div></li><li><p>Define a function <code>putQStrLn</code> that outputs a string surrounded by quotes, <code>'&quot;'</code></p><pre><code class="active haskell">putQStrLn str = undefined

main = putQStrLn &quot;You can quote me.&quot;</code></pre><div class="hidden" title="Show solution"><pre><code class="active haskell">putQStrLn str = do
    putChar '&quot;'
    putStr str
    putChar '&quot;'
    putChar '\n'

main = putQStrLn &quot;You can quote me.&quot;</code></pre></div></li><li><p>Rewrite the previous exercise to take the input string from the user.</p><div class="hidden" title="Show solution"><pre><code class="active haskell">putQStrLn str = do
    putChar '&quot;'
    putStr str
    putChar '&quot;'
    putChar '\n'

main = do
    putStrLn &quot;Enter text:&quot;
    str &lt;- getLine
    putQStrLn str</code></pre></div></li></ol><h2 id="bibliography"><a href="#bibliography">Bibliography</a></h2><p>Unless otherwise attributed, the quotations come from these two books:</p><ol><li>Lao Tzu, <a href="http://www.amazon.com/Tao-Te-Ching-Stephen-Mitchell/dp/0060812451">Tao Te Ching</a>, Stephen Mitchell, translator. This translation is easier to read, but it contains Mitchell's own interpretations.</li><li>Lao Tzu, <a href="http://www.amazon.com/Tao-Te-Ching-Lao-Tzu/dp/1590305469">Tao Te Ching</a>, Stephen Addiss and Stanley Lombardo, translators. This translation is closer to the original, but is very terse and, at times, cryptic.</li></ol><p>I also took my spiritual guidance from this article:</p><ol><li><p>Eugenio Moggi, <a href="http://www.disi.unige.it/person/MoggiE/ftp/ic91.pdf">Notions of computation and monads</a>.</p></li></ol></article>

<div id="disqus_thread"><script>var disqus_shortname = "bartosz_milewski"; (function() { var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true; dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq); })();</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">comments powered by <span class="logo-disqus">Disqus</span></a></a>
</div>

</div>
</div>
<div class="row article-footer"><div class="span7 meta"><span class="sociallinksunicode social">
<a href="https://twitter.com/home?status=$url$" target="_blank"><i class="icon-twitter"></i></a>&nbsp;
<a href="http://www.facebook.com/sharer/sharer.php?u=$url$" target="_blank"><i class="icon-facebook"></i></a>&nbsp;
<a href="https://plus.google.com/share?url=$url$" target="_blank"><i class="icon-google-plus"></i></a></span>
</div>
</div>
</div>
<div class="footer"><div class="container"><div class="row"><div class="span12"><ul class="menu"><li><a href="https://www.schoolofhaskell.com/">School</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user">Users</a>
</li>

<li><a class="brand" href="https://fpcomplete.com">Sponsored by:
<img src="/static/img/logo.png" title="FPComplete">
</a>
</li>
</ul>
</div>
</div>
<div class="row"><div class="span12"></div>
</div>
</div>
</div>
<link rel="stylesheet" type="text/css" href="/static/bootstrap/css/bootstrap-responsive.css" />
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script><script src="https://www.schoolofhaskell.com/static/combined/Y-3k9_tW.js"></script><script>$(function(){
  $("a.logout").click(function(){
    var form = $("<form method='post'/>");
    form.attr("action", $(this).attr("href"));
    $("body").append(form);
    form.submit();
    return false;
  });
});

$(function(){
    $('.sociallinksunicode a').each(function(){
        $(this).attr('href',$(this).attr('href').replace('$url$',document.location));
    });
});

$(function(){
  // If we need to select a user/select a password then show the
  // details confirmation form, otherwise enable the getting started
  // section.
  if($('.alert-block a').text().match(/(selected a username|change your password)/)) {
    $("#confirm-details").show();
    $("#confirm-details #inputUsername").focus();
  } else {
    $("#get-started").removeClass('disabled').addClass('enabled');
  }

  // For lack of a plain HTML validation story this will do.
  $('.welcome-page').each(function(){
    $('form').submit(check);
  });
  function check(){
    setTimeout(check,500);
    var error = false;
    $('.error').removeClass('error');
    $('#enter-details input').each(function(){
      if($(this).val() == '') {
        $(this).parent().parent().addClass('error');
        error = true;
      }
    });
    if(error) return false;
    if($('[name=password]').val() == $('[name=confirm]').val()) {
      $('#confirm').removeClass('error');
      return true;
    } else {
      $('#confirm').addClass('error');
      return false;
    }
  }
});

$(function(){
  // When scrolling over a snippet editor, activate the "clone in IDE" popovers
  $('article').each(function(){
    var n = 100;
    var wait = 10000;
    function check(){
      if($('.clone').length == 0) {
        setTimeout(check,n);
        return;
      }
      var activated = $.cookie('clone-popover');
      if (activated) return;
      var activate = false;
      $('.controlsRun:onScreen').each(function(){
        $.cookie('clone-popover', 'true', { expires: 30, path: '/' });
        activate = true;
        return false;
      });
      if(activate) {
          $('.clone').each(function(){
              // The bootstrap API is rather unreasonable to say the
              // least.
              next = $(this).parent();
              var title = next.attr('title');
              next.attr('data-content',$(this).attr('data-content'));
              next.attr('title',$(this).attr('title'));
              next.popover('show',{
                  title: $(this).attr('title')
              });
              next.attr('title',title);
          });
          setTimeout(function(){
              $('.clone').each(function(){
                  $(this).parent().popover('hide');
              });
          },wait);
      } else {
        setTimeout(check,n);
      }
    }
    setTimeout(check,n);
  });
});

// onScreen jQuery plugin v0.2.1
// (c) 2011-2013 Ben Pickles
//
// http://benpickles.github.com/onScreen
//
// Released under MIT license.
(function(a){a.expr[":"].onScreen=function(b){var c=a(window),d=c.scrollTop(),e=c.height(),f=d+e,g=a(b),h=g.offset().top,i=g.height(),j=h+i;return h>=d&&h<f||j>d&&j<=f||i>e&&h<=d&&j>=f}})(jQuery);

/*!
 * jQuery Cookie Plugin v1.1
 * https://github.com/carhartl/jquery-cookie
 *
 * Copyright 2011, Klaus Hartl
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.opensource.org/licenses/GPL-2.0
 */
(function($, document) {

  var pluses = /\+/g;
  function raw(s) {
    return s;
  }
  function decoded(s) {
    return decodeURIComponent(s.replace(pluses, ' '));
  }

  $.cookie = function(key, value, options) {

    // key and at least value given, set cookie...
    if (arguments.length > 1 && (!/Object/.test(Object.prototype.toString.call(value)) || value == null)) {
      options = $.extend({}, $.cookie.defaults, options);

      if (value == null) {
	options.expires = -1;
      }

      if (typeof options.expires === 'number') {
	var days = options.expires, t = options.expires = new Date();
	t.setDate(t.getDate() + days);
      }

      value = String(value);

      return (document.cookie = [
	encodeURIComponent(key), '=', options.raw ? value : encodeURIComponent(value),
	options.expires ? '; expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE
	options.path    ? '; path=' + options.path : '',
	options.domain  ? '; domain=' + options.domain : '',
	options.secure  ? '; secure' : ''
      ].join(''));
    }

    // key and possibly options given, get cookie...
    options = value || $.cookie.defaults || {};
    var decode = options.raw ? raw : decoded;
    var cookies = document.cookie.split('; ');
    for (var i = 0, parts; (parts = cookies[i] && cookies[i].split('=')); i++) {
      if (decode(parts.shift()) === key) {
	return decode(parts.join('='));
      }
    }
    return null;
  };
  $.cookie.defaults = {};})(jQuery, document);
</script><!--[if lt IE 10]><script src="https://www.schoolofhaskell.com/static/design/js/ie.js?etag=ayV2DuJ0"></script><![endif]--><script>if(!window.location.href.match(/localhost/)){var track = '/tutorial/user/bartosz/basics-of-haskell/the-tao-of-monad';
window._gaq = [['_setAccount','UA-36928035-1'],track != ''? ['_trackPageview',track] : ['_trackPageview']
,['_trackPageLoadTime']];window._gaq.push(['_setCustomVar',1,'Section','School of Haskell',3]);
window._gaq.push(['_setCustomVar',2,'User Type','Visitor',1]);
(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);

})();}</script>
<!-- Prompt IE 6 users to install Chrome Frame. Remove this if you want to support IE 6.  chromium.org/developers/how-tos/chrome-frame-getting-started --><!--[if lt IE 7 ]><script src="//ajax.googleapis.com/ajax/libs/chrome-frame/1.0.3/CFInstall.min.js"></script><script>window.attachEvent('onload',function(){CFInstall.check({mode:'overlay'})})</script><![endif]--></body></html>