<!DOCTYPE html>
<html><head><title>Functor, Applicative, and Monad - School of Haskell | School of Haskell</title><meta http-equiv="x-ua-compatible" content="IE=9"><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="google-site-verification" content="Rfxk2TdeMMXEXHgJ2_OO8Rt3hPbQSDao0OXQV_n6z_s" /><link href="//fonts.googleapis.com/css?family=Merriweather" rel="stylesheet" type="text/css"><link href="https://www.schoolofhaskell.com/recent-content/feed" type="application/rss+xml" rel="alternate" title="Recently published content">
<link rel="stylesheet" href="https://www.schoolofhaskell.com/static/combined/UlwEHVcM.css"><style>.social{margin-right:1em}h1{font-family:Merriweather !important}article{font-family:Merriweather !important}article li{font-family:Merriweather !important;line-height:1.6em}h1,h2,h3,h4,h4,h5{font-family:Merriweather !important}.editor p{font-family:Frutiger, "Frutiger Linotype", Univers, Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans Condensed", "Liberation Sans", "Nimbus Sans L", Tahoma, Geneva, "Helvetica Neue", Helvetica, Arial, sans-serif}.article-footer{border-top:1px solid #ddd;padding-top:1em;margin-top:1em}body{font-size:16px !important}.navbar .navbar-inner{background:#3c3f41}.navbar .brand{font-size:14px}.navbar .brand img{width:6em}.navbar .icon-wrench{margin:0 -0.5em 0 -0.5em;padding:0 1em 0 1em;height:20px}.navbar-inverse .nav .active a{background:#333638}.navbar-inverse .nav > li > a{color:#a7a7a7
}.navbar-inverse .btn-navbar{background:#333638}.navbar-inverse .nav > li a:hover,.navbar-inverse .btn{background:#333537 !important}@media (max-width: 979px) {.icon-wrench{padding-left:1em !important}}.breadcrumb{border-top-left-radius:0;border-top-right-radius:0}h1{margin-top:20px}.breadcrumb-container + .main-content h1{margin-top:0}.footer{padding:30px 0;margin-top:70px;border-top:1px solid #e5e5e5;background-color:#f5f5f5}.footer ul.footer-menu{list-style-type:none}.footer ul.footer-menu li{display:inline-block}.footer ul.footer-menu li + li{margin-left:0.5em}.footer ul.footer-menu li + li:before{margin-right:0.5em;content:"Â·";color:#999}.footer ul.menu li{display:inline-block}.footer ul.menu li + li{margin-left:0.5em}.footer .copyright{margin-left:25px}.main-content{min-height:100%}.gravatar{width:80px;height:80px;border-radius:2px;background:#eee}.empty-gravatar{width:0}.container{font-family:"Segoe UI", Candara, "Bitstream Vera Sans", "DejaVu Sans", "Bitstream Vera Sans", "Trebuchet MS", Verdana, "Verdana Ref", sans-serif}.container h1,.container h2,.container h4,.container h4,.container h5{font-family:"Segoe UI", Candara, "Bitstream Vera Sans", "DejaVu Sans", "Bitstream Vera Sans", "Trebuchet MS", Verdana, "Verdana Ref", sans-serif}article{font-family:Merriweather !important}article h1{font-family:Merriweather !important}article li{font-family:Merriweather !important;line-height:1.6em}article li + li{margin-top:0.5em}article div.code{background:#f9f9f9;border:1px solid #d1d1d1;position:relative;border-radius:0.2em;margin:0.25em 0 0.75em 0;min-height:2.5em}article code{color:#005580;font-size:14px;white-space:pre}article a.hoogle > code{color:#0088cc;font-size:14px;white-space:pre;border:0}article .expand-code{display:none}article pre{overflow:auto;word-wrap:normal}article code.active{display:block;max-height:430px}article h1{font-size:31.5px}article h3{font-size:17.5px}article h4{font-size:14px}article h5,article h6{font-size:11.9px}article p{line-height:1.7em}article h1 code,article h2 code,article h3 code,article h4 code,article h5 code,article h6 code{font-size:inherit !important}article h1 a,article h2 a,article h3 a,article h4 a,article h5 a,article h6 a{color:#444}article h1 a:before,article h2 a:before,article h3 a:before,article h4 a:before,article h5 a:before,article h6 a:before{margin-left:-1.5em;padding-right:0.5em;font-family:fontawesome;content:"\f0c1";font-size:20px;color:#fff}article h1 a:hover,article h2 a:hover,article h3 a:hover,article h4 a:hover,article h5 a:hover,article h6 a:hover{text-decoration:none;color:#0088cc}article h1 a:hover:before,article h2 a:hover:before,article h3 a:hover:before,article h4 a:hover:before,article h5 a:hover:before,article h6 a:hover:before{color:#888}article h2{font-size:24.5px}article .popover{font-family:actor}article .popover h3.popover-title{font-family:actor !important;font-size:1em}article .popover .popover-content{width:15em;font-size:1em}article .controlsRun{display:block;padding:0.5em;text-align:right;background:#f2f2f2}article .controlsRun a.clone{margin-right:1em;font-family:actor;text-decoration:none}article .controlsRun a.clone span{padding-left:0.5em}article .controlsRun a.run,article .controlsRun a.reset,article .controlsRun a.show-code{font-size:16px}article .controlsRun a.run span,article .controlsRun a.reset span,article .controlsRun a.show-code span{display:none}article .controlsRun a.reset{margin-left:0.5em;color:#a2becc}article .controlsRun a.reset{display:none}article .controlsRun a.show-code{margin-right:0.75em}article .controlsRun a.run:hover,article .controlsRun a.show-code:hover{text-decoration:none}article .controlsRun a.show-code.active{color:#DC0D0D}article .controlsRun a[disabled]{color:#a2becc;cursor:default}article .collapse-area .collapse-header{background:#0088cc;color:#fff;padding:0.3em;cursor:pointer}article .collapse-area .hidden-toggle:before{content:"\f0d7";font-family:fontawesome;margin-right:0.5em;margin-left:0.25em}article .collapse-area .collapsed-files{overflow:auto;height:auto}article .collapse-area.collapse-disabled{display:none}article .collapse-area.collapse-area-off .collapsed-files{height:0px;overflow:hidden}article .collapse-area.collapse-area-off .hidden-toggle:before{content:"\f0da"}article .snippet-stdio .stdout{margin:0.5em;padding-right:2em;position:relative;word-wrap:break-word}article .snippet-stdio .stdin{-webkit-box-shadow:none;-moz-box-shadow:none;box-shadow:none;-webkit-transition:none;-moz-transition:none;-o-transition:none;transition:none;padding:0;margin:0}article .hoogle-results{margin:0.25em}article .hoogle-results .hoogle-inner{background:#fff;padding:0.5em;border-radius:3px;border:1px solid #ddd}article .hoogle-results .hoogle-inner .close-link{position:relative;float:right;margin-top:-0.5em;margin-right:-0.5em}article .snippet-output-errors{margin:1em 0.5em 0.5em 0.5em;position:relative}article .snippet-output-errors ul{list-style-type:none;margin:0;position:relative}article .snippet-output-errors pre{border:0;border-radius:0;padding:0.25em;margin:0;background:inherit;color:inherit}article .snippet-output-errors .close-link{color:inherit;background:inherit}article .snippet-editors{z-index:0;padding:0.25em}article .close-link{padding:0.5em;background:#eaeaea;border-bottom-left-radius:0.2em;border-top-right-radius:0.2em;position:absolute;top:0;right:0}article .close-link:hover{text-decoration:none}article .snippet-title{padding:0.5em 0 0 0.5em}article .snippet-title .snippet-icon{font-family:FontAwesome;display:inline-block;margin-right:0.5em}article .fullModuleCode + div .snippet-title{margin-top:0.5em;border-top:1px solid #ccc;padding-top:0.5em}article .CodeMirror{height:auto;min-height:1em;line-height:1.5em;background:transparent;font-size:14px !important}article .CodeMirror .highlighted{background:rgba(250, 210, 0, 0.45) !important}article .CodeMirror-widget{margin-left:2em;line-height:1.8}article .CodeMirror.collapsed{height:10em !important}article .editor .expander{text-align:center;display:block;padding:0.5em;text-decoration:none;border-bottom-left-radius:2px;border-bottom-right-radius:2px}article .editor .expander .ellipsis{background:white;border:1px solid #ccc;padding:0 0.5em;height:1em;line-height:0.5em;display:inline-block;color:#555;cursor:pointer}article .editor .expander .ellipsis:hover{background:#ddd;color:#333}article .web-runner{margin:0.5em;padding:0.5em;border:1px solid #ccc;border-radius:3px;background:#f5f5f5}article .web-runner iframe{border:0;margin-top:0.5em;margin-bottom:0;background:white}article .web-runner .controls i{cursor:pointer;color:#0088cc}article .web-runner .controls i:hover{color:#222}article .web-runner .controls i + i{margin-left:0.5em}article .web-runner .controls .icon-remove{float:right}article .hidden{display:block;visibility:visible}article .controlsShowHide{margin-bottom:0.5em}.tutorial-body{float:left !important}.tutorial-nav{float:right !important}@media (max-width: 979px) {.related-content{float:right}.author-name{display:block;margin-left:20px !important;padding-left:5px;margin-top:5px}article h1 a:hover:before,article h2 a:hover:before,article h3 a:hover:before,article h4 a:hover:before,article h5 a:hover:before,article h6 a:hover:before{color:#fff}.tutorial-nav{float:none !important;width:auto !important}.tutorial-body{float:none !important;width:auto !important}}@media (min-width: 980px) and (max-width: 1199px) {.navbar-search{display:none}.tutorial-nav{width:200px}.tutorial-body{width:720px}}#accountPage h1{margin:20px 0 0 0}#accountPage h2{font-size:20px}.group-contents .span8{float:left}.group-contents .span4{float:right}.container > .alert-block{margin-top:1em}.alert{color:#aa874a
}.social{margin-bottom:.8em;display:block}.social a{text-decoration:none}.social i{font-size:1.1em;color:#fff;padding:0.25em;border-radius:0.25em;width:1em;display:inline-block;text-align:center}.social i.icon-twitter{background:#0088cc}.social i.icon-facebook{background:#3b5998
  }.social i.icon-google-plus{background:#dd4b39
  }.well pre{background:#fcfcfc}.well h2{margin-top:0}code{color:#005580;font-size:14px;white-space:pre}</style><!--[if lt IE 8]><link rel="stylesheet" href="https://www.schoolofhaskell.com/static/design/css/ie7.css?etag=TSMl9x1V"><![endif]--><!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]--></head><body class="not-logged-in" itemscope itemtype="http://schema.org/Product"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-H62P" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-H62P');</script><div class="navbar navbar-inverse navbar-static-top"><div class="navbar-inner"><div class="container"><a class="btn btn-navbar" type="button" data-toggle="collapse" data-target=".nav-collapse"><span class="icon-bar"></span>
<span class="icon-bar"></span>
<span class="icon-bar"></span>
</a>
<a class="brand" href="/"><img src="/static/img/haskell-logo-wide.png" title="School of Haskell">
</a>
<div class="nav-collapse collapse"><ul class="nav"><li><a href="https://www.schoolofhaskell.com/">School</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user">Users</a>
</li>
</ul>
<form class="navbar-search pull-left" action="https://www.schoolofhaskell.com/search"><input class="search-query" type="text" placeholder="Search" name="search">
</form>
</div>
</div>
</div>
</div>
<div class="container breadcrumb-container"><div class="row"><div class="span12"><ul class="breadcrumb"><li><a href="https://www.schoolofhaskell.com/user/snoyberg">Michael Snoyman</a>
<span class="divider">/</span>
</li>
<li><a href="https://www.schoolofhaskell.com/user/snoyberg/general-haskell">General Haskell</a>
<span class="divider">/</span>
</li>
<li><a href="https://www.schoolofhaskell.com/user/snoyberg/general-haskell/basics">Basics</a>
<span class="divider">/</span>
</li>
<li><a href="https://www.schoolofhaskell.com/user/snoyberg/general-haskell/basics/functors-applicative-functors-and-monads">Functor, Applicative, and Monad</a>
</li>
</ul>
</div>
</div>
</div>
<div class="container main-content"><div class="row"><div class="span12"><h1 itemprop="name">Functor, Applicative, and Monad</h1>
</div>
</div>
<div class="row"><div class="span7 meta"><p><span class="date"> 2 Jan 2017</span>
<span class="author"><a href="https://www.schoolofhaskell.com/user/snoyberg">Michael Snoyman</a>
</span>
<span class="view-edit-link pull-right"><a class="view-source-link" href="https://www.schoolofhaskell.com/tutorial-raw/1/bc9e253b97bd52e92f2e195539cd57a516e3756b">View Markdown source</a>
</span>
</p>
<p class="tags"></p>
</div>
</div>
<div class="row"><div class="span7 meta"><span class="sociallinksunicode social">
<a href="https://twitter.com/home?status=$url$" target="_blank"><i class="icon-twitter"></i></a>&nbsp;
<a href="http://www.facebook.com/sharer/sharer.php?u=$url$" target="_blank"><i class="icon-facebook"></i></a>&nbsp;
<a href="https://plus.google.com/share?url=$url$" target="_blank"><i class="icon-google-plus"></i></a></span>
</div>
</div>
<p class="alert">As of March 2020, School of Haskell has been switched to read-only mode.</p>
<div class="row" itemprop="desc"><div class="span4 tutorial-nav"><div class="related-content"><ul class="nav nav-tabs nav-stacked"><li><script>reddit_target='fpcomplete'</script>
<script src="https://redditstatic.s3.amazonaws.com/button/button1.js"></script>
</li>
<li><a href="https://www.schoolofhaskell.com/user/snoyberg/general-haskell/basics/foldable-mapm-maybe-and-recursive-functions">Previous content: Foldable.mapM_, Maybe, and recursive functions</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user/snoyberg/general-haskell/basics">Go up to: Basics</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user/snoyberg">See all content by Michael Snoyman</a>
</li>
</ul>

</div>
<div class="aside"><h3>Sections</h3>
<ul><li><a href="#decoupling-code">Decoupling code</a></li><li><a href="#functors">Functors</a></li><li><a href="#do-notation">do-notation</a></li><li><a href="#dealing-with-two-variables">Dealing with two variables</a></li><li><a href="#partial-application">Partial application</a></li><li><a href="#applicative-functors">Applicative functors</a></li><li><a href="#so-we-don-t-need-monads-">So we don&#39;t need Monads?</a></li><li><a href="#exercises">Exercises</a></li></ul></div>
</div>
<div class="span8 tutorial-body" data-environment="ghc-7.8-stable-14.09">
<article><p><b>NOTE</b> This content is now being maintained on <a href="http://www.snoyman.com/blog/2017/01/functors-applicatives-and-monads">my personal blog</a>. The content here may be out of date.</p><hr /><p>Let's start off with a very simple problem. We want to let a user input his/her
birth year, and tell him/her his/her age in the year 2020.
Using the function <code>read</code>, this is really simple:</p><pre><code class="active haskell">main = do
    putStrLn &quot;Please enter your birth year&quot;
    year &lt;- getLine
    putStrLn $ &quot;In 2020, you will be: &quot; ++ show (2020 - read year)</code></pre><p>If you run that program and type in a valid year, you'll get the right result.
However, what happens when you enter something invalid?</p><pre><code>Please enter your birth year
hello
main.hs: Prelude.read: no parse</code></pre><p>The problem is that the user input is coming in as a <code>String</code>, and <code>read</code> is
trying to parse it into an <code>Integer</code>. But not all <code>String</code>s are valid
<code>Integer</code>s. <code>read</code> is what we call a <b>partial function</b>, meaning that under
some circumstances it will return an error instead of a valid result.</p><p>A more resilient way to write our code is to use the <code>readMay</code> function, which
will return a <code>Maybe Integer</code> value. This makes it clear with the types
themselves that the parse may succeed or fail. To test this out, try running
the following code:</p><pre><code class="active haskell">import Safe (readMay)

main = do
    -- We use explicit types to tell the compiler how to try and parse the
    -- string.
    print (readMay &quot;1980&quot; :: Maybe Integer)
    print (readMay &quot;hello&quot; :: Maybe Integer)
    print (readMay &quot;2000&quot; :: Maybe Integer)
    print (readMay &quot;two-thousand&quot; :: Maybe Integer)</code></pre><p>So how can we use this to solve our original problem? We need to now determine
if the result of <code>readMay</code> was successful (as <code>Just</code>) or failed (a <code>Nothing</code>).
One way to do this is with pattern matching:</p><pre><code class="active haskell">import Safe (readMay)

main = do
    putStrLn &quot;Please enter your birth year&quot;
    yearString &lt;- getLine
    case readMay yearString of
        Nothing -&gt; putStrLn &quot;You provided an invalid year&quot;
        Just year -&gt; putStrLn $ &quot;In 2020, you will be: &quot; ++ show (2020 - year)</code></pre><h2 id="decoupling-code"><a href="#decoupling-code">Decoupling code</a></h2><p>This code is a bit coupled; let's split it up to have a separate function for
displaying the output to the user, and another separate function for
calculating the age.</p><pre><code class="active haskell">import Safe (readMay)

displayAge maybeAge =
    case maybeAge of
        Nothing -&gt; putStrLn &quot;You provided an invalid year&quot;
        Just age -&gt; putStrLn $ &quot;In 2020, you will be: &quot; ++ show age

yearToAge year = 2020 - year

main = do
    putStrLn &quot;Please enter your birth year&quot;
    yearString &lt;- getLine
    let maybeAge =
            case readMay yearString of
                Nothing -&gt; Nothing
                Just year -&gt; Just (yearToAge year)
    displayAge maybeAge</code></pre><p>This code does exactly the same thing as our previous version. But the
definition of <code>maybeAge</code> in the <code>main</code> function looks pretty repetitive to me.
We check if the parse year is <code>Nothing</code>. If it's <code>Nothing</code>, we return
<code>Nothing</code>. If it's <code>Just</code>, we return <code>Just</code>, after applying the function
<code>yearToAge</code>. That seems like a lot of line noise to do something simple. All we
want is to conditionally apply <code>yearToAge</code>.</p><h2 id="functors"><a href="#functors">Functors</a></h2><p>Fortunately, we have a helper function to do just that. <code>fmap</code>, or <b>functor
mapping</b>, will apply some function over the value contained by a <b>functor</b>.
<code>Maybe</code> is one example of a functor, another common one is a list. In the case
of <code>Maybe</code>, <code>fmap</code> does precisely what we described above. So we can replace
our code with:</p><pre><code class="active haskell">import Safe (readMay)

displayAge maybeAge =
    case maybeAge of
        Nothing -&gt; putStrLn &quot;You provided an invalid year&quot;
        Just age -&gt; putStrLn $ &quot;In 2020, you will be: &quot; ++ show age

yearToAge year = 2020 - year

main = do
    putStrLn &quot;Please enter your birth year&quot;
    yearString &lt;- getLine
    let maybeAge = fmap yearToAge (readMay yearString)
    displayAge maybeAge</code></pre><p>Our code definitely got shorter, and hopefully a bit clearer as well. Now it's
obvious that all we're doing is applying the <code>yearToAge</code> function over the
contents of the <code>Maybe</code> value.</p><p>So what <i>is</i> a functor? It's some kind of container of values. In <code>Maybe</code>, our
container holds zero or one values. With lists, we have a container for zero or
more values. Some containers are even more exotic; the <code>IO</code> functor is actually
providing an action to perform in order to retrieve a value. The only thing
functors share is that they provide some <code>fmap</code> function which lets you modify
their contents.</p><h2 id="do-notation"><a href="#do-notation">do-notation</a></h2><p>We have another option as well: we can use do-notation. This is the same way
we've been writing our <code>main</code> function in so far. That's because- as we
mentioned in the previous paragraph- <code>IO</code> is a functor as well. Let's see how
we can change our code to not use <code>fmap</code>:</p><pre><code class="active haskell">import Safe (readMay)

displayAge maybeAge =
    case maybeAge of
        Nothing -&gt; putStrLn &quot;You provided an invalid year&quot;
        Just age -&gt; putStrLn $ &quot;In 2020, you will be: &quot; ++ show age

yearToAge year = 2020 - year

main = do
    putStrLn &quot;Please enter your birth year&quot;
    yearString &lt;- getLine
    let maybeAge = do
            yearInteger &lt;- readMay yearString
            return $ yearToAge yearInteger
    displayAge maybeAge</code></pre><p>Inside the <code>do-</code>block, we have the <b>slurp operator</b> <code>&lt;-</code>. This
operator is special for do-notation, and is used to pull a value out of its
wrapper (in this case, <code>Maybe</code>). Once we've extracted the value, we can
manipulate it with normal functions, like <code>yearToAge</code>. When we complete our
do-block, we have to return a value wrapped up in that container again. That's
what the <code>return</code> function does.</p><p>do-notation isn't available for all <code>Functor</code>s; it's a special feature reserved
only for <code>Monad</code>s. <code>Monad</code>s are an extension of <code>Functor</code>s that provide a
little extra power. We're not really taking advantage of any of that extra
power here; we'll need to make our program more complicated to demonstrate
it.</p><h2 id="dealing-with-two-variables"><a href="#dealing-with-two-variables">Dealing with two variables</a></h2><p>It's kind of limiting that we have a hard-coded year to compare against. Let's
fix that by allowing the user to specify the &quot;future year.&quot; We'll start off
with a simple implementation using pattern matching and then move back to do
notation.</p><pre><code class="active haskell">import Safe (readMay)

displayAge maybeAge =
    case maybeAge of
        Nothing -&gt; putStrLn &quot;You provided invalid input&quot;
        Just age -&gt; putStrLn $ &quot;In that year, you will be: &quot; ++ show age

main = do
    putStrLn &quot;Please enter your birth year&quot;
    birthYearString &lt;- getLine
    putStrLn &quot;Please enter some year in the future&quot;
    futureYearString &lt;- getLine
    let maybeAge =
            case readMay birthYearString of
                Nothing -&gt; Nothing
                Just birthYear -&gt;
                    case readMay futureYearString of
                        Nothing -&gt; Nothing
                        Just futureYear -&gt; Just (futureYear - birthYear)
    displayAge maybeAge</code></pre><p>OK, it gets the job done... but it's very tedious. Fortunately, do-notation makes this kind of code really simple:</p><pre><code class="active haskell">import Safe (readMay)

displayAge maybeAge =
    case maybeAge of
        Nothing -&gt; putStrLn &quot;You provided invalid input&quot;
        Just age -&gt; putStrLn $ &quot;In that year, you will be: &quot; ++ show age

yearDiff futureYear birthYear = futureYear - birthYear

main = do
    putStrLn &quot;Please enter your birth year&quot;
    birthYearString &lt;- getLine
    putStrLn &quot;Please enter some year in the future&quot;
    futureYearString &lt;- getLine
    let maybeAge = do
            birthYear &lt;- readMay birthYearString
            futureYear &lt;- readMay futureYearString
            return $ yearDiff futureYear birthYear
    displayAge maybeAge</code></pre><p>This is very convenient: we've now slurped our two values in our do-notation.
If either parse returns <code>Nothing</code>, then the entire do-block will return
<code>Nothing</code>. This demonstrates an important property about <code>Maybe</code>: it provides
<b>short circuiting</b>.</p><p>Without resorting to other helper functions or pattern matching, there's no way
to write this code using just <code>fmap</code>. So we've found an example of code that
requires more power than <code>Functor</code>s provide, and <code>Monad</code>s provide that power.</p><h2 id="partial-application"><a href="#partial-application">Partial application</a></h2><p>But maybe there's something else that provides enough power to write our
two-variable code without the full power of <code>Monad</code>. To see what this might be,
let's look more carefully at our types.</p><p>We're working with two values: <code>readMay birthYearString</code> and <code>readMay
futureYearString</code>. Both of these values have the type <code>Maybe Integer</code>. And we
want to apply the function <code>yearDiff</code>, which has the type <code>Integer -&gt; Integer
-&gt; Integer</code>.</p><p>If we go back to trying to use <code>fmap</code>, we'll seemingly run into a bit of a
problem. The type of <code>fmap</code>- specialized for <code>Maybe</code> and <code>Integer</code>- is
<code>(Integer -&gt; a) -&gt; Maybe Integer -&gt; Maybe a</code>. In other words, it takes a
function that takes a single argument (an <code>Integer</code>) and returns a value of
some type <code>a</code>, takes a second argument of a <code>Maybe Integer</code>, and gives back a
value of type <code>Maybe a</code>. But our function- <code>yearDiff</code>- actually takes two
arguments, not one. So <code>fmap</code> can't be used at all, right?</p><p>Not true actually. This is where one of Haskell's very powerful features comes
into play. Any time we have a function of two arguments, we can also look at is
as a function of one argument which returns a <b>function</b>. We can make this
more clear with parentheses:</p><pre><code class="haskell">yearDiff :: Integer -&gt; Integer -&gt; Integer
yearDiff :: Integer -&gt; (Integer -&gt; Integer)</code></pre><p>So how does that help us? We can look at the <code>fmap</code> function as:</p><pre><code class="haskell">fmap :: (Integer -&gt; (Integer -&gt; Integer))
     -&gt; Maybe Integer -&gt; Maybe (Integer -&gt; Integer)</code></pre><p>Then when we apply <code>fmap</code> to <code>yearDiff</code>, we end up with:</p><pre><code class="haskell">fmap yearDiff :: Maybe Integer -&gt; Maybe (Integer -&gt; Integer)</code></pre><p>That's pretty cool. We can apply <i>this</i> to our <code>readMay futureYearString</code> and
end up with:</p><pre><code class="haskell">fmap yearDiff (readMay futureYearString) :: Maybe (Integer -&gt; Integer)</code></pre><p>That's certainly very interesting, but it doesn't help us. We need to somehow
apply this value of type <code>Maybe (Integer -&gt; Integer)</code> to our <code>readMay
birthYearString</code> of type <code>Maybe Integer</code>. We can do this with do-notation:</p><pre><code class="active haskell">import Safe (readMay)

displayAge maybeAge =
    case maybeAge of
        Nothing -&gt; putStrLn &quot;You provided invalid input&quot;
        Just age -&gt; putStrLn $ &quot;In that year, you will be: &quot; ++ show age

yearDiff futureYear birthYear = futureYear - birthYear

main = do
    putStrLn &quot;Please enter your birth year&quot;
    birthYearString &lt;- getLine
    putStrLn &quot;Please enter some year in the future&quot;
    futureYearString &lt;- getLine
    let maybeAge = do
            yearToAge &lt;- fmap yearDiff (readMay futureYearString)
            birthYear &lt;- readMay birthYearString
            return $ yearToAge birthYear
    displayAge maybeAge</code></pre><p>We can even use <code>fmap</code> twice and avoid the second slurp:</p><pre><code class="active haskell">import Safe (readMay)

displayAge maybeAge =
    case maybeAge of
        Nothing -&gt; putStrLn &quot;You provided invalid input&quot;
        Just age -&gt; putStrLn $ &quot;In that year, you will be: &quot; ++ show age

yearDiff futureYear birthYear = futureYear - birthYear

main = do
    putStrLn &quot;Please enter your birth year&quot;
    birthYearString &lt;- getLine
    putStrLn &quot;Please enter some year in the future&quot;
    futureYearString &lt;- getLine
    let maybeAge = do
            yearToAge &lt;- fmap yearDiff (readMay futureYearString)
            fmap yearToAge (readMay birthYearString)
    displayAge maybeAge</code></pre><p>But we don't have a way to apply our <code>Maybe (Integer -&gt; Integer)</code> function to
our <code>Maybe Integer</code> directly.</p><h2 id="applicative-functors"><a href="#applicative-functors">Applicative functors</a></h2><p>And now we get to our final concept: applicative functors. The idea is simple:
we want to be able to apply a function which is <i>inside</i> a functor to a value
inside a functor. The magic operator for this is <code>&lt;*&gt;</code>. Let's
see how it works in our example:</p><pre><code class="active haskell">import Safe (readMay)
import Control.Applicative ((&lt;*&gt;))

displayAge maybeAge =
    case maybeAge of
        Nothing -&gt; putStrLn &quot;You provided invalid input&quot;
        Just age -&gt; putStrLn $ &quot;In that year, you will be: &quot; ++ show age

yearDiff futureYear birthYear = futureYear - birthYear

main = do
    putStrLn &quot;Please enter your birth year&quot;
    birthYearString &lt;- getLine
    putStrLn &quot;Please enter some year in the future&quot;
    futureYearString &lt;- getLine
    let maybeAge =
            fmap yearDiff (readMay futureYearString)
                &lt;*&gt; readMay birthYearString
    displayAge maybeAge</code></pre><p>In fact, the combination of <code>fmap</code> and <code>&lt;*&gt;</code> is so common that we have a
special operator, <code>&lt;$&gt;</code>, which is a synonym for <code>fmap</code>. That means we can make
our code just a little prettier:</p><pre><code class="active haskell">import Safe (readMay)
import Control.Applicative ((&lt;$&gt;), (&lt;*&gt;))

displayAge maybeAge =
    case maybeAge of
        Nothing -&gt; putStrLn &quot;You provided invalid input&quot;
        Just age -&gt; putStrLn $ &quot;In that year, you will be: &quot; ++ show age

yearDiff futureYear birthYear = futureYear - birthYear

main = do
    putStrLn &quot;Please enter your birth year&quot;
    birthYearString &lt;- getLine
    putStrLn &quot;Please enter some year in the future&quot;
    futureYearString &lt;- getLine
-- show
    let maybeAge = yearDiff
            &lt;$&gt; readMay futureYearString
            &lt;*&gt; readMay birthYearString
-- /show
    displayAge maybeAge</code></pre><p>Notice the distinction between <code>&lt;$&gt;</code> and <code>&lt;*&gt;</code>. The former uses a function
which is <i>not</i> wrapped in a functor, while the latter applies a function which
is wrapped up.</p><h2 id="so-we-don-t-need-monads-"><a href="#so-we-don-t-need-monads-">So we don't need Monads?</a></h2><p>So if we can do such great stuff with functors and applicative functors, why do
we need monads at all? The terse answer is <b>context sensitivity</b>: with a
monad, you can make decisions on which processing path to follow based on
previous results. With applicative functors, you have to always apply the same
functions.</p><p>Let's give a contrived example: if the future year is less than the birth year,
we'll assume that the user just got confused and entered the values in reverse,
so we'll automatically fix it by reversing the arguments to <code>yearDiff</code>.  With
do-notation and an if statement, it's easy:</p><pre><code class="active haskell">import Safe (readMay)

displayAge maybeAge =
    case maybeAge of
        Nothing -&gt; putStrLn &quot;You provided invalid input&quot;
        Just age -&gt; putStrLn $ &quot;In that year, you will be: &quot; ++ show age

yearDiff futureYear birthYear = futureYear - birthYear

main = do
    putStrLn &quot;Please enter your birth year&quot;
    birthYearString &lt;- getLine
    putStrLn &quot;Please enter some year in the future&quot;
    futureYearString &lt;- getLine
    let maybeAge = do
            futureYear &lt;- readMay futureYearString
            birthYear &lt;- readMay birthYearString
            return $
                if futureYear &lt; birthYear
                    then yearDiff birthYear futureYear
                    else yearDiff futureYear birthYear
    displayAge maybeAge</code></pre><h2 id="exercises"><a href="#exercises">Exercises</a></h2><ol><li><p>Implement <code>fmap</code> using <code>&lt;*&gt;</code> and <code>return</code>.</p><pre><code class="active haskell">import Control.Applicative ((&lt;*&gt;), Applicative)
import Prelude (return, Monad)
import qualified Prelude

fmap :: (Applicative m, Monad m) =&gt; (a -&gt; b) -&gt; (m a -&gt; m b)
-- show
fmap ... ... = FIXME
-- /show

main =
    case fmap (Prelude.+ 1) (Prelude.Just 2) of
        Prelude.Just 3 -&gt; Prelude.putStrLn &quot;Good job!&quot;
        _ -&gt; Prelude.putStrLn &quot;Try again&quot;</code></pre><div class="hidden" title="SHOW SOLUTION"><pre><code class="active haskell">import Control.Applicative ((&lt;*&gt;))

-- show
myFmap function wrappedValue = return function &lt;*&gt; wrappedValue

main = print $ myFmap (+ 1) $ Just 5
-- /show</code></pre></div></li><li><p>How is <code>return</code> implemented for the <code>Maybe</code> monad? Try replacing <code>return</code>
with its implementation in the code above.</p><pre><code class="haskell active">-- show
returnMaybe = FIXME
-- /show

main
    | returnMaybe &quot;Hello&quot; == Just &quot;Hello&quot; = putStrLn &quot;Correct!&quot;
    | otherwise = putStrLn &quot;Incorrect, please try again&quot;</code></pre><div class="hidden" title="SHOW SOLUTION"><p><code>return</code> is simply the <code>Just</code> constructor. This gets defined as:</p><pre><code class="haskell">instance Monad Maybe where
    return = Just</code></pre></div></li><li><p><code>yearDiff</code> is really just subtraction. Try to replace the calls to
<code>yearDiff</code> with explicit usage of the <code>-</code> operator.</p><pre><code class="haskell active">import Safe (readMay)

displayAge maybeAge =
    case maybeAge of
        Nothing -&gt; putStrLn &quot;You provided invalid input&quot;
        Just age -&gt; putStrLn $ &quot;In that year, you will be: &quot; ++ show age

main = do
    putStrLn &quot;Please enter your birth year&quot;
    birthYearString &lt;- getLine
    putStrLn &quot;Please enter some year in the future&quot;
    futureYearString &lt;- getLine
    let maybeAge = do
            futureYear &lt;- readMay futureYearString
            birthYear &lt;- readMay birthYearString
            return $
-- show
                if futureYear &lt; birthYear
                    then yearDiff birthYear futureYear
                    else yearDiff futureYear birthYear
-- /show
    displayAge maybeAge</code></pre><div class="hidden" title="SHOW SOLUTION"><pre><code class="haskell">import Safe (readMay)

displayAge maybeAge =
    case maybeAge of
        Nothing -&gt; putStrLn &quot;You provided invalid input&quot;
        Just age -&gt; putStrLn $ &quot;In that year, you will be: &quot; ++ show age

main = do
    putStrLn &quot;Please enter your birth year&quot;
    birthYearString &lt;- getLine
    putStrLn &quot;Please enter some year in the future&quot;
    futureYearString &lt;- getLine
    let maybeAge = do
            futureYear &lt;- readMay futureYearString
            birthYear &lt;- readMay birthYearString
            return $
-- show
                if futureYear &lt; birthYear
                    then birthYear - futureYear
                    else futureYear - birthYear
-- /show
    displayAge maybeAge</code></pre></div></li><li><p>It's possible to write an applicative functor version of the
auto-reverse-arguments code by modifying the <code>yearDiff</code> function. Try to do
so.</p><pre><code class="active haskell">import Safe (readMay)
import Control.Applicative ((&lt;$&gt;), (&lt;*&gt;))

displayAge maybeAge =
    case maybeAge of
        Nothing -&gt; putStrLn &quot;You provided invalid input&quot;
        Just age -&gt; putStrLn $ &quot;In that year, you will be: &quot; ++ show age

-- show
yearDiff futureYear birthYear = FIXME
-- /show

main
    | yearDiff 5 6 == 1 = putStrLn &quot;Correct!&quot;
    | otherwise = putStrLn &quot;Please try again&quot;</code></pre><div class="hidden" title="SHOW SOLUTION"><pre><code class="active haskell">import Safe (readMay)

displayAge maybeAge =
    case maybeAge of
        Nothing -&gt; putStrLn &quot;You provided invalid input&quot;
        Just age -&gt; putStrLn $ &quot;In that year, you will be: &quot; ++ show age

-- show
yearDiff futureYear birthYear
    | futureYear &gt; birthYear = futureYear - birthYear
    | otherwise = birthYear - futureYear
-- /show

main = do
    putStrLn &quot;Please enter your birth year&quot;
    birthYearString &lt;- getLine
    putStrLn &quot;Please enter some year in the future&quot;
    futureYearString &lt;- getLine
    let maybeAge = do
            futureYear &lt;- readMay futureYearString
            birthYear &lt;- readMay birthYearString
            return $
                if futureYear &lt; birthYear
                    then yearDiff birthYear futureYear
                    else yearDiff futureYear birthYear
    displayAge maybeAge</code></pre></div><ul><li><p>Now try to do it without modifying <code>yearDiff</code> directly, but by using a
helper function which is applied to <code>yearDiff</code>.</p><pre><code class="active haskell">import Safe (readMay)
import Control.Applicative ((&lt;$&gt;), (&lt;*&gt;))

displayAge maybeAge =
    case maybeAge of
        Nothing -&gt; putStrLn &quot;You provided invalid input&quot;
        Just age -&gt; putStrLn $ &quot;In that year, you will be: &quot; ++ show age

yearDiff futureYear birthYear = futureYear - birthYear
-- show
yourHelperFunction f ...
-- /show

main
    | yourHelperFunction yearDiff 5 6 == 1 = putStrLn &quot;Correct!&quot;
    | otherwise = putStrLn &quot;Please try again&quot;</code></pre><div class="hidden" title="SHOW SOLUTION"><pre><code class="active haskell">import Safe (readMay)

displayAge maybeAge =
    case maybeAge of
        Nothing -&gt; putStrLn &quot;You provided invalid input&quot;
        Just age -&gt; putStrLn $ &quot;In that year, you will be: &quot; ++ show age

yearDiff futureYear birthYear = futureYear - birthYear

main = do
    putStrLn &quot;Please enter your birth year&quot;
    birthYearString &lt;- getLine
    putStrLn &quot;Please enter some year in the future&quot;
    futureYearString &lt;- getLine
    let maybeAge = do
            futureYear &lt;- readMay futureYearString
            birthYear &lt;- readMay birthYearString
            return $
                if futureYear &lt; birthYear
                    then yourHelperFunction yearDiff birthYear futureYear
                    else yourHelperFunction yearDiff futureYear birthYear
    displayAge maybeAge

-- show
yourHelperFunction f x y
    | x &gt; y = f x y
    | otherwise = f y x
-- /show</code></pre></div></li></ul></li></ol></article>

<div id="disqus_thread"><script>var disqus_shortname = "snoyberg-soh"; (function() { var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true; dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq); })();</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">comments powered by <span class="logo-disqus">Disqus</span></a></a>
</div>

</div>
</div>
<div class="row article-footer"><div class="span7 meta"><span class="sociallinksunicode social">
<a href="https://twitter.com/home?status=$url$" target="_blank"><i class="icon-twitter"></i></a>&nbsp;
<a href="http://www.facebook.com/sharer/sharer.php?u=$url$" target="_blank"><i class="icon-facebook"></i></a>&nbsp;
<a href="https://plus.google.com/share?url=$url$" target="_blank"><i class="icon-google-plus"></i></a></span>
</div>
</div>
</div>
<div class="footer"><div class="container"><div class="row"><div class="span12"><ul class="menu"><li><a href="https://www.schoolofhaskell.com/">School</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user">Users</a>
</li>

<li><a class="brand" href="https://fpcomplete.com">Sponsored by:
<img src="/static/img/logo.png" title="FPComplete">
</a>
</li>
</ul>
</div>
</div>
<div class="row"><div class="span12"></div>
</div>
</div>
</div>
<link rel="stylesheet" type="text/css" href="/static/bootstrap/css/bootstrap-responsive.css" />
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script><script src="https://www.schoolofhaskell.com/static/combined/Y-3k9_tW.js"></script><script>$(function(){
  $("a.logout").click(function(){
    var form = $("<form method='post'/>");
    form.attr("action", $(this).attr("href"));
    $("body").append(form);
    form.submit();
    return false;
  });
});

$(function(){
    $('.sociallinksunicode a').each(function(){
        $(this).attr('href',$(this).attr('href').replace('$url$',document.location));
    });
});

$(function(){
  // If we need to select a user/select a password then show the
  // details confirmation form, otherwise enable the getting started
  // section.
  if($('.alert-block a').text().match(/(selected a username|change your password)/)) {
    $("#confirm-details").show();
    $("#confirm-details #inputUsername").focus();
  } else {
    $("#get-started").removeClass('disabled').addClass('enabled');
  }

  // For lack of a plain HTML validation story this will do.
  $('.welcome-page').each(function(){
    $('form').submit(check);
  });
  function check(){
    setTimeout(check,500);
    var error = false;
    $('.error').removeClass('error');
    $('#enter-details input').each(function(){
      if($(this).val() == '') {
        $(this).parent().parent().addClass('error');
        error = true;
      }
    });
    if(error) return false;
    if($('[name=password]').val() == $('[name=confirm]').val()) {
      $('#confirm').removeClass('error');
      return true;
    } else {
      $('#confirm').addClass('error');
      return false;
    }
  }
});

$(function(){
  // When scrolling over a snippet editor, activate the "clone in IDE" popovers
  $('article').each(function(){
    var n = 100;
    var wait = 10000;
    function check(){
      if($('.clone').length == 0) {
        setTimeout(check,n);
        return;
      }
      var activated = $.cookie('clone-popover');
      if (activated) return;
      var activate = false;
      $('.controlsRun:onScreen').each(function(){
        $.cookie('clone-popover', 'true', { expires: 30, path: '/' });
        activate = true;
        return false;
      });
      if(activate) {
          $('.clone').each(function(){
              // The bootstrap API is rather unreasonable to say the
              // least.
              next = $(this).parent();
              var title = next.attr('title');
              next.attr('data-content',$(this).attr('data-content'));
              next.attr('title',$(this).attr('title'));
              next.popover('show',{
                  title: $(this).attr('title')
              });
              next.attr('title',title);
          });
          setTimeout(function(){
              $('.clone').each(function(){
                  $(this).parent().popover('hide');
              });
          },wait);
      } else {
        setTimeout(check,n);
      }
    }
    setTimeout(check,n);
  });
});

// onScreen jQuery plugin v0.2.1
// (c) 2011-2013 Ben Pickles
//
// http://benpickles.github.com/onScreen
//
// Released under MIT license.
(function(a){a.expr[":"].onScreen=function(b){var c=a(window),d=c.scrollTop(),e=c.height(),f=d+e,g=a(b),h=g.offset().top,i=g.height(),j=h+i;return h>=d&&h<f||j>d&&j<=f||i>e&&h<=d&&j>=f}})(jQuery);

/*!
 * jQuery Cookie Plugin v1.1
 * https://github.com/carhartl/jquery-cookie
 *
 * Copyright 2011, Klaus Hartl
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.opensource.org/licenses/GPL-2.0
 */
(function($, document) {

  var pluses = /\+/g;
  function raw(s) {
    return s;
  }
  function decoded(s) {
    return decodeURIComponent(s.replace(pluses, ' '));
  }

  $.cookie = function(key, value, options) {

    // key and at least value given, set cookie...
    if (arguments.length > 1 && (!/Object/.test(Object.prototype.toString.call(value)) || value == null)) {
      options = $.extend({}, $.cookie.defaults, options);

      if (value == null) {
	options.expires = -1;
      }

      if (typeof options.expires === 'number') {
	var days = options.expires, t = options.expires = new Date();
	t.setDate(t.getDate() + days);
      }

      value = String(value);

      return (document.cookie = [
	encodeURIComponent(key), '=', options.raw ? value : encodeURIComponent(value),
	options.expires ? '; expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE
	options.path    ? '; path=' + options.path : '',
	options.domain  ? '; domain=' + options.domain : '',
	options.secure  ? '; secure' : ''
      ].join(''));
    }

    // key and possibly options given, get cookie...
    options = value || $.cookie.defaults || {};
    var decode = options.raw ? raw : decoded;
    var cookies = document.cookie.split('; ');
    for (var i = 0, parts; (parts = cookies[i] && cookies[i].split('=')); i++) {
      if (decode(parts.shift()) === key) {
	return decode(parts.join('='));
      }
    }
    return null;
  };
  $.cookie.defaults = {};})(jQuery, document);
</script><!--[if lt IE 10]><script src="https://www.schoolofhaskell.com/static/design/js/ie.js?etag=ayV2DuJ0"></script><![endif]--><script>if(!window.location.href.match(/localhost/)){var track = '/tutorial/user/snoyberg/general-haskell/basics/functors-applicative-functors-and-monads';
window._gaq = [['_setAccount','UA-36928035-1'],track != ''? ['_trackPageview',track] : ['_trackPageview']
,['_trackPageLoadTime']];window._gaq.push(['_setCustomVar',1,'Section','School of Haskell',3]);
window._gaq.push(['_setCustomVar',2,'User Type','Visitor',1]);
(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);

})();}</script>
<!-- Prompt IE 6 users to install Chrome Frame. Remove this if you want to support IE 6.  chromium.org/developers/how-tos/chrome-frame-getting-started --><!--[if lt IE 7 ]><script src="//ajax.googleapis.com/ajax/libs/chrome-frame/1.0.3/CFInstall.min.js"></script><script>window.attachEvent('onload',function(){CFInstall.check({mode:'overlay'})})</script><![endif]--></body></html>