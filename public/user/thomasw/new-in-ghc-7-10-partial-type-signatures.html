<!DOCTYPE html>
<html><head><title>New in GHC 7.10: Partial Type Signatures - School of Haskell | School of Haskell</title><meta http-equiv="x-ua-compatible" content="IE=9"><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="google-site-verification" content="Rfxk2TdeMMXEXHgJ2_OO8Rt3hPbQSDao0OXQV_n6z_s" /><link href="//fonts.googleapis.com/css?family=Merriweather" rel="stylesheet" type="text/css"><link href="https://www.schoolofhaskell.com/recent-content/feed" type="application/rss+xml" rel="alternate" title="Recently published content">
<link rel="stylesheet" href="https://www.schoolofhaskell.com/static/combined/UlwEHVcM.css"><style>.social{margin-right:1em}h1{font-family:Merriweather !important}article{font-family:Merriweather !important}article li{font-family:Merriweather !important;line-height:1.6em}h1,h2,h3,h4,h4,h5{font-family:Merriweather !important}.editor p{font-family:Frutiger, "Frutiger Linotype", Univers, Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans Condensed", "Liberation Sans", "Nimbus Sans L", Tahoma, Geneva, "Helvetica Neue", Helvetica, Arial, sans-serif}.article-footer{border-top:1px solid #ddd;padding-top:1em;margin-top:1em}body{font-size:16px !important}.navbar .navbar-inner{background:#3c3f41}.navbar .brand{font-size:14px}.navbar .brand img{width:6em}.navbar .icon-wrench{margin:0 -0.5em 0 -0.5em;padding:0 1em 0 1em;height:20px}.navbar-inverse .nav .active a{background:#333638}.navbar-inverse .nav > li > a{color:#a7a7a7
}.navbar-inverse .btn-navbar{background:#333638}.navbar-inverse .nav > li a:hover,.navbar-inverse .btn{background:#333537 !important}@media (max-width: 979px) {.icon-wrench{padding-left:1em !important}}.breadcrumb{border-top-left-radius:0;border-top-right-radius:0}h1{margin-top:20px}.breadcrumb-container + .main-content h1{margin-top:0}.footer{padding:30px 0;margin-top:70px;border-top:1px solid #e5e5e5;background-color:#f5f5f5}.footer ul.footer-menu{list-style-type:none}.footer ul.footer-menu li{display:inline-block}.footer ul.footer-menu li + li{margin-left:0.5em}.footer ul.footer-menu li + li:before{margin-right:0.5em;content:"Â·";color:#999}.footer ul.menu li{display:inline-block}.footer ul.menu li + li{margin-left:0.5em}.footer .copyright{margin-left:25px}.main-content{min-height:100%}.gravatar{width:80px;height:80px;border-radius:2px;background:#eee}.empty-gravatar{width:0}.container{font-family:"Segoe UI", Candara, "Bitstream Vera Sans", "DejaVu Sans", "Bitstream Vera Sans", "Trebuchet MS", Verdana, "Verdana Ref", sans-serif}.container h1,.container h2,.container h4,.container h4,.container h5{font-family:"Segoe UI", Candara, "Bitstream Vera Sans", "DejaVu Sans", "Bitstream Vera Sans", "Trebuchet MS", Verdana, "Verdana Ref", sans-serif}article{font-family:Merriweather !important}article h1{font-family:Merriweather !important}article li{font-family:Merriweather !important;line-height:1.6em}article li + li{margin-top:0.5em}article div.code{background:#f9f9f9;border:1px solid #d1d1d1;position:relative;border-radius:0.2em;margin:0.25em 0 0.75em 0;min-height:2.5em}article code{color:#005580;font-size:14px;white-space:pre}article a.hoogle > code{color:#0088cc;font-size:14px;white-space:pre;border:0}article .expand-code{display:none}article pre{overflow:auto;word-wrap:normal}article code.active{display:block;max-height:430px}article h1{font-size:31.5px}article h3{font-size:17.5px}article h4{font-size:14px}article h5,article h6{font-size:11.9px}article p{line-height:1.7em}article h1 code,article h2 code,article h3 code,article h4 code,article h5 code,article h6 code{font-size:inherit !important}article h1 a,article h2 a,article h3 a,article h4 a,article h5 a,article h6 a{color:#444}article h1 a:before,article h2 a:before,article h3 a:before,article h4 a:before,article h5 a:before,article h6 a:before{margin-left:-1.5em;padding-right:0.5em;font-family:fontawesome;content:"\f0c1";font-size:20px;color:#fff}article h1 a:hover,article h2 a:hover,article h3 a:hover,article h4 a:hover,article h5 a:hover,article h6 a:hover{text-decoration:none;color:#0088cc}article h1 a:hover:before,article h2 a:hover:before,article h3 a:hover:before,article h4 a:hover:before,article h5 a:hover:before,article h6 a:hover:before{color:#888}article h2{font-size:24.5px}article .popover{font-family:actor}article .popover h3.popover-title{font-family:actor !important;font-size:1em}article .popover .popover-content{width:15em;font-size:1em}article .controlsRun{display:block;padding:0.5em;text-align:right;background:#f2f2f2}article .controlsRun a.clone{margin-right:1em;font-family:actor;text-decoration:none}article .controlsRun a.clone span{padding-left:0.5em}article .controlsRun a.run,article .controlsRun a.reset,article .controlsRun a.show-code{font-size:16px}article .controlsRun a.run span,article .controlsRun a.reset span,article .controlsRun a.show-code span{display:none}article .controlsRun a.reset{margin-left:0.5em;color:#a2becc}article .controlsRun a.reset{display:none}article .controlsRun a.show-code{margin-right:0.75em}article .controlsRun a.run:hover,article .controlsRun a.show-code:hover{text-decoration:none}article .controlsRun a.show-code.active{color:#DC0D0D}article .controlsRun a[disabled]{color:#a2becc;cursor:default}article .collapse-area .collapse-header{background:#0088cc;color:#fff;padding:0.3em;cursor:pointer}article .collapse-area .hidden-toggle:before{content:"\f0d7";font-family:fontawesome;margin-right:0.5em;margin-left:0.25em}article .collapse-area .collapsed-files{overflow:auto;height:auto}article .collapse-area.collapse-disabled{display:none}article .collapse-area.collapse-area-off .collapsed-files{height:0px;overflow:hidden}article .collapse-area.collapse-area-off .hidden-toggle:before{content:"\f0da"}article .snippet-stdio .stdout{margin:0.5em;padding-right:2em;position:relative;word-wrap:break-word}article .snippet-stdio .stdin{-webkit-box-shadow:none;-moz-box-shadow:none;box-shadow:none;-webkit-transition:none;-moz-transition:none;-o-transition:none;transition:none;padding:0;margin:0}article .hoogle-results{margin:0.25em}article .hoogle-results .hoogle-inner{background:#fff;padding:0.5em;border-radius:3px;border:1px solid #ddd}article .hoogle-results .hoogle-inner .close-link{position:relative;float:right;margin-top:-0.5em;margin-right:-0.5em}article .snippet-output-errors{margin:1em 0.5em 0.5em 0.5em;position:relative}article .snippet-output-errors ul{list-style-type:none;margin:0;position:relative}article .snippet-output-errors pre{border:0;border-radius:0;padding:0.25em;margin:0;background:inherit;color:inherit}article .snippet-output-errors .close-link{color:inherit;background:inherit}article .snippet-editors{z-index:0;padding:0.25em}article .close-link{padding:0.5em;background:#eaeaea;border-bottom-left-radius:0.2em;border-top-right-radius:0.2em;position:absolute;top:0;right:0}article .close-link:hover{text-decoration:none}article .snippet-title{padding:0.5em 0 0 0.5em}article .snippet-title .snippet-icon{font-family:FontAwesome;display:inline-block;margin-right:0.5em}article .fullModuleCode + div .snippet-title{margin-top:0.5em;border-top:1px solid #ccc;padding-top:0.5em}article .CodeMirror{height:auto;min-height:1em;line-height:1.5em;background:transparent;font-size:14px !important}article .CodeMirror .highlighted{background:rgba(250, 210, 0, 0.45) !important}article .CodeMirror-widget{margin-left:2em;line-height:1.8}article .CodeMirror.collapsed{height:10em !important}article .editor .expander{text-align:center;display:block;padding:0.5em;text-decoration:none;border-bottom-left-radius:2px;border-bottom-right-radius:2px}article .editor .expander .ellipsis{background:white;border:1px solid #ccc;padding:0 0.5em;height:1em;line-height:0.5em;display:inline-block;color:#555;cursor:pointer}article .editor .expander .ellipsis:hover{background:#ddd;color:#333}article .web-runner{margin:0.5em;padding:0.5em;border:1px solid #ccc;border-radius:3px;background:#f5f5f5}article .web-runner iframe{border:0;margin-top:0.5em;margin-bottom:0;background:white}article .web-runner .controls i{cursor:pointer;color:#0088cc}article .web-runner .controls i:hover{color:#222}article .web-runner .controls i + i{margin-left:0.5em}article .web-runner .controls .icon-remove{float:right}article .hidden{display:block;visibility:visible}article .controlsShowHide{margin-bottom:0.5em}.tutorial-body{float:left !important}.tutorial-nav{float:right !important}@media (max-width: 979px) {.related-content{float:right}.author-name{display:block;margin-left:20px !important;padding-left:5px;margin-top:5px}article h1 a:hover:before,article h2 a:hover:before,article h3 a:hover:before,article h4 a:hover:before,article h5 a:hover:before,article h6 a:hover:before{color:#fff}.tutorial-nav{float:none !important;width:auto !important}.tutorial-body{float:none !important;width:auto !important}}@media (min-width: 980px) and (max-width: 1199px) {.navbar-search{display:none}.tutorial-nav{width:200px}.tutorial-body{width:720px}}#accountPage h1{margin:20px 0 0 0}#accountPage h2{font-size:20px}.group-contents .span8{float:left}.group-contents .span4{float:right}.container > .alert-block{margin-top:1em}.alert{color:#aa874a
}.social{margin-bottom:.8em;display:block}.social a{text-decoration:none}.social i{font-size:1.1em;color:#fff;padding:0.25em;border-radius:0.25em;width:1em;display:inline-block;text-align:center}.social i.icon-twitter{background:#0088cc}.social i.icon-facebook{background:#3b5998
  }.social i.icon-google-plus{background:#dd4b39
  }.well pre{background:#fcfcfc}.well h2{margin-top:0}code{color:#005580;font-size:14px;white-space:pre}</style><!--[if lt IE 8]><link rel="stylesheet" href="https://www.schoolofhaskell.com/static/design/css/ie7.css?etag=TSMl9x1V"><![endif]--><!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]--></head><body class="not-logged-in" itemscope itemtype="http://schema.org/Product"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-H62P" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-H62P');</script><div class="navbar navbar-inverse navbar-static-top"><div class="navbar-inner"><div class="container"><a class="btn btn-navbar" type="button" data-toggle="collapse" data-target=".nav-collapse"><span class="icon-bar"></span>
<span class="icon-bar"></span>
<span class="icon-bar"></span>
</a>
<a class="brand" href="/"><img src="/static/img/haskell-logo-wide.png" title="School of Haskell">
</a>
<div class="nav-collapse collapse"><ul class="nav"><li><a href="https://www.schoolofhaskell.com/">School</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user">Users</a>
</li>
</ul>
<form class="navbar-search pull-left" action="https://www.schoolofhaskell.com/search"><input class="search-query" type="text" placeholder="Search" name="search">
</form>
</div>
</div>
</div>
</div>
<div class="container breadcrumb-container"><div class="row"><div class="span12"><ul class="breadcrumb"><li><a href="https://www.schoolofhaskell.com/user/thomasw">Thomas Winant</a>
<span class="divider">/</span>
</li>
<li><a href="https://www.schoolofhaskell.com/user/thomasw/new-in-ghc-7-10-partial-type-signatures">New in GHC 7.10: Partial Type Signatures</a>
</li>
</ul>
</div>
</div>
</div>
<div class="container main-content"><div class="row"><div class="span12"><h1 itemprop="name">New in GHC 7.10: Partial Type Signatures</h1>
</div>
</div>
<div class="row"><div class="span7 meta"><p><span class="date">14 Apr 2015</span>
<span class="author"><a href="https://www.schoolofhaskell.com/user/thomasw">Thomas Winant</a>
</span>
<span class="view-edit-link pull-right"><a class="view-source-link" href="https://www.schoolofhaskell.com/tutorial-raw/18133/cd00ad74fe232a39cbba05245284a7f05f5df1c7">View Markdown source</a>
</span>
</p>
<p class="tags"></p>
</div>
</div>
<div class="row"><div class="span7 meta"><span class="sociallinksunicode social">
<a href="https://twitter.com/home?status=$url$" target="_blank"><i class="icon-twitter"></i></a>&nbsp;
<a href="http://www.facebook.com/sharer/sharer.php?u=$url$" target="_blank"><i class="icon-facebook"></i></a>&nbsp;
<a href="https://plus.google.com/share?url=$url$" target="_blank"><i class="icon-google-plus"></i></a></span>
</div>
</div>
<p class="alert">As of March 2020, School of Haskell has been switched to read-only mode.</p>
<div class="row" itemprop="desc"><div class="span4 tutorial-nav"><div class="related-content"><ul class="nav nav-tabs nav-stacked"><li><script>reddit_target='fpcomplete'</script>
<script src="https://redditstatic.s3.amazonaws.com/button/button1.js"></script>
</li>
<li><a href="https://www.schoolofhaskell.com/user/thomasw">See all content by Thomas Winant</a>
</li>
</ul>

</div>
<div class="aside"><h3>Sections</h3>
<ul><li><a href="#introduction">Introduction</a></li><li><a href="#syntax---options">Syntax &amp; Options</a><ul><li><a href="#type-wildcards">Type Wildcards</a></li><li><a href="#named-wildcards">Named Wildcards</a></li><li><a href="#constraint-wildcards">Constraint Wildcards</a></li><li><a href="#extra-constraints-wildcard">Extra-constraints Wildcard</a></li><li><a href="#flags">Flags</a></li></ul></li><li><a href="#use-cases">Use Cases</a></li></ul></div>
</div>
<div class="span8 tutorial-body" data-environment="def">
<article><p>In this tutorial we introduce you to the <code>PartialTypeSignatures</code> extension
available in GHC starting from version 7.10. The goal is to teach you what you
can do with this extension and how it can improve your development workflow.</p><h1 id="introduction"><a href="#introduction">Introduction</a></h1><p>Partial type signatures were introduced in GHC 7.10 to give the
programmer fine-grained control over type annotations. Prior to GHC
7.10, the programmer essentially faced a binary choice when it came to
writing a type signature: do I write a <b>complete</b> type signature, or
<b>none</b> at all?</p><p>Let's say you're writing a simple program tracking some preferences of
your co-workers. Currently, we're only interested in the editor they're
using. Let's define some data types to model this information.</p><pre><code class="haskell">data CoWorker = CoWorker String
              deriving (Eq, Ord)

data Editor = Emacs | Vim
            deriving (Eq)</code></pre><p>Now let's define a function to remember a co-worker's editor preference.
We know we need at least two arguments, the co-worker and his/her editor
preference. However, we're not sure yet about the rest of the type,
maybe we'll go with a simple association list, i.e.
<code>[(CoWorker, Editor)]</code> or maybe with a map, i.e. <code>Map CoWorker Editor</code>, we don't know yet. With the limited information we currently have, our function will probably look like this:</p><pre><code class="haskell">rememberEditor coWorker editor = undefined</code></pre><p>As we're not sure about what the function will actually do, we don't
know its return type yet, which prevents us from annotating its type.
Wouldn't it be helpful to already annotate the types of the arguments?</p><p>Imagine we're using this function later on. Our memory is a bit foggy
and we accidentally swap the argument order:</p><pre><code class="haskell">test = rememberEditor Emacs (CoWorker &quot;John&quot;)</code></pre><p>Unfortunately, GHC's type checker will happily accept this code! As
<code>rememberEditor</code> has no type signature yet, and its body is missing, GHC
has no clue about the types of the arguments.</p><p>Even though we knew the types of the arguments, we couldn't pass on this
information to GHC's type checker as we couldn't annotate this (pattern
signatures could help, but you have to sprinkle them throughout your
program).</p><p>This is exactly the problem <i>partial type signatures</i> solves, by giving
the programmer fine-grained control over type annotations. Let's add a
partial type signature to our example so GHC's type checker can help us
find our type errors again.</p><pre><code class="haskell">rememberEditor :: CoWorker -&gt; Editor -&gt; _
rememberEditor coWorker editor = undefined</code></pre><p>A partial type signature looks just like a regular type signature except
for the fact that it can contain <i>wildcards</i> (written as underscores),
which take the place of the unknown parts of your type signature. The
wildcard in the (partial) type signature above thus indicates that the
return type (which can be another function) of <code>rememberEditor</code> is unknown.</p><p>Now GHC's type checker can use these type annotations to detect the
swapped argument order:</p><pre><code>Couldn't match expected type `CoWorker' with actual type `Editor'
In the first argument of `rememberEditor', namely `Emacs'

Couldn't match expected type `Editor' with actual type `CoWorker'
In the second argument of `rememberEditor', namely `(CoWorker &quot;John&quot;)'</code></pre><p>After giving it some thought, we decide to go for a <code>Map</code> and implement <code>rememberEditor</code> as follows.</p><pre><code class="haskell">import           Data.Map (Map)
import qualified Data.Map as Map

rememberEditor :: CoWorker -&gt; Editor -&gt; _
rememberEditor coWorker editor = Map.insert coWorker editor</code></pre><p>Now GHC's type checker will even inform us of the type to replace the wildcard
with!</p><pre><code>Found hole `_'
  with type: Map CoWorker Editor -&gt; Map CoWorker Editor
  ...</code></pre><br /><blockquote><p>A partial type signature combines <i>type checking</i> (type
annotations) with <i>type inference</i> (wildcards) in one type signature.</p></blockquote><h1 id="syntax---options"><a href="#syntax---options">Syntax &amp; Options</a></h1><p>There are a number of different kinds of wildcards you can use, as well
compiler flags to control the warnings and/or errors.</p><h2 id="type-wildcards"><a href="#type-wildcards">Type Wildcards</a></h2><p>The simplest wildcard is the <i>type wildcard</i>. For instance the wildcard
used in the example above was a type wildcard. A type wildcard is a
wildcard that occurs in the <i>type</i> part of a type signature, or put in
other words, a wildcard <i>not occurring in the constraints</i> of a type
signature.</p><p>A wildcard can be filled in with a closed type like <code>Int</code>, <code>[String]</code>,
<code>Editor</code>; a function like <code>Int -&gt; Bool</code>; a type containing a type
variable like <code>a -&gt; Bool</code>; a higher-kinded type like <code>Maybe</code>, <code>Either</code>,
<code>Either a</code>, <code>m</code>; pretty much every type.</p><p>When a wildcard is unconstrained, i.e. it is not filled in with any type
after type inference, it is <i>generalized</i> over: it is replaced with a
new type variable.</p><p>Take for example this standard <code>filter</code> function:</p><pre><code class="haskell">filter :: (a -&gt; Bool) -&gt; [a] -&gt; [a]
filter p xs = [x | x &lt;- xs, p x]</code></pre><p>The following partial type signatures are all valid. The type checker will each
time infer exactly the same type for <code>filter</code>: <code>(a -&gt; Bool) -&gt; [a] -&gt; [a]</code>.</p><pre><code class="haskell">(a -&gt; _)    -&gt; [a] -&gt; [a]
(_ -&gt; Bool) -&gt; [a] -&gt; [a]
({-hi-}_ _ _{-/hi-})     -&gt; [a] -&gt; [a]
_           -&gt; [a] -&gt; [a]
_           -&gt; [a] -&gt; [_]
_           -&gt; [a] -&gt; {-hi-}_{-/hi-} a
_           -&gt; [a] -&gt; _
_           -&gt; _   -&gt; _
_           -&gt; {-hi-}_{-/hi-}
{-hi-}_{-/hi-}</code></pre><p>Highlighted wildcards:</p><ol><li><p><code>a -&gt; Bool</code> can also be written in prefix-notation as <code>(-&gt;) a Bool</code>.
The first wildcard will be filled in with <code>(-&gt;)</code>, the second with
<code>a</code>, and the third with <code>Bool</code>.</p></li><li><p>The wildcard will unify with <code>[]</code>, the type constructor for lists.</p></li><li><p>As a wildcard can unify with a function type, a single wildcard can
be filled in with a function with any arity.</p></li><li><p>This partial type signature can be left out, as it is the same as
writing no type signature at all and fully rely on type inference.</p></li></ol><h2 id="named-wildcards"><a href="#named-wildcards">Named Wildcards</a></h2><p>Wildcards can also be named, to clarify their meaning, but more
important, to refer to them later on. All wildcards with the same name
within one type signature will be filled in with the same type. You can
name a wildcard by writing an identifier after the underscore of the
wildcard, e.g. <code>_foo</code>.</p><blockquote><p>Haskell 2010 and previous versions of GHC interpret named
wildcards like <code>_foo</code> as type variables. To remain backwards compatible,
named wildcards are hidden behind the <code>NamedWildCards</code> extension flag.
Remember to add the following line to the top of your file when you want
to <code>_foo</code> to be interpreted as a named wildcard instead of a type
variable.</p></blockquote><pre><code class="haskell">{-# LANGUAGE NamedWildCards #-}</code></pre><p>Let's say we wrote the following partial type signature for <code>filter</code>:</p><pre><code class="haskell">-- Partial type signature with named wildcards
filter :: (_x   -&gt; _x)   -&gt; [_x]   -&gt; [_x]
-- Inferred type
filter :: (Bool -&gt; Bool) -&gt; [Bool] -&gt; [Bool]
-- Most general type of filter
filter :: (a    -&gt; Bool) -&gt; [a]    -&gt; [a]</code></pre><p>The second occurrence of <code>_x</code> is filled in with <code>Bool</code> after type
inference, all other instances of <code>_x</code> were not filled in with any type.
If they hadn't been named wildcards, they would have been replaced with
a type variable, e.g. <code>a</code>. But because they have the same name as the
wildcard filled in with <code>Bool</code>, they are all filled in with <code>Bool</code>.</p><p>When a named wildcard is not filled in with any type after type
inference, it is generalised over, just like an unnamed wildcard. There
is one small difference: the new type variable will have <code>w_NAME</code> as
name where <code>NAME</code> is the name of the named wildcard.</p><pre><code class="haskell">identity :: _foo -&gt; _foo
identity x = x
-- Inferred type:
identity :: w_foo -&gt; w_foo</code></pre><p>Named wildcards must not be confused with type variables because they
can still be filled in with a closed type like <code>Int</code>, e.g.</p><pre><code class="haskell">not :: _foo -&gt; _foo
not True = False
not False = True
-- Inferred type:
not :: Bool -&gt; Bool</code></pre><h2 id="constraint-wildcards"><a href="#constraint-wildcards">Constraint Wildcards</a></h2><p>As you might have guessed, wildcards occurring in the constraints part
are called <i>constraint wildcards</i>. Unfortunately, constraint wildcards
aren't all that useful. Take the following example.</p><pre><code class="haskell">showPlusOne :: _ a =&gt; a -&gt; String
showPlusOne x = show (1 + x)</code></pre><p>Because we use <code>show</code> and <code>(+)</code>, <code>x</code> must implement both the <code>Show</code> and
the <code>Num</code> type classes. Should the wildcard be filled in with <code>Show</code> or
<code>Num</code>? We certainly don't want the type checker to guess! Unlike types,
which are unified to fill in the wildcards, constraints are solved,
which isn't amenable to filling in wildcards. Therefore, wildcards in
constraints are not supported.</p><p>However, some wildcards do make sense in constraints, but only when they
comply with certain restrictions to keep the type checker from guessing.
The rules are as follows.</p><ul><li>Only named wildcards are allowed in constraints ...</li><li>... when they're also present in the rest of the type</li></ul><p>Of the following type signatures only the last one satisfies both rules
and will be allowed.</p><pre><code class="haskell">Eq _  =&gt; a  -&gt; a  -&gt; Bool -- No
Eq _x =&gt; a  -&gt; a  -&gt; Bool -- No
Eq _x =&gt; _x -&gt; _x -&gt; Bool -- Yes</code></pre><p>When these rules are followed, regular type inference will take care of
filling in the wildcards, and the type checker won't have to guess.</p><h2 id="extra-constraints-wildcard"><a href="#extra-constraints-wildcard">Extra-constraints Wildcard</a></h2><p>There is one more kind of wildcard, the extra-constraints wildcard, not
to be confused with constraint wildcards. Whereas constraint wildcards
occur <i>within</i> a constraint, an extra-constraints wildcard occurs <i>as</i>
a constraint. When a partial type signature contains an
extra-constraints wildcard, it means that the type checker may infer any
number (0..n) of extra constraints, which will then be integrated in the
final type of the binding. For example:</p><pre><code class="haskell">showPlusOne :: _ =&gt; a -&gt; String -- Inferred for `_': (Num a, Show a)
showPlusOne x = show (1 + x)</code></pre><p>The type checker will infer the extra constraints <code>Num a</code> and <code>Show a</code>,
just as when you would have left out the type signature. The two
constraints will be used to fill in the extra-constraints wildcard.</p><p>You can combine annotated constraints with an extra-constraints
wildcard. There are however some restrictions: there can't be more than
one extra-constraints wildcard in a type signature and it must come as
the last constraint.</p><p>Some more examples:</p><pre><code class="haskell">showNum :: (Num a, _) =&gt; a -&gt; String
showNum x = show x
-- Found hole `_' with inferred constraints: (Show a)
-- ..</code></pre><pre><code class="haskell">forM :: _ =&gt; _
forM x f = mapM f x -- mapM :: Monad m =&gt; (a -&gt; m b) -&gt; t a -&gt; m (t b)
-- Found hole `_' with inferred constraints: (Monad m, Traversable t)
-- ..
--
-- Found hole `_' with type: t -&gt; a -&gt; (a -&gt; m b) -&gt; m (t b)
-- ..</code></pre><pre><code class="haskell">false :: _ =&gt; Bool
false = False
-- Found hole `_' with inferred constraints: ()
-- ..</code></pre><p>In the <code>filter</code> example, we said that the partial type signature
<code>filter :: _</code> is the same as writing no type signature at all. This
wasn't entirely true, because extra constraints are not allowed without
the extra-constraints wildcard. But now we have all the ingredients to
define the most general partial type signature: <code>_ =&gt; _</code>, which you can
leave out just as well, as it is equivalent to writing no type signature
at all!</p><h2 id="flags"><a href="#flags">Flags</a></h2><p>In past version of GHC, wildcards (underscores) in type signatures
produced parse errors. Starting from GHC 7.10 they no longer produce
parse errors but type errors.</p><p>Take the following simple program:</p><pre><code class="haskell">x :: _
x = True</code></pre><p>Compiling this with GHC 7.8 produces:</p><pre><code>Tutorial.hs:1:6: parse error on input `_'</code></pre><p>Whereas compiling it with GHC 7.10 produces:</p><pre><code>Tutorial.hs:1:6:
    Found hole `_' with type: Bool
    To use the inferred type, enable PartialTypeSignatures
    In the type signature for `x': _</code></pre><p>The error message now informs you of the inferred type of the wildcard
or hole, just like <code>TypedHoles</code> tells you the type of a hole. However,
unlike <code>TypedHoles</code> which requires you to choose the right expression of
that type, knowing the type of a wildcard or hole is enough to fill in
the hole!</p><p>When you want to compile your program without manually filling in the holes,
just enable the <code>PartialTypeSignatures</code> extension flag, which will demote the
errors caused by holes in type signatures to warnings and use the inferred
types to fill in the holes. When you don't want these warnings either, pass
<code>-fno-warn-partial-type-signatures</code> to GHC and it will suppress the warnings
too.</p><p>Remember from the section on <a href="#named-wildcards">Named Wildcards</a> that you need the <code>NamedWildCards</code>
extension flag to use named wildcards, otherwise they will be interpreted as
type variables.</p><h1 id="use-cases"><a href="#use-cases">Use Cases</a></h1><p>Partial type signatures can come in handy in the following use cases:</p><ul><li><p>During development, like in the introductory example. By annotating the
types you already know, even though you don't know the whole type
yet, you give the type checker information to help catch your type
errors. Furthermore, a (partial) type signature is a form of
machine-checked documentation that you can quickly glance at to
remind you of the type of the function, or at least the parts you
already know.</p></li><li><p>Interactive hole-driven development in combination with
<code>TypedHoles</code>. The type checker just tells you what types to fill in.</p></li><li><p>The type signature is too verbose and complicated. By replacing the
verbose or complicated parts with underscores you can direct the
user's focus to the parts of the type signature that really matter.
Or when a bunch of related functions have similar but verbose types,
the distracting common boilerplate can be hidden with underscores,
thereby stressing the differences.</p></li><li><p>Not all programs can be written without type annotations as some
types cannot be inferred, e.g. higher-rank types. With a partial
type signature, you can annotate the parts required for type
inference to succeed, but leave out the boilerplate. In the example
below, the argument of <code>foo</code> cannot be inferred and needs a type
annotation. However, the return type can easily be inferred, but why
should we have to annotate it as well?</p><pre><code class="haskell">foo :: (forall a. [a] -&gt; [a]) -&gt; {-hi-}([Bool], [Char]){-/hi-}
foo x = (x [True, False], x ['a', 'b'])
test = foo reverse  -- reverse :: forall a. [a] -&gt; [a]</code></pre><p>With a partial type signature:</p><pre><code class="haskell">foo :: (forall a. [a] -&gt; [a]) -&gt; {-hi-}_{-/hi-}
foo x = (x [True, False], x ['a', 'b'])
test = foo reverse  -- reverse :: forall a. [a] -&gt; [a]</code></pre></li></ul><p>Further reading:</p><ul><li><p><a href="https://lirias.kuleuven.be/handle/123456789/423475">Paper</a></p></li><li><p><a href="https://ghc.haskell.org/trac/ghc/wiki/PartialTypeSignatures">GHC wiki page</a></p></li></ul></article>


</div>
</div>
<div class="row article-footer"><div class="span7 meta"><span class="sociallinksunicode social">
<a href="https://twitter.com/home?status=$url$" target="_blank"><i class="icon-twitter"></i></a>&nbsp;
<a href="http://www.facebook.com/sharer/sharer.php?u=$url$" target="_blank"><i class="icon-facebook"></i></a>&nbsp;
<a href="https://plus.google.com/share?url=$url$" target="_blank"><i class="icon-google-plus"></i></a></span>
</div>
</div>
</div>
<div class="footer"><div class="container"><div class="row"><div class="span12"><ul class="menu"><li><a href="https://www.schoolofhaskell.com/">School</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user">Users</a>
</li>

<li><a class="brand" href="https://fpcomplete.com">Sponsored by:
<img src="/static/img/logo.png" title="FPComplete">
</a>
</li>
</ul>
</div>
</div>
<div class="row"><div class="span12"></div>
</div>
</div>
</div>
<link rel="stylesheet" type="text/css" href="/static/bootstrap/css/bootstrap-responsive.css" />
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script><script src="https://www.schoolofhaskell.com/static/combined/Y-3k9_tW.js"></script><script>$(function(){
  $("a.logout").click(function(){
    var form = $("<form method='post'/>");
    form.attr("action", $(this).attr("href"));
    $("body").append(form);
    form.submit();
    return false;
  });
});

$(function(){
    $('.sociallinksunicode a').each(function(){
        $(this).attr('href',$(this).attr('href').replace('$url$',document.location));
    });
});

$(function(){
  // If we need to select a user/select a password then show the
  // details confirmation form, otherwise enable the getting started
  // section.
  if($('.alert-block a').text().match(/(selected a username|change your password)/)) {
    $("#confirm-details").show();
    $("#confirm-details #inputUsername").focus();
  } else {
    $("#get-started").removeClass('disabled').addClass('enabled');
  }

  // For lack of a plain HTML validation story this will do.
  $('.welcome-page').each(function(){
    $('form').submit(check);
  });
  function check(){
    setTimeout(check,500);
    var error = false;
    $('.error').removeClass('error');
    $('#enter-details input').each(function(){
      if($(this).val() == '') {
        $(this).parent().parent().addClass('error');
        error = true;
      }
    });
    if(error) return false;
    if($('[name=password]').val() == $('[name=confirm]').val()) {
      $('#confirm').removeClass('error');
      return true;
    } else {
      $('#confirm').addClass('error');
      return false;
    }
  }
});

$(function(){
  // When scrolling over a snippet editor, activate the "clone in IDE" popovers
  $('article').each(function(){
    var n = 100;
    var wait = 10000;
    function check(){
      if($('.clone').length == 0) {
        setTimeout(check,n);
        return;
      }
      var activated = $.cookie('clone-popover');
      if (activated) return;
      var activate = false;
      $('.controlsRun:onScreen').each(function(){
        $.cookie('clone-popover', 'true', { expires: 30, path: '/' });
        activate = true;
        return false;
      });
      if(activate) {
          $('.clone').each(function(){
              // The bootstrap API is rather unreasonable to say the
              // least.
              next = $(this).parent();
              var title = next.attr('title');
              next.attr('data-content',$(this).attr('data-content'));
              next.attr('title',$(this).attr('title'));
              next.popover('show',{
                  title: $(this).attr('title')
              });
              next.attr('title',title);
          });
          setTimeout(function(){
              $('.clone').each(function(){
                  $(this).parent().popover('hide');
              });
          },wait);
      } else {
        setTimeout(check,n);
      }
    }
    setTimeout(check,n);
  });
});

// onScreen jQuery plugin v0.2.1
// (c) 2011-2013 Ben Pickles
//
// http://benpickles.github.com/onScreen
//
// Released under MIT license.
(function(a){a.expr[":"].onScreen=function(b){var c=a(window),d=c.scrollTop(),e=c.height(),f=d+e,g=a(b),h=g.offset().top,i=g.height(),j=h+i;return h>=d&&h<f||j>d&&j<=f||i>e&&h<=d&&j>=f}})(jQuery);

/*!
 * jQuery Cookie Plugin v1.1
 * https://github.com/carhartl/jquery-cookie
 *
 * Copyright 2011, Klaus Hartl
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.opensource.org/licenses/GPL-2.0
 */
(function($, document) {

  var pluses = /\+/g;
  function raw(s) {
    return s;
  }
  function decoded(s) {
    return decodeURIComponent(s.replace(pluses, ' '));
  }

  $.cookie = function(key, value, options) {

    // key and at least value given, set cookie...
    if (arguments.length > 1 && (!/Object/.test(Object.prototype.toString.call(value)) || value == null)) {
      options = $.extend({}, $.cookie.defaults, options);

      if (value == null) {
	options.expires = -1;
      }

      if (typeof options.expires === 'number') {
	var days = options.expires, t = options.expires = new Date();
	t.setDate(t.getDate() + days);
      }

      value = String(value);

      return (document.cookie = [
	encodeURIComponent(key), '=', options.raw ? value : encodeURIComponent(value),
	options.expires ? '; expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE
	options.path    ? '; path=' + options.path : '',
	options.domain  ? '; domain=' + options.domain : '',
	options.secure  ? '; secure' : ''
      ].join(''));
    }

    // key and possibly options given, get cookie...
    options = value || $.cookie.defaults || {};
    var decode = options.raw ? raw : decoded;
    var cookies = document.cookie.split('; ');
    for (var i = 0, parts; (parts = cookies[i] && cookies[i].split('=')); i++) {
      if (decode(parts.shift()) === key) {
	return decode(parts.join('='));
      }
    }
    return null;
  };
  $.cookie.defaults = {};})(jQuery, document);
</script><!--[if lt IE 10]><script src="https://www.schoolofhaskell.com/static/design/js/ie.js?etag=ayV2DuJ0"></script><![endif]--><script>if(!window.location.href.match(/localhost/)){var track = '/tutorial/user/thomasw/new-in-ghc-7-10-partial-type-signatures';
window._gaq = [['_setAccount','UA-36928035-1'],track != ''? ['_trackPageview',track] : ['_trackPageview']
,['_trackPageLoadTime']];window._gaq.push(['_setCustomVar',1,'Section','School of Haskell',3]);
window._gaq.push(['_setCustomVar',2,'User Type','Visitor',1]);
(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);

})();}</script>
<!-- Prompt IE 6 users to install Chrome Frame. Remove this if you want to support IE 6.  chromium.org/developers/how-tos/chrome-frame-getting-started --><!--[if lt IE 7 ]><script src="//ajax.googleapis.com/ajax/libs/chrome-frame/1.0.3/CFInstall.min.js"></script><script>window.attachEvent('onload',function(){CFInstall.check({mode:'overlay'})})</script><![endif]--></body></html>