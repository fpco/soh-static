<!DOCTYPE html>
<html><head><title>How to Replace Failure by a Heap of Successes - School of Haskell | School of Haskell</title><meta http-equiv="x-ua-compatible" content="IE=9"><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="google-site-verification" content="Rfxk2TdeMMXEXHgJ2_OO8Rt3hPbQSDao0OXQV_n6z_s" /><link href="//fonts.googleapis.com/css?family=Merriweather" rel="stylesheet" type="text/css"><link href="https://www.schoolofhaskell.com/recent-content/feed" type="application/rss+xml" rel="alternate" title="Recently published content">
<link rel="stylesheet" href="https://www.schoolofhaskell.com/static/combined/UlwEHVcM.css"><style>.social{margin-right:1em}h1{font-family:Merriweather !important}article{font-family:Merriweather !important}article li{font-family:Merriweather !important;line-height:1.6em}h1,h2,h3,h4,h4,h5{font-family:Merriweather !important}.editor p{font-family:Frutiger, "Frutiger Linotype", Univers, Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans Condensed", "Liberation Sans", "Nimbus Sans L", Tahoma, Geneva, "Helvetica Neue", Helvetica, Arial, sans-serif}.article-footer{border-top:1px solid #ddd;padding-top:1em;margin-top:1em}body{font-size:16px !important}.navbar .navbar-inner{background:#3c3f41}.navbar .brand{font-size:14px}.navbar .brand img{width:6em}.navbar .icon-wrench{margin:0 -0.5em 0 -0.5em;padding:0 1em 0 1em;height:20px}.navbar-inverse .nav .active a{background:#333638}.navbar-inverse .nav > li > a{color:#a7a7a7
}.navbar-inverse .btn-navbar{background:#333638}.navbar-inverse .nav > li a:hover,.navbar-inverse .btn{background:#333537 !important}@media (max-width: 979px) {.icon-wrench{padding-left:1em !important}}.breadcrumb{border-top-left-radius:0;border-top-right-radius:0}h1{margin-top:20px}.breadcrumb-container + .main-content h1{margin-top:0}.footer{padding:30px 0;margin-top:70px;border-top:1px solid #e5e5e5;background-color:#f5f5f5}.footer ul.footer-menu{list-style-type:none}.footer ul.footer-menu li{display:inline-block}.footer ul.footer-menu li + li{margin-left:0.5em}.footer ul.footer-menu li + li:before{margin-right:0.5em;content:"Â·";color:#999}.footer ul.menu li{display:inline-block}.footer ul.menu li + li{margin-left:0.5em}.footer .copyright{margin-left:25px}.main-content{min-height:100%}.gravatar{width:80px;height:80px;border-radius:2px;background:#eee}.empty-gravatar{width:0}.container{font-family:"Segoe UI", Candara, "Bitstream Vera Sans", "DejaVu Sans", "Bitstream Vera Sans", "Trebuchet MS", Verdana, "Verdana Ref", sans-serif}.container h1,.container h2,.container h4,.container h4,.container h5{font-family:"Segoe UI", Candara, "Bitstream Vera Sans", "DejaVu Sans", "Bitstream Vera Sans", "Trebuchet MS", Verdana, "Verdana Ref", sans-serif}article{font-family:Merriweather !important}article h1{font-family:Merriweather !important}article li{font-family:Merriweather !important;line-height:1.6em}article li + li{margin-top:0.5em}article div.code{background:#f9f9f9;border:1px solid #d1d1d1;position:relative;border-radius:0.2em;margin:0.25em 0 0.75em 0;min-height:2.5em}article code{color:#005580;font-size:14px;white-space:pre}article a.hoogle > code{color:#0088cc;font-size:14px;white-space:pre;border:0}article .expand-code{display:none}article pre{overflow:auto;word-wrap:normal}article code.active{display:block;max-height:430px}article h1{font-size:31.5px}article h3{font-size:17.5px}article h4{font-size:14px}article h5,article h6{font-size:11.9px}article p{line-height:1.7em}article h1 code,article h2 code,article h3 code,article h4 code,article h5 code,article h6 code{font-size:inherit !important}article h1 a,article h2 a,article h3 a,article h4 a,article h5 a,article h6 a{color:#444}article h1 a:before,article h2 a:before,article h3 a:before,article h4 a:before,article h5 a:before,article h6 a:before{margin-left:-1.5em;padding-right:0.5em;font-family:fontawesome;content:"\f0c1";font-size:20px;color:#fff}article h1 a:hover,article h2 a:hover,article h3 a:hover,article h4 a:hover,article h5 a:hover,article h6 a:hover{text-decoration:none;color:#0088cc}article h1 a:hover:before,article h2 a:hover:before,article h3 a:hover:before,article h4 a:hover:before,article h5 a:hover:before,article h6 a:hover:before{color:#888}article h2{font-size:24.5px}article .popover{font-family:actor}article .popover h3.popover-title{font-family:actor !important;font-size:1em}article .popover .popover-content{width:15em;font-size:1em}article .controlsRun{display:block;padding:0.5em;text-align:right;background:#f2f2f2}article .controlsRun a.clone{margin-right:1em;font-family:actor;text-decoration:none}article .controlsRun a.clone span{padding-left:0.5em}article .controlsRun a.run,article .controlsRun a.reset,article .controlsRun a.show-code{font-size:16px}article .controlsRun a.run span,article .controlsRun a.reset span,article .controlsRun a.show-code span{display:none}article .controlsRun a.reset{margin-left:0.5em;color:#a2becc}article .controlsRun a.reset{display:none}article .controlsRun a.show-code{margin-right:0.75em}article .controlsRun a.run:hover,article .controlsRun a.show-code:hover{text-decoration:none}article .controlsRun a.show-code.active{color:#DC0D0D}article .controlsRun a[disabled]{color:#a2becc;cursor:default}article .collapse-area .collapse-header{background:#0088cc;color:#fff;padding:0.3em;cursor:pointer}article .collapse-area .hidden-toggle:before{content:"\f0d7";font-family:fontawesome;margin-right:0.5em;margin-left:0.25em}article .collapse-area .collapsed-files{overflow:auto;height:auto}article .collapse-area.collapse-disabled{display:none}article .collapse-area.collapse-area-off .collapsed-files{height:0px;overflow:hidden}article .collapse-area.collapse-area-off .hidden-toggle:before{content:"\f0da"}article .snippet-stdio .stdout{margin:0.5em;padding-right:2em;position:relative;word-wrap:break-word}article .snippet-stdio .stdin{-webkit-box-shadow:none;-moz-box-shadow:none;box-shadow:none;-webkit-transition:none;-moz-transition:none;-o-transition:none;transition:none;padding:0;margin:0}article .hoogle-results{margin:0.25em}article .hoogle-results .hoogle-inner{background:#fff;padding:0.5em;border-radius:3px;border:1px solid #ddd}article .hoogle-results .hoogle-inner .close-link{position:relative;float:right;margin-top:-0.5em;margin-right:-0.5em}article .snippet-output-errors{margin:1em 0.5em 0.5em 0.5em;position:relative}article .snippet-output-errors ul{list-style-type:none;margin:0;position:relative}article .snippet-output-errors pre{border:0;border-radius:0;padding:0.25em;margin:0;background:inherit;color:inherit}article .snippet-output-errors .close-link{color:inherit;background:inherit}article .snippet-editors{z-index:0;padding:0.25em}article .close-link{padding:0.5em;background:#eaeaea;border-bottom-left-radius:0.2em;border-top-right-radius:0.2em;position:absolute;top:0;right:0}article .close-link:hover{text-decoration:none}article .snippet-title{padding:0.5em 0 0 0.5em}article .snippet-title .snippet-icon{font-family:FontAwesome;display:inline-block;margin-right:0.5em}article .fullModuleCode + div .snippet-title{margin-top:0.5em;border-top:1px solid #ccc;padding-top:0.5em}article .CodeMirror{height:auto;min-height:1em;line-height:1.5em;background:transparent;font-size:14px !important}article .CodeMirror .highlighted{background:rgba(250, 210, 0, 0.45) !important}article .CodeMirror-widget{margin-left:2em;line-height:1.8}article .CodeMirror.collapsed{height:10em !important}article .editor .expander{text-align:center;display:block;padding:0.5em;text-decoration:none;border-bottom-left-radius:2px;border-bottom-right-radius:2px}article .editor .expander .ellipsis{background:white;border:1px solid #ccc;padding:0 0.5em;height:1em;line-height:0.5em;display:inline-block;color:#555;cursor:pointer}article .editor .expander .ellipsis:hover{background:#ddd;color:#333}article .web-runner{margin:0.5em;padding:0.5em;border:1px solid #ccc;border-radius:3px;background:#f5f5f5}article .web-runner iframe{border:0;margin-top:0.5em;margin-bottom:0;background:white}article .web-runner .controls i{cursor:pointer;color:#0088cc}article .web-runner .controls i:hover{color:#222}article .web-runner .controls i + i{margin-left:0.5em}article .web-runner .controls .icon-remove{float:right}article .hidden{display:block;visibility:visible}article .controlsShowHide{margin-bottom:0.5em}.tutorial-body{float:left !important}.tutorial-nav{float:right !important}@media (max-width: 979px) {.related-content{float:right}.author-name{display:block;margin-left:20px !important;padding-left:5px;margin-top:5px}article h1 a:hover:before,article h2 a:hover:before,article h3 a:hover:before,article h4 a:hover:before,article h5 a:hover:before,article h6 a:hover:before{color:#fff}.tutorial-nav{float:none !important;width:auto !important}.tutorial-body{float:none !important;width:auto !important}}@media (min-width: 980px) and (max-width: 1199px) {.navbar-search{display:none}.tutorial-nav{width:200px}.tutorial-body{width:720px}}#accountPage h1{margin:20px 0 0 0}#accountPage h2{font-size:20px}.group-contents .span8{float:left}.group-contents .span4{float:right}.container > .alert-block{margin-top:1em}.alert{color:#aa874a
}.social{margin-bottom:.8em;display:block}.social a{text-decoration:none}.social i{font-size:1.1em;color:#fff;padding:0.25em;border-radius:0.25em;width:1em;display:inline-block;text-align:center}.social i.icon-twitter{background:#0088cc}.social i.icon-facebook{background:#3b5998
  }.social i.icon-google-plus{background:#dd4b39
  }.well pre{background:#fcfcfc}.well h2{margin-top:0}code{color:#005580;font-size:14px;white-space:pre}</style><!--[if lt IE 8]><link rel="stylesheet" href="https://www.schoolofhaskell.com/static/design/css/ie7.css?etag=TSMl9x1V"><![endif]--><!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]--></head><body class="not-logged-in" itemscope itemtype="http://schema.org/Product"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-H62P" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-H62P');</script><div class="navbar navbar-inverse navbar-static-top"><div class="navbar-inner"><div class="container"><a class="btn btn-navbar" type="button" data-toggle="collapse" data-target=".nav-collapse"><span class="icon-bar"></span>
<span class="icon-bar"></span>
<span class="icon-bar"></span>
</a>
<a class="brand" href="/"><img src="/static/img/haskell-logo-wide.png" title="School of Haskell">
</a>
<div class="nav-collapse collapse"><ul class="nav"><li><a href="https://www.schoolofhaskell.com/">School</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user">Users</a>
</li>
</ul>
<form class="navbar-search pull-left" action="https://www.schoolofhaskell.com/search"><input class="search-query" type="text" placeholder="Search" name="search">
</form>
</div>
</div>
</div>
</div>
<div class="container breadcrumb-container"><div class="row"><div class="span12"><ul class="breadcrumb"><li><a href="https://www.schoolofhaskell.com/user/edwardk">Edward Kmett</a>
<span class="divider">/</span>
</li>
<li><a href="https://www.schoolofhaskell.com/user/edwardk/heap-of-successes">How to Replace Failure by a Heap of Successes</a>
</li>
</ul>
</div>
</div>
</div>
<div class="container main-content"><div class="row"><div class="span12"><h1 itemprop="name">How to Replace Failure by a Heap of Successes</h1>
</div>
</div>
<div class="row"><div class="span7 meta"><p><span class="date"> 2 May 2015</span>
<span class="author"><a href="https://www.schoolofhaskell.com/user/edwardk">Edward Kmett</a>
</span>
<span class="view-edit-link pull-right"><a class="view-source-link" href="https://www.schoolofhaskell.com/tutorial-raw/4906/0f6911c474fa38006c6b1ba653b47020740cadcf">View Markdown source</a>
</span>
</p>
<p class="tags"></p>
</div>
</div>
<div class="row"><div class="span7 meta"><span class="sociallinksunicode social">
<a href="https://twitter.com/home?status=$url$" target="_blank"><i class="icon-twitter"></i></a>&nbsp;
<a href="http://www.facebook.com/sharer/sharer.php?u=$url$" target="_blank"><i class="icon-facebook"></i></a>&nbsp;
<a href="https://plus.google.com/share?url=$url$" target="_blank"><i class="icon-google-plus"></i></a></span>
</div>
</div>
<p class="alert">As of March 2020, School of Haskell has been switched to read-only mode.</p>
<div class="row" itemprop="desc"><div class="span4 tutorial-nav"><div class="related-content"><ul class="nav nav-tabs nav-stacked"><li><script>reddit_target='fpcomplete'</script>
<script src="https://redditstatic.s3.amazonaws.com/button/button1.js"></script>
</li>
<li><a href="https://www.schoolofhaskell.com/user/edwardk/unlifted-structures">Previous content: Unlifted Structures</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user/edwardk/phoas">Next content: PHOAS For Free</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user/edwardk">See all content by Edward Kmett</a>
</li>
</ul>

</div>
<div class="aside"><h3>Sections</h3>
<ul><li><a href="#monoid-actions">Monoid Actions</a></li><li><a href="#update-vs--state">Update vs. State</a></li><li><a href="#a-list-of-successes">A List of Successes</a></li><li><a href="#a-heap-of-successes">A Heap of Successes</a></li><li><a href="#caveats">Caveats</a></li><li><a href="#on-leftovers">On Leftovers</a></li><li><a href="#conclusion">Conclusion</a></li></ul></div>
</div>
<div class="span8 tutorial-body" data-environment="def">
<article><p>One problem that libraries like <code>pipes</code> and <code>machines</code> often have to deal with is the notion of <a href="https://hackage.haskell.org/package/pipes-parse-3.0.2/docs/Pipes-Parse.html">leftovers</a>. What do you do with the stuff you haven't consumed? As parsers (and stream transducers) are usually implemented, we wind up losing contravariance on the input argument and/or we have to clutter our code with a separate type argument or transformer for handling leftovers. How can we do better?</p><p>Danel Ahman and Tarmo Uustalu gave us a nice general theory of <a href="http://homepages.inf.ed.ac.uk/s1225336/papers/types13postproc.pdf">Update Monads</a>. Today I want to go and tie that notion back to the idea of writing parsing combinators. I've been explaining this technique to folks since long before I'd ever heard the term &quot;update monad,&quot; but never took the time to write it up.</p><p>Why now? I also then want to showcase a new way to exploit the limited structure of the updates to make a more efficient <code>Applicative</code> for parsing, and also talk a bit about how this same general design can be used to address the issue of leftovers in streaming models.</p><h1 id="monoid-actions"><a href="#monoid-actions">Monoid Actions</a></h1><p>You can always update any state to any new (or old) state in the state monad. We have <code>get</code> and <code>put</code> after all.</p><p>Something like</p><pre><code class="haskell">undo m = do
  s &lt;- get
  a &lt;- m
  put s
  return a</code></pre><p>will let us roll back to a previous state after we make a change, no matter what it is.</p><p>But what if you want to restrict the space of updates you are allowed to make to the state? What if some actions should be irreversible or you are interested in a very small space of updates which can be expressed in tightly bounded space that is much smaller than the entire new state itself?</p><p>An example where you might want an update to be irreversible is if you are keeping state about a bunch of file handles. Closing a file handle may affect that state, but you can't meaningfully &quot;reopen it&quot; just by reverting to a previous state involving the status of all of your file handles.</p><p>In practice we usually try to hide the whole state from the user by not exporting it, and then providing a limited palette of operations we can perform on top of our now-opaque representation.</p><p>This isn't the only option we have!</p><p>Another way to do this is to define some language of updates and of how updates compose. The easiest such language to use that will fit nicely with the needs of a <code>Monad</code> is to make it so a chain of such updates can be composed associatively, and such that there is a unit update. In other words, the right vocabulary for &quot;updating&quot; our state is probably a <code>Monoid</code>. Then we need to figure out how to apply that <code>Monoid</code> to our state.</p><p>For this we can appeal to the notion of a (right) <a href="http://en.wikipedia.org/wiki/Semigroup_action">monoid action on a set</a>.</p><p>That is to say we want:</p><pre><code class="haskell">class Monoid m =&gt; RightMonoidAction s m where
  act :: s -&gt; m -&gt; s</code></pre><p>such that</p><pre><code class="haskell">act s mempty = s
act s (mappend m n) = act (act s m) n</code></pre><p>All this says is that the identity element changes nothing, and that the composition of monoid elements results in the composition of the effects on the state.</p><p>The laws can be stated slightly more elegantly for left monoid actions, <code>m -&gt; s -&gt; s</code>, where we can think of <code>act</code> as monoid homomorphism from <code>m</code> to <code>Endo s</code>, but it is convenient to think of time as advancing to the right, so we'll stick to right monoid actions for now. Left monoid actions are discussed in a fairly practical setting in Brent Yorgey's very pleasant functional pearl <a href="http://www.cis.upenn.edu/~byorgey/pub/monoid-pearl.pdf">Monoids: Themes and Variations</a>.</p><h1 id="update-vs--state"><a href="#update-vs--state">Update vs. State</a></h1><p>So then what is an update monad?</p><p>Well, let's consider the old fashioned state monad again:</p><pre><code class="haskell">newtype State s a = State { runState :: s -&gt; (a, s) }</code></pre><p>This looks like a composition of two functors, <code>(-&gt;) s</code> and <code>(,) s</code>, although the second is flipped, but it doesn't <i>act</i> like the composition of reader and writer!</p><p>The notion of an <code>Update</code> monad came out of trying to find something that felt more like that composition.</p><p>What if we break up the need for the two <code>s</code>s to be the same? Done one way you get the Bob Atkey-style parameterized monad for State:</p><pre><code class="haskell">newtype State i j a = State { runState :: i -&gt; (a, j) }</code></pre><p>This is what we usually do, but another way to more loosely couple the types of the two <code>s</code>'s is to take the update to be some answer in a <code>Monoid</code> that has an action on our state.</p><pre><code class="haskell">newtype Update s m a = Update { runUpdate :: s -&gt; (m, a) }</code></pre><p>This has the same type as above (except for the fact that I needlessly shuffled the pair), but we want to give it a completely different <code>Monad</code>. Instead of a parameterized monad, we want a regular <code>Monad</code>. Instead of matching indices, we're applying the updates to our state.</p><p>The result you give back for how to manipulate the state is a mere update that has an appropriate monoid action on the state, rather than a whole new state:</p><pre><code class="haskell">instance RightMonoidAction s m =&gt; Applicative (Update s m) where
  pure a = Update $ \s -&gt; (mempty, a)
  Update ff &lt;*&gt; Update fa = Update $ \s -&gt; case ff s of
    (m, f) -&gt; case fa (act s m) of
      (n, a) -&gt; (mappend m n, f a)

instance RightMonoidAction s m =&gt; Monad (Update s m) where
  return a = Update $ \s -&gt; (mempty, a)
  Update f &gt;&gt;= k = Update $ \s -&gt; case f s of
    (m, a) -&gt; case runUpdate (k a) (act s m) of
      (n, b) -&gt; (mappend m n, b)</code></pre><p>So what examples might we come up with?</p><p>We can always <code>get</code> in an update monad:</p><pre><code class="haskell">get = Update $ \s -&gt; (mempty, s)</code></pre><p>And it is easy to define an action for <code>Endo s</code> on <code>s</code>. Using that choice of <code>Monoid</code> lets us easily recover something with the full power of <code>State</code>.</p><pre><code class="haskell">instance RightMonoidAction s (Endo s) where
  act s (Endo f) = f s

put s = Update $ \_ -&gt; (Endo (const s), ())</code></pre><p>We can also recover the power of <code>State</code> by using <code>Last</code> from <code>Data.Monoid</code> with an appropriate action.</p><pre><code class="haskell">
instance RightMonoidAction s (Last s) where
  act s (Last m) = fromMaybe s m

put s = Update $ \_ -&gt; (Last (Just s), ())</code></pre><p>We can recover <code>Writer m</code> with</p><pre><code class="haskell">instance Monoid m =&gt; RightMonoidAction () m where
  act () m = ()</code></pre><p>or recover <code>Reader e</code> with</p><pre><code class="haskell">instance RightMonoidAction e () where
  act e () = e</code></pre><p>For a simple example, let's say you have a monotonically increasing counter for fresh variables. You could have the update language consist of how many times you bump the counter, the relative change, rather than the new counter value itself.</p><p>Ahman and Uustalu have a bunch of other examples and we'll build one more below.</p><p>As an aside: We can also derive a coupdate comonad. This can be useful for defining a variant notion of a lens where we restrict updates to updates that can be made in some monoidal language. This works because coupdate is analogous to the store comonad restricted to updates in some monoidal language. We might revisit that concept in a future post, but Danel Ahman and Tarmo Uustalu wrote up an <a href="http://homepages.inf.ed.ac.uk/s1225336/papers/types14.pdf">incredibly brief summary</a> of them.</p><p>Sadly, the MPTC for <code>RightMonoidAction</code> is rather annoying to use in practice. We might want <code>RightMonoidAction m m</code> for every <code>Monoid</code>, but we likely also want <code>RightMonoidAction s (Endo s)</code>, which results in overlap, incoherence and conflict. You can work around this to some extent with <code>newtype</code> noise.</p><p>Consequently, we won't actually be using the type given above, but we'll be applying it in spirit.</p><p>One benefit of thinking in terms of update monads is that now you can expose all of the guts of your application, and nobody can violate your state change invariants anyways. This resolves the false dichotomy between <a href="https://www.reddit.com/r/haskell/comments/2uoton/edward_kmett_encapsulation_vs_code_reuse/">encapsulation and code reuse</a> for this one application domain.</p><h1 id="a-list-of-successes"><a href="#a-list-of-successes">A List of Successes</a></h1><p>To keep the code approachable, I'll go back to the simplest and cleanest design of a parser I know. The title of this post is a riff on Philip Wadler's 1985 paper <a href="https://rkrishnan.org/files/wadler-1985.pdf">How to Replace Failure by a List of Successes</a> in which he talked about a very straightforward example of a parser that works particularly well in a lazy language.</p><p>So what does a &quot;list of successes&quot; parser look like?</p><pre><code class="haskell">data Parser a = Parser { runParser :: String -&gt; [(a, String)] }</code></pre><p>Today we'd recognize it as just <code>StateT String []</code>, but monad transformers didn't exist back then.</p><p>To try to get away from arbitrary state, we should ask ourselves the question, &quot;what actions do we actually want to be able to apply to the <code>String</code>?&quot;</p><p>Well, a nice parser will only ever drop characters, so we could switch out the state <code>String</code> for one with a monoid action on it such as</p><pre><code class="haskell">newtype Drop = Drop Int

instance Monoid Drop where
  mempty = Drop 0
  mappend (Drop a) (Drop b) = Drop (a + b)

instance RightMonoidAction [a] Drop where
  act s (Drop n) = drop n s</code></pre><p>Note: evil parsers that do things like push back input they haven't seen cause problems for parser combinators that avoid backtracking on consumption unless under <code>try</code> and the like, such as Parsec, so this is a fairly sound assumption.</p><p>This is just the <code>Sum Int</code> monoid, with a carefully chosen action. The action is valid as long as we limit ourselves to non-negative drops in aggregate smaller than the maximum size of an <code>Int</code>.</p><p>Now we can consider the corresponding &quot;update monad transformer,&quot; which would give us something like</p><pre><code class="haskell">data Parser a = Parser { runParser :: String -&gt; [(Drop, a)] }</code></pre><p>But since we're using the notion of an update monad in spirit rather than in actuality we'll drop the newtype for <code>Drop</code> and just use <code>Int</code>. We'll agree to just &quot;think&quot; <code>Drop</code> really hard when we see it in the future.</p><pre><code class="haskell">data Parser a = Parser { runParser :: String -&gt; [(Int, a)] }</code></pre><p>The one thing that we've really gained here is that we can know that no action randomly replaces the input string with another string. They all consume the same source.</p><p>One win we could have, if <code>String</code> was replaced by <code>ByteString</code> (or <code>Text</code>) here, is that you could exploit this to allow the user to recognize an identifier using any combination of actions and then <code>slice</code> the <code>ByteString</code> (or <code>Text</code>) over the range that sub-parser matched. This would give you efficient sharing with the source, rather than breaking the input down into characters and then rebuilding a new bytestring that shares nothing. Slicing in <code>trifecta</code> is done in this spirit, but on fingertrees of bytestrings instead.</p><p>Moreover, we've gained something else critical. We've gained information about exactly how many characters we've consumed in a way that could let us work smarter for actions in the applicative and for <code>(&gt;&gt;)</code>.</p><h1 id="a-heap-of-successes"><a href="#a-heap-of-successes">A Heap of Successes</a></h1><p>If we grouped the results up by the <code>Int</code> worth of characters we are dropping, this would tell us the offset of everything in that group, regardless of parse result.</p><p>We could do this with something like:</p><pre><code class="haskell">data Parser a = Parser { runParser :: String -&gt; IntMap [a] }</code></pre><p>But what we really want is cheap access to the next element, not random access so this sounds a lot more like a heap to me.</p><p>We could go grab something like a pairing heap from an older post I wrote on <a href="https://www.fpcomplete.com/user/edwardk/revisiting-matrix-multiplication/part-5">Heaps of Performance</a>, or grab a more standard heap construction.</p><p>For now, I'm going to punt on that and decide to proceed with a simple <code>[(Int, a)]</code> representation where I maintain one invariant: The list is sorted by the number of elements we're dropping.</p><pre><code class="haskell">type Heap a = [(Int, a)]</code></pre><p>When I'm referring to a heap for now, I'll be referring to a list in this form. A sorted list is a <i>unary</i> heap replete with the heap property and everything, so I'm not even lying!</p><p>Feel free to replace it with something with better performance characteristics, though.</p><p>We can merge heaps:</p><pre><code class="haskell">-- fair interleaving, because, well, why not? i guess we'll see.
merge :: Heap a -&gt; Heap a -&gt; Heap a
merge [] as = as
merge as [] = as
merge aas@(a:as) bbs@(b:bs)
  | fst a &lt;= fst b = a : merge bbs as
  | otherwise      = b : merge bs aas</code></pre><p>and we can <code>gather</code> results by key.</p><pre><code class="haskell">gather :: Heap a -&gt; Heap [a]
gather [] = []
gather ((i0, a0) : as0) = go i0 [a0] as0 where
  go i acc [] = [(i,acc)]
  go i acc ((j, a) : as)
    | i == j    = go i (a:acc) as
    | otherwise = (i, acc) : go j [a] as</code></pre><p>So, let's write a parser:</p><pre><code class="haskell">newtype Parser i o = Parser { runParser :: [i] -&gt; Heap o }
  deriving Functor</code></pre><p><code>State s a</code> is neither covariant or contravariant in <code>s</code>, because <code>s</code> occurs in both positive and negative position, but we can parameterize the Parser covariantly on its input type, because unlike the usual <code>Parser</code> we can make this a <code>Profunctor</code>: The <code>i</code> only occurs in negative position, and the <code>RightMonoidAction</code> on the lists we read as input for <code>Drop</code> doesn't care about the type parameter of the list.</p><pre><code class="haskell">instance Profunctor Parser where
  dimap f g (Parser m) = Parser $ map (second g) . m . map f</code></pre><p>But we can start to see a bigger win when it comes to the <code>Applicative</code> instance:</p><pre><code class="haskell">instance Applicative (Parser i) where
  pure a = Parser $ \_ -&gt; [(0,a)]
  Parser mf &lt;*&gt; Parser ma = Parser $ \s0 -&gt; go 0 s0 (gather (mf s0)) [] where
    go i s ((j, fs) : fss) acc
      | s' &lt;- drop (j-i) s = go j s' fss
                           $ merge acc
                           $ ma s' &gt;&gt;= \(k,a) -&gt; fmap (\f -&gt; (j+k,f a)) fs
    go _ _ [] acc = acc</code></pre><p>In the expression <code>m &lt;*&gt; n</code>, the parser <code>n</code> doesn't care about the value returned by <code>m</code>. It only cares about how many characters it consumed. So what we do here is:</p><ol><li><p>First, gather up all parses of the same length.</p></li><li><p>Starting with an empty heap as an accumulator, loop over the different lengths of parses in ascending order, dropping the delta from the previous drop from a working state, and feeding it to the second parser. When we're done we take the heap, shift everything in it by the number of elements we dropped to get there, and merge it with an accumulator.</p></li><li><p>Emit the accumulated heap.</p></li></ol><pre><code class="haskell">instance Alternative (Parser i) where
  empty = Parser $ \_ -&gt; []
  Parser m &lt;|&gt; Parser n = Parser $ \s -&gt; m s `merge` n s</code></pre><p>The <code>Alternative</code> just merges the two result heaps.</p><p>Turning to the <code>Monad</code>, we don't get the benefits we had with <code>(&lt;*&gt;)</code> in the <code>(&gt;&gt;=)</code> case. Subsequent parsing steps can now care about the values seen so far, so <code>gather</code> doesn't help. We can still at least drive the subsequent parses by dropping incrementally, as before, though.</p><pre><code class="haskell">instance Monad (Parser i) where
  return a = Parser $ \_ -&gt; [(0,a)]
  Parser ma &gt;&gt;= amb = Parser $ \s0 -&gt; go 0 s0 (ma s0) [] where
    go i s ((j, a) : fss) acc
      | s' &lt;- drop (j-i) s = go j s' fss
                           $ merge acc
                           $ (\(k,b) -&gt; (j+k,b)) &lt;$&gt; runParser (amb a) s'
    go _ _ [] acc = acc
  (&gt;&gt;) = (*&gt;)
  fail _ = empty 

instance MonadPlus (Parser i) where
  mzero = empty
  mplus = (&lt;|&gt;)</code></pre><p>With that we can go and write instances to make this compatible with the operations in my <code>parsers</code> package:</p><p>We can do basic parsing:</p><pre><code class="haskell">instance Parsing (Parser i) where
  -- do or do not, there is no try
  try = id
  m &lt;?&gt; _ = m
  unexpected _ = empty
  eof = Parser $ \s -&gt; case s of
    [] -&gt; [(0,())]
    _  -&gt; []
  notFollowedBy (Parser m) = Parser $ \s -&gt;
    if null (m s)
    then [(0,())]
    else []</code></pre><p>We can recognize characters:</p><pre><code class="haskell">instance (c ~ Char) =&gt; CharParsing (Parser c) where
  satisfy p = Parser $ \s -&gt; case s of
    c:_ | p c -&gt; [(1,c)]
    _         -&gt; []</code></pre><p>And this parser can gracefully support <code>lookAhead</code>.</p><pre><code class="haskell">instance LookAheadParsing (Parser i) where
  lookAhead (Parser m) = Parser $ \s -&gt; first (const 0) &lt;$&gt; m s</code></pre><p>And we can write a helper combinator that converts to a more traditional &quot;list of successes&quot; form.</p><pre><code class="haskell">parse :: Parser i o -&gt; [i] -&gt; [(o, [i])]
parse (Parser m) s0 = go 0 s0 (m s0) where
  go i s ((j,o):xs) | s' &lt;- drop (j-i) s = (o,s') : go j s' xs
  go _ _ [] = []</code></pre><h1 id="caveats"><a href="#caveats">Caveats</a></h1><p>The <code>Update</code> monad conversion isn't free. Left associated binds in an <code>Update</code> monad now apply two different actions to the same source, whereas normally we apply the two actions in series. Compare</p><pre><code class="haskell">(drop 10000 s, drop (10000+123) s)</code></pre><p>with</p><pre><code class="haskell">let s' = drop 10000 s in (s', drop 123 s')`</code></pre><p>You'd generally rather have the latter, so <code>State</code> still has a reason to exist!</p><p>Here we mitigate that to some extent by gathering all of our updates in a particular order that lets us share some work between them to reduce this cost when working across multiple results, but we still run into this for left associated binds.</p><p>There are several workarounds an update monad might employ to control for this phenomenon:</p><ul><li>We could also work around this by hitting this with the <code>Codensity</code> monad to <a href="http://comonad.com/reader/2011/free-monads-for-less/">force everything into right association</a>.</li><li>Or we can work smarter by finding a better representation for our set or Monoid. For example, if we had a cheaper drop by using <a href="https://www.fpcomplete.com/user/edwardk/fibonacci/leonardo">Leonardo</a> or <a href="https://www.fpcomplete.com/user/edwardk/online-lca#skew-binary">skew-binary</a> random access lists to reduce it to <i>O(log n)</i>, then we could greatly reduce the costs of applying our monoid action.</li></ul><h1 id="on-leftovers"><a href="#on-leftovers">On Leftovers</a></h1><p>Given the structure above, we <i>could</i> define a <code>Category</code> for parsing with (in part)</p><pre><code class="haskell">instance Category Parser where
  id = Parser $ \ case
    a:_ -&gt; [(1,a)]
    _   -&gt; []
  ... </code></pre><p>Then we can drive <code>(f . g)</code> by having the right parser consume input and spit out a single output token, and repeating to generate a lexer that generates tokens consumed by the next parser. This is problematic though, we're generating a list of lists of tokens due to the non-determinism possible in the lexing phase, and they share prefixes, not suffixes. This is much better served by switching away from the simple parser model we have here where we know everything up front, and instead starting to talk about something like a <code>Conduit</code>, <code>Iteratee</code>, <code>Pipe</code> or <code>Machine</code>.</p><p><i>Exercise:</i> Why can't we have <code>Arrow</code>, <code>Strong</code>, <code>Choice</code>, etc?</p><p>Now, I don't like leftovers. This same mechanism whereby we spot the fact that we are only doing a limited form of update (e.g. dropping) extends to scrapping &quot;leftovers&quot; from these streaming models as well as models where we know the entire state up front. We just need an appropriate notion of &quot;action&quot;.</p><h1 id="conclusion"><a href="#conclusion">Conclusion</a></h1><p>To get here what did we do? We used the fact that an update monad can have a smaller, simpler update language than a <code>State</code> monad. Then we took an existing <code>StateT</code>-based monad for parsing and converted it to an appropriate <code>UpdateT</code> monad. Afterwards we realized we could impose an invariant on the order it gave back its results in the list to gather up like updates and enable us to have a more efficient <code>Applicative</code>.</p><p>I leave as an exercise the task of swapping out <code>[(Int, a)]</code> for a min-heap. We don't need to maintain a full sorted list. We can punt the task of sorting to a heap.</p><p>I also leave as an exercise how to extract the proper leftmost parse first. <code>merge</code> being needlessly fair destroyed this property along with the truth of the <code>Monad</code> laws (unless you quotient out the order in which you get results). Heaps will also destroy this property without some extra tagging to help resolve ties. <code>gather</code> also needs to reverse the accumulators to ensure this property holds. I'm not bothering with either of these things in the code above.</p><p><i>Exercise:</i> Why would we need to tag? How could we do it?</p><p>Moreover, I've only converted a fairly simple parser to this format above. Doing so with proper error handling is a more complex affair.</p><p>I've collapsed the code above into a single <a href="https://gist.github.com/ekmett/578eaf3e5a37f7315e6c">gist</a>.</p><p>-<a href="mailto:ekmett@gmail.com">Edward Kmett</a></p><p>May 1, 2015</p></article>

<div id="disqus_thread"><script>var disqus_shortname = "edwardk"; (function() { var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true; dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq); })();</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">comments powered by <span class="logo-disqus">Disqus</span></a></a>
</div>

</div>
</div>
<div class="row article-footer"><div class="span7 meta"><span class="sociallinksunicode social">
<a href="https://twitter.com/home?status=$url$" target="_blank"><i class="icon-twitter"></i></a>&nbsp;
<a href="http://www.facebook.com/sharer/sharer.php?u=$url$" target="_blank"><i class="icon-facebook"></i></a>&nbsp;
<a href="https://plus.google.com/share?url=$url$" target="_blank"><i class="icon-google-plus"></i></a></span>
</div>
</div>
</div>
<div class="footer"><div class="container"><div class="row"><div class="span12"><ul class="menu"><li><a href="https://www.schoolofhaskell.com/">School</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user">Users</a>
</li>

<li><a class="brand" href="https://fpcomplete.com">Sponsored by:
<img src="/static/img/logo.png" title="FPComplete">
</a>
</li>
</ul>
</div>
</div>
<div class="row"><div class="span12"></div>
</div>
</div>
</div>
<link rel="stylesheet" type="text/css" href="/static/bootstrap/css/bootstrap-responsive.css" />
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script><script src="https://www.schoolofhaskell.com/static/combined/Y-3k9_tW.js"></script><script>$(function(){
  $("a.logout").click(function(){
    var form = $("<form method='post'/>");
    form.attr("action", $(this).attr("href"));
    $("body").append(form);
    form.submit();
    return false;
  });
});

$(function(){
    $('.sociallinksunicode a').each(function(){
        $(this).attr('href',$(this).attr('href').replace('$url$',document.location));
    });
});

$(function(){
  // If we need to select a user/select a password then show the
  // details confirmation form, otherwise enable the getting started
  // section.
  if($('.alert-block a').text().match(/(selected a username|change your password)/)) {
    $("#confirm-details").show();
    $("#confirm-details #inputUsername").focus();
  } else {
    $("#get-started").removeClass('disabled').addClass('enabled');
  }

  // For lack of a plain HTML validation story this will do.
  $('.welcome-page').each(function(){
    $('form').submit(check);
  });
  function check(){
    setTimeout(check,500);
    var error = false;
    $('.error').removeClass('error');
    $('#enter-details input').each(function(){
      if($(this).val() == '') {
        $(this).parent().parent().addClass('error');
        error = true;
      }
    });
    if(error) return false;
    if($('[name=password]').val() == $('[name=confirm]').val()) {
      $('#confirm').removeClass('error');
      return true;
    } else {
      $('#confirm').addClass('error');
      return false;
    }
  }
});

$(function(){
  // When scrolling over a snippet editor, activate the "clone in IDE" popovers
  $('article').each(function(){
    var n = 100;
    var wait = 10000;
    function check(){
      if($('.clone').length == 0) {
        setTimeout(check,n);
        return;
      }
      var activated = $.cookie('clone-popover');
      if (activated) return;
      var activate = false;
      $('.controlsRun:onScreen').each(function(){
        $.cookie('clone-popover', 'true', { expires: 30, path: '/' });
        activate = true;
        return false;
      });
      if(activate) {
          $('.clone').each(function(){
              // The bootstrap API is rather unreasonable to say the
              // least.
              next = $(this).parent();
              var title = next.attr('title');
              next.attr('data-content',$(this).attr('data-content'));
              next.attr('title',$(this).attr('title'));
              next.popover('show',{
                  title: $(this).attr('title')
              });
              next.attr('title',title);
          });
          setTimeout(function(){
              $('.clone').each(function(){
                  $(this).parent().popover('hide');
              });
          },wait);
      } else {
        setTimeout(check,n);
      }
    }
    setTimeout(check,n);
  });
});

// onScreen jQuery plugin v0.2.1
// (c) 2011-2013 Ben Pickles
//
// http://benpickles.github.com/onScreen
//
// Released under MIT license.
(function(a){a.expr[":"].onScreen=function(b){var c=a(window),d=c.scrollTop(),e=c.height(),f=d+e,g=a(b),h=g.offset().top,i=g.height(),j=h+i;return h>=d&&h<f||j>d&&j<=f||i>e&&h<=d&&j>=f}})(jQuery);

/*!
 * jQuery Cookie Plugin v1.1
 * https://github.com/carhartl/jquery-cookie
 *
 * Copyright 2011, Klaus Hartl
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.opensource.org/licenses/GPL-2.0
 */
(function($, document) {

  var pluses = /\+/g;
  function raw(s) {
    return s;
  }
  function decoded(s) {
    return decodeURIComponent(s.replace(pluses, ' '));
  }

  $.cookie = function(key, value, options) {

    // key and at least value given, set cookie...
    if (arguments.length > 1 && (!/Object/.test(Object.prototype.toString.call(value)) || value == null)) {
      options = $.extend({}, $.cookie.defaults, options);

      if (value == null) {
	options.expires = -1;
      }

      if (typeof options.expires === 'number') {
	var days = options.expires, t = options.expires = new Date();
	t.setDate(t.getDate() + days);
      }

      value = String(value);

      return (document.cookie = [
	encodeURIComponent(key), '=', options.raw ? value : encodeURIComponent(value),
	options.expires ? '; expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE
	options.path    ? '; path=' + options.path : '',
	options.domain  ? '; domain=' + options.domain : '',
	options.secure  ? '; secure' : ''
      ].join(''));
    }

    // key and possibly options given, get cookie...
    options = value || $.cookie.defaults || {};
    var decode = options.raw ? raw : decoded;
    var cookies = document.cookie.split('; ');
    for (var i = 0, parts; (parts = cookies[i] && cookies[i].split('=')); i++) {
      if (decode(parts.shift()) === key) {
	return decode(parts.join('='));
      }
    }
    return null;
  };
  $.cookie.defaults = {};})(jQuery, document);
</script><!--[if lt IE 10]><script src="https://www.schoolofhaskell.com/static/design/js/ie.js?etag=ayV2DuJ0"></script><![endif]--><script>if(!window.location.href.match(/localhost/)){var track = '/tutorial/user/edwardk/heap-of-successes';
window._gaq = [['_setAccount','UA-36928035-1'],track != ''? ['_trackPageview',track] : ['_trackPageview']
,['_trackPageLoadTime']];window._gaq.push(['_setCustomVar',1,'Section','School of Haskell',3]);
window._gaq.push(['_setCustomVar',2,'User Type','Visitor',1]);
(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);

})();}</script>
<!-- Prompt IE 6 users to install Chrome Frame. Remove this if you want to support IE 6.  chromium.org/developers/how-tos/chrome-frame-getting-started --><!--[if lt IE 7 ]><script src="//ajax.googleapis.com/ajax/libs/chrome-frame/1.0.3/CFInstall.min.js"></script><script>window.attachEvent('onload',function(){CFInstall.check({mode:'overlay'})})</script><![endif]--></body></html>