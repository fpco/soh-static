<!DOCTYPE html>
<html><head><title>Part III: Extending Vector - School of Haskell | School of Haskell</title><meta http-equiv="x-ua-compatible" content="IE=9"><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="google-site-verification" content="Rfxk2TdeMMXEXHgJ2_OO8Rt3hPbQSDao0OXQV_n6z_s" /><link href="//fonts.googleapis.com/css?family=Merriweather" rel="stylesheet" type="text/css"><link href="https://www.schoolofhaskell.com/recent-content/feed" type="application/rss+xml" rel="alternate" title="Recently published content">
<link rel="stylesheet" href="https://www.schoolofhaskell.com/static/combined/UlwEHVcM.css"><style>.social{margin-right:1em}h1{font-family:Merriweather !important}article{font-family:Merriweather !important}article li{font-family:Merriweather !important;line-height:1.6em}h1,h2,h3,h4,h4,h5{font-family:Merriweather !important}.editor p{font-family:Frutiger, "Frutiger Linotype", Univers, Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans Condensed", "Liberation Sans", "Nimbus Sans L", Tahoma, Geneva, "Helvetica Neue", Helvetica, Arial, sans-serif}.article-footer{border-top:1px solid #ddd;padding-top:1em;margin-top:1em}body{font-size:16px !important}.navbar .navbar-inner{background:#3c3f41}.navbar .brand{font-size:14px}.navbar .brand img{width:6em}.navbar .icon-wrench{margin:0 -0.5em 0 -0.5em;padding:0 1em 0 1em;height:20px}.navbar-inverse .nav .active a{background:#333638}.navbar-inverse .nav > li > a{color:#a7a7a7
}.navbar-inverse .btn-navbar{background:#333638}.navbar-inverse .nav > li a:hover,.navbar-inverse .btn{background:#333537 !important}@media (max-width: 979px) {.icon-wrench{padding-left:1em !important}}.breadcrumb{border-top-left-radius:0;border-top-right-radius:0}h1{margin-top:20px}.breadcrumb-container + .main-content h1{margin-top:0}.footer{padding:30px 0;margin-top:70px;border-top:1px solid #e5e5e5;background-color:#f5f5f5}.footer ul.footer-menu{list-style-type:none}.footer ul.footer-menu li{display:inline-block}.footer ul.footer-menu li + li{margin-left:0.5em}.footer ul.footer-menu li + li:before{margin-right:0.5em;content:"Â·";color:#999}.footer ul.menu li{display:inline-block}.footer ul.menu li + li{margin-left:0.5em}.footer .copyright{margin-left:25px}.main-content{min-height:100%}.gravatar{width:80px;height:80px;border-radius:2px;background:#eee}.empty-gravatar{width:0}.container{font-family:"Segoe UI", Candara, "Bitstream Vera Sans", "DejaVu Sans", "Bitstream Vera Sans", "Trebuchet MS", Verdana, "Verdana Ref", sans-serif}.container h1,.container h2,.container h4,.container h4,.container h5{font-family:"Segoe UI", Candara, "Bitstream Vera Sans", "DejaVu Sans", "Bitstream Vera Sans", "Trebuchet MS", Verdana, "Verdana Ref", sans-serif}article{font-family:Merriweather !important}article h1{font-family:Merriweather !important}article li{font-family:Merriweather !important;line-height:1.6em}article li + li{margin-top:0.5em}article div.code{background:#f9f9f9;border:1px solid #d1d1d1;position:relative;border-radius:0.2em;margin:0.25em 0 0.75em 0;min-height:2.5em}article code{color:#005580;font-size:14px;white-space:pre}article a.hoogle > code{color:#0088cc;font-size:14px;white-space:pre;border:0}article .expand-code{display:none}article pre{overflow:auto;word-wrap:normal}article code.active{display:block;max-height:430px}article h1{font-size:31.5px}article h3{font-size:17.5px}article h4{font-size:14px}article h5,article h6{font-size:11.9px}article p{line-height:1.7em}article h1 code,article h2 code,article h3 code,article h4 code,article h5 code,article h6 code{font-size:inherit !important}article h1 a,article h2 a,article h3 a,article h4 a,article h5 a,article h6 a{color:#444}article h1 a:before,article h2 a:before,article h3 a:before,article h4 a:before,article h5 a:before,article h6 a:before{margin-left:-1.5em;padding-right:0.5em;font-family:fontawesome;content:"\f0c1";font-size:20px;color:#fff}article h1 a:hover,article h2 a:hover,article h3 a:hover,article h4 a:hover,article h5 a:hover,article h6 a:hover{text-decoration:none;color:#0088cc}article h1 a:hover:before,article h2 a:hover:before,article h3 a:hover:before,article h4 a:hover:before,article h5 a:hover:before,article h6 a:hover:before{color:#888}article h2{font-size:24.5px}article .popover{font-family:actor}article .popover h3.popover-title{font-family:actor !important;font-size:1em}article .popover .popover-content{width:15em;font-size:1em}article .controlsRun{display:block;padding:0.5em;text-align:right;background:#f2f2f2}article .controlsRun a.clone{margin-right:1em;font-family:actor;text-decoration:none}article .controlsRun a.clone span{padding-left:0.5em}article .controlsRun a.run,article .controlsRun a.reset,article .controlsRun a.show-code{font-size:16px}article .controlsRun a.run span,article .controlsRun a.reset span,article .controlsRun a.show-code span{display:none}article .controlsRun a.reset{margin-left:0.5em;color:#a2becc}article .controlsRun a.reset{display:none}article .controlsRun a.show-code{margin-right:0.75em}article .controlsRun a.run:hover,article .controlsRun a.show-code:hover{text-decoration:none}article .controlsRun a.show-code.active{color:#DC0D0D}article .controlsRun a[disabled]{color:#a2becc;cursor:default}article .collapse-area .collapse-header{background:#0088cc;color:#fff;padding:0.3em;cursor:pointer}article .collapse-area .hidden-toggle:before{content:"\f0d7";font-family:fontawesome;margin-right:0.5em;margin-left:0.25em}article .collapse-area .collapsed-files{overflow:auto;height:auto}article .collapse-area.collapse-disabled{display:none}article .collapse-area.collapse-area-off .collapsed-files{height:0px;overflow:hidden}article .collapse-area.collapse-area-off .hidden-toggle:before{content:"\f0da"}article .snippet-stdio .stdout{margin:0.5em;padding-right:2em;position:relative;word-wrap:break-word}article .snippet-stdio .stdin{-webkit-box-shadow:none;-moz-box-shadow:none;box-shadow:none;-webkit-transition:none;-moz-transition:none;-o-transition:none;transition:none;padding:0;margin:0}article .hoogle-results{margin:0.25em}article .hoogle-results .hoogle-inner{background:#fff;padding:0.5em;border-radius:3px;border:1px solid #ddd}article .hoogle-results .hoogle-inner .close-link{position:relative;float:right;margin-top:-0.5em;margin-right:-0.5em}article .snippet-output-errors{margin:1em 0.5em 0.5em 0.5em;position:relative}article .snippet-output-errors ul{list-style-type:none;margin:0;position:relative}article .snippet-output-errors pre{border:0;border-radius:0;padding:0.25em;margin:0;background:inherit;color:inherit}article .snippet-output-errors .close-link{color:inherit;background:inherit}article .snippet-editors{z-index:0;padding:0.25em}article .close-link{padding:0.5em;background:#eaeaea;border-bottom-left-radius:0.2em;border-top-right-radius:0.2em;position:absolute;top:0;right:0}article .close-link:hover{text-decoration:none}article .snippet-title{padding:0.5em 0 0 0.5em}article .snippet-title .snippet-icon{font-family:FontAwesome;display:inline-block;margin-right:0.5em}article .fullModuleCode + div .snippet-title{margin-top:0.5em;border-top:1px solid #ccc;padding-top:0.5em}article .CodeMirror{height:auto;min-height:1em;line-height:1.5em;background:transparent;font-size:14px !important}article .CodeMirror .highlighted{background:rgba(250, 210, 0, 0.45) !important}article .CodeMirror-widget{margin-left:2em;line-height:1.8}article .CodeMirror.collapsed{height:10em !important}article .editor .expander{text-align:center;display:block;padding:0.5em;text-decoration:none;border-bottom-left-radius:2px;border-bottom-right-radius:2px}article .editor .expander .ellipsis{background:white;border:1px solid #ccc;padding:0 0.5em;height:1em;line-height:0.5em;display:inline-block;color:#555;cursor:pointer}article .editor .expander .ellipsis:hover{background:#ddd;color:#333}article .web-runner{margin:0.5em;padding:0.5em;border:1px solid #ccc;border-radius:3px;background:#f5f5f5}article .web-runner iframe{border:0;margin-top:0.5em;margin-bottom:0;background:white}article .web-runner .controls i{cursor:pointer;color:#0088cc}article .web-runner .controls i:hover{color:#222}article .web-runner .controls i + i{margin-left:0.5em}article .web-runner .controls .icon-remove{float:right}article .hidden{display:block;visibility:visible}article .controlsShowHide{margin-bottom:0.5em}.tutorial-body{float:left !important}.tutorial-nav{float:right !important}@media (max-width: 979px) {.related-content{float:right}.author-name{display:block;margin-left:20px !important;padding-left:5px;margin-top:5px}article h1 a:hover:before,article h2 a:hover:before,article h3 a:hover:before,article h4 a:hover:before,article h5 a:hover:before,article h6 a:hover:before{color:#fff}.tutorial-nav{float:none !important;width:auto !important}.tutorial-body{float:none !important;width:auto !important}}@media (min-width: 980px) and (max-width: 1199px) {.navbar-search{display:none}.tutorial-nav{width:200px}.tutorial-body{width:720px}}#accountPage h1{margin:20px 0 0 0}#accountPage h2{font-size:20px}.group-contents .span8{float:left}.group-contents .span4{float:right}.container > .alert-block{margin-top:1em}.alert{color:#aa874a
}.social{margin-bottom:.8em;display:block}.social a{text-decoration:none}.social i{font-size:1.1em;color:#fff;padding:0.25em;border-radius:0.25em;width:1em;display:inline-block;text-align:center}.social i.icon-twitter{background:#0088cc}.social i.icon-facebook{background:#3b5998
  }.social i.icon-google-plus{background:#dd4b39
  }.well pre{background:#fcfcfc}.well h2{margin-top:0}code{color:#005580;font-size:14px;white-space:pre}</style><!--[if lt IE 8]><link rel="stylesheet" href="https://www.schoolofhaskell.com/static/design/css/ie7.css?etag=TSMl9x1V"><![endif]--><!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]--></head><body class="not-logged-in" itemscope itemtype="http://schema.org/Product"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-H62P" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-H62P');</script><div class="navbar navbar-inverse navbar-static-top"><div class="navbar-inner"><div class="container"><a class="btn btn-navbar" type="button" data-toggle="collapse" data-target=".nav-collapse"><span class="icon-bar"></span>
<span class="icon-bar"></span>
<span class="icon-bar"></span>
</a>
<a class="brand" href="/"><img src="/static/img/haskell-logo-wide.png" title="School of Haskell">
</a>
<div class="nav-collapse collapse"><ul class="nav"><li><a href="https://www.schoolofhaskell.com/">School</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user">Users</a>
</li>
</ul>
<form class="navbar-search pull-left" action="https://www.schoolofhaskell.com/search"><input class="search-query" type="text" placeholder="Search" name="search">
</form>
</div>
</div>
</div>
</div>
<div class="container breadcrumb-container"><div class="row"><div class="span12"><ul class="breadcrumb"><li><a href="https://www.schoolofhaskell.com/user/edwardk">Edward Kmett</a>
<span class="divider">/</span>
</li>
<li><a href="https://www.schoolofhaskell.com/user/edwardk/revisiting-matrix-multiplication">Revisiting Matrix Multiplication</a>
<span class="divider">/</span>
</li>
<li><a href="https://www.schoolofhaskell.com/user/edwardk/revisiting-matrix-multiplication/part-3">Part III: Extending Vector</a>
</li>
</ul>
</div>
</div>
</div>
<div class="container main-content"><div class="row"><div class="span12"><h1 itemprop="name">Part III: Extending Vector</h1>
</div>
</div>
<div class="row"><div class="span7 meta"><p><span class="date">25 Aug 2013</span>
<span class="author"><a href="https://www.schoolofhaskell.com/user/edwardk">Edward Kmett</a>
</span>
<span class="view-edit-link pull-right"><a class="view-source-link" href="https://www.schoolofhaskell.com/tutorial-raw/4906/c9948ec20386ad678e5f35781e4854b172e6308a">View Markdown source</a>
</span>
</p>
<p class="tags"></p>
</div>
</div>
<div class="row"><div class="span7 meta"><span class="sociallinksunicode social">
<a href="https://twitter.com/home?status=$url$" target="_blank"><i class="icon-twitter"></i></a>&nbsp;
<a href="http://www.facebook.com/sharer/sharer.php?u=$url$" target="_blank"><i class="icon-facebook"></i></a>&nbsp;
<a href="https://plus.google.com/share?url=$url$" target="_blank"><i class="icon-google-plus"></i></a></span>
</div>
</div>
<p class="alert">As of March 2020, School of Haskell has been switched to read-only mode.</p>
<div class="row" itemprop="desc"><div class="span4 tutorial-nav"><div class="related-content"><ul class="nav nav-tabs nav-stacked"><li><script>reddit_target='fpcomplete'</script>
<script src="https://redditstatic.s3.amazonaws.com/button/button1.js"></script>
</li>
<li><a href="https://www.schoolofhaskell.com/user/edwardk/revisiting-matrix-multiplication/part-2">Previous content: Part II: The Zen of Z-Ordering</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user/edwardk/revisiting-matrix-multiplication/part-4">Next content: Part IV: IntMap!?</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user/edwardk/revisiting-matrix-multiplication">Go up to: Revisiting Matrix Multiplication</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user/edwardk">See all content by Edward Kmett</a>
</li>
</ul>

</div>
<div class="aside"><h3>Sections</h3>
<ul><li><a href="#vector">Vector</a></li><li><a href="#sorting-out-vectors">Sorting out Vectors</a></li><li><a href="#unboxed-vectors">Unboxed Vectors</a></li><li><a href="#hybrid-vectors">Hybrid Vectors</a></li><li><a href="#custom-stream-fusion">Custom Stream Fusion</a></li><li><a href="#matrices--not-vectors">Matrices, not Vectors</a></li></ul></div>
</div>
<div class="span8 tutorial-body" data-environment="ghc-7.8-stable-14.09">
<article><p>As before, if you haven't already, I'd highly recommend reading parts <a href="https://www.fpcomplete.com/user/edwardk/revisiting-matrix-multiplication-part-1">1</a> and <a href="https://www.fpcomplete.com/user/edwardk/revisiting-matrix-multiplication-part-2">2</a> before proceeding. That said, if you ignore the motivation for the sorting, this post largely stands alone as a practicum on how to extend the <code>vector</code> package with a custom <code>Vector</code> type and custom stream fusion combinators.</p><p><b>All</b> of the No-Prizes from the previous post are still available! That said, <a href="http://www.reddit.com/user/ssylvan">ssyvlan</a> on reddit was quite helpful in discussions about how to do the leading zero count more efficiently.</p><p>There is only one No-Prize opportunity in this post simply because it otherwise is a fairly simple engineering exercise, and other than that one point I can't think of open questions I have about this code.</p><h1 id="vector"><a href="#vector">Vector</a></h1><p>Now that we have Morton keys, I finally want to at least be able to <i>represent</i> a sparse matrix.</p><p>When I think speed in Haskell, I think <code>vector</code>, <code>repa</code>, or <code>accelerate</code>. Today I'm going to focus on <code>vector</code>, because I think it is the easiest to adapt to suit my purposes.</p><p>Roman Leshchinskiy, author of <code>vector</code> is probably the single most dedicated disciple of speed I can think of in the Haskell community today. I pay lip service to speed, but he'll sit there and spend weeks fixing any single thing that he can't optimize away into a tight c-like loop. If we're going to try to be competitive with a more traditonal language implementation in the end, we'll want to piggyback on his efforts. Any loss of speed due to stupid misuses of his tools, on the other hand, will entirely be my fault.</p><p>One of the main things that <code>vector</code> gives us is the power of <a href="http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.104.7401">stream fusion</a>. That is to say that if you build a <code>Vector</code> and then immediately consume it, the <code>vector</code> library is often smart enough to never bother to construct the intermediate <code>Vector</code> at all! As we multiply we'll be merging and concatenating streams of values. It is nice to know we can avoid building huge arrays in the interim.</p><p>Again, as I merely pay lip service to the speed God and don't attend services regularly, I'll be going through the motions with a couple of custom stream fusion combinators later on, but I've done rather poor software engineering in that I haven't bothered to check that I needed them. I'd be truly surprised if that turned out not to be the case though.</p><p>Sadly, the vocabulary of <code>Vector</code> here is somewhat overloaded, so from here out when I talk about a <code>Vector</code>, unless I explicitly state otherwise, I mean the concept of <code>Vector</code> from <code>Data.Vector</code>. If it isn't clear from context then, I'll try to pretend the following imports are in scope:</p><pre><code class="active haskell">-- show
import Data.Vector as Boxed
import Data.Vector.Generic as Generic
import Data.Vector.Unboxed as Unboxed
import Data.Vector.Primitive as Primitive
import Data.Vector.Storable as Storable
-- /show

-- show These will also occur in code samples
import qualified Data.Vector.Generic.Mutable as GM
import qualified Data.Vector.Generic as G
import Data.Vector.Fusion.Stream as Stream

-- /show
main = putStrLn &quot;Those modules still exist!&quot;</code></pre><p>... that way if I talk about an <code>Unboxed.Vector</code> it should make some sense.</p><h1 id="sorting-out-vectors"><a href="#sorting-out-vectors">Sorting out Vectors</a></h1><p>The reason I want to use <code>vector</code> is that I want my storage to be arranged contiguously in memory whenever possible. Moreover, it enables me to use Dan Doel's excellent <code>vector-algorithms</code> to manipulate the the Vector of <code>(Key,Value)</code> pairs in our sparse matrices.</p><p>This comes up right away when we start to try to build a sparse matrix, as I want to sort my sparse matrices by <code>Key</code> in Morton order, and <code>vector-algorithms</code> provides me with a large number of sorting algorithms to experiment with, including the fastest <a href="http://hackage.haskell.org/packages/archive/vector-algorithms/0.5.4.2/doc/html/Data-Vector-Algorithms-Intro.html">intro sort</a> available in Haskell today. Moreover, it also includes an <a href="http://hackage.haskell.org/packages/archive/vector-algorithms/0.5.4.2/doc/html/Data-Vector-Algorithms-AmericanFlag.html">american flag</a> sort that could be used to gain asymptotically on the initial insertion by using the fact that we can not only compare but tell you the bit position at which our keys differ, even if we use variable length keys. This means we're not limited to the asymptotics of a <code>comparison sort</code> when constructing our initial matrices.</p><p>Dan's sorts rely very heavily on aggressive inlining to get worker-wrapper transforms to fire and to ensure that things like the comparisons done inside the sorting routine are being passed unboxed values.</p><p>Using <code>vector</code> and <code>vector-algorithms</code> leads to our first stumbling block.</p><p>What I want to do is store a <code>Vector (Key, a)</code> in such a way that I can have unboxed keys. However, I don't want to lose the flexibility to have unboxed values!</p><p>To that end, when I started this project about a week ago, I pushed out a <a href="http://hackage.haskell.org/package/hybrid-vectors"><code>hybrid-vectors</code></a> package to <a href="http://hackage.haskell.org/packages/hackage.html">hackage</a>.</p><p>As it'll be the glue that holds together our matrix representation until I find something better, I felt it made sense to say a few words motivating its construction.</p><h1 id="unboxed-vectors"><a href="#unboxed-vectors">Unboxed Vectors</a></h1><p><code>vector</code> is already quite smart about managing storage. In particular an unboxed <code>Vector</code> of pairs is managed as a pair of vectors of the individual parts. Anybody who has done much GPU work will recognize this as the <i>structure of arrays</i> (<b>SoA</b>) approach that is often used there rather than <i>array of structures</i> (<b>AoS</b>) approach used more traditionally throughout the rest of the industry.</p><p>In case you've never thought about it before, it is worth mentioning that it has many benefits. One of those benefits is that you don't pay cache storage for parts of the structure you don't look at. You also don't incur unnecessary time/space trade-offs for alignment issues, etc. The cache dominates most concerns about slightly more complicated addressing logic, and if you look at things like the x86 instruction set, the addressing logic usually simplifies as well! We can calculate the <code>\*{1,2,4,8}</code> multiplier in the index <i>en passant</i>, but the odd sizes you get in &quot;array of structures&quot; are usually not so easy to use.</p><p>All of this is well and good, but I can't just use <a href="http://hackage.haskell.org/packages/archive/vector/0.10.0.1/doc/html/Data-Vector-Unboxed.html"><code>Data.Vector.Unboxed</code></a>.</p><p>My particular motivation for working on this code in the first place requires me to be able to do matrix multiplication over certain fairly complicated ring-like structures that I can't <a href="http://hackage.haskell.org/packages/archive/vector/0.10.0.1/doc/html/Data-Vector-Unboxed.html#t:Unbox"><code>Unbox</code></a>. I say &quot;ring-like&quot; because right seminearrings without <a href="http://en.wikipedia.org/wiki/Zero_divisor">zero-divisors</a> arise in various forms of <a href="http://en.wikipedia.org/wiki/Chart_parser">chart parsing</a>, and <a href="http://www.cse.chalmers.se/~bernardy/PP.pdf">some</a> are even <a href="http://en.wikipedia.org/wiki/Nonassociative_ring">non-associative</a>!</p><h1 id="hybrid-vectors"><a href="#hybrid-vectors">Hybrid Vectors</a></h1><p>Fortunately, in a great feat of engineering, Roman left the entire <code>Vector</code> framework open to extension with new <code>Vector</code> types, by providing us with <a href="http://hackage.haskell.org/packages/archive/vector/0.10.0.1/doc/html/Data-Vector-Generic.html"><code>Data.Vector.Generic</code></a> and moreover, he made it so that the entire stream fusion framework he uses will just magically work with any instance of <a href="http://hackage.haskell.org/packages/archive/vector/0.10.0.1/doc/html/Data-Vector-Generic.html#t:Vector"><code>Generic.Vector</code></a>.</p><p>So all we need to do is define our own <code>Vector</code> (and <code>MVector</code>) type for the kinds of &quot;hybrid&quot; vectors we need.</p><p>Then Dan's fast sorting algorithms can be used out of the box and we can steal and extend Roman's fusion framework.</p><p><code>Data.Vector.Unboxed</code> has already shown us the way to build an SoA-style vector. We just need it to be more permissive about what kind of <code>Generic.Vector</code> vectors are allowed to comprise each side.</p><p>To define a <code>Generic.Vector</code>, first we must define <code>Generic.MVector</code> that'll be used for most operations involved in building or manipulating it behind the scenes.</p><pre><code class="active haskell">{-# LANGUAGE CPP #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE KindSignatures #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE UndecidableInstances #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE ScopedTypeVariables #-}

import Control.Monad
import Data.Monoid
import qualified Data.Vector.Generic.Mutable as GM
import qualified Data.Vector.Generic as G
import Data.Vector.Fusion.Stream as Stream
import Data.Data
import Prelude hiding ( length, null, replicate, reverse, map, read, take, drop, init, tail )
import Text.Read
-- show
data MVector :: (* -&gt; * -&gt; *) -&gt; (* -&gt; * -&gt; *) -&gt; * -&gt; * -&gt; * where
  MV :: !(u s a) -&gt; !(v s b) -&gt; MVector u v s (a, b)

instance (GM.MVector u a, GM.MVector v b) =&gt; GM.MVector (MVector u v) (a, b) where
  basicLength (MV ks _) = GM.basicLength ks
  basicUnsafeSlice s e (MV ks vs) = MV (GM.basicUnsafeSlice s e ks) (GM.basicUnsafeSlice s e vs)
  basicOverlaps (MV ks vs) (MV ks' vs') = GM.basicOverlaps ks ks' || GM.basicOverlaps vs vs'
  basicUnsafeNew n = liftM2 MV (GM.basicUnsafeNew n) (GM.basicUnsafeNew n)
  basicUnsafeReplicate n (k,v) = liftM2 MV (GM.basicUnsafeReplicate n k) (GM.basicUnsafeReplicate n v)
  basicUnsafeRead (MV ks vs) n = liftM2 (,) (GM.basicUnsafeRead ks n) (GM.basicUnsafeRead vs n)
  basicUnsafeWrite (MV ks vs) n (k,v) = GM.basicUnsafeWrite ks n k &gt;&gt; GM.basicUnsafeWrite vs n v
  basicClear (MV ks vs) = GM.basicClear ks &gt;&gt; GM.basicClear vs
  basicSet (MV ks vs) (k,v) = GM.basicSet ks k &gt;&gt; GM.basicSet vs v
  basicUnsafeCopy (MV ks vs) (MV ks' vs') = GM.basicUnsafeCopy ks ks' &gt;&gt; GM.basicUnsafeCopy vs vs'
  basicUnsafeMove (MV ks vs) (MV ks' vs') = GM.basicUnsafeMove ks ks' &gt;&gt; GM.basicUnsafeMove vs vs'
  basicUnsafeGrow (MV ks vs) n = liftM2 MV (GM.basicUnsafeGrow ks n) (GM.basicUnsafeGrow vs n)
-- /show
main = putStrLn &quot;It typechecks, so it must be correct.&quot;</code></pre><p>All we've done is say that our <code>Hybrid.MVector u v s (a,b)</code> is going to be comprised (strictly!) of two other vectors <code>u s a</code> and <code>v s b</code> so long as we have appropriate <code>Generic.MVector</code> instances to rely upon, and so long as they can both be manipulated in the same <a href="http://hackage.haskell.org/packages/archive/primitive/0.5.0.1/doc/html/Control-Monad-Primitive.html#t:PrimMonad"><code>PrimMonad</code></a>.</p><p>All we've done is borrow from similar operations from the vectors that comprise our constituent parts.</p><p>In the real code we then proceed to <code>INLINE</code> everything in sight, so that any inlined combinators from <code>Data.Vector.Generic</code> can &quot;see through&quot; our <code>instance</code> and <code>INLINE</code> the bodies of our methods.</p><p>We can construct a custom <code>Generic.Vector</code> similarly.</p><pre><code class="active haskell">{-# START_FILE Hybrid.hs #-}
{-# LANGUAGE CPP #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE KindSignatures #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE UndecidableInstances #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE ScopedTypeVariables #-}
module Hybrid where

import Control.Monad
import Data.Monoid
import qualified Data.Vector.Generic.Mutable as GM
import qualified Data.Vector.Generic as G
import Data.Vector.Fusion.Stream as Stream
import Data.Data
import Prelude hiding ( length, null, replicate, reverse, map, read, take, drop, init, tail )
import Text.Read

data MVector :: (* -&gt; * -&gt; *) -&gt; (* -&gt; * -&gt; *) -&gt; * -&gt; * -&gt; * where
  MV :: !(u s a) -&gt; !(v s b) -&gt; MVector u v s (a, b)

instance (GM.MVector u a, GM.MVector v b) =&gt; GM.MVector (MVector u v) (a, b) where
  basicLength (MV ks _) = GM.basicLength ks
  basicUnsafeSlice s e (MV ks vs) = MV (GM.basicUnsafeSlice s e ks) (GM.basicUnsafeSlice s e vs)
  basicOverlaps (MV ks vs) (MV ks' vs') = GM.basicOverlaps ks ks' || GM.basicOverlaps vs vs'
  basicUnsafeNew n = liftM2 MV (GM.basicUnsafeNew n) (GM.basicUnsafeNew n)
  basicUnsafeReplicate n (k,v) = liftM2 MV (GM.basicUnsafeReplicate n k) (GM.basicUnsafeReplicate n v)
  basicUnsafeRead (MV ks vs) n = liftM2 (,) (GM.basicUnsafeRead ks n) (GM.basicUnsafeRead vs n)
  basicUnsafeWrite (MV ks vs) n (k,v) = do
    GM.basicUnsafeWrite ks n k
    GM.basicUnsafeWrite vs n v
  basicClear (MV ks vs) = do
    GM.basicClear ks
    GM.basicClear vs
  basicSet (MV ks vs) (k,v) = do
    GM.basicSet ks k
    GM.basicSet vs v
  basicUnsafeCopy (MV ks vs) (MV ks' vs') = do
    GM.basicUnsafeCopy ks ks'
    GM.basicUnsafeCopy vs vs'
  basicUnsafeMove (MV ks vs) (MV ks' vs') = do
    GM.basicUnsafeMove ks ks'
    GM.basicUnsafeMove vs vs'
  basicUnsafeGrow (MV ks vs) n = liftM2 MV (GM.basicUnsafeGrow ks n) (GM.basicUnsafeGrow vs n)

  {-# INLINE basicLength #-}
  {-# INLINE basicUnsafeSlice #-}
  {-# INLINE basicOverlaps #-}
  {-# INLINE basicUnsafeNew #-}
  {-# INLINE basicUnsafeReplicate #-}
  {-# INLINE basicUnsafeRead #-}
  {-# INLINE basicUnsafeWrite #-}
  {-# INLINE basicClear #-}
  {-# INLINE basicSet #-}
  {-# INLINE basicUnsafeCopy #-}
  {-# INLINE basicUnsafeMove #-}
  {-# INLINE basicUnsafeGrow #-}

-- show
data Vector :: (* -&gt; *) -&gt; (* -&gt; *) -&gt; * -&gt; * where
  V :: !(u a) -&gt; !(v b) -&gt; Vector u v (a, b)

type instance G.Mutable (Vector u v) = MVector (G.Mutable u) (G.Mutable v)

instance (G.Vector u a, G.Vector v b) =&gt; G.Vector (Vector u v) (a, b) where
  basicUnsafeFreeze (MV ks vs) = liftM2 V (G.basicUnsafeFreeze ks) (G.basicUnsafeFreeze vs)
  basicUnsafeThaw (V ks vs) = liftM2 MV (G.basicUnsafeThaw ks) (G.basicUnsafeThaw vs)
  basicLength (V ks _) = G.basicLength ks
  basicUnsafeSlice i j (V ks vs) = V (G.basicUnsafeSlice i j ks) (G.basicUnsafeSlice i j vs)
  basicUnsafeIndexM (V ks vs) n = liftM2 (,) (G.basicUnsafeIndexM ks n) (G.basicUnsafeIndexM vs n)
  basicUnsafeCopy (MV ks vs) (V ks' vs') = do
    G.basicUnsafeCopy ks ks'
    G.basicUnsafeCopy vs vs'
  elemseq (V ks vs) (k,v) b = G.elemseq ks k (G.elemseq vs v b)
-- /show
  {-# INLINE basicUnsafeFreeze #-}
  {-# INLINE basicUnsafeThaw #-}
  {-# INLINE basicLength #-}
  {-# INLINE basicUnsafeSlice #-}
  {-# INLINE basicUnsafeIndexM #-}
  {-# INLINE basicUnsafeCopy #-}
  {-# INLINE elemseq #-}

instance (G.Vector u a, G.Vector v b, c ~ (a, b)) =&gt; Monoid (Vector u v c) where
  mappend = (G.++)
  {-# INLINE mappend #-}
  mempty = G.empty
  {-# INLINE mempty #-}
  mconcat = G.concat
  {-# INLINE mconcat #-}

instance (G.Vector u a, G.Vector v b, Show a, Show b, c ~ (a, b)) =&gt; Show (Vector u v c) where
  showsPrec = G.showsPrec

instance (G.Vector u a, G.Vector v b, Read a, Read b, c ~ (a, b)) =&gt; Read (Vector u v c) where
  readPrec = G.readPrec
  readListPrec = readListPrecDefault
  
instance (G.Vector u a, G.Vector v b, Eq a, Eq b, c ~ (a, b)) =&gt; Eq (Vector u v c) where
  xs == ys = Stream.eq (G.stream xs) (G.stream ys)
  xs /= ys = not (Stream.eq (G.stream xs) (G.stream ys))
  {-# INLINE (==) #-}
  {-# INLINE (/=) #-}

instance (G.Vector u a, G.Vector v b, Ord a, Ord b, c ~ (a, b)) =&gt; Ord (Vector u v c) where
  compare xs ys = Stream.cmp (G.stream xs) (G.stream ys)
  {-# INLINE compare #-}

{-# START_FILE Main.hs #-}

module Main where
import Hybrid
import Data.Vector.Unboxed as Unboxed
import Data.Vector
import Data.Vector as Boxed
import Data.Vector.Generic as Generic
import Data.Vector.Unboxed as Unboxed
import Data.Vector.Primitive as Primitive
import Data.Vector.Storable as Storable
import qualified Data.Vector.Generic.Mutable as GM
import qualified Data.Vector.Generic as G
import Data.Vector.Fusion.Stream as Stream

-- show
type V = Hybrid.Vector Unboxed.Vector Boxed.Vector (Int,Integer)
main = do
  print (G.fromList [(1,2),(3,4)] :: V) 
  print $ G.slice 2 3 (G.fromList (Prelude.zip [1..10] [11..20]) :: V)
-- /show</code></pre><p>It is worth taking a couple of minutes to talk about the instances, though.</p><p><code>Generic.Vector</code> types typically provide the obvious <code>Monoid</code>, <code>Show</code>, <code>Read</code>, <code>Eq</code>, and <code>Ord</code> instances we've come to expect.</p><p>But if we were not careful and wrote</p><pre><code class="haskell">instance (G.Vector u a, G.Vector v b) =&gt; Monoid (Vector u v (a,b))</code></pre><p>then the compiler would be unduly reticent to use the instance. That is, it won't realize that the moment it can see that we have a <code>Hybrid.Vector</code>, that the argument must be a pair as, after all, our GADT only has one constructor!</p><p>So instead we need to write the remaining instances to abuse the power of <a href="http://research.microsoft.com/en-us/um/people/simonpj/papers/ext-f/">system Fc</a> and modern Haskell to say that once the compiler figures out it needs one of these instances for a <code>Hybrid.Vector u v c</code> it can infer <code>c</code> must be of the form <code>(a,b)</code> by writing these instances as</p><pre><code class="haskell">instance (G.Vector u a, G.Vector v b, c ~ (a, b)) =&gt; Monoid (Vector u v c) where
  mappend = (G.++)
  mempty = G.empty
  mconcat = G.concat</code></pre><pre><code class="haskell">instance (G.Vector u a, G.Vector v b, Show a, Show b, c ~ (a, b)) =&gt; Show (Vector u v c) where
  showsPrec = G.showsPrec</code></pre><pre><code class="haskell">instance (G.Vector u a, G.Vector v b, Read a, Read b, c ~ (a, b)) =&gt; Read (Vector u v c) where
  readPrec = G.readPrec
  readListPrec = readListPrecDefault</code></pre><p>With <code>Eq</code> and <code>Ord</code> we need to lean a little bit on the fusion machinery, just because no such defaults are provided for us.</p><pre><code class="haskell">instance (G.Vector u a, G.Vector v b, Eq a, Eq b, c ~ (a, b)) =&gt; Eq (Vector u v c) where
  xs == ys = Stream.eq (G.stream xs) (G.stream ys)
  xs /= ys = not (Stream.eq (G.stream xs) (G.stream ys))</code></pre><pre><code class="haskell">instance (G.Vector u a, G.Vector v b, Ord a, Ord b, c ~ (a, b)) =&gt; Ord (Vector u v c) where
  compare xs ys = Stream.cmp (G.stream xs) (G.stream ys)</code></pre><p>Now, we finally have everything we need for our <code>Hybrid.Vector</code> type to feel like a real <code>Vector</code>.</p><p>OK, not quite <i>everything</i>, for reasons that I'm sure make sense to Roman, he goes and duplicates the entire <code>vector</code> API individually customized to each vector subtype within their own modules. Admittedly, it does help with inference in the presence of such an all encompassing API that can both produce and consume values of the same type. To that end, <code>hybrid-vectors</code> includes a couple thousand lines of boilerplate as well to make a <code>vector</code> programmer feel at home. It also contains another, related notion, that of a <a href="http://hackage.haskell.org/packages/archive/hybrid-vectors/0.1/doc/html/Data-Vector-Mixed.html"><code>Mixed.Vector</code></a> that permits more operations to cooperate across vector types, as it was something that was easy to implement while I had all of the <code>vector</code> internals paged in mentally.</p><p>However, the details of that implementation is entirely mechanical.</p><p>Similarly, we need to go through a similar boilerplate exercise making an instance of <code>Unbox</code> for <code>Key</code>, but nothing new is learned.</p><h1 id="custom-stream-fusion"><a href="#custom-stream-fusion">Custom Stream Fusion</a></h1><p>Before we move on, we are going to need at least one custom stream fusion combinator for adding two matrices together.</p><p>I don't want to pre-judge that all addition will fall under the purview of the <code>Num</code> typeclass, as for instance since we're sparse we can use <code>Mat Unboxed.Vector ()</code> as a Boolean matrix and pay surprisingly little overhead as an <code>Unboxed.Vector</code> of <code>()</code>s is represented simply by its <code>size</code>!</p><p>Consequently, let's define a generalized merge operation that can permit values to cancel.</p><pre><code class="haskell">mergeStreamsWith 
  :: (Monad m, Ord i) 
  =&gt; (a -&gt; a -&gt; Maybe a) 
  -&gt; Stream m (i, a)
  -&gt; Stream m (i, a)
  -&gt; Stream m (i, a)</code></pre><p>In <code>Vector</code>'s current version of monadic stream fusion, a <code>Stream</code> consists of a step function, a state, and any knowledge we have about the <code>Size</code> of the <code>Stream</code>.</p><pre><code class="haskell">data Stream m a = forall s . Stream (s -&gt; m (Step s a)) s Size   </code></pre><p>Therefore with an appropriate new <code>step</code> function, we can write:</p><pre><code class="haskell">mergeStreamsWith f (Stream stepa sa0 na) (Stream stepb sb0 nb)
  = Stream step (MergeStart sa0 sb0) (toMax na + toMax nb)</code></pre><p>Here our starting state <code>MergeStart</code> is described below, and we convert the bounds we know on the input streams into a conservative upper bound on our new stream size.</p><p>Stream fusion works by ensuring that each <code>Step</code> you take does not recurse, so the compiler is able to move all of the iteration to one outer-most loop.</p><p>At each <code>Step</code>, we can <code>Yield</code> a new answer and switch to a new state, simply switch to a new state or terminate our <code>Stream</code>.</p><pre><code class="haskell">data Step s a = Yield a s | Skip s | Done   </code></pre><p>In our case we need to consume from two other streams, but we can only afford to ask for a bounded amount of work from each at each <code>Step</code>. So let's build a custom state type for our <code>Stream</code>:</p><pre><code class="haskell">data MergeState sa sb i a
  = MergeL sa sb i a
  | MergeR sa sb i a
  | MergeLeftEnded sb
  | MergeRightEnded sa
  | MergeStart sa sb</code></pre><p>We'll want to reason through our <code>step</code> function by cases as it is rather tedious.</p><p><code>MergeStart</code> is our initial state, consisting of the initial states of both of our input streams.</p><pre><code class="haskell">  step (MergeStart sa sb) = do
    r &lt;- stepa sa
    return $ case r of
      Yield (i, a) sa' -&gt; Skip (MergeL sa' sb i a)
      Skip sa'         -&gt; Skip (MergeStart sa' sb)
      Done             -&gt; Skip (MergeLeftEnded sb)</code></pre><p>We try to read from the left stream. If it succeeds we know the value from the left stream (and are in state <code>MergeL</code>). If it skips we have to try again. If it says it has no more content, we should fast forward through the right hand stream with <code>MergeLeftEnded</code>.</p><p>The rest of the logic follows similarly.</p><p>Once we have a value from our left <code>Stream</code>, we should try to read from our right, merging values if their indices are equal, and otherwise putting them in order. Depending on which candidate was merged, we proceed to <code>MergeR</code> or <code>MergeL</code>. If during the <code>Merge</code>, we determine that our elements cancelled out, e.g. <code>5 + (-5)</code>, thn rather than recurse into start to ensure a bounded amount of work is done, we <code>Skip</code> back there.</p><pre><code class="haskell">  step (MergeL sa sb i a) = do
    r &lt;- stepb sb
    return $ case r of
      Yield (j, b) sb' -&gt; case compare i j of
        LT -&gt; Yield (i, a)     (MergeR sa sb' j b)
        EQ -&gt; case f a b of
           Just c  -&gt; Yield (i, c) (MergeStart sa sb')
           Nothing -&gt; Skip (MergeStart sa sb')
        GT -&gt; Yield (j, b)     (MergeL sa sb' i a)
      Skip sb' -&gt; Skip (MergeL sa sb' i a)
      Done     -&gt; Yield (i, a) (MergeRightEnded sa)</code></pre><p><code>MergeR</code> is entirely symmetric to <code>MergeL</code>:</p><pre><code class="haskell">  step (MergeR sa sb j b) = do
    r &lt;- stepa sa
    return $ case r of
      Yield (i, a) sa' -&gt; case compare i j of
        LT -&gt; Yield (i, a)     (MergeR sa' sb j b)
        EQ -&gt; case f a b of
          Just c  -&gt; Yield (i, c) (MergeStart sa' sb)
          Nothing -&gt; Skip (MergeStart sa' sb)
        GT -&gt; Yield (j, b)     (MergeL sa' sb i a)
      Skip sa' -&gt; Skip (MergeR sa' sb j b)
      Done     -&gt; Yield (j, b) (MergeLeftEnded sb)</code></pre><p>and then we just have to deal with fast forwarding:</p><pre><code class="haskell">  step (MergeLeftEnded sb) = do
    r &lt;- stepb sb
    return $ case r of
      Yield (j, b) sb' -&gt; Yield (j, b) (MergeLeftEnded sb')
      Skip sb'         -&gt; Skip (MergeLeftEnded sb')
      Done             -&gt; Done
  step (MergeRightEnded sa) = do
    r &lt;- stepa sa
    return $ case r of
      Yield (i, a) sa' -&gt; Yield (i, a) (MergeRightEnded sa')
      Skip sa'         -&gt; Skip (MergeRightEnded sa')
      Done             -&gt; Done</code></pre><p>Putting it all together we get:</p><pre><code class="active haskell">-- show
import Data.Vector.Fusion.Stream.Monadic (Step(..), Stream(..))
import Data.Vector.Fusion.Stream.Size

data MergeState sa sb i a
  = MergeL sa sb i a
  | MergeR sa sb i a
  | MergeLeftEnded sb
  | MergeRightEnded sa
  | MergeStart sa sb

mergeStreamsWith
  :: (Monad m, Ord i) 
  =&gt; (a -&gt; a -&gt; Maybe a) 
  -&gt; Stream m (i, a) 
  -&gt; Stream m (i, a) 
  -&gt; Stream m (i, a)
mergeStreamsWith f (Stream stepa sa0 na) (Stream stepb sb0 nb)
  = Stream step (MergeStart sa0 sb0) (toMax na + toMax nb) where
  step (MergeStart sa sb) = do
    r &lt;- stepa sa
    return $ case r of
      Yield (i, a) sa' -&gt; Skip (MergeL sa' sb i a)
      Skip sa'         -&gt; Skip (MergeStart sa' sb)
      Done             -&gt; Skip (MergeLeftEnded sb)
  step (MergeL sa sb i a) = do
    r &lt;- stepb sb
    return $ case r of
      Yield (j, b) sb' -&gt; case compare i j of
        LT -&gt; Yield (i, a)     (MergeR sa sb' j b)
        EQ -&gt; case f a b of
           Just c  -&gt; Yield (i, c) (MergeStart sa sb')
           Nothing -&gt; Skip (MergeStart sa sb')
        GT -&gt; Yield (j, b)     (MergeL sa sb' i a)
      Skip sb' -&gt; Skip (MergeL sa sb' i a)
      Done     -&gt; Yield (i, a) (MergeRightEnded sa)
  step (MergeR sa sb j b) = do
    r &lt;- stepa sa
    return $ case r of
      Yield (i, a) sa' -&gt; case compare i j of
        LT -&gt; Yield (i, a)     (MergeR sa' sb j b)
        EQ -&gt; case f a b of
          Just c  -&gt; Yield (i, c) (MergeStart sa' sb)
          Nothing -&gt; Skip (MergeStart sa' sb)
        GT -&gt; Yield (j, b)     (MergeL sa' sb i a)
      Skip sa' -&gt; Skip (MergeR sa' sb j b)
      Done     -&gt; Yield (j, b) (MergeLeftEnded sb)
  step (MergeLeftEnded sb) = do
    r &lt;- stepb sb
    return $ case r of
      Yield (j, b) sb' -&gt; Yield (j, b) (MergeLeftEnded sb')
      Skip sb'         -&gt; Skip (MergeLeftEnded sb')
      Done             -&gt; Done
  step (MergeRightEnded sa) = do
    r &lt;- stepa sa
    return $ case r of
      Yield (i, a) sa' -&gt; Yield (i, a) (MergeRightEnded sa')
      Skip sa'         -&gt; Skip (MergeRightEnded sa')
      Done             -&gt; Done
  {-# INLINE [0] step #-}
{-# INLINE [1] mergeStreamsWith #-}
-- /show
main = putStrLn &quot;That compiles, too.&quot;</code></pre><p>It is worth noting the phase-controlled <code>INLINE</code> pragmas in the final definition as well. Without them you really won't see much benefit from stream fusion! They ensure that the compiler is careful to hold onto the steps uninlined until the right moment.</p><blockquote><p><b>No-Prize #6</b></p><p>It'd probably be much more efficient for us to us an efficient <code>k-merge</code> or, even better, a cache-oblivious
variant that is careful to make no assumptions about our caches. The only two operations we'll be using
<code>Stream</code> fusion for are concatenation and <code>mergeStreamsWith</code> for now. Is there a more efficient fusion form we should be using that can exploit this structure?</p></blockquote><h1 id="matrices--not-vectors"><a href="#matrices--not-vectors">Matrices, not Vectors</a></h1><p>Now that we have <code>hybrid-vectors</code>, we can <i>finally</i> peek at what our matrix representation can look like.</p><pre><code class="haskell">newtype Mat v a = Mat { runMat :: Hybrid.Vector Unboxed.Vector v (Key, a) }</code></pre><p>and how we could build one:</p><pre><code class="haskell">fromList :: Generic.Vector v a =&gt; [(Key, a)] -&gt; Mat v a
fromList xs 
  = Mat 
  $ Generic.modify (Intro.sortBy (compare `on` fst)) 
  $ Generic.fromList xs</code></pre><p>As we'll see next time don't need type parameters for the number of dimensions and we don't need to store information on the dimensionality of the contents as well as we'll be able to turn back to the notions of &quot;most significant most significant difference&quot; and 2-fattest numbers a second time.</p><p>And you'd hoped the bit-twiddling was behind us. Hah!</p><p>-<a href="mailto:ekmett@gmail.com">Edward Kmett</a></p><p>August 18, 2013</p></article>

<div id="disqus_thread"><script>var disqus_shortname = "edwardk"; (function() { var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true; dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq); })();</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">comments powered by <span class="logo-disqus">Disqus</span></a></a>
</div>

</div>
</div>
<div class="row article-footer"><div class="span7 meta"><span class="sociallinksunicode social">
<a href="https://twitter.com/home?status=$url$" target="_blank"><i class="icon-twitter"></i></a>&nbsp;
<a href="http://www.facebook.com/sharer/sharer.php?u=$url$" target="_blank"><i class="icon-facebook"></i></a>&nbsp;
<a href="https://plus.google.com/share?url=$url$" target="_blank"><i class="icon-google-plus"></i></a></span>
</div>
</div>
</div>
<div class="footer"><div class="container"><div class="row"><div class="span12"><ul class="menu"><li><a href="https://www.schoolofhaskell.com/">School</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user">Users</a>
</li>

<li><a class="brand" href="https://fpcomplete.com">Sponsored by:
<img src="/static/img/logo.png" title="FPComplete">
</a>
</li>
</ul>
</div>
</div>
<div class="row"><div class="span12"></div>
</div>
</div>
</div>
<link rel="stylesheet" type="text/css" href="/static/bootstrap/css/bootstrap-responsive.css" />
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script><script src="https://www.schoolofhaskell.com/static/combined/Y-3k9_tW.js"></script><script>$(function(){
  $("a.logout").click(function(){
    var form = $("<form method='post'/>");
    form.attr("action", $(this).attr("href"));
    $("body").append(form);
    form.submit();
    return false;
  });
});

$(function(){
    $('.sociallinksunicode a').each(function(){
        $(this).attr('href',$(this).attr('href').replace('$url$',document.location));
    });
});

$(function(){
  // If we need to select a user/select a password then show the
  // details confirmation form, otherwise enable the getting started
  // section.
  if($('.alert-block a').text().match(/(selected a username|change your password)/)) {
    $("#confirm-details").show();
    $("#confirm-details #inputUsername").focus();
  } else {
    $("#get-started").removeClass('disabled').addClass('enabled');
  }

  // For lack of a plain HTML validation story this will do.
  $('.welcome-page').each(function(){
    $('form').submit(check);
  });
  function check(){
    setTimeout(check,500);
    var error = false;
    $('.error').removeClass('error');
    $('#enter-details input').each(function(){
      if($(this).val() == '') {
        $(this).parent().parent().addClass('error');
        error = true;
      }
    });
    if(error) return false;
    if($('[name=password]').val() == $('[name=confirm]').val()) {
      $('#confirm').removeClass('error');
      return true;
    } else {
      $('#confirm').addClass('error');
      return false;
    }
  }
});

$(function(){
  // When scrolling over a snippet editor, activate the "clone in IDE" popovers
  $('article').each(function(){
    var n = 100;
    var wait = 10000;
    function check(){
      if($('.clone').length == 0) {
        setTimeout(check,n);
        return;
      }
      var activated = $.cookie('clone-popover');
      if (activated) return;
      var activate = false;
      $('.controlsRun:onScreen').each(function(){
        $.cookie('clone-popover', 'true', { expires: 30, path: '/' });
        activate = true;
        return false;
      });
      if(activate) {
          $('.clone').each(function(){
              // The bootstrap API is rather unreasonable to say the
              // least.
              next = $(this).parent();
              var title = next.attr('title');
              next.attr('data-content',$(this).attr('data-content'));
              next.attr('title',$(this).attr('title'));
              next.popover('show',{
                  title: $(this).attr('title')
              });
              next.attr('title',title);
          });
          setTimeout(function(){
              $('.clone').each(function(){
                  $(this).parent().popover('hide');
              });
          },wait);
      } else {
        setTimeout(check,n);
      }
    }
    setTimeout(check,n);
  });
});

// onScreen jQuery plugin v0.2.1
// (c) 2011-2013 Ben Pickles
//
// http://benpickles.github.com/onScreen
//
// Released under MIT license.
(function(a){a.expr[":"].onScreen=function(b){var c=a(window),d=c.scrollTop(),e=c.height(),f=d+e,g=a(b),h=g.offset().top,i=g.height(),j=h+i;return h>=d&&h<f||j>d&&j<=f||i>e&&h<=d&&j>=f}})(jQuery);

/*!
 * jQuery Cookie Plugin v1.1
 * https://github.com/carhartl/jquery-cookie
 *
 * Copyright 2011, Klaus Hartl
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.opensource.org/licenses/GPL-2.0
 */
(function($, document) {

  var pluses = /\+/g;
  function raw(s) {
    return s;
  }
  function decoded(s) {
    return decodeURIComponent(s.replace(pluses, ' '));
  }

  $.cookie = function(key, value, options) {

    // key and at least value given, set cookie...
    if (arguments.length > 1 && (!/Object/.test(Object.prototype.toString.call(value)) || value == null)) {
      options = $.extend({}, $.cookie.defaults, options);

      if (value == null) {
	options.expires = -1;
      }

      if (typeof options.expires === 'number') {
	var days = options.expires, t = options.expires = new Date();
	t.setDate(t.getDate() + days);
      }

      value = String(value);

      return (document.cookie = [
	encodeURIComponent(key), '=', options.raw ? value : encodeURIComponent(value),
	options.expires ? '; expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE
	options.path    ? '; path=' + options.path : '',
	options.domain  ? '; domain=' + options.domain : '',
	options.secure  ? '; secure' : ''
      ].join(''));
    }

    // key and possibly options given, get cookie...
    options = value || $.cookie.defaults || {};
    var decode = options.raw ? raw : decoded;
    var cookies = document.cookie.split('; ');
    for (var i = 0, parts; (parts = cookies[i] && cookies[i].split('=')); i++) {
      if (decode(parts.shift()) === key) {
	return decode(parts.join('='));
      }
    }
    return null;
  };
  $.cookie.defaults = {};})(jQuery, document);
</script><!--[if lt IE 10]><script src="https://www.schoolofhaskell.com/static/design/js/ie.js?etag=ayV2DuJ0"></script><![endif]--><script>if(!window.location.href.match(/localhost/)){var track = '/tutorial/user/edwardk/revisiting-matrix-multiplication/part-3';
window._gaq = [['_setAccount','UA-36928035-1'],track != ''? ['_trackPageview',track] : ['_trackPageview']
,['_trackPageLoadTime']];window._gaq.push(['_setCustomVar',1,'Section','School of Haskell',3]);
window._gaq.push(['_setCustomVar',2,'User Type','Visitor',1]);
(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);

})();}</script>
<!-- Prompt IE 6 users to install Chrome Frame. Remove this if you want to support IE 6.  chromium.org/developers/how-tos/chrome-frame-getting-started --><!--[if lt IE 7 ]><script src="//ajax.googleapis.com/ajax/libs/chrome-frame/1.0.3/CFInstall.min.js"></script><script>window.attachEvent('onload',function(){CFInstall.check({mode:'overlay'})})</script><![endif]--></body></html>