<!DOCTYPE html>
<html><head><title>Part IV: IntMap!? - School of Haskell | School of Haskell</title><meta http-equiv="x-ua-compatible" content="IE=9"><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="google-site-verification" content="Rfxk2TdeMMXEXHgJ2_OO8Rt3hPbQSDao0OXQV_n6z_s" /><link href="//fonts.googleapis.com/css?family=Merriweather" rel="stylesheet" type="text/css"><link href="https://www.schoolofhaskell.com/recent-content/feed" type="application/rss+xml" rel="alternate" title="Recently published content">
<link rel="stylesheet" href="https://www.schoolofhaskell.com/static/combined/UlwEHVcM.css"><style>.social{margin-right:1em}h1{font-family:Merriweather !important}article{font-family:Merriweather !important}article li{font-family:Merriweather !important;line-height:1.6em}h1,h2,h3,h4,h4,h5{font-family:Merriweather !important}.editor p{font-family:Frutiger, "Frutiger Linotype", Univers, Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans Condensed", "Liberation Sans", "Nimbus Sans L", Tahoma, Geneva, "Helvetica Neue", Helvetica, Arial, sans-serif}.article-footer{border-top:1px solid #ddd;padding-top:1em;margin-top:1em}body{font-size:16px !important}.navbar .navbar-inner{background:#3c3f41}.navbar .brand{font-size:14px}.navbar .brand img{width:6em}.navbar .icon-wrench{margin:0 -0.5em 0 -0.5em;padding:0 1em 0 1em;height:20px}.navbar-inverse .nav .active a{background:#333638}.navbar-inverse .nav > li > a{color:#a7a7a7
}.navbar-inverse .btn-navbar{background:#333638}.navbar-inverse .nav > li a:hover,.navbar-inverse .btn{background:#333537 !important}@media (max-width: 979px) {.icon-wrench{padding-left:1em !important}}.breadcrumb{border-top-left-radius:0;border-top-right-radius:0}h1{margin-top:20px}.breadcrumb-container + .main-content h1{margin-top:0}.footer{padding:30px 0;margin-top:70px;border-top:1px solid #e5e5e5;background-color:#f5f5f5}.footer ul.footer-menu{list-style-type:none}.footer ul.footer-menu li{display:inline-block}.footer ul.footer-menu li + li{margin-left:0.5em}.footer ul.footer-menu li + li:before{margin-right:0.5em;content:"Â·";color:#999}.footer ul.menu li{display:inline-block}.footer ul.menu li + li{margin-left:0.5em}.footer .copyright{margin-left:25px}.main-content{min-height:100%}.gravatar{width:80px;height:80px;border-radius:2px;background:#eee}.empty-gravatar{width:0}.container{font-family:"Segoe UI", Candara, "Bitstream Vera Sans", "DejaVu Sans", "Bitstream Vera Sans", "Trebuchet MS", Verdana, "Verdana Ref", sans-serif}.container h1,.container h2,.container h4,.container h4,.container h5{font-family:"Segoe UI", Candara, "Bitstream Vera Sans", "DejaVu Sans", "Bitstream Vera Sans", "Trebuchet MS", Verdana, "Verdana Ref", sans-serif}article{font-family:Merriweather !important}article h1{font-family:Merriweather !important}article li{font-family:Merriweather !important;line-height:1.6em}article li + li{margin-top:0.5em}article div.code{background:#f9f9f9;border:1px solid #d1d1d1;position:relative;border-radius:0.2em;margin:0.25em 0 0.75em 0;min-height:2.5em}article code{color:#005580;font-size:14px;white-space:pre}article a.hoogle > code{color:#0088cc;font-size:14px;white-space:pre;border:0}article .expand-code{display:none}article pre{overflow:auto;word-wrap:normal}article code.active{display:block;max-height:430px}article h1{font-size:31.5px}article h3{font-size:17.5px}article h4{font-size:14px}article h5,article h6{font-size:11.9px}article p{line-height:1.7em}article h1 code,article h2 code,article h3 code,article h4 code,article h5 code,article h6 code{font-size:inherit !important}article h1 a,article h2 a,article h3 a,article h4 a,article h5 a,article h6 a{color:#444}article h1 a:before,article h2 a:before,article h3 a:before,article h4 a:before,article h5 a:before,article h6 a:before{margin-left:-1.5em;padding-right:0.5em;font-family:fontawesome;content:"\f0c1";font-size:20px;color:#fff}article h1 a:hover,article h2 a:hover,article h3 a:hover,article h4 a:hover,article h5 a:hover,article h6 a:hover{text-decoration:none;color:#0088cc}article h1 a:hover:before,article h2 a:hover:before,article h3 a:hover:before,article h4 a:hover:before,article h5 a:hover:before,article h6 a:hover:before{color:#888}article h2{font-size:24.5px}article .popover{font-family:actor}article .popover h3.popover-title{font-family:actor !important;font-size:1em}article .popover .popover-content{width:15em;font-size:1em}article .controlsRun{display:block;padding:0.5em;text-align:right;background:#f2f2f2}article .controlsRun a.clone{margin-right:1em;font-family:actor;text-decoration:none}article .controlsRun a.clone span{padding-left:0.5em}article .controlsRun a.run,article .controlsRun a.reset,article .controlsRun a.show-code{font-size:16px}article .controlsRun a.run span,article .controlsRun a.reset span,article .controlsRun a.show-code span{display:none}article .controlsRun a.reset{margin-left:0.5em;color:#a2becc}article .controlsRun a.reset{display:none}article .controlsRun a.show-code{margin-right:0.75em}article .controlsRun a.run:hover,article .controlsRun a.show-code:hover{text-decoration:none}article .controlsRun a.show-code.active{color:#DC0D0D}article .controlsRun a[disabled]{color:#a2becc;cursor:default}article .collapse-area .collapse-header{background:#0088cc;color:#fff;padding:0.3em;cursor:pointer}article .collapse-area .hidden-toggle:before{content:"\f0d7";font-family:fontawesome;margin-right:0.5em;margin-left:0.25em}article .collapse-area .collapsed-files{overflow:auto;height:auto}article .collapse-area.collapse-disabled{display:none}article .collapse-area.collapse-area-off .collapsed-files{height:0px;overflow:hidden}article .collapse-area.collapse-area-off .hidden-toggle:before{content:"\f0da"}article .snippet-stdio .stdout{margin:0.5em;padding-right:2em;position:relative;word-wrap:break-word}article .snippet-stdio .stdin{-webkit-box-shadow:none;-moz-box-shadow:none;box-shadow:none;-webkit-transition:none;-moz-transition:none;-o-transition:none;transition:none;padding:0;margin:0}article .hoogle-results{margin:0.25em}article .hoogle-results .hoogle-inner{background:#fff;padding:0.5em;border-radius:3px;border:1px solid #ddd}article .hoogle-results .hoogle-inner .close-link{position:relative;float:right;margin-top:-0.5em;margin-right:-0.5em}article .snippet-output-errors{margin:1em 0.5em 0.5em 0.5em;position:relative}article .snippet-output-errors ul{list-style-type:none;margin:0;position:relative}article .snippet-output-errors pre{border:0;border-radius:0;padding:0.25em;margin:0;background:inherit;color:inherit}article .snippet-output-errors .close-link{color:inherit;background:inherit}article .snippet-editors{z-index:0;padding:0.25em}article .close-link{padding:0.5em;background:#eaeaea;border-bottom-left-radius:0.2em;border-top-right-radius:0.2em;position:absolute;top:0;right:0}article .close-link:hover{text-decoration:none}article .snippet-title{padding:0.5em 0 0 0.5em}article .snippet-title .snippet-icon{font-family:FontAwesome;display:inline-block;margin-right:0.5em}article .fullModuleCode + div .snippet-title{margin-top:0.5em;border-top:1px solid #ccc;padding-top:0.5em}article .CodeMirror{height:auto;min-height:1em;line-height:1.5em;background:transparent;font-size:14px !important}article .CodeMirror .highlighted{background:rgba(250, 210, 0, 0.45) !important}article .CodeMirror-widget{margin-left:2em;line-height:1.8}article .CodeMirror.collapsed{height:10em !important}article .editor .expander{text-align:center;display:block;padding:0.5em;text-decoration:none;border-bottom-left-radius:2px;border-bottom-right-radius:2px}article .editor .expander .ellipsis{background:white;border:1px solid #ccc;padding:0 0.5em;height:1em;line-height:0.5em;display:inline-block;color:#555;cursor:pointer}article .editor .expander .ellipsis:hover{background:#ddd;color:#333}article .web-runner{margin:0.5em;padding:0.5em;border:1px solid #ccc;border-radius:3px;background:#f5f5f5}article .web-runner iframe{border:0;margin-top:0.5em;margin-bottom:0;background:white}article .web-runner .controls i{cursor:pointer;color:#0088cc}article .web-runner .controls i:hover{color:#222}article .web-runner .controls i + i{margin-left:0.5em}article .web-runner .controls .icon-remove{float:right}article .hidden{display:block;visibility:visible}article .controlsShowHide{margin-bottom:0.5em}.tutorial-body{float:left !important}.tutorial-nav{float:right !important}@media (max-width: 979px) {.related-content{float:right}.author-name{display:block;margin-left:20px !important;padding-left:5px;margin-top:5px}article h1 a:hover:before,article h2 a:hover:before,article h3 a:hover:before,article h4 a:hover:before,article h5 a:hover:before,article h6 a:hover:before{color:#fff}.tutorial-nav{float:none !important;width:auto !important}.tutorial-body{float:none !important;width:auto !important}}@media (min-width: 980px) and (max-width: 1199px) {.navbar-search{display:none}.tutorial-nav{width:200px}.tutorial-body{width:720px}}#accountPage h1{margin:20px 0 0 0}#accountPage h2{font-size:20px}.group-contents .span8{float:left}.group-contents .span4{float:right}.container > .alert-block{margin-top:1em}.alert{color:#aa874a
}.social{margin-bottom:.8em;display:block}.social a{text-decoration:none}.social i{font-size:1.1em;color:#fff;padding:0.25em;border-radius:0.25em;width:1em;display:inline-block;text-align:center}.social i.icon-twitter{background:#0088cc}.social i.icon-facebook{background:#3b5998
  }.social i.icon-google-plus{background:#dd4b39
  }.well pre{background:#fcfcfc}.well h2{margin-top:0}code{color:#005580;font-size:14px;white-space:pre}</style><!--[if lt IE 8]><link rel="stylesheet" href="https://www.schoolofhaskell.com/static/design/css/ie7.css?etag=TSMl9x1V"><![endif]--><!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]--></head><body class="not-logged-in" itemscope itemtype="http://schema.org/Product"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-H62P" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-H62P');</script><div class="navbar navbar-inverse navbar-static-top"><div class="navbar-inner"><div class="container"><a class="btn btn-navbar" type="button" data-toggle="collapse" data-target=".nav-collapse"><span class="icon-bar"></span>
<span class="icon-bar"></span>
<span class="icon-bar"></span>
</a>
<a class="brand" href="/"><img src="/static/img/haskell-logo-wide.png" title="School of Haskell">
</a>
<div class="nav-collapse collapse"><ul class="nav"><li><a href="https://www.schoolofhaskell.com/">School</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user">Users</a>
</li>
</ul>
<form class="navbar-search pull-left" action="https://www.schoolofhaskell.com/search"><input class="search-query" type="text" placeholder="Search" name="search">
</form>
</div>
</div>
</div>
</div>
<div class="container breadcrumb-container"><div class="row"><div class="span12"><ul class="breadcrumb"><li><a href="https://www.schoolofhaskell.com/user/edwardk">Edward Kmett</a>
<span class="divider">/</span>
</li>
<li><a href="https://www.schoolofhaskell.com/user/edwardk/revisiting-matrix-multiplication">Revisiting Matrix Multiplication</a>
<span class="divider">/</span>
</li>
<li><a href="https://www.schoolofhaskell.com/user/edwardk/revisiting-matrix-multiplication/part-4">Part IV: IntMap!?</a>
</li>
</ul>
</div>
</div>
</div>
<div class="container main-content"><div class="row"><div class="span12"><h1 itemprop="name">Part IV: IntMap!?</h1>
</div>
</div>
<div class="row"><div class="span7 meta"><p><span class="date">25 Aug 2013</span>
<span class="author"><a href="https://www.schoolofhaskell.com/user/edwardk">Edward Kmett</a>
</span>
<span class="view-edit-link pull-right"><a class="view-source-link" href="https://www.schoolofhaskell.com/tutorial-raw/4906/4892553edbb35ab05743b820e3d3f17b88343c66">View Markdown source</a>
</span>
</p>
<p class="tags"></p>
</div>
</div>
<div class="row"><div class="span7 meta"><span class="sociallinksunicode social">
<a href="https://twitter.com/home?status=$url$" target="_blank"><i class="icon-twitter"></i></a>&nbsp;
<a href="http://www.facebook.com/sharer/sharer.php?u=$url$" target="_blank"><i class="icon-facebook"></i></a>&nbsp;
<a href="https://plus.google.com/share?url=$url$" target="_blank"><i class="icon-google-plus"></i></a></span>
</div>
</div>
<p class="alert">As of March 2020, School of Haskell has been switched to read-only mode.</p>
<div class="row" itemprop="desc"><div class="span4 tutorial-nav"><div class="related-content"><ul class="nav nav-tabs nav-stacked"><li><script>reddit_target='fpcomplete'</script>
<script src="https://redditstatic.s3.amazonaws.com/button/button1.js"></script>
</li>
<li><a href="https://www.schoolofhaskell.com/user/edwardk/revisiting-matrix-multiplication/part-3">Previous content: Part III: Extending Vector</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user/edwardk/revisiting-matrix-multiplication/part-5">Next content: Part V: Heaps of Performance</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user/edwardk/revisiting-matrix-multiplication">Go up to: Revisiting Matrix Multiplication</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user/edwardk">See all content by Edward Kmett</a>
</li>
</ul>

</div>
<div class="aside"><h3>Sections</h3>
<ul><li><a href="#intmap--">IntMap?!</a><ul><li><a href="#classifying-keys">Classifying Keys</a></li><li><a href="#stock-definitions">Stock Definitions</a></li><li><a href="#lookup">Lookup</a></li><li><a href="#insert">Insert</a></li><li><a href="#delete">Delete</a></li><li><a href="#at">At</a></li><li><a href="#run-it-">Run It!</a></li></ul></li></ul></div>
</div>
<div class="span8 tutorial-body" data-environment="ghc-7.8-stable-14.09">
<article><p>Back in <a href="https://www.fpcomplete.com/user/edwardk/revisiting-matrix-multiplication-part-2">part 2</a> we showed how we can compare two keys in Morton order without having to actually do the interleaving.</p><p>I'm going to take some time today to try to help folks build intuition for what that means by taking a look at an old standby in the Haskell ecosystem, <code>Data.IntMap</code>, and use the techniques we developed in part 2 to generate a version of some of the core routines that uses the same <code>xor</code> trick rather than store the prefix and mask it stores today.</p><p>Nothing in here has to do with matrix multiplication, but it is a powerful application of the notion of a &quot;most significant difference&quot; and <code>xor</code> based comparison by it.</p><p>If you're just getting here, you might want to start with parts <a href="https://www.fpcomplete.com/user/edwardk/revisiting-matrix-multiplication-part-1">1</a>, <a href="https://www.fpcomplete.com/user/edwardk/revisiting-matrix-multiplication-part-2">2</a> and <a href="https://www.fpcomplete.com/user/edwardk/revisiting-matrix-multiplication-part-3">3</a>, but there is no pressure. Like <a href="https://www.fpcomplete.com/user/edwardk/revisiting-matrix-multiplication-part-3">part 3</a>, this post can largely stand alone.</p><h1 id="intmap--"><a href="#intmap--">IntMap?!</a></h1><p>Changing to my &quot;difference tree&quot; approach permits a number of operations to terminate earlier, and may well turn out to be a viable way to improve the venerable <code>IntMap</code> in the <code>containers</code> package, but I'm using it here mostly to help us develop familiarity with the 'most significant most significant difference'.</p><p>In many ways this is a degenerate case, but it at least helps us develop some facility for using the tool!</p><p>In <code>Data.IntMap.Base</code>, based on some decade old code from <a href="http://research.microsoft.com/en-us/people/daan/">Daan Leijen</a>, the <code>containers</code> library defines:</p><pre><code class="haskell">type Prefix = Int
type Mask   = Int

data IntMap a
  = Nil
  | Tip {-# UNPACK #-} !Int a
  | Bin {-# UNPACK #-} !Prefix {-# UNPACK #-} !Mask !(IntMap a) !(IntMap a)</code></pre><p>The <code>Prefix</code> and <code>Mask</code> contain information about the known common prefix of the PATRICIA trie up to that point, and the <code>Mask</code> of the position where they diverge.</p><p>Using what we now know, we can change this to</p><pre><code class="haskell">data IntMap a
  = Nil
  | Tip {-# UNPACK #-} !Int a
  | Bin {-# UNPACK #-} !Int {-# UNPACK #-} !Int !(IntMap a) !(IntMap a)</code></pre><p>where the values we store in the <code>Bin</code> constructor are just the minimum and maximum <code>Int</code> key in the tree below.</p><h2 id="classifying-keys"><a href="#classifying-keys">Classifying Keys</a></h2><p>To do so we need to be able to distinguish between roughly 6 cases for how a key can interact with the map, as if we had the <code>Prefix</code> and <code>Mask</code> in hand. From left to right:</p><pre><code class="haskell">data Class
  = FarLeft   -- differs on a higher msb, outside left branch
  | NearLeft  -- differs on the same msb, but outside current left branch
  | InLeft    -- within the left branch
  | InRight   -- within the right branch
  | NearRight -- differs on the same msb, but outside current right branch
  | FarRight  -- differs on a higher msb, outside right branch</code></pre><p>The <code>xor</code> trick I mentioned at the end of part 2 can be bundled into a slightly unwieldy combinator, <code>significant</code> such that <code>significant a b c d</code> implies that the position of the most significant difference between <code>c</code> and <code>d</code> dominates the position of the most significant difference between <code>a</code> and <code>b</code>.</p><pre><code class="haskell">significant :: Int -&gt; Int -&gt; Int -&gt; Int -&gt; Bool
significant a b c d = ab &lt; cd &amp;&amp; ab &lt; xor ab cd where
  cd = xor c d
  ab = xor a b</code></pre><p>With that we can proceed to use trickery and slight of hand to classify our keys with regards to the bounds of our <code>IntMap</code>:</p><pre><code class="active haskell">import Data.Bits

data Class
  = FarLeft   -- differs on a higher msb, outside left branch
  | NearLeft  -- differs on the same msb, but outside current left branch
  | InLeft    -- within the left branch
  | InRight   -- within the right branch
  | NearRight -- differs on the same msb, but outside current right branch
  | FarRight  -- differs on a higher msb, outside right branch
  deriving (Eq,Ord,Show,Read)

significant :: Int -&gt; Int -&gt; Int -&gt; Int -&gt; Bool
significant a b c d = ab &lt; cd &amp;&amp; ab &lt; xor ab cd where
  cd = xor c d
  ab = xor a b

-- show
classify :: Int -&gt; Int -&gt; Int -&gt; Class
classify k x y
  | k &lt; x = if significant x y k y then FarLeft else NearLeft
  | k &gt; y = if significant x y x k then FarRight else NearRight
  | significant k y x y = InRight
  | otherwise = InLeft
  
main = print $ classify 1 2 4
-- /show</code></pre><p>We don't need to use the full power of classify, as often some subset of those 6 cases will be the same, so lets define a couple of additional combinators:</p><pre><code class="haskell">outside :: Int -&gt; Int -&gt; Int -&gt; Bool
outside k x y = k &lt; x || k &gt; y

insideR :: Int -&gt; Int -&gt; Int -&gt; Bool
insideR k x y = significant k y x y</code></pre><p><code>outside</code> serves as a more accurate version of <code>nomatch</code> from the <code>Data.IntMap</code> internals, and <code>insideR</code> assumes we're inside the range <code>[x..y]</code> and notes that if there is an extra bit of difference between <code>x</code> and <code>y</code> than between <code>k</code> and <code>y</code>, then we're in the right branch.</p><p>We simply use integer comparisons and 3 <code>xor</code>s to classify how our key relates to the range of our <code>IntMap</code>.</p><p>We won't actually be using <code>classify</code> explicitly but you can play with it to see if you agree with its results! You'll be able to see it conceptually at work in the code below though.</p><h2 id="stock-definitions"><a href="#stock-definitions">Stock Definitions</a></h2><p>Some of the stock combinators don't change at all:</p><pre><code class="haskell">null :: IntMap a -&gt; Bool
null Nil = True
null _   = False

empty :: IntMap a
empty = Nil</code></pre><p>Similarly the instances don't change:</p><pre><code class="haskell">instance Traversable IntMap where
  traverse f m0 = go m0 where
    go (Bin x y l r) = Bin x y &lt;$&gt; go l &lt;*&gt; go r
    go (Tip x a) = Tip x &lt;$&gt; f a
    go Nil = pure Nil
  {-# INLINE traverse #-}

instance Foldable IntMap where
  foldMap f m0 = go m0 where
    go Nil = mempty
    go (Tip _ a) = f a
    go (Bin _ _ l r) = mappend (go l) (go r)
  {-# INLINE foldMap #-}

instance Functor IntMap where
  fmap f m0 = go m0 where
    go Nil = Nil
    go (Tip x a) = Tip x (f a)
    go (Bin x y l r) = Bin x y (go l) (go r)
  {-# INLINE fmap #-}</code></pre><p>but fast new friends become possible.</p><pre><code class="haskell">range :: IntMap a -&gt; Maybe (Int,Int)
range Nil           = Nothing
range (Tip i a)     = Just (i,i)
range (Bin i j _ _) = Just (i,j)</code></pre><p>Given the common usecase of finding the maximum key in an <code>IntMap</code> and inserting a new entry, that is a pretty nice side-effect!</p><h2 id="lookup"><a href="#lookup">Lookup</a></h2><p>The next combinator to benefit from this change is <code>lookup</code>.</p><pre><code class="haskell">lookup :: Int -&gt; IntMap a -&gt; Maybe a
lookup k m0 = go m0 where
  go (Tip i a)
    | k == i    = Just a
    | otherwise = Nothing
  go (Bin x y  l r)
    | outside k x y = Nothing
    | insideR r x y = go r
    | otherwise     = go l
  go Nil = Nothing
{-# INLINE lookup #-}</code></pre><p><code>lookup</code> can now use the smarter <code>outside</code> check to fail faster than it can in stock <code>containers</code>.</p><h2 id="insert"><a href="#insert">Insert</a></h2><p>Defining <code>insert</code> showcases the need for all 6 cases from <code>classify</code>. You can identify them in the reasoning below for how to handle the <code>Bin</code> case.</p><pre><code class="haskell">insert :: Int -&gt; a -&gt; IntMap a -&gt; IntMap a
insert k a m0 = go m0 where
  go Nil = Tip k a
  go (Tip j b) = case compare k j of
    LT -&gt; Bin k j (Tip k a) (Tip j b)
    EQ -&gt; Tip k a
    GT -&gt; Bin j k (Tip j b) (Tip k a)
  go n@(Bin x y l r)
    | k &lt; x = if significant x y k y then Bin k y (Tip k a) n
                                     else Bin k y (go l) r
    | k &gt; y = if significant x y x k then Bin x k n (Tip k a)
                                     else Bin x k l (go r)
    | significant k y x y = Bin x y l (go r)
    | otherwise           = Bin x y (go l) r</code></pre><h2 id="delete"><a href="#delete">Delete</a></h2><p>We can also define <code>delete</code>, benefiting similarly from the earlier exit in the unnecessary deletion case:</p><pre><code class="haskell">newx :: Int -&gt; IntMap a -&gt; IntMap a -&gt; IntMap a
newx _ Nil r = r
newx y l@(Tip x _) r = Bin x y l r
newx y l@(Bin x _ _ _) r = Bin x y l r
{-# INLINE newx #-}

newy :: Int -&gt; IntMap a -&gt; IntMap a -&gt; IntMap a
newy _ l Nil = l
newy x l r@(Tip y _)     = Bin x y l r
newy x l r@(Bin _ y _ _) = Bin x y l r
{-# INLINE newy #-}

delete :: Int -&gt; IntMap a -&gt; IntMap a
delete k m0 = go m0 where
  go n@(Bin x y l r)
    | outside k x y = n
    | insideR k x y = newy x l (go r)
    | otherwise     = newx y (go l) r
  go n@(Tip x a)
    | k == x    = Nil
    | otherwise = n
  go Nil = Nil
{-# INLINE delete #-}</code></pre><p>Here we suffer ever so slightly. The Prefix and Mask are fixed when we call bin in the old code, but now we need to inspect the values we're given in newx and newy to find their bounds.</p><h2 id="at"><a href="#at">At</a></h2><p>Finally, no post of mine would be complete without at least one reference to <code>lens</code>.</p><p>We can define the new <code>alterF</code> Lens that is being backported to <code>containers</code> for our modified <code>IntMap</code> directly. Here I'll call it <code>at</code>, due to its similarity to the <code>lens</code> combinator of the same name.</p><pre><code class="haskell">at :: Functor f =&gt; Int -&gt; (Maybe a -&gt; f (Maybe a)) -&gt; IntMap a -&gt; f (IntMap a)
at k f m0 = go m0 where
  go Nil       = maybe Nil (Tip k) &lt;$&gt; f Nothing
  go n@(Tip x a) = case compare k x of
    LT -&gt; maybe n (\b -&gt; Bin k x (Tip k b) n) &lt;$&gt; f Nothing
    EQ -&gt; maybe Nil (Tip k) &lt;$&gt; f (Just a)
    GT -&gt; maybe n (\b -&gt; Bin x k n (Tip k b)) &lt;$&gt; f Nothing
  go n@(Bin x y l r)
    | k &lt; x = if significant x y k y then maybe n (\b -&gt; Bin k y (Tip k b) n) &lt;$&gt; f Nothing
                                     else maybe n (\b -&gt; Bin (min k x) y (insert k b l) r) &lt;$&gt; f Nothing
    | k &gt; y = if significant x y x k then maybe n (\b -&gt; Bin x k n (Tip k b)) &lt;$&gt; f Nothing
                                     else maybe n (\b -&gt; Bin x (max k y) l (insert k b r)) &lt;$&gt; f Nothing
    | insideR k x y = newy x l &lt;$&gt; go r
    | otherwise     = (\l' -&gt; newx y l' r) &lt;$&gt; go l
{-# INLINE at #-}</code></pre><p>We can view the scarier, but Haskell 98 type for at in the definition above as</p><pre><code class="haskell">at :: Int -&gt; Lens' (IntMap a) (Maybe a)</code></pre><p>This combinator is a bit hideous, but it <i>should</i> work! Feel free to test it. =)</p><h2 id="run-it-"><a href="#run-it-">Run It!</a></h2><p>Putting it all together we get:</p><pre><code class="active haskell">-- show
import Control.Applicative hiding (empty)
import Control.Lens hiding (at,outside)
import Data.Bits
import Data.Foldable
import Data.Traversable
import Data.Monoid
import Prelude hiding (lookup, null)

data IntMap a
  = Nil
  | Tip {-# UNPACK #-} !Int a
  | Bin {-# UNPACK #-} !Int {-# UNPACK #-} !Int !(IntMap a) !(IntMap a)
  deriving (Eq,Ord,Show,Read)

null :: IntMap a -&gt; Bool
null Nil = True
null _   = False
{-# INLINE null #-}

empty :: IntMap a
empty = Nil
{-# INLINE empty #-}

range :: IntMap a -&gt; Maybe (Int,Int)
range Nil           = Nothing
range (Tip i a)     = Just (i,i)
range (Bin i j _ _) = Just (i,j)
{-# INLINE range #-}

instance Traversable IntMap where
  traverse f m0 = go m0 where
    go (Bin x y l r) = Bin x y &lt;$&gt; go l &lt;*&gt; go r
    go (Tip x a) = Tip x &lt;$&gt; f a
    go Nil = pure Nil
  {-# INLINE traverse #-}

instance Foldable IntMap where
  foldMap f m0 = go m0 where
    go Nil = mempty
    go (Tip _ a) = f a
    go (Bin _ _ l r) = mappend (go l) (go r)
  {-# INLINE foldMap #-}

instance Functor IntMap where
  fmap f m0 = go m0 where
    go Nil = Nil
    go (Tip x a) = Tip x (f a)
    go (Bin x y l r) = Bin x y (go l) (go r)
  {-# INLINE fmap #-}

-- @significant a b c d@ implies that the position of the most significant difference between
-- @c@ and @d@ dominates the position of the difference between @a and b@.
significant :: Int -&gt; Int -&gt; Int -&gt; Int -&gt; Bool
significant a b c d = ab &lt; cd &amp;&amp; ab &lt; xor ab cd where
  cd = xor c d
  ab = xor a b
{-# INLINE significant #-}

-- | for expository purposes only
data Class
  = FarLeft   -- differs on a higher msb, outside left branch
  | NearLeft  -- differs on the same msb, but outside current left branch
  | InLeft    -- within the left branch
  | InRight   -- within the right branch
  | NearRight -- differs on the same msb, but outside current right branch
  | FarRight  -- differs on a higher msb, outside right branch
  deriving (Eq,Ord,Show,Read)

-- | classify a key @k@ with regards to a binary tree split on the 2-fattest number within @(x..y]@
classify :: Int -&gt; Int -&gt; Int -&gt; Class
classify k x y
  | k &lt; x = if significant x y k y then FarLeft else NearLeft
  | k &gt; y = if significant x y x k then FarRight else NearRight
  | significant k y x y = InRight
  | otherwise = InLeft
{-# INLINE classify #-}

outside :: Int -&gt; Int -&gt; Int -&gt; Bool
outside k x y = k &lt; x || k &gt; y
{-# INLINE outside #-}

insideR :: Int -&gt; Int -&gt; Int -&gt; Bool
insideR k x y = significant k y x y
{-# INLINE insideR #-}

lookup :: Int -&gt; IntMap a -&gt; Maybe a
lookup k m0 = go m0 where
  go (Tip i a)
    | k == i    = Just a
    | otherwise = Nothing
  go (Bin x y  l r)
    | outside k x y = Nothing -- short-circuit
    | insideR k x y = go r
    | otherwise     = go l
  go Nil = Nothing
{-# INLINE lookup #-}

insert :: Int -&gt; a -&gt; IntMap a -&gt; IntMap a
insert k a m0 = go m0 where
  go Nil = Tip k a
  go (Tip j b) = case compare k j of
    LT -&gt; Bin k j (Tip k a) (Tip j b)
    EQ -&gt; Tip k a
    GT -&gt; Bin j k (Tip j b) (Tip k a)
  go n@(Bin x y l r)
    | k &lt; x = if significant x y k y then Bin k y (Tip k a) n
                                     else Bin k y (go l) r
    | k &gt; y = if significant x y x k then Bin x k n (Tip k a)
                                     else Bin x k l (go r)
    | significant k y x y = Bin x y l (go r)
    | otherwise           = Bin x y (go l) r
{-# INLINE insert #-}

newx :: Int -&gt; IntMap a -&gt; IntMap a -&gt; IntMap a
newx _ Nil r = r
newx y l@(Tip x _) r = Bin x y l r
newx y l@(Bin x _ _ _) r = Bin x y l r
{-# INLINE newx #-}

newy :: Int -&gt; IntMap a -&gt; IntMap a -&gt; IntMap a
newy _ l Nil = l
newy x l r@(Tip y _)     = Bin x y l r
newy x l r@(Bin _ y _ _) = Bin x y l r
{-# INLINE newy #-}

delete :: Int -&gt; IntMap a -&gt; IntMap a
delete k m0 = go m0 where
  go n@(Bin x y l r)
    | outside k x y = n
    | insideR k x y = newy x l (go r)
    | otherwise     = newx y (go l) r
  go n@(Tip x a)
    | k == x    = Nil
    | otherwise = n
  go Nil = Nil
{-# INLINE delete #-}

at :: Functor f =&gt; Int -&gt; (Maybe a -&gt; f (Maybe a)) -&gt; IntMap a -&gt; f (IntMap a)
at k f m0 = go m0 where
  go Nil       = maybe Nil (Tip k) &lt;$&gt; f Nothing
  go n@(Tip x a) = case compare k x of    
    LT -&gt; maybe n (\b -&gt; Bin k x (Tip k b) n) &lt;$&gt; f Nothing
    EQ -&gt; maybe Nil (Tip k) &lt;$&gt; f (Just a)
    GT -&gt; maybe n (\b -&gt; Bin x k n (Tip k b)) &lt;$&gt; f Nothing
  go n@(Bin x y l r)
    | k &gt; y = if significant x y x k then maybe n (\b -&gt; Bin x k n (Tip k b)) &lt;$&gt; f Nothing               -- far right
                                     else maybe n (\b -&gt; Bin x (max k y) l (insert k b r)) &lt;$&gt; f Nothing  -- near right
    | k &lt; x = if significant x y k y then maybe n (\b -&gt; Bin k y (Tip k b) n) &lt;$&gt; f Nothing               -- far left
                                     else maybe n (\b -&gt; Bin (min k x) y (insert k b l) r) &lt;$&gt; f Nothing  -- near left
    | significant k y x y = newy x l &lt;$&gt; go r -- in right
    | otherwise           = (\l' -&gt; newx y l' r) &lt;$&gt; go l -- in left
{-# INLINE at #-}

bin :: IntMap a -&gt; IntMap a -&gt; IntMap a
bin l Nil = l
bin Nil r = r
bin l@(Tip x _)     r@(Tip y _)     = Bin x y l r
bin l@(Tip x _)     r@(Bin _ y _ _) = Bin x y l r
bin l@(Bin x _ _ _) r@(Bin _ y _ _) = Bin x y l r
bin l@(Bin x _ _ _) r@(Tip y _)     = Bin x y l r
{-# INLINE bin #-}
-- /show
-- show Run it!
main = print $ (empty &amp; at 1 ?~ &quot;hello&quot; &amp; at 2 ?~ &quot;world&quot;) ^. at 2
-- /show</code></pre><p>I have no idea if this is faster than the approach taken by <code>Data.IntMap</code> in practice on real data, but <code>xor</code> is your friend.</p><p>A great opportunity for participation would be to prove whether this code is faster or slower than the code in <code>Data.IntMap</code> in practice and if it proves to be faster, flesh it out!</p><p>I have one last diversion I need to post about before I can finally get to talking about the algorithm that started this discussion.</p><p>-<a href="mailto:ekmett@gmail.com">Edward Kmett</a></p><p>August 23 2013</p></article>

<div id="disqus_thread"><script>var disqus_shortname = "edwardk"; (function() { var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true; dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq); })();</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">comments powered by <span class="logo-disqus">Disqus</span></a></a>
</div>

</div>
</div>
<div class="row article-footer"><div class="span7 meta"><span class="sociallinksunicode social">
<a href="https://twitter.com/home?status=$url$" target="_blank"><i class="icon-twitter"></i></a>&nbsp;
<a href="http://www.facebook.com/sharer/sharer.php?u=$url$" target="_blank"><i class="icon-facebook"></i></a>&nbsp;
<a href="https://plus.google.com/share?url=$url$" target="_blank"><i class="icon-google-plus"></i></a></span>
</div>
</div>
</div>
<div class="footer"><div class="container"><div class="row"><div class="span12"><ul class="menu"><li><a href="https://www.schoolofhaskell.com/">School</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user">Users</a>
</li>

<li><a class="brand" href="https://fpcomplete.com">Sponsored by:
<img src="/static/img/logo.png" title="FPComplete">
</a>
</li>
</ul>
</div>
</div>
<div class="row"><div class="span12"></div>
</div>
</div>
</div>
<link rel="stylesheet" type="text/css" href="/static/bootstrap/css/bootstrap-responsive.css" />
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script><script src="https://www.schoolofhaskell.com/static/combined/Y-3k9_tW.js"></script><script>$(function(){
  $("a.logout").click(function(){
    var form = $("<form method='post'/>");
    form.attr("action", $(this).attr("href"));
    $("body").append(form);
    form.submit();
    return false;
  });
});

$(function(){
    $('.sociallinksunicode a').each(function(){
        $(this).attr('href',$(this).attr('href').replace('$url$',document.location));
    });
});

$(function(){
  // If we need to select a user/select a password then show the
  // details confirmation form, otherwise enable the getting started
  // section.
  if($('.alert-block a').text().match(/(selected a username|change your password)/)) {
    $("#confirm-details").show();
    $("#confirm-details #inputUsername").focus();
  } else {
    $("#get-started").removeClass('disabled').addClass('enabled');
  }

  // For lack of a plain HTML validation story this will do.
  $('.welcome-page').each(function(){
    $('form').submit(check);
  });
  function check(){
    setTimeout(check,500);
    var error = false;
    $('.error').removeClass('error');
    $('#enter-details input').each(function(){
      if($(this).val() == '') {
        $(this).parent().parent().addClass('error');
        error = true;
      }
    });
    if(error) return false;
    if($('[name=password]').val() == $('[name=confirm]').val()) {
      $('#confirm').removeClass('error');
      return true;
    } else {
      $('#confirm').addClass('error');
      return false;
    }
  }
});

$(function(){
  // When scrolling over a snippet editor, activate the "clone in IDE" popovers
  $('article').each(function(){
    var n = 100;
    var wait = 10000;
    function check(){
      if($('.clone').length == 0) {
        setTimeout(check,n);
        return;
      }
      var activated = $.cookie('clone-popover');
      if (activated) return;
      var activate = false;
      $('.controlsRun:onScreen').each(function(){
        $.cookie('clone-popover', 'true', { expires: 30, path: '/' });
        activate = true;
        return false;
      });
      if(activate) {
          $('.clone').each(function(){
              // The bootstrap API is rather unreasonable to say the
              // least.
              next = $(this).parent();
              var title = next.attr('title');
              next.attr('data-content',$(this).attr('data-content'));
              next.attr('title',$(this).attr('title'));
              next.popover('show',{
                  title: $(this).attr('title')
              });
              next.attr('title',title);
          });
          setTimeout(function(){
              $('.clone').each(function(){
                  $(this).parent().popover('hide');
              });
          },wait);
      } else {
        setTimeout(check,n);
      }
    }
    setTimeout(check,n);
  });
});

// onScreen jQuery plugin v0.2.1
// (c) 2011-2013 Ben Pickles
//
// http://benpickles.github.com/onScreen
//
// Released under MIT license.
(function(a){a.expr[":"].onScreen=function(b){var c=a(window),d=c.scrollTop(),e=c.height(),f=d+e,g=a(b),h=g.offset().top,i=g.height(),j=h+i;return h>=d&&h<f||j>d&&j<=f||i>e&&h<=d&&j>=f}})(jQuery);

/*!
 * jQuery Cookie Plugin v1.1
 * https://github.com/carhartl/jquery-cookie
 *
 * Copyright 2011, Klaus Hartl
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.opensource.org/licenses/GPL-2.0
 */
(function($, document) {

  var pluses = /\+/g;
  function raw(s) {
    return s;
  }
  function decoded(s) {
    return decodeURIComponent(s.replace(pluses, ' '));
  }

  $.cookie = function(key, value, options) {

    // key and at least value given, set cookie...
    if (arguments.length > 1 && (!/Object/.test(Object.prototype.toString.call(value)) || value == null)) {
      options = $.extend({}, $.cookie.defaults, options);

      if (value == null) {
	options.expires = -1;
      }

      if (typeof options.expires === 'number') {
	var days = options.expires, t = options.expires = new Date();
	t.setDate(t.getDate() + days);
      }

      value = String(value);

      return (document.cookie = [
	encodeURIComponent(key), '=', options.raw ? value : encodeURIComponent(value),
	options.expires ? '; expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE
	options.path    ? '; path=' + options.path : '',
	options.domain  ? '; domain=' + options.domain : '',
	options.secure  ? '; secure' : ''
      ].join(''));
    }

    // key and possibly options given, get cookie...
    options = value || $.cookie.defaults || {};
    var decode = options.raw ? raw : decoded;
    var cookies = document.cookie.split('; ');
    for (var i = 0, parts; (parts = cookies[i] && cookies[i].split('=')); i++) {
      if (decode(parts.shift()) === key) {
	return decode(parts.join('='));
      }
    }
    return null;
  };
  $.cookie.defaults = {};})(jQuery, document);
</script><!--[if lt IE 10]><script src="https://www.schoolofhaskell.com/static/design/js/ie.js?etag=ayV2DuJ0"></script><![endif]--><script>if(!window.location.href.match(/localhost/)){var track = '/tutorial/user/edwardk/revisiting-matrix-multiplication/part-4';
window._gaq = [['_setAccount','UA-36928035-1'],track != ''? ['_trackPageview',track] : ['_trackPageview']
,['_trackPageLoadTime']];window._gaq.push(['_setCustomVar',1,'Section','School of Haskell',3]);
window._gaq.push(['_setCustomVar',2,'User Type','Visitor',1]);
(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);

})();}</script>
<!-- Prompt IE 6 users to install Chrome Frame. Remove this if you want to support IE 6.  chromium.org/developers/how-tos/chrome-frame-getting-started --><!--[if lt IE 7 ]><script src="//ajax.googleapis.com/ajax/libs/chrome-frame/1.0.3/CFInstall.min.js"></script><script>window.attachEvent('onload',function(){CFInstall.check({mode:'overlay'})})</script><![endif]--></body></html>