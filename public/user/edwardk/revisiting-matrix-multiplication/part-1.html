<!DOCTYPE html>
<html><head><title>Part I: Bit Shuffling with Lenses and Isomorphisms - School of Haskell | School of Haskell</title><meta http-equiv="x-ua-compatible" content="IE=9"><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="google-site-verification" content="Rfxk2TdeMMXEXHgJ2_OO8Rt3hPbQSDao0OXQV_n6z_s" /><link href="//fonts.googleapis.com/css?family=Merriweather" rel="stylesheet" type="text/css"><link href="https://www.schoolofhaskell.com/recent-content/feed" type="application/rss+xml" rel="alternate" title="Recently published content">
<link rel="stylesheet" href="https://www.schoolofhaskell.com/static/combined/UlwEHVcM.css"><style>.social{margin-right:1em}h1{font-family:Merriweather !important}article{font-family:Merriweather !important}article li{font-family:Merriweather !important;line-height:1.6em}h1,h2,h3,h4,h4,h5{font-family:Merriweather !important}.editor p{font-family:Frutiger, "Frutiger Linotype", Univers, Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans Condensed", "Liberation Sans", "Nimbus Sans L", Tahoma, Geneva, "Helvetica Neue", Helvetica, Arial, sans-serif}.article-footer{border-top:1px solid #ddd;padding-top:1em;margin-top:1em}body{font-size:16px !important}.navbar .navbar-inner{background:#3c3f41}.navbar .brand{font-size:14px}.navbar .brand img{width:6em}.navbar .icon-wrench{margin:0 -0.5em 0 -0.5em;padding:0 1em 0 1em;height:20px}.navbar-inverse .nav .active a{background:#333638}.navbar-inverse .nav > li > a{color:#a7a7a7
}.navbar-inverse .btn-navbar{background:#333638}.navbar-inverse .nav > li a:hover,.navbar-inverse .btn{background:#333537 !important}@media (max-width: 979px) {.icon-wrench{padding-left:1em !important}}.breadcrumb{border-top-left-radius:0;border-top-right-radius:0}h1{margin-top:20px}.breadcrumb-container + .main-content h1{margin-top:0}.footer{padding:30px 0;margin-top:70px;border-top:1px solid #e5e5e5;background-color:#f5f5f5}.footer ul.footer-menu{list-style-type:none}.footer ul.footer-menu li{display:inline-block}.footer ul.footer-menu li + li{margin-left:0.5em}.footer ul.footer-menu li + li:before{margin-right:0.5em;content:"·";color:#999}.footer ul.menu li{display:inline-block}.footer ul.menu li + li{margin-left:0.5em}.footer .copyright{margin-left:25px}.main-content{min-height:100%}.gravatar{width:80px;height:80px;border-radius:2px;background:#eee}.empty-gravatar{width:0}.container{font-family:"Segoe UI", Candara, "Bitstream Vera Sans", "DejaVu Sans", "Bitstream Vera Sans", "Trebuchet MS", Verdana, "Verdana Ref", sans-serif}.container h1,.container h2,.container h4,.container h4,.container h5{font-family:"Segoe UI", Candara, "Bitstream Vera Sans", "DejaVu Sans", "Bitstream Vera Sans", "Trebuchet MS", Verdana, "Verdana Ref", sans-serif}article{font-family:Merriweather !important}article h1{font-family:Merriweather !important}article li{font-family:Merriweather !important;line-height:1.6em}article li + li{margin-top:0.5em}article div.code{background:#f9f9f9;border:1px solid #d1d1d1;position:relative;border-radius:0.2em;margin:0.25em 0 0.75em 0;min-height:2.5em}article code{color:#005580;font-size:14px;white-space:pre}article a.hoogle > code{color:#0088cc;font-size:14px;white-space:pre;border:0}article .expand-code{display:none}article pre{overflow:auto;word-wrap:normal}article code.active{display:block;max-height:430px}article h1{font-size:31.5px}article h3{font-size:17.5px}article h4{font-size:14px}article h5,article h6{font-size:11.9px}article p{line-height:1.7em}article h1 code,article h2 code,article h3 code,article h4 code,article h5 code,article h6 code{font-size:inherit !important}article h1 a,article h2 a,article h3 a,article h4 a,article h5 a,article h6 a{color:#444}article h1 a:before,article h2 a:before,article h3 a:before,article h4 a:before,article h5 a:before,article h6 a:before{margin-left:-1.5em;padding-right:0.5em;font-family:fontawesome;content:"\f0c1";font-size:20px;color:#fff}article h1 a:hover,article h2 a:hover,article h3 a:hover,article h4 a:hover,article h5 a:hover,article h6 a:hover{text-decoration:none;color:#0088cc}article h1 a:hover:before,article h2 a:hover:before,article h3 a:hover:before,article h4 a:hover:before,article h5 a:hover:before,article h6 a:hover:before{color:#888}article h2{font-size:24.5px}article .popover{font-family:actor}article .popover h3.popover-title{font-family:actor !important;font-size:1em}article .popover .popover-content{width:15em;font-size:1em}article .controlsRun{display:block;padding:0.5em;text-align:right;background:#f2f2f2}article .controlsRun a.clone{margin-right:1em;font-family:actor;text-decoration:none}article .controlsRun a.clone span{padding-left:0.5em}article .controlsRun a.run,article .controlsRun a.reset,article .controlsRun a.show-code{font-size:16px}article .controlsRun a.run span,article .controlsRun a.reset span,article .controlsRun a.show-code span{display:none}article .controlsRun a.reset{margin-left:0.5em;color:#a2becc}article .controlsRun a.reset{display:none}article .controlsRun a.show-code{margin-right:0.75em}article .controlsRun a.run:hover,article .controlsRun a.show-code:hover{text-decoration:none}article .controlsRun a.show-code.active{color:#DC0D0D}article .controlsRun a[disabled]{color:#a2becc;cursor:default}article .collapse-area .collapse-header{background:#0088cc;color:#fff;padding:0.3em;cursor:pointer}article .collapse-area .hidden-toggle:before{content:"\f0d7";font-family:fontawesome;margin-right:0.5em;margin-left:0.25em}article .collapse-area .collapsed-files{overflow:auto;height:auto}article .collapse-area.collapse-disabled{display:none}article .collapse-area.collapse-area-off .collapsed-files{height:0px;overflow:hidden}article .collapse-area.collapse-area-off .hidden-toggle:before{content:"\f0da"}article .snippet-stdio .stdout{margin:0.5em;padding-right:2em;position:relative;word-wrap:break-word}article .snippet-stdio .stdin{-webkit-box-shadow:none;-moz-box-shadow:none;box-shadow:none;-webkit-transition:none;-moz-transition:none;-o-transition:none;transition:none;padding:0;margin:0}article .hoogle-results{margin:0.25em}article .hoogle-results .hoogle-inner{background:#fff;padding:0.5em;border-radius:3px;border:1px solid #ddd}article .hoogle-results .hoogle-inner .close-link{position:relative;float:right;margin-top:-0.5em;margin-right:-0.5em}article .snippet-output-errors{margin:1em 0.5em 0.5em 0.5em;position:relative}article .snippet-output-errors ul{list-style-type:none;margin:0;position:relative}article .snippet-output-errors pre{border:0;border-radius:0;padding:0.25em;margin:0;background:inherit;color:inherit}article .snippet-output-errors .close-link{color:inherit;background:inherit}article .snippet-editors{z-index:0;padding:0.25em}article .close-link{padding:0.5em;background:#eaeaea;border-bottom-left-radius:0.2em;border-top-right-radius:0.2em;position:absolute;top:0;right:0}article .close-link:hover{text-decoration:none}article .snippet-title{padding:0.5em 0 0 0.5em}article .snippet-title .snippet-icon{font-family:FontAwesome;display:inline-block;margin-right:0.5em}article .fullModuleCode + div .snippet-title{margin-top:0.5em;border-top:1px solid #ccc;padding-top:0.5em}article .CodeMirror{height:auto;min-height:1em;line-height:1.5em;background:transparent;font-size:14px !important}article .CodeMirror .highlighted{background:rgba(250, 210, 0, 0.45) !important}article .CodeMirror-widget{margin-left:2em;line-height:1.8}article .CodeMirror.collapsed{height:10em !important}article .editor .expander{text-align:center;display:block;padding:0.5em;text-decoration:none;border-bottom-left-radius:2px;border-bottom-right-radius:2px}article .editor .expander .ellipsis{background:white;border:1px solid #ccc;padding:0 0.5em;height:1em;line-height:0.5em;display:inline-block;color:#555;cursor:pointer}article .editor .expander .ellipsis:hover{background:#ddd;color:#333}article .web-runner{margin:0.5em;padding:0.5em;border:1px solid #ccc;border-radius:3px;background:#f5f5f5}article .web-runner iframe{border:0;margin-top:0.5em;margin-bottom:0;background:white}article .web-runner .controls i{cursor:pointer;color:#0088cc}article .web-runner .controls i:hover{color:#222}article .web-runner .controls i + i{margin-left:0.5em}article .web-runner .controls .icon-remove{float:right}article .hidden{display:block;visibility:visible}article .controlsShowHide{margin-bottom:0.5em}.tutorial-body{float:left !important}.tutorial-nav{float:right !important}@media (max-width: 979px) {.related-content{float:right}.author-name{display:block;margin-left:20px !important;padding-left:5px;margin-top:5px}article h1 a:hover:before,article h2 a:hover:before,article h3 a:hover:before,article h4 a:hover:before,article h5 a:hover:before,article h6 a:hover:before{color:#fff}.tutorial-nav{float:none !important;width:auto !important}.tutorial-body{float:none !important;width:auto !important}}@media (min-width: 980px) and (max-width: 1199px) {.navbar-search{display:none}.tutorial-nav{width:200px}.tutorial-body{width:720px}}#accountPage h1{margin:20px 0 0 0}#accountPage h2{font-size:20px}.group-contents .span8{float:left}.group-contents .span4{float:right}.container > .alert-block{margin-top:1em}.alert{color:#aa874a
}.social{margin-bottom:.8em;display:block}.social a{text-decoration:none}.social i{font-size:1.1em;color:#fff;padding:0.25em;border-radius:0.25em;width:1em;display:inline-block;text-align:center}.social i.icon-twitter{background:#0088cc}.social i.icon-facebook{background:#3b5998
  }.social i.icon-google-plus{background:#dd4b39
  }.well pre{background:#fcfcfc}.well h2{margin-top:0}code{color:#005580;font-size:14px;white-space:pre}</style><!--[if lt IE 8]><link rel="stylesheet" href="https://www.schoolofhaskell.com/static/design/css/ie7.css?etag=TSMl9x1V"><![endif]--><!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]--></head><body class="not-logged-in" itemscope itemtype="http://schema.org/Product"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-H62P" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-H62P');</script><div class="navbar navbar-inverse navbar-static-top"><div class="navbar-inner"><div class="container"><a class="btn btn-navbar" type="button" data-toggle="collapse" data-target=".nav-collapse"><span class="icon-bar"></span>
<span class="icon-bar"></span>
<span class="icon-bar"></span>
</a>
<a class="brand" href="/"><img src="/static/img/haskell-logo-wide.png" title="School of Haskell">
</a>
<div class="nav-collapse collapse"><ul class="nav"><li><a href="https://www.schoolofhaskell.com/">School</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user">Users</a>
</li>
</ul>
<form class="navbar-search pull-left" action="https://www.schoolofhaskell.com/search"><input class="search-query" type="text" placeholder="Search" name="search">
</form>
</div>
</div>
</div>
</div>
<div class="container breadcrumb-container"><div class="row"><div class="span12"><ul class="breadcrumb"><li><a href="https://www.schoolofhaskell.com/user/edwardk">Edward Kmett</a>
<span class="divider">/</span>
</li>
<li><a href="https://www.schoolofhaskell.com/user/edwardk/revisiting-matrix-multiplication">Revisiting Matrix Multiplication</a>
<span class="divider">/</span>
</li>
<li><a href="https://www.schoolofhaskell.com/user/edwardk/revisiting-matrix-multiplication/part-1">Part I: Bit Shuffling with Lenses and Isomorphisms</a>
</li>
</ul>
</div>
</div>
</div>
<div class="container main-content"><div class="row"><div class="span12"><h1 itemprop="name">Part I: Bit Shuffling with Lenses and Isomorphisms</h1>
</div>
</div>
<div class="row"><div class="span7 meta"><p><span class="date">25 Aug 2013</span>
<span class="author"><a href="https://www.schoolofhaskell.com/user/edwardk">Edward Kmett</a>
</span>
<span class="view-edit-link pull-right"><a class="view-source-link" href="https://www.schoolofhaskell.com/tutorial-raw/4906/499f6f6ad03e6dc2feab4905f94308e5417e7458">View Markdown source</a>
</span>
</p>
<p class="tags"></p>
</div>
</div>
<div class="row"><div class="span7 meta"><span class="sociallinksunicode social">
<a href="https://twitter.com/home?status=$url$" target="_blank"><i class="icon-twitter"></i></a>&nbsp;
<a href="http://www.facebook.com/sharer/sharer.php?u=$url$" target="_blank"><i class="icon-facebook"></i></a>&nbsp;
<a href="https://plus.google.com/share?url=$url$" target="_blank"><i class="icon-google-plus"></i></a></span>
</div>
</div>
<p class="alert">As of March 2020, School of Haskell has been switched to read-only mode.</p>
<div class="row" itemprop="desc"><div class="span4 tutorial-nav"><div class="related-content"><ul class="nav nav-tabs nav-stacked"><li><script>reddit_target='fpcomplete'</script>
<script src="https://redditstatic.s3.amazonaws.com/button/button1.js"></script>
</li>
<li><a href="https://www.schoolofhaskell.com/user/edwardk/revisiting-matrix-multiplication/part-2">Next content: Part II: The Zen of Z-Ordering</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user/edwardk/revisiting-matrix-multiplication">Go up to: Revisiting Matrix Multiplication</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user/edwardk">See all content by Edward Kmett</a>
</li>
</ul>

</div>
<div class="aside"><h3>Sections</h3>
<ul><li><a href="#morton-ordering">Morton Ordering</a></li><li><a href="#every-day-i-m-shuffling">Every Day I&#39;m Shuffling</a></li><li><a href="#a-strange-game">A Strange Game</a></li></ul></div>
</div>
<div class="span8 tutorial-body" data-environment="ghc-7.8-stable-14.09">
<article><p>I'm going to try a few new things today.</p><p>First, I'm trying to write a post using the School of Haskell.</p><p>Second, I'm going to try to work through some code in a rather collaborative fashion. That is to say, I have a general idea of where I'm going and how to make it fast, but I have yet to do so and I'd like to actively encourage you to help me figure it out.</p><p>So, what are we hacking on?</p><p>I was recently reminded by Carter Schonwald about some properties of Morton ordering that turned out to be particularly relevant to sparse matrix multiplication. Along the way I discovered a particularly nice formulation of the problem, and I figured it would be a fun way to get my feet wet writing stuff here.</p><p>Hopefully, this series will have a bit of something for everybody: Some lenses, some bit bashing, worries about cache coherence, stream fusion, nice recursion patterns, finding simpler formulations for traditional algorithms, and general functional programming fun.</p><p>I'll also try to call out opportunities for readers to help as I go along. Particularly in the later parts, there will be a lot of room for improvement and many hands make light work!</p><p>The code for this project is available on github at <a href="https://github.com/ekmett/sparse">github.com/ekmett/sparse</a> if you are impatient and want to skip ahead. It isn't quite the last page in a murder mystery, and I haven't been shy about talking about this stuff, but I fully intend to crank away on development in there, so it may get pretty far in advance of these posts -- especially if you are late to the party!</p><p>Later on, we'll get to some numerics, and maybe they'll even perform decently, but today is mostly just setting up key space.</p><p>I'm hoping that by throwing open development a bit, I can help showcase a bit about how I think and attack a new problem as a Haskell programmer.</p><p>The latter parts are definitely currently unoptimized, but showcase what I think is a new technique (or at least a &quot;new to me&quot; technique) that I want to play with.</p><p>With all that out of the way, lets move on to</p><h1 id="morton-ordering"><a href="#morton-ordering">Morton Ordering</a></h1><p><a href="http://en.wikipedia.org/wiki/Z-order_curve">Morton ordering</a> (aka the Z-curve) is a technique for getting cache locality in multiple dimensions by interleaving the bits of your different keys rather than storing them lexicographically. It was discovered way back in 1966, so I figured it was time to  write up an article about it.</p><p><img alt="z-order" src="https://www.schoolofhaskell.com/content-proxy?src=http%3A%2F%2Fupload.wikimedia.org%2Fwikipedia%2Fcommons%2Fthumb%2Fc%2Fcd%2FFour-level_Z.svg%2F600px-Four-level_Z.svg.png" /></p><p>The idea is that instead of picking one of the keys to put first you interleave their bits. Now, you are in some sense slightly screwed up when it comes to sorting by either axis, but you're more or less equally screwed no matter which way you go, and you're less screwed than you would be if you were cutting row-wise across a column-major or column-wise across a row-major ordered version of things. In general you get to exploit locality in either dimension to some degree. The extra locality you get isn't as good as you can get with a proper <a href="http://en.wikipedia.org/wiki/Hilbert_curve">Hilbert curve</a> or with one of the other high end space filling curves, but those start requiring a lot more bit twiddling.</p><p>(If someone wants to follow along the later parts with a Hilbert or H curve and find where my tricks fail, I'd love to see the result!)</p><p>I want to work through how we can work with keys in Morton order in two ways. Today I'll walk through the first way.</p><p>Neither of these techniques is particularly new, but having at least one of them is necessary for what is to come.</p><h1 id="every-day-i-m-shuffling"><a href="#every-day-i-m-shuffling"><a href="http://www.youtube.com/watch?v=KQ6zr6kCPj8&amp;t=3m38s">Every Day I'm Shuffling</a></a></h1><p>We can turn to <a href="http://www.hackersdelight.org/">Hacker's Delight</a> to find a routine for interleaving the high and low parts of a word together.</p><pre><code class="c">unsigned shuffle1(unsigned x) {
// ------------------------------ cut ----------------------------------
   x = (x &amp; 0x0000FF00) &lt;&lt; 8 | (x &gt;&gt; 8) &amp; 0x0000FF00 | x &amp; 0xFF0000FF;
   x = (x &amp; 0x00F000F0) &lt;&lt; 4 | (x &gt;&gt; 4) &amp; 0x00F000F0 | x &amp; 0xF00FF00F;
   x = (x &amp; 0x0C0C0C0C) &lt;&lt; 2 | (x &gt;&gt; 2) &amp; 0x0C0C0C0C | x &amp; 0xC3C3C3C3;
   x = (x &amp; 0x22222222) &lt;&lt; 1 | (x &gt;&gt; 1) &amp; 0x22222222 | x &amp; 0x99999999;
// ---------------------------- end cut --------------------------------
   return x;
}</code></pre><p>What this does is take a bunch of bits like</p><pre><code class="text">abcd efgh ijkl mnop ABCD EFGH IJKL MNOP</code></pre><p>and then shuffles them until they are fully interleaved in parallel within the word carefully.</p><pre><code class="text">abcd efgh ABCD EFGH ijkl mnop IJKL MNOP
abcd ABCD efgh EFGH ijkl IJKL mnop MNOP
abAB cdCD efEF ghGH ijIJ klKL mnMN opOP
aAbB cCdD eEfF gGhH iIjJ kKlL mMnN oOpP</code></pre><p>We can view this technique perhaps as an early precursor to something out of the more the modern SWAR (SIMD within a register) <a href="http://aggregate.org/SWAR/Dis/dissertation.pdf">toolbox</a>, but we'll be doing everything by hand.</p><p>Now, I want to work with slightly larger keys, and I'd rather work in Haskell, so we can transcode that and reimplement it to work on larger word sizes with appropriate tweaks to the constants involved.</p><pre><code class="active haskell">-- show
import Data.Bits
import Data.Word
import Control.Lens
import Numeric.Lens
-- /show

-- show
shuffle :: Word64 -&gt; Word64
shuffle k0 = k5 where
  k1 = unsafeShiftL (k0 .&amp;. 0x00000000FFFF0000) 16 .|. unsafeShiftR k0 16 .&amp;. 0x00000000FFFF0000 .|. k0 .&amp;. 0xFFFF00000000FFFF
  k2 = unsafeShiftL (k1 .&amp;. 0x0000FF000000FF00) 8  .|. unsafeShiftR k1 8  .&amp;. 0x0000FF000000FF00 .|. k1 .&amp;. 0xFF0000FFFF0000FF
  k3 = unsafeShiftL (k2 .&amp;. 0x00F000F000F000F0) 4  .|. unsafeShiftR k2 4  .&amp;. 0x00F000F000F000F0 .|. k2 .&amp;. 0xF00FF00FF00FF00F
  k4 = unsafeShiftL (k3 .&amp;. 0x0C0C0C0C0C0C0C0C) 2  .|. unsafeShiftR k3 2  .&amp;. 0x0C0C0C0C0C0C0C0C .|. k3 .&amp;. 0xC3C3C3C3C3C3C3C3
  k5 = unsafeShiftL (k4 .&amp;. 0x2222222222222222) 1  .|. unsafeShiftR k4 1  .&amp;. 0x2222222222222222 .|. k4 .&amp;. 0x9999999999999999
-- /show

-- show main
main = print $ base 2 # shuffle 0x00000000FFFFFFFF
-- /show
</code></pre><p>Now we can build our <code>Key</code> type:</p><pre><code class="haskell">newtype Key = Key Word64

key :: Word32 -&gt; Word32 -&gt; Key
key i j = Key $ shuffle $ unsafeShiftL (fromIntegral i) 32 .|. fromIntegral j</code></pre><p>For convenience, it'd be nice to see what the key was originally to show it, and later on to be able to project it back out, so first, lets define an <code>unshuffle</code>.</p><pre><code class="active haskell">import Data.Bits
import Data.Word
import Control.Lens
import Numeric.Lens

-- show
unshuffle :: Word64 -&gt; Word64
unshuffle k0 = k5 where
  t0 = xor k0 (unsafeShiftR k0 1 ) .&amp;. 0x2222222222222222
  k1 = k0 `xor` t0 `xor` unsafeShiftL t0 1
  t1 = xor k1 (unsafeShiftR k1 2 ) .&amp;. 0x0C0C0C0C0C0C0C0C
  k2 = k1 `xor` t1 `xor` unsafeShiftL t1 2
  t2 = xor k2 (unsafeShiftR k2 4 ) .&amp;. 0x00F000F000F000F0
  k3 = k2 `xor` t2 `xor` unsafeShiftL t2 4
  t3 = xor k3 (unsafeShiftR k3 8 ) .&amp;. 0x0000FF000000FF00
  k4 = k3 `xor` t3 `xor` unsafeShiftL t3 8
  t4 = xor k4 (unsafeShiftR k4 16) .&amp;. 0x00000000FFFF0000
  k5 = k4 `xor` t4 `xor` unsafeShiftL t4 16
-- /show
{-# INLINE unshuffle #-}

-- show main
main = print $ base 2 # unshuffle 0xAAAAAAAAAAAAAAAA
-- /show</code></pre><blockquote><p><b>No-Prize Opportunity #1:</b></p><p>There exists an <code>unshuffle</code> that works much more like <code>shuffle</code>! What is the definition? The first reader to email me a working version of it wins a No-Prize.</p><p>[<b>Edit:</b> No-Prize #1 has been awarded to <a href="https://twitter.com/SCombinator">Sanjoy Das</a>. However, <a href="http://reddit.com/user/riotnerd">riotnerd</a> was the first to provide both a working unshuffle alongside the <a href="http://www.reddit.com/r/haskell/comments/1kecqt/revisiting_matrix_multiplication_part_i_by_edward/cbo8qwy?context=3">proof</a> that they compose to identity and so he has earned an honorable mention. His presentation showed good style and demonstrated the equality via clean equational rewriting.]</p><div class="hidden"><pre><code class="haskell">unshuffle k0 = k5 where
  k5 = unsafeShiftL (k4 .&amp;. 0x00000000FFFF0000) 16 .|. unsafeShiftR k4 16 .&amp;. 0x00000000FFFF0000 .|. k4 .&amp;. 0xFFFF00000000FFFF
  k4 = unsafeShiftL (k3 .&amp;. 0x0000FF000000FF00) 8  .|. unsafeShiftR k3 8  .&amp;. 0x0000FF000000FF00 .|. k3 .&amp;. 0xFF0000FFFF0000FF
  k3 = unsafeShiftL (k2 .&amp;. 0x00F000F000F000F0) 4  .|. unsafeShiftR k2 4  .&amp;. 0x00F000F000F000F0 .|. k2 .&amp;. 0xF00FF00FF00FF00F
  k2 = unsafeShiftL (k1 .&amp;. 0x0C0C0C0C0C0C0C0C) 2  .|. unsafeShiftR k1 2  .&amp;. 0x0C0C0C0C0C0C0C0C .|. k1 .&amp;. 0xC3C3C3C3C3C3C3C3
  k1 = unsafeShiftL (k0 .&amp;. 0x2222222222222222) 1  .|. unsafeShiftR k0 1  .&amp;. 0x2222222222222222 .|. k0 .&amp;. 0x9999999999999999</code></pre></div></blockquote><p>Interestingly, with <code>-fllvm</code>, that change, and a high enough optimization level, GHC is smart enough to realize <code>shuffle . unshuffle = id</code>!</p><p>With that, we can implement</p><pre><code class="haskell">unkey :: Key -&gt; (Word32, Word32)</code></pre><p>Now, we have what we need to make an isomorphism.</p><p>We could define</p><pre><code class="haskell">keyed :: Iso' (Word32,Word32) Key
keyed = iso (uncurry key) unkey</code></pre><p>and then we could expose field accessors that work like Key was a pair using the overloaded field accessors in <code>lens</code>:</p><pre><code class="haskell">instance Field1 Key Key Word32 Word32 where
  _1 = from keyed._1

instance Field2 Key Key Word32 Word32 where
  _2 = from keyed._2</code></pre><p>With this we can take a key, and freely manipulate one side of it with the lens combinators. e.g.</p><pre><code class="haskell">key 100 200 ^. _2 = 200
key 100 200 &amp; _2 .~ 300 = key 100 300</code></pre><p>and we can use these to make a custom <code>Show</code> and <code>Read</code> for our <code>Key</code> type that isn't so eyebleedingly tough to read:</p><pre><code class="haskell">instance Show Key where
  showsPrec d w = case unkey w of
    (i,j) -&gt; showParen (d &gt; 10) $
      showString &quot;key &quot; . Prelude.showsPrec 11 i .
           showChar ' ' . Prelude.showsPrec 11 j

instance Read Key where
  readsPrec d = readParen (d &gt; 10) $ \r -&gt;
    [ (key i j, u)
    | (&quot;key&quot;,s) &lt;- lex r
    , (i,t) &lt;- readsPrec 11 s
    , (j,u) &lt;- readsPrec 11 t
    ]</code></pre><p>now most users don't need to care too much about the internal implementation of <code>Key</code>.</p><p>That said, we revisit our awesomely succinct implementation for <code>_1</code> and <code>_2</code> above, because we can implement <code>_1</code> and <code>_2</code> much more efficiently if we don't bother to shuffle and unshuffle the other side at all!</p><p>Fortunately, once again the Hacker's Delight has our backs.</p><p>This time I'm going to encode the indexed lens directly rather than compose it out of simpler pieces:</p><pre><code class="haskell">-- | Masks for the interleaved components of a key
m1, m2 :: Word64
m1 = 0xAAAAAAAAAAAAAAAA -- the mask for the first component of our key.
m2 = 0x5555555555555555 -- the mask for the second component of our key.
{-# INLINE m1 #-}
{-# INLINE m2 #-}

instance (a ~ Word32, b ~ Word32) =&gt; Field2 Key Key a b where
  _2 f (Key ij) = indexed f (1 :: Int) (fromIntegral k5) &lt;&amp;&gt; \j -&gt; let
         j0 = fromIntegral j
         j1 = unsafeShiftL (j0 .&amp;. 0x00000000FFFF0000) 16 .|. j0 .&amp;. 0xFFFF00000000FFFF
         j2 = unsafeShiftL (j1 .&amp;. 0x0000FF000000FF00) 8  .|. j1 .&amp;. 0xFF0000FFFF0000FF
         j3 = unsafeShiftL (j2 .&amp;. 0x00F000F000F000F0) 4  .|. j2 .&amp;. 0xF00FF00FF00FF00F
         j4 = unsafeShiftL (j3 .&amp;. 0x0C0C0C0C0C0C0C0C) 2  .|. j3 .&amp;. 0xC3C3C3C3C3C3C3C3
         j5 = unsafeShiftL (j4 .&amp;. 0x2222222222222222) 1  .|. j4 .&amp;. 0x9999999999999999
      in Key (ij .&amp;. m1 .|. j5)
    where
      k0 = ij .&amp;. m2
      k1 = (unsafeShiftR k0 1  .|. k0) .&amp;. 0x3333333333333333
      k2 = (unsafeShiftR k1 2  .|. k1) .&amp;. 0x0F0F0F0F0F0F0F0F
      k3 = (unsafeShiftR k2 4  .|. k2) .&amp;. 0x00FF00FF00FF00FF
      k4 = (unsafeShiftR k3 8  .|. k3) .&amp;. 0x0000FFFF0000FFFF
      k5 = (unsafeShiftR k4 16 .|. k4) .&amp;. 0x00000000FFFFFFFF</code></pre><p>Here _2 is being made manually into an 'indexed lens' (really just to make the Field typeclass happy), it is always index 1, and it half-unshuffles out the right hand side of my <code>Word64</code> to make a Word32 suitable for consumption, and when given a replacement, shuffles it into place, and masks off what it is replacing in the <code>Key</code>.</p><p>I had a slightly fiddly issue with the signature that arose, because I needed to use a type equality rather than the more obvious <code>Field2 Key Key Word32 Word32</code> instance to make it so that <code>(.~)</code> selects the right instance.</p><p>Exercise: Try changing it to the obvious version in the module at the bottom of this file and see what happens to main!</p><blockquote><p><b>No-Prize opportunity #2</b></p><p>I'm currently using the following definition for <code>_1</code>, but what does a cleaner version that avoids the shifts on <code>i5</code> and <code>k0</code> with modified masks/shifts look like? Email me first with the answer for your No-Prize.</p><pre><code class="haskell">instance (a ~ Word32, b ~ Word32) =&gt; Field2 Key Key a b where
  _1 f (Key ij) = indexed f (0 :: Int) (fromIntegral k5) &lt;&amp;&gt; \i -&gt; let
         i0 = fromIntegral i
         i1 = unsafeShiftL (i0 .&amp;. 0x00000000FFFF0000) 16 .|. i0 .&amp;. 0xFFFF00000000FFFF
         i2 = unsafeShiftL (i1 .&amp;. 0x0000FF000000FF00) 8  .|. i1 .&amp;. 0xFF0000FFFF0000FF
         i3 = unsafeShiftL (i2 .&amp;. 0x00F000F000F000F0) 4  .|. i2 .&amp;. 0xF00FF00FF00FF00F
         i4 = unsafeShiftL (i3 .&amp;. 0x0C0C0C0C0C0C0C0C) 2  .|. i3 .&amp;. 0xC3C3C3C3C3C3C3C3
         i5 = unsafeShiftL (i4 .&amp;. 0x2222222222222222) 1  .|. i4 .&amp;. 0x9999999999999999
      in Key (unsafeShiftL i5 1 .|. ij .&amp;. m2)
    where
      k0 = unsafeShiftR (ij .&amp;. m1) 1
      k1 = (unsafeShiftR k0 1  .|. k0) .&amp;. 0x3333333333333333
      k2 = (unsafeShiftR k1 2  .|. k1) .&amp;. 0x0F0F0F0F0F0F0F0F
      k3 = (unsafeShiftR k2 4  .|. k2) .&amp;. 0x00FF00FF00FF00FF
      k4 = (unsafeShiftR k3 8  .|. k3) .&amp;. 0x0000FFFF0000FFFF
      k5 = (unsafeShiftR k4 16 .|. k4) .&amp;. 0x00000000FFFFFFFF</code></pre><p>[ Edit: No-Prize #2 is has been (partially!) awarded to <a href="http://www.thenewsh.com/~newsham/">Tim Newsham</a>, who provided the solution by carefully working the shifts back through the masks after he was stymied in his quest for No-Prize #1 by being too late to the party. His solution resolves the shifts on <code>k5</code>, but not <code>i0</code>. Can we do better? Why or why not? I also realize that in practice the reduction in constant sharing may likely outweigh the removal of the shift.]</p><div class="hidden"><pre><code class="haskell">instance (a ~ Word32, b ~ Word32) =&gt; Field2 Key Key a b where
  _1 f (Key ij) = indexed f (0 :: Int) (fromIntegral k5) &lt;&amp;&gt; \i -&gt; let
         i0 = fromIntegral i
         i1 = unsafeShiftL (i0 .&amp;. 0x00000000FFFF0000) 17 .|. i0 .&amp;. 0xFFFE00000001FFFE
         i2 = unsafeShiftL (i1 .&amp;. 0x0000FF000000FF00) 9  .|. i1 .&amp;. 0xFE0001FFFE0001FE
         i3 = unsafeShiftL (i2 .&amp;. 0x00F000F000F000F0) 5  .|. i2 .&amp;. 0xE01FE01FE01FE01E
         i4 = unsafeShiftL (i3 .&amp;. 0x0C0C0C0C0C0C0C0C) 3  .|. i3 .&amp;. 0x0F0F0F0F0F0F0F0E
         i5 = unsafeShiftL (i4 .&amp;. 0x2222222222222222) 2  .|. i4 .&amp;. 0x3333333333333332
      in Key (unsafeShiftL 1 i5 .|. ij .&amp;. m2)
    where
      k0 = ij .&amp;. m1
      k1 = (unsafeShiftR k0 2  .|. k0) .&amp;. 0x6666666666666666
      k2 = (unsafeShiftR k1 3  .|. k1) .&amp;. 0x1E1E1E1E1E1E1E1E
      k3 = (unsafeShiftR k2 5  .|. k2) .&amp;. 0x01FE01FE01FE01FE
      k4 = (unsafeShiftR k3 9  .|. k3) .&amp;. 0x0001FFFE0001FFFE
      k5 = (unsafeShiftR k4 15 .|. k4) .&amp;. 0x00000001FFFFFFFE</code></pre></div></blockquote><p>The current implementation of this code, with whatever changes have been made in the meantime, sans some cleanup for presentation is currently available as <a href="https://github.com/ekmett/sparse/blob/master/src/Sparse/Matrix/Key.hs">Sparse/Matrix/Key.hs</a>.</p><p>Now we can compare two keys for Morton order just by embedding them and comparing them, but can we do better?</p><h1 id="a-strange-game"><a href="#a-strange-game"><a href="http://www.youtube.com/watch?v=uOoXwxqeVzg">A Strange Game</a></a></h1><p>I'll pick up next time with how we can compare two keys by their Morton ordering without actually performing the interleaving at all! This technique will be important in what is to come, even if we may not use it directly for the keys themselves.</p><p>Hopefully by parts 3 or 4 we'll be deep in the bowels of Vector carving up custom stream fusion combinators and rethinking whether we want to partition a matrix or &quot;thin&quot; it to build an efficient sparse matrix multiplication routine.</p><p>I've included a current copy of the <code>Key</code> code below as an active document with minor alterations to enable you to play with it interactively. (It has a few cosmetic differences from the code above.)</p><p>-<a href="mailto:ekmett@gmail.com">Edward Kmett</a>
August 14th, 2013</p><pre><code class="active haskell">-- show Sparse/Matrix/Key.hs
{-# LANGUAGE KindSignatures #-}
{-# LANGUAGE DefaultSignatures #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE UndecidableInstances #-}
{-# LANGUAGE MultiParamTypeClasses #-}

-----------------------------------------------------------------------------
-- |
-- Copyright   :  (C) 2013 Edward Kmett
-- License     :  BSD-style (see the file LICENSE)
-- Maintainer  :  Edward Kmett &lt;ekmett@gmail.com&gt;
-- Stability   :  experimental
-- Portability :  non-portable
--
-- Keys in Morton order
--
-- This module provides combinators for shuffling together the bits of two
-- key components to get a key that is based on their interleaved bits.
--
-- See &lt;http://en.wikipedia.org/wiki/Z-order_curve&gt; for more information
-- about Morton order.
--
----------------------------------------------------------------------------

import Control.Lens
import Data.Bits
import Data.Word

-- * Morton Order

-- | @key i j@ interleaves the bits of the keys @i@ and @j@.
--
-- Keys are then just values sorted in \&quot;Morton Order\&quot;.
newtype Key = Key { runKey :: Word64 }
  deriving (Eq, Ord)

-- | Construct a key from a pair of indices.
--
-- @
-- key i j ^. _1 = i
-- key i j ^. _2 = j
-- @
key :: Word32 -&gt; Word32 -&gt; Key
key i j = Key k5 where
  k0 = unsafeShiftL (fromIntegral i) 32 .|. fromIntegral j
  k1 = unsafeShiftL (k0 .&amp;. 0x00000000FFFF0000) 16 .|. unsafeShiftR k0 16 .&amp;. 0x00000000FFFF0000 .|. k0 .&amp;. 0xFFFF00000000FFFF
  k2 = unsafeShiftL (k1 .&amp;. 0x0000FF000000FF00) 8  .|. unsafeShiftR k1 8  .&amp;. 0x0000FF000000FF00 .|. k1 .&amp;. 0xFF0000FFFF0000FF
  k3 = unsafeShiftL (k2 .&amp;. 0x00F000F000F000F0) 4  .|. unsafeShiftR k2 4  .&amp;. 0x00F000F000F000F0 .|. k2 .&amp;. 0xF00FF00FF00FF00F
  k4 = unsafeShiftL (k3 .&amp;. 0x0C0C0C0C0C0C0C0C) 2  .|. unsafeShiftR k3 2  .&amp;. 0x0C0C0C0C0C0C0C0C .|. k3 .&amp;. 0xC3C3C3C3C3C3C3C3
  k5 = unsafeShiftL (k4 .&amp;. 0x2222222222222222) 1  .|. unsafeShiftR k4 1  .&amp;. 0x2222222222222222 .|. k4 .&amp;. 0x9999999999999999
{-# INLINE key #-}

-- | This isomorphism lets you build a key from a pair of indices.
--
-- @
-- key i j ≡ (i,j)^.shuffled
-- @
--
-- @
-- 'shuffled' . 'unshuffled' = 'id'
-- 'unshuffled' . 'shuffled' = 'id'
-- @
shuffled :: Iso' (Word32, Word32) Key
shuffled = iso (uncurry key) unshuffle
{-# INLINE shuffled #-}

-- | This isomorphism lets you build a pair of indices from a key.
unshuffled :: Iso' Key (Word32, Word32)
unshuffled = iso unshuffle (uncurry key)
{-# INLINE unshuffled #-}

unshuffle :: Key -&gt; (Word32, Word32)
unshuffle (Key k0) = (fromIntegral (unsafeShiftR k5 32), fromIntegral k5) where
  t0 = xor k0 (unsafeShiftR k0 1 ) .&amp;. 0x2222222222222222
  k1 = k0 `xor` t0 `xor` unsafeShiftL t0 1
  t1 = xor k1 (unsafeShiftR k1 2 ) .&amp;. 0x0C0C0C0C0C0C0C0C
  k2 = k1 `xor` t1 `xor` unsafeShiftL t1 2
  t2 = xor k2 (unsafeShiftR k2 4 ) .&amp;. 0x00F000F000F000F0
  k3 = k2 `xor` t2 `xor` unsafeShiftL t2 4
  t3 = xor k3 (unsafeShiftR k3 8 ) .&amp;. 0x0000FF000000FF00
  k4 = k3 `xor` t3 `xor` unsafeShiftL t3 8
  t4 = xor k4 (unsafeShiftR k4 16) .&amp;. 0x00000000FFFF0000
  k5 = k4 `xor` t4 `xor` unsafeShiftL t4 16
{-# INLINE unshuffle #-}

instance (a ~ Word32, b ~ Word32) =&gt; Field1 Key Key a b where
  _1 f (Key ij) = indexed f (0 :: Int) (fromIntegral k5) &lt;&amp;&gt; \i -&gt; let
         i0 = fromIntegral i
         i1 = unsafeShiftL (i0 .&amp;. 0x00000000FFFF0000) 16 .|. i0 .&amp;. 0xFFFF00000000FFFF
         i2 = unsafeShiftL (i1 .&amp;. 0x0000FF000000FF00) 8  .|. i1 .&amp;. 0xFF0000FFFF0000FF
         i3 = unsafeShiftL (i2 .&amp;. 0x00F000F000F000F0) 4  .|. i2 .&amp;. 0xF00FF00FF00FF00F
         i4 = unsafeShiftL (i3 .&amp;. 0x0C0C0C0C0C0C0C0C) 2  .|. i3 .&amp;. 0xC3C3C3C3C3C3C3C3
         i5 = unsafeShiftL (i4 .&amp;. 0x2222222222222222) 1  .|. i4 .&amp;. 0x9999999999999999
      in Key (unsafeShiftL i5 1 .|. ij .&amp;. m2)
    where
      k0 = unsafeShiftR (ij .&amp;. m1) 1
      k1 = (unsafeShiftR k0 1  .|. k0) .&amp;. 0x3333333333333333
      k2 = (unsafeShiftR k1 2  .|. k1) .&amp;. 0x0F0F0F0F0F0F0F0F
      k3 = (unsafeShiftR k2 4  .|. k2) .&amp;. 0x00FF00FF00FF00FF
      k4 = (unsafeShiftR k3 8  .|. k3) .&amp;. 0x0000FFFF0000FFFF
      k5 = (unsafeShiftR k4 16 .|. k4) .&amp;. 0x00000000FFFFFFFF
  -- _1 = unshuffled._1 -- reference implementation
  {-# INLINE _1 #-}

instance (a ~ Word32, b ~ Word32) =&gt; Field2 Key Key a b where
  _2 f (Key ij) = indexed f (1 :: Int) (fromIntegral k5) &lt;&amp;&gt; \j -&gt; let
         j0 = fromIntegral j
         j1 = unsafeShiftL (j0 .&amp;. 0x00000000FFFF0000) 16 .|. j0 .&amp;. 0xFFFF00000000FFFF
         j2 = unsafeShiftL (j1 .&amp;. 0x0000FF000000FF00) 8  .|. j1 .&amp;. 0xFF0000FFFF0000FF
         j3 = unsafeShiftL (j2 .&amp;. 0x00F000F000F000F0) 4  .|. j2 .&amp;. 0xF00FF00FF00FF00F
         j4 = unsafeShiftL (j3 .&amp;. 0x0C0C0C0C0C0C0C0C) 2  .|. j3 .&amp;. 0xC3C3C3C3C3C3C3C3
         j5 = unsafeShiftL (j4 .&amp;. 0x2222222222222222) 1  .|. j4 .&amp;. 0x9999999999999999
      in Key (ij .&amp;. m1 .|. j5)
    where
      k0 = ij .&amp;. m2
      k1 = (unsafeShiftR k0 1  .|. k0) .&amp;. 0x3333333333333333
      k2 = (unsafeShiftR k1 2  .|. k1) .&amp;. 0x0F0F0F0F0F0F0F0F
      k3 = (unsafeShiftR k2 4  .|. k2) .&amp;. 0x00FF00FF00FF00FF
      k4 = (unsafeShiftR k3 8  .|. k3) .&amp;. 0x0000FFFF0000FFFF
      k5 = (unsafeShiftR k4 16 .|. k4) .&amp;. 0x00000000FFFFFFFF
  -- _2 = unshuffled._2 -- reference implementation
  {-# INLINE _2 #-}

instance Show Key where
  showsPrec d w = case unshuffle w of
    (i,j) -&gt; showParen (d &gt; 10) $
      showString &quot;key &quot; . Prelude.showsPrec 11 i .
           showChar ' ' . Prelude.showsPrec 11 j

instance Read Key where
  readsPrec d = readParen (d &gt; 10) $ \r -&gt;
    [ (key i j, u)
    | (&quot;key&quot;,s) &lt;- lex r
    , (i,t) &lt;- readsPrec 11 s
    , (j,u) &lt;- readsPrec 11 t
    ]

-- * Utilities

-- | Masks for the interleaved components of a key
m1, m2 :: Word64
m1 = 0xAAAAAAAAAAAAAAAA
m2 = 0x5555555555555555
{-# INLINE m1 #-}
{-# INLINE m2 #-}

-- /show


-- show playground
main :: IO ()
main = do
 print $ key 100 200 ^. _2
 print $ key 100 200 &amp; _1 .~ 300
-- /show</code></pre></article>

<div id="disqus_thread"><script>var disqus_shortname = "edwardk"; (function() { var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true; dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq); })();</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">comments powered by <span class="logo-disqus">Disqus</span></a></a>
</div>

</div>
</div>
<div class="row article-footer"><div class="span7 meta"><span class="sociallinksunicode social">
<a href="https://twitter.com/home?status=$url$" target="_blank"><i class="icon-twitter"></i></a>&nbsp;
<a href="http://www.facebook.com/sharer/sharer.php?u=$url$" target="_blank"><i class="icon-facebook"></i></a>&nbsp;
<a href="https://plus.google.com/share?url=$url$" target="_blank"><i class="icon-google-plus"></i></a></span>
</div>
</div>
</div>
<div class="footer"><div class="container"><div class="row"><div class="span12"><ul class="menu"><li><a href="https://www.schoolofhaskell.com/">School</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user">Users</a>
</li>

<li><a class="brand" href="https://fpcomplete.com">Sponsored by:
<img src="/static/img/logo.png" title="FPComplete">
</a>
</li>
</ul>
</div>
</div>
<div class="row"><div class="span12"></div>
</div>
</div>
</div>
<link rel="stylesheet" type="text/css" href="/static/bootstrap/css/bootstrap-responsive.css" />
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script><script src="https://www.schoolofhaskell.com/static/combined/Y-3k9_tW.js"></script><script>$(function(){
  $("a.logout").click(function(){
    var form = $("<form method='post'/>");
    form.attr("action", $(this).attr("href"));
    $("body").append(form);
    form.submit();
    return false;
  });
});

$(function(){
    $('.sociallinksunicode a').each(function(){
        $(this).attr('href',$(this).attr('href').replace('$url$',document.location));
    });
});

$(function(){
  // If we need to select a user/select a password then show the
  // details confirmation form, otherwise enable the getting started
  // section.
  if($('.alert-block a').text().match(/(selected a username|change your password)/)) {
    $("#confirm-details").show();
    $("#confirm-details #inputUsername").focus();
  } else {
    $("#get-started").removeClass('disabled').addClass('enabled');
  }

  // For lack of a plain HTML validation story this will do.
  $('.welcome-page').each(function(){
    $('form').submit(check);
  });
  function check(){
    setTimeout(check,500);
    var error = false;
    $('.error').removeClass('error');
    $('#enter-details input').each(function(){
      if($(this).val() == '') {
        $(this).parent().parent().addClass('error');
        error = true;
      }
    });
    if(error) return false;
    if($('[name=password]').val() == $('[name=confirm]').val()) {
      $('#confirm').removeClass('error');
      return true;
    } else {
      $('#confirm').addClass('error');
      return false;
    }
  }
});

$(function(){
  // When scrolling over a snippet editor, activate the "clone in IDE" popovers
  $('article').each(function(){
    var n = 100;
    var wait = 10000;
    function check(){
      if($('.clone').length == 0) {
        setTimeout(check,n);
        return;
      }
      var activated = $.cookie('clone-popover');
      if (activated) return;
      var activate = false;
      $('.controlsRun:onScreen').each(function(){
        $.cookie('clone-popover', 'true', { expires: 30, path: '/' });
        activate = true;
        return false;
      });
      if(activate) {
          $('.clone').each(function(){
              // The bootstrap API is rather unreasonable to say the
              // least.
              next = $(this).parent();
              var title = next.attr('title');
              next.attr('data-content',$(this).attr('data-content'));
              next.attr('title',$(this).attr('title'));
              next.popover('show',{
                  title: $(this).attr('title')
              });
              next.attr('title',title);
          });
          setTimeout(function(){
              $('.clone').each(function(){
                  $(this).parent().popover('hide');
              });
          },wait);
      } else {
        setTimeout(check,n);
      }
    }
    setTimeout(check,n);
  });
});

// onScreen jQuery plugin v0.2.1
// (c) 2011-2013 Ben Pickles
//
// http://benpickles.github.com/onScreen
//
// Released under MIT license.
(function(a){a.expr[":"].onScreen=function(b){var c=a(window),d=c.scrollTop(),e=c.height(),f=d+e,g=a(b),h=g.offset().top,i=g.height(),j=h+i;return h>=d&&h<f||j>d&&j<=f||i>e&&h<=d&&j>=f}})(jQuery);

/*!
 * jQuery Cookie Plugin v1.1
 * https://github.com/carhartl/jquery-cookie
 *
 * Copyright 2011, Klaus Hartl
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.opensource.org/licenses/GPL-2.0
 */
(function($, document) {

  var pluses = /\+/g;
  function raw(s) {
    return s;
  }
  function decoded(s) {
    return decodeURIComponent(s.replace(pluses, ' '));
  }

  $.cookie = function(key, value, options) {

    // key and at least value given, set cookie...
    if (arguments.length > 1 && (!/Object/.test(Object.prototype.toString.call(value)) || value == null)) {
      options = $.extend({}, $.cookie.defaults, options);

      if (value == null) {
	options.expires = -1;
      }

      if (typeof options.expires === 'number') {
	var days = options.expires, t = options.expires = new Date();
	t.setDate(t.getDate() + days);
      }

      value = String(value);

      return (document.cookie = [
	encodeURIComponent(key), '=', options.raw ? value : encodeURIComponent(value),
	options.expires ? '; expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE
	options.path    ? '; path=' + options.path : '',
	options.domain  ? '; domain=' + options.domain : '',
	options.secure  ? '; secure' : ''
      ].join(''));
    }

    // key and possibly options given, get cookie...
    options = value || $.cookie.defaults || {};
    var decode = options.raw ? raw : decoded;
    var cookies = document.cookie.split('; ');
    for (var i = 0, parts; (parts = cookies[i] && cookies[i].split('=')); i++) {
      if (decode(parts.shift()) === key) {
	return decode(parts.join('='));
      }
    }
    return null;
  };
  $.cookie.defaults = {};})(jQuery, document);
</script><!--[if lt IE 10]><script src="https://www.schoolofhaskell.com/static/design/js/ie.js?etag=ayV2DuJ0"></script><![endif]--><script>if(!window.location.href.match(/localhost/)){var track = '/tutorial/user/edwardk/revisiting-matrix-multiplication/part-1';
window._gaq = [['_setAccount','UA-36928035-1'],track != ''? ['_trackPageview',track] : ['_trackPageview']
,['_trackPageLoadTime']];window._gaq.push(['_setCustomVar',1,'Section','School of Haskell',3]);
window._gaq.push(['_setCustomVar',2,'User Type','Visitor',1]);
(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);

})();}</script>
<!-- Prompt IE 6 users to install Chrome Frame. Remove this if you want to support IE 6.  chromium.org/developers/how-tos/chrome-frame-getting-started --><!--[if lt IE 7 ]><script src="//ajax.googleapis.com/ajax/libs/chrome-frame/1.0.3/CFInstall.min.js"></script><script>window.attachEvent('onload',function(){CFInstall.check({mode:'overlay'})})</script><![endif]--></body></html>