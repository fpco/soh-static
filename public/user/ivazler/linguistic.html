<!DOCTYPE html>
<html><head><title>M-words in Linguistics - School of Haskell | School of Haskell</title><meta http-equiv="x-ua-compatible" content="IE=9"><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="google-site-verification" content="Rfxk2TdeMMXEXHgJ2_OO8Rt3hPbQSDao0OXQV_n6z_s" /><link href="//fonts.googleapis.com/css?family=Merriweather" rel="stylesheet" type="text/css"><link href="https://www.schoolofhaskell.com/recent-content/feed" type="application/rss+xml" rel="alternate" title="Recently published content">
<link rel="stylesheet" href="https://www.schoolofhaskell.com/static/combined/UlwEHVcM.css"><style>.social{margin-right:1em}h1{font-family:Merriweather !important}article{font-family:Merriweather !important}article li{font-family:Merriweather !important;line-height:1.6em}h1,h2,h3,h4,h4,h5{font-family:Merriweather !important}.editor p{font-family:Frutiger, "Frutiger Linotype", Univers, Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans Condensed", "Liberation Sans", "Nimbus Sans L", Tahoma, Geneva, "Helvetica Neue", Helvetica, Arial, sans-serif}.article-footer{border-top:1px solid #ddd;padding-top:1em;margin-top:1em}body{font-size:16px !important}.navbar .navbar-inner{background:#3c3f41}.navbar .brand{font-size:14px}.navbar .brand img{width:6em}.navbar .icon-wrench{margin:0 -0.5em 0 -0.5em;padding:0 1em 0 1em;height:20px}.navbar-inverse .nav .active a{background:#333638}.navbar-inverse .nav > li > a{color:#a7a7a7
}.navbar-inverse .btn-navbar{background:#333638}.navbar-inverse .nav > li a:hover,.navbar-inverse .btn{background:#333537 !important}@media (max-width: 979px) {.icon-wrench{padding-left:1em !important}}.breadcrumb{border-top-left-radius:0;border-top-right-radius:0}h1{margin-top:20px}.breadcrumb-container + .main-content h1{margin-top:0}.footer{padding:30px 0;margin-top:70px;border-top:1px solid #e5e5e5;background-color:#f5f5f5}.footer ul.footer-menu{list-style-type:none}.footer ul.footer-menu li{display:inline-block}.footer ul.footer-menu li + li{margin-left:0.5em}.footer ul.footer-menu li + li:before{margin-right:0.5em;content:"Â·";color:#999}.footer ul.menu li{display:inline-block}.footer ul.menu li + li{margin-left:0.5em}.footer .copyright{margin-left:25px}.main-content{min-height:100%}.gravatar{width:80px;height:80px;border-radius:2px;background:#eee}.empty-gravatar{width:0}.container{font-family:"Segoe UI", Candara, "Bitstream Vera Sans", "DejaVu Sans", "Bitstream Vera Sans", "Trebuchet MS", Verdana, "Verdana Ref", sans-serif}.container h1,.container h2,.container h4,.container h4,.container h5{font-family:"Segoe UI", Candara, "Bitstream Vera Sans", "DejaVu Sans", "Bitstream Vera Sans", "Trebuchet MS", Verdana, "Verdana Ref", sans-serif}article{font-family:Merriweather !important}article h1{font-family:Merriweather !important}article li{font-family:Merriweather !important;line-height:1.6em}article li + li{margin-top:0.5em}article div.code{background:#f9f9f9;border:1px solid #d1d1d1;position:relative;border-radius:0.2em;margin:0.25em 0 0.75em 0;min-height:2.5em}article code{color:#005580;font-size:14px;white-space:pre}article a.hoogle > code{color:#0088cc;font-size:14px;white-space:pre;border:0}article .expand-code{display:none}article pre{overflow:auto;word-wrap:normal}article code.active{display:block;max-height:430px}article h1{font-size:31.5px}article h3{font-size:17.5px}article h4{font-size:14px}article h5,article h6{font-size:11.9px}article p{line-height:1.7em}article h1 code,article h2 code,article h3 code,article h4 code,article h5 code,article h6 code{font-size:inherit !important}article h1 a,article h2 a,article h3 a,article h4 a,article h5 a,article h6 a{color:#444}article h1 a:before,article h2 a:before,article h3 a:before,article h4 a:before,article h5 a:before,article h6 a:before{margin-left:-1.5em;padding-right:0.5em;font-family:fontawesome;content:"\f0c1";font-size:20px;color:#fff}article h1 a:hover,article h2 a:hover,article h3 a:hover,article h4 a:hover,article h5 a:hover,article h6 a:hover{text-decoration:none;color:#0088cc}article h1 a:hover:before,article h2 a:hover:before,article h3 a:hover:before,article h4 a:hover:before,article h5 a:hover:before,article h6 a:hover:before{color:#888}article h2{font-size:24.5px}article .popover{font-family:actor}article .popover h3.popover-title{font-family:actor !important;font-size:1em}article .popover .popover-content{width:15em;font-size:1em}article .controlsRun{display:block;padding:0.5em;text-align:right;background:#f2f2f2}article .controlsRun a.clone{margin-right:1em;font-family:actor;text-decoration:none}article .controlsRun a.clone span{padding-left:0.5em}article .controlsRun a.run,article .controlsRun a.reset,article .controlsRun a.show-code{font-size:16px}article .controlsRun a.run span,article .controlsRun a.reset span,article .controlsRun a.show-code span{display:none}article .controlsRun a.reset{margin-left:0.5em;color:#a2becc}article .controlsRun a.reset{display:none}article .controlsRun a.show-code{margin-right:0.75em}article .controlsRun a.run:hover,article .controlsRun a.show-code:hover{text-decoration:none}article .controlsRun a.show-code.active{color:#DC0D0D}article .controlsRun a[disabled]{color:#a2becc;cursor:default}article .collapse-area .collapse-header{background:#0088cc;color:#fff;padding:0.3em;cursor:pointer}article .collapse-area .hidden-toggle:before{content:"\f0d7";font-family:fontawesome;margin-right:0.5em;margin-left:0.25em}article .collapse-area .collapsed-files{overflow:auto;height:auto}article .collapse-area.collapse-disabled{display:none}article .collapse-area.collapse-area-off .collapsed-files{height:0px;overflow:hidden}article .collapse-area.collapse-area-off .hidden-toggle:before{content:"\f0da"}article .snippet-stdio .stdout{margin:0.5em;padding-right:2em;position:relative;word-wrap:break-word}article .snippet-stdio .stdin{-webkit-box-shadow:none;-moz-box-shadow:none;box-shadow:none;-webkit-transition:none;-moz-transition:none;-o-transition:none;transition:none;padding:0;margin:0}article .hoogle-results{margin:0.25em}article .hoogle-results .hoogle-inner{background:#fff;padding:0.5em;border-radius:3px;border:1px solid #ddd}article .hoogle-results .hoogle-inner .close-link{position:relative;float:right;margin-top:-0.5em;margin-right:-0.5em}article .snippet-output-errors{margin:1em 0.5em 0.5em 0.5em;position:relative}article .snippet-output-errors ul{list-style-type:none;margin:0;position:relative}article .snippet-output-errors pre{border:0;border-radius:0;padding:0.25em;margin:0;background:inherit;color:inherit}article .snippet-output-errors .close-link{color:inherit;background:inherit}article .snippet-editors{z-index:0;padding:0.25em}article .close-link{padding:0.5em;background:#eaeaea;border-bottom-left-radius:0.2em;border-top-right-radius:0.2em;position:absolute;top:0;right:0}article .close-link:hover{text-decoration:none}article .snippet-title{padding:0.5em 0 0 0.5em}article .snippet-title .snippet-icon{font-family:FontAwesome;display:inline-block;margin-right:0.5em}article .fullModuleCode + div .snippet-title{margin-top:0.5em;border-top:1px solid #ccc;padding-top:0.5em}article .CodeMirror{height:auto;min-height:1em;line-height:1.5em;background:transparent;font-size:14px !important}article .CodeMirror .highlighted{background:rgba(250, 210, 0, 0.45) !important}article .CodeMirror-widget{margin-left:2em;line-height:1.8}article .CodeMirror.collapsed{height:10em !important}article .editor .expander{text-align:center;display:block;padding:0.5em;text-decoration:none;border-bottom-left-radius:2px;border-bottom-right-radius:2px}article .editor .expander .ellipsis{background:white;border:1px solid #ccc;padding:0 0.5em;height:1em;line-height:0.5em;display:inline-block;color:#555;cursor:pointer}article .editor .expander .ellipsis:hover{background:#ddd;color:#333}article .web-runner{margin:0.5em;padding:0.5em;border:1px solid #ccc;border-radius:3px;background:#f5f5f5}article .web-runner iframe{border:0;margin-top:0.5em;margin-bottom:0;background:white}article .web-runner .controls i{cursor:pointer;color:#0088cc}article .web-runner .controls i:hover{color:#222}article .web-runner .controls i + i{margin-left:0.5em}article .web-runner .controls .icon-remove{float:right}article .hidden{display:block;visibility:visible}article .controlsShowHide{margin-bottom:0.5em}.tutorial-body{float:left !important}.tutorial-nav{float:right !important}@media (max-width: 979px) {.related-content{float:right}.author-name{display:block;margin-left:20px !important;padding-left:5px;margin-top:5px}article h1 a:hover:before,article h2 a:hover:before,article h3 a:hover:before,article h4 a:hover:before,article h5 a:hover:before,article h6 a:hover:before{color:#fff}.tutorial-nav{float:none !important;width:auto !important}.tutorial-body{float:none !important;width:auto !important}}@media (min-width: 980px) and (max-width: 1199px) {.navbar-search{display:none}.tutorial-nav{width:200px}.tutorial-body{width:720px}}#accountPage h1{margin:20px 0 0 0}#accountPage h2{font-size:20px}.group-contents .span8{float:left}.group-contents .span4{float:right}.container > .alert-block{margin-top:1em}.alert{color:#aa874a
}.social{margin-bottom:.8em;display:block}.social a{text-decoration:none}.social i{font-size:1.1em;color:#fff;padding:0.25em;border-radius:0.25em;width:1em;display:inline-block;text-align:center}.social i.icon-twitter{background:#0088cc}.social i.icon-facebook{background:#3b5998
  }.social i.icon-google-plus{background:#dd4b39
  }.well pre{background:#fcfcfc}.well h2{margin-top:0}code{color:#005580;font-size:14px;white-space:pre}</style><!--[if lt IE 8]><link rel="stylesheet" href="https://www.schoolofhaskell.com/static/design/css/ie7.css?etag=TSMl9x1V"><![endif]--><!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]--></head><body class="not-logged-in" itemscope itemtype="http://schema.org/Product"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-H62P" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-H62P');</script><div class="navbar navbar-inverse navbar-static-top"><div class="navbar-inner"><div class="container"><a class="btn btn-navbar" type="button" data-toggle="collapse" data-target=".nav-collapse"><span class="icon-bar"></span>
<span class="icon-bar"></span>
<span class="icon-bar"></span>
</a>
<a class="brand" href="/"><img src="/static/img/haskell-logo-wide.png" title="School of Haskell">
</a>
<div class="nav-collapse collapse"><ul class="nav"><li><a href="https://www.schoolofhaskell.com/">School</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user">Users</a>
</li>
</ul>
<form class="navbar-search pull-left" action="https://www.schoolofhaskell.com/search"><input class="search-query" type="text" placeholder="Search" name="search">
</form>
</div>
</div>
</div>
</div>
<div class="container breadcrumb-container"><div class="row"><div class="span12"><ul class="breadcrumb"><li><a href="https://www.schoolofhaskell.com/user/ivazler">Ivan Vazler</a>
<span class="divider">/</span>
</li>
<li><a href="https://www.schoolofhaskell.com/user/ivazler/linguistic">M-words in Linguistics</a>
</li>
</ul>
</div>
</div>
</div>
<div class="container main-content"><div class="row"><div class="span12"><h1 itemprop="name">M-words in Linguistics</h1>
</div>
</div>
<div class="row"><div class="span7 meta"><p><span class="date">18 Mar 2015</span>
<span class="author"><a href="https://www.schoolofhaskell.com/user/ivazler">Ivan Vazler</a>
</span>
<span class="view-edit-link pull-right"><a class="view-source-link" href="https://www.schoolofhaskell.com/tutorial-raw/14491/5c73e99918df2b90921bfbb70d6971d93e152d3a">View Markdown source</a>
</span>
</p>
<p class="tags"></p>
</div>
</div>
<div class="row"><div class="span7 meta"><span class="sociallinksunicode social">
<a href="https://twitter.com/home?status=$url$" target="_blank"><i class="icon-twitter"></i></a>&nbsp;
<a href="http://www.facebook.com/sharer/sharer.php?u=$url$" target="_blank"><i class="icon-facebook"></i></a>&nbsp;
<a href="https://plus.google.com/share?url=$url$" target="_blank"><i class="icon-google-plus"></i></a></span>
</div>
</div>
<p class="alert">As of March 2020, School of Haskell has been switched to read-only mode.</p>
<div class="row" itemprop="desc"><div class="span4 tutorial-nav"><div class="related-content"><ul class="nav nav-tabs nav-stacked"><li><script>reddit_target='fpcomplete'</script>
<script src="https://redditstatic.s3.amazonaws.com/button/button1.js"></script>
</li>
<li><a href="https://www.schoolofhaskell.com/user/ivazler/primjer">Previous content: Primjer</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user/ivazler">See all content by Ivan Vazler</a>
</li>
</ul>

</div>
<div class="aside"><h3>Sections</h3>
<ul><li><a href="#an-introduction-to-formal-analysis-of-the-truth-of-a-sentence">An introduction to formal analysis of the truth of a sentence</a><ul><li><a href="#example-1">Example 1</a><ul><li><a href="#example-1-with-integer-alphabet">Example 1 with integer alphabet</a></li></ul></li><li><a href="#example-2">Example 2</a></li><li><a href="#example-3">Example 3</a></li><li><a href="#example-4">Example 4</a></li><li><a href="#example-5">Example 5</a></li><li><a href="#example-6">Example 6</a></li><li><a href="#example-7">Example 7</a></li><li><a href="#the-rules-of-inference-and-tautologies">The rules of inference and tautologies</a></li><li><a href="#appendix">Appendix</a><ul><li><a href="#operator-tables">Operator tables</a></li><li><a href="#example">Example</a></li><li><a href="#integer-type-example">Integer type example</a></li><li><a href="#expression-calculator">Expression calculator</a></li></ul></li></ul></li></ul></div>
</div>
<div class="span8 tutorial-body" data-environment="def">
<article><h1 id="an-introduction-to-formal-analysis-of-the-truth-of-a-sentence"><a href="#an-introduction-to-formal-analysis-of-the-truth-of-a-sentence">An introduction to formal analysis of the truth of a sentence</a></h1><p>In the scripts below users can change parts of the program.
Places where changes can be made are denoted by &quot;&lt;-- CHANGE&quot;.</p><p>When setting alphabet:</p><ul><li>users can give any list as an alphabet, eg. <i>([4,7,2,157]::[Int])</i> or <i>['a'..'z']</i>. The type <i>::[Int]</i> is necessary to prevent ambiguity (the same list could be a list of type Float, Double,...).</li><li>the order of elements in the list gives the ordering of letters in the alphabet</li><li>Char type alphabet assumes all letters are lowercase; uppercase letters represent two consecutive identical lowercase ones</li><li>when using non-Char type alphabet the consecutive letters in output will be separated with the symbol &quot;-&quot;</li></ul><p>When setting words:</p><ul><li>make sure the words contain an even number of letters</li><li>make sure the words contain only letters from the alphabet, Eg. if the alphabet is <i>abc=lista2abeceda ([4,7,2,157]::[Int])</i> then a word from it could be <i>x=lista2rijec ([4,4,2,157,4,2]::[Int])</i></li></ul><h2 id="example-1"><a href="#example-1">Example 1</a></h2><p>For an alphabet <i>{a, b, c, d, e, f, g}</i>, and an order <i>a &lt; b &lt; c &lt; d &lt; e &lt; f &lt; g</i>  we can conclude:</p><ul><li>the starting symbol is <i>a</i>, the ending symbol is <i>g</i>, while the center of the alphabet is <i>d</i>;</li><li>the base consists of 49 atoms: <i>{aa, ab, ac,..., ag, ba, bb, bc,..., bg,...,ga,gb,..., gg}</i>;</li><li>the M-word  <i>x = abbcdddc = aBcDdc</i> is the concatenation of 4 atoms: <i>x = ab Â· bc Â· dd Â· dc</i>;</li><li>dual word of <i>x</i> is <i>x'=gffeddde</i>;</li><li>starting and ending symbols of <i>x</i> are <i>l(x)= a</i> and <i>r(x)=c</i>,  and of its dual are <i>l'(x)= g</i> and <i>r'(x) = e</i>;</li><li>shell: <i>q(x) = ac</i>;</li><li>the length of <i>x</i> is given by <i>Î»(abbcdddc) = -2</i>;</li><li>compression: as <i>Î»(ac) = -2</i>, it follows <i>Î»(abbcdddc)= Î»(ac)</i>, so <i>x = abbcdddc = ac</i>;</li><li>infimum and supremum: <i>d â f = d,    f â g = g,    l'(x) â r'(x) = e</i>.</li></ul><pre><code class="active haskell">{-# START_FILE Linguistic2.hs #-}
-- show
-- /show
{-# LANGUAGE UndecidableInstances, FlexibleInstances, OverlappingInstances, IncoherentInstances #-}
module Linguistic2 where

import           Data.Char  (chr, isLower, isUpper, ord, toLower, toUpper)
import           Data.List  (elemIndex, nub)
import           Data.Maybe (fromJust)

-- alphabet type definition and constructors
data Slovo a = Slovo a deriving (Eq, Show)
data Abeceda a = Abeceda {unAbeceda :: [Slovo a]} deriving (Eq, Show)
type Rijec a = [Slovo a]

-- |for a list the function constructs the alphabet containing unique elements of the list
lista2abeceda :: Eq a =&gt; [a] -&gt; Abeceda a
lista2abeceda xs=Abeceda [Slovo x|x&lt;-nub xs]

-- |for 2 Enum types (like Char) the function constructs the alphabet from first to second one
enum2abeceda :: (Eq a, Enum a) =&gt; a -&gt; a -&gt; Abeceda a
enum2abeceda a z=lista2abeceda [a..z]

-- |for a list the function constructs the word containing letters in the list
lista2rijec :: (Show a,Eq a) =&gt; [a] -&gt; Rijec a
lista2rijec xs| even (length xs)= [Slovo x|x&lt;-xs]
              | otherwise= error(&quot;The word &quot;++show xs++&quot; doesn't have an even number of letters.&quot;)

-- |for a word the function returns the list of letters in the word
rijec2lista :: Eq a =&gt; Rijec a -&gt; [a]
rijec2lista xs= [x|Slovo x&lt;-xs]

elemAbc :: Eq a =&gt; Slovo a -&gt; Abeceda a -&gt; Bool
elemAbc s (Abeceda a) = elem s a

elemIndexAbc :: Eq a =&gt; Slovo a -&gt; Abeceda a -&gt; Maybe Int
elemIndexAbc s (Abeceda a) = elemIndex s a

sup :: Eq a =&gt; Abeceda a -&gt; Slovo a -&gt; Slovo a -&gt; Slovo a
sup a x y| x `elemIndexAbc` a==Nothing || y `elemIndexAbc` a==Nothing = error(&quot;Letter is not from the alphabet.&quot;)
         | fromJust (x `elemIndexAbc` a) &gt; fromJust(y `elemIndexAbc` a) = x
         | otherwise = y

inf :: Eq a =&gt; Abeceda a -&gt; Slovo a -&gt; Slovo a -&gt; Slovo a
inf a x y| x `elemIndexAbc` a==Nothing || y `elemIndexAbc` a==Nothing = error(&quot;Letter is not from the alphabet.&quot;)
         | fromJust (x `elemIndexAbc` a) &lt; fromJust(y `elemIndexAbc` a) = x
         | otherwise = y

-- |function converting two consecutive lowercase letters to an uppercase letter
zapisu :: String-&gt;String
zapisu []=[]
zapisu [x]=[x]
zapisu (x:y:xs)|isLower x &amp;&amp; x==y = toUpper x:zapisu xs
               |otherwise=x:zapisu (y:xs)

-- |function converting uppercase letter to two consecutive lowercase letters
zapisl :: String-&gt;String
zapisl []=[]
zapisl (x:xs)|isUpper x =x':x':zapisl xs
             |otherwise =x:zapisl xs
             where x'=toLower x

-- string output of a word
class Show a =&gt; Ispisiv a where
    ispis :: Show a =&gt; Rijec a -&gt; String
    ispis []=[]
    ispis [Slovo x]=show x
    ispis (Slovo x:xs)=show x++&quot;-&quot;++ispis xs

instance Show a =&gt; Ispisiv a
instance Ispisiv Char where
    ispis=zapisu.ispis'

ispis' :: Rijec Char -&gt; String
ispis' []=[]
ispis' [Slovo x]=[x]
ispis' (Slovo x:xs)=x:ispis' xs

-- functions returning left and right letters of a word
l :: [Slovo a] -&gt; Slovo a
l = head
d :: [Slovo a] -&gt; Slovo a
d = last

-- |function returning a dual of a letter in an alphabet
dual :: Eq a =&gt; Abeceda a -&gt; Slovo a -&gt; Slovo a
dual (Abeceda []) s = error(&quot;Nema duala - slovo nije u abecedi.&quot;)
dual (Abeceda [c]) s | s==c = c
                     | otherwise = error(&quot;No dual - Letter is not from the alphabet.&quot;)
dual (Abeceda cs) s | s==lijevi = desni
                    | s==desni = lijevi
                    | otherwise = dual (Abeceda (tail (init cs))) s
                     where lijevi= l cs
                           desni= d cs

-- functions returning duals of left/right letters of a word
l' :: Eq a =&gt; Abeceda a -&gt; [Slovo a] -&gt; Slovo a
l' a= (dual a).l
d' :: Eq a =&gt; Abeceda a -&gt; [Slovo a] -&gt; Slovo a
d' a= (dual a).d

ljuska :: [Slovo a]-&gt;[Slovo a]
ljuska xs=[l xs,d xs]


-- |distance between letters in an alphabet
dd :: Eq a =&gt; Abeceda a -&gt; Slovo a -&gt; Slovo a -&gt; Int
dd a x y| m==Nothing || n==Nothing = error(&quot;Cannot calculate distance. Letter is not from the alphabet.&quot;)
        | otherwise = abs (fromJust m-fromJust n)
  where m=x `elemIndexAbc` a
        n=y `elemIndexAbc` a

-- |word length
duljina :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Int
duljina a []=0
duljina a [c]=0
duljina a (c1:c2:cs)= - dd a c1 c2 - duljina a (c2:cs)

-- word shortening
krati1 :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a    -- function shortening a 4 letter word
krati1 a [p,r,s,t] | duljina a [p,r,s,t]==duljina a [p,t] = [p,t]
                 | otherwise = [p,r,s,t]
krati1 _ cs = cs

krati2 :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a     -- function shortening a 4 letter sub-word
krati2 _ [] = []
krati2 a(c:cs) | length kr==2 = kr ++ drop 3 cs
               | otherwise = c : krati2 a cs
               where kr = ((krati1 a).(take 4)) (c:cs)

krati :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a    -- function fully shortening a word
krati a cs | cs/=kr = krati a kr
           | otherwise = cs
           where kr = krati2 a cs

-- symmetries
opD :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opD _ []=[]
opD a (s:t:ys)=dual a s:dual a t:opD a ys

opE :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opE _ []=[]
opE a xs=t:s:opE a ys
        where n=length xs
              t=d xs
              s=xs !! (n-2)
              ys=take (n-2) xs
--opE a (s:t:ys)=opE a ys++[t,s]    --kraÄe, ali nije po formuli iz teksta

opF :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opF a=(opD a).(opE a)

-- permutations
opI :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opI a xs=l xs:xs++[d xs]

-- |negation operator
opK :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opK a xs=l' a xs:xs++[d' a xs]

opG :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opG a xs=d xs:xs++[l xs]

opH :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opH a xs=d' a xs:xs++[l' a xs]

-- serial and parallel conjecture operators
opS :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a -&gt; Rijec a
opS a xs ys = inf a (l xs) (l ys) : inf a (l xs) (l ys) : xs ++
              [sup a (d xs) (l ys),inf a (d xs) (l ys)] ++ ys ++
              [sup a (d xs) (d ys),sup a (d xs) (d ys)]

opP :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a -&gt; Rijec a
opP a xs ys = sup a (l xs) (l ys) : sup a (l xs) (l ys) : xs ++
              [inf a (d xs) (l ys),sup a (d xs) (l ys)] ++ ys ++
              [inf a (d xs) (d ys),inf a (d xs) (d ys)]

-- |partitions
particija :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Char
particija a xs | lijevi&gt;=*lijevi' &amp;&amp; desni&lt;=*desni' &amp;&amp; lijevi&gt;*desni ='T'
               | lijevi&lt;=*lijevi' &amp;&amp; desni&lt;=*desni' &amp;&amp; not (lijevi==lijevi' || desni==desni') ='A'
               | lijevi==lijevi' &amp;&amp; desni==desni' ='0'
               | lijevi&gt;=*lijevi' &amp;&amp; desni&gt;=*desni' &amp;&amp; not (lijevi==lijevi' || desni==desni')  ='Z'
               | lijevi&lt;=*lijevi' &amp;&amp; desni&gt;=*desni' &amp;&amp; lijevi&lt;*desni  ='F'
         where lijevi=l xs
               desni=d xs
               lijevi'=l' a xs
               desni'=d' a xs
               x &gt;* y| m==Nothing || n==Nothing =error(&quot;Letter not in alphabet.&quot;)
                     | otherwise = (fromJust m) &gt; (fromJust n)
                      where m=x `elemIndexAbc` a
                            n=y `elemIndexAbc` a
               x &gt;=* y = x &gt;* y || x==y
               x &lt;* y = not (x &gt;=* y)
               x &lt;=* y = not (x &gt;* y)

-- implications
pimp :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a -&gt; Rijec a
pimp a x y=(opK a x) `opP'` y
    where opP'=opP a

simp :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a -&gt; Rijec a
simp a x y=(opK a x) `opS'` y
    where opS'=opS a

-- equivalencies
pekv :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a -&gt; Rijec a
pekv a x y=(x `pimp'` y) `opS'` (y `pimp'` x)
    where opS'=opS a
          pimp'=pimp a

sekv :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a -&gt; Rijec a
sekv a x y=(x `simp'` y) `opP'` (y `simp'` x)
    where opP'=opP a
          simp'=simp a

-- |tautologies and rules
taut :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt;Rijec a -&gt; Rijec a -&gt; [(String,Char)]
taut a x y z= zip
  [&quot;1.ZAKON ISKLJUCENJA TRECEG&quot;,
  &quot;2.DUAL ZAKONA ISKLJUCENJA TRECEG&quot;,
  &quot;3.TRANZITIVNOST IMPLIKACIJE&quot;,
  &quot;4.DUAL TRANZITIVNOSTI IMPLIKACIJE&quot;,
  &quot;5.ZAKON DVOSTRUKE NEGACIJE&quot;,
  &quot;6.ZAKON KONTRAPOZICIJE&quot;,
  &quot;7.DUAL ZAKONA KONTRAPOZICIJE&quot;,
  &quot;8.ZAKON APSORPCIJE ILI UPIJANJA&quot;,
  &quot;9.DUAL ZAKONA APSORPCIJE ILI UPIJANJA&quot;,
  &quot;10.MODUS PONENDO PONENS&quot;,
  &quot;11.DUAL MODUSA PONENDO PONENS&quot;,
  &quot;12.MODUS TOLENDO TOLLENS&quot;,
  &quot;13.DOKAZ NABRAJANJEM&quot;,
  &quot;14.DOVODJENJE DO PROTURJECJA&quot;]
  (map (particija a) [
    x `opP'` (neg x),
    x `opS'` (neg x),
    ((x `pimp'` y) `opS'` (y `pimp'` z)) `pimp'` (x `pimp'` z),
    ((x `simp'` y) `opP'` (y `simp'` z)) `simp'` (x `simp'` z),
    (neg (neg x)) `pekv'` x,
    (x `pimp'` y) `pimp'` ((neg y) `pimp'` (neg x)),
    (x `simp'` y) `simp'` ((neg y) `simp'` (neg x)),
    (x `opP'` (y `opP'` x)) `pimp'` x,
    (x `opS'` (y `opS'` x)) `simp'` x,
    (x `opS'` (x `pimp'` y)) `pimp'` y,
    (x `opP'` (x `simp'` y)) `simp'` y,
    ((neg x) `opS'` ((neg x) `pimp'` (neg y))) `pimp'` (neg y),
    ((x `pimp'` z) `opS'` (y `pimp'` z)) `pimp'` ((x `opP'` y) `pimp'` z),
    ((x `pimp'` y) `opS'` (x `pimp'` (neg y))) `pimp'` (neg x)
    ]
  )
  where opP'=opP a
        opS'=opS a
        pimp'=pimp a
        simp'=simp a
        pekv'=pekv a
        sekv'=sekv a
        neg=opK a
        
{-# START_FILE Main.hs #-}
module Main where
import Linguistic2

main :: IO ()

-- show Alphabet
main=do let {abc=lista2abeceda &quot;abcdefg&quot;}         -- &lt;-- CHANGE
-- /show


-- show Word x
        let {x=lista2rijec.zapisl $ &quot;aBcDdc&quot;}     -- &lt;-- CHANGE
-- In the previous line the part '.zapisl $' is added only for Char type words to convert uppercase letters to lowercase.
-- /show


-- show Dual
        putStrLn (&quot;x'= &quot;++ ispis (map (dual abc) x))
-- /show


-- show Starting and ending symbols
        putStr (&quot;l(x)= &quot;++ ispis [l x]++&quot;, &quot;)
        putStr (&quot;r(x)= &quot;++ ispis [d x]++&quot;, &quot;)
        putStr (&quot;l'(x)= &quot;++ ispis [l' abc x]++&quot;, &quot;)
        putStrLn (&quot;r'(x)= &quot;++ ispis [d' abc x])
-- /show


-- show Shell
        putStrLn (&quot;q(x)= &quot;++ ispis (ljuska x))
-- /show


-- show Length
        putStrLn (&quot;Î»(x)= &quot;++ show (duljina abc x))
-- /show


-- show Compression
        putStrLn (ispis x ++&quot; =zip= &quot;++ ispis (krati abc x))
-- /show


-- show Infimum and supremum
        putStrLn (&quot;inf(l'(x),r'(x))= &quot;++ ispis [inf abc (l' abc x) (d' abc x)])
        putStrLn (&quot;sup(l'(x),r'(x))= &quot;++ ispis [sup abc (l' abc x) (d' abc x)])
-- /show</code></pre><h3 id="example-1-with-integer-alphabet"><a href="#example-1-with-integer-alphabet">Example 1 with integer alphabet</a></h3><pre><code class="active haskell">{-# START_FILE Linguistic2.hs #-}
-- show
-- /show
{-# LANGUAGE UndecidableInstances, FlexibleInstances, OverlappingInstances, IncoherentInstances #-}
module Linguistic2 where

import           Data.Char  (chr, isLower, isUpper, ord, toLower, toUpper)
import           Data.List  (elemIndex, nub)
import           Data.Maybe (fromJust)

-- alphabet type definition and constructors
data Slovo a = Slovo a deriving (Eq, Show)
data Abeceda a = Abeceda {unAbeceda :: [Slovo a]} deriving (Eq, Show)
type Rijec a = [Slovo a]

-- |for a list the function constructs the alphabet containing unique elements of the list
lista2abeceda :: Eq a =&gt; [a] -&gt; Abeceda a
lista2abeceda xs=Abeceda [Slovo x|x&lt;-nub xs]

-- |for 2 Enum types (like Char) the function constructs the alphabet from first to second one
enum2abeceda :: (Eq a, Enum a) =&gt; a -&gt; a -&gt; Abeceda a
enum2abeceda a z=lista2abeceda [a..z]

-- |for a list the function constructs the word containing letters in the list
lista2rijec :: (Show a,Eq a) =&gt; [a] -&gt; Rijec a
lista2rijec xs| even (length xs)= [Slovo x|x&lt;-xs]
              | otherwise= error(&quot;The word &quot;++show xs++&quot; doesn't have an even number of letters.&quot;)

-- |for a word the function returns the list of letters in the word
rijec2lista :: Eq a =&gt; Rijec a -&gt; [a]
rijec2lista xs= [x|Slovo x&lt;-xs]

elemAbc :: Eq a =&gt; Slovo a -&gt; Abeceda a -&gt; Bool
elemAbc s (Abeceda a) = elem s a

elemIndexAbc :: Eq a =&gt; Slovo a -&gt; Abeceda a -&gt; Maybe Int
elemIndexAbc s (Abeceda a) = elemIndex s a

sup :: Eq a =&gt; Abeceda a -&gt; Slovo a -&gt; Slovo a -&gt; Slovo a
sup a x y| x `elemIndexAbc` a==Nothing || y `elemIndexAbc` a==Nothing = error(&quot;Letter is not from the alphabet.&quot;)
         | fromJust (x `elemIndexAbc` a) &gt; fromJust(y `elemIndexAbc` a) = x
         | otherwise = y

inf :: Eq a =&gt; Abeceda a -&gt; Slovo a -&gt; Slovo a -&gt; Slovo a
inf a x y| x `elemIndexAbc` a==Nothing || y `elemIndexAbc` a==Nothing = error(&quot;Letter is not from the alphabet.&quot;)
         | fromJust (x `elemIndexAbc` a) &lt; fromJust(y `elemIndexAbc` a) = x
         | otherwise = y

-- |function converting two consecutive lowercase letters to an uppercase letter
zapisu :: String-&gt;String
zapisu []=[]
zapisu [x]=[x]
zapisu (x:y:xs)|isLower x &amp;&amp; x==y = toUpper x:zapisu xs
               |otherwise=x:zapisu (y:xs)

-- |function converting uppercase letter to two consecutive lowercase letters
zapisl :: String-&gt;String
zapisl []=[]
zapisl (x:xs)|isUpper x =x':x':zapisl xs
             |otherwise =x:zapisl xs
             where x'=toLower x

-- string output of a word
class Show a =&gt; Ispisiv a where
    ispis :: Show a =&gt; Rijec a -&gt; String
    ispis []=[]
    ispis [Slovo x]=show x
    ispis (Slovo x:xs)=show x++&quot;-&quot;++ispis xs

instance Show a =&gt; Ispisiv a
instance Ispisiv Char where
    ispis=zapisu.ispis'

ispis' :: Rijec Char -&gt; String
ispis' []=[]
ispis' [Slovo x]=[x]
ispis' (Slovo x:xs)=x:ispis' xs

-- functions returning left and right letters of a word
l :: [Slovo a] -&gt; Slovo a
l = head
d :: [Slovo a] -&gt; Slovo a
d = last

-- |function returning a dual of a letter in an alphabet
dual :: Eq a =&gt; Abeceda a -&gt; Slovo a -&gt; Slovo a
dual (Abeceda []) s = error(&quot;Nema duala - slovo nije u abecedi.&quot;)
dual (Abeceda [c]) s | s==c = c
                     | otherwise = error(&quot;No dual - Letter is not from the alphabet.&quot;)
dual (Abeceda cs) s | s==lijevi = desni
                    | s==desni = lijevi
                    | otherwise = dual (Abeceda (tail (init cs))) s
                     where lijevi= l cs
                           desni= d cs

-- functions returning duals of left/right letters of a word
l' :: Eq a =&gt; Abeceda a -&gt; [Slovo a] -&gt; Slovo a
l' a= (dual a).l
d' :: Eq a =&gt; Abeceda a -&gt; [Slovo a] -&gt; Slovo a
d' a= (dual a).d

ljuska :: [Slovo a]-&gt;[Slovo a]
ljuska xs=[l xs,d xs]


-- |distance between letters in an alphabet
dd :: Eq a =&gt; Abeceda a -&gt; Slovo a -&gt; Slovo a -&gt; Int
dd a x y| m==Nothing || n==Nothing = error(&quot;Cannot calculate distance. Letter is not from the alphabet.&quot;)
        | otherwise = abs (fromJust m-fromJust n)
  where m=x `elemIndexAbc` a
        n=y `elemIndexAbc` a

-- |word length
duljina :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Int
duljina a []=0
duljina a [c]=0
duljina a (c1:c2:cs)= - dd a c1 c2 - duljina a (c2:cs)

-- word shortening
krati1 :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a    -- function shortening a 4 letter word
krati1 a [p,r,s,t] | duljina a [p,r,s,t]==duljina a [p,t] = [p,t]
                 | otherwise = [p,r,s,t]
krati1 _ cs = cs

krati2 :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a     -- function shortening a 4 letter sub-word
krati2 _ [] = []
krati2 a(c:cs) | length kr==2 = kr ++ drop 3 cs
               | otherwise = c : krati2 a cs
               where kr = ((krati1 a).(take 4)) (c:cs)

krati :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a    -- function fully shortening a word
krati a cs | cs/=kr = krati a kr
           | otherwise = cs
           where kr = krati2 a cs

-- symmetries
opD :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opD _ []=[]
opD a (s:t:ys)=dual a s:dual a t:opD a ys

opE :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opE _ []=[]
opE a xs=t:s:opE a ys
        where n=length xs
              t=d xs
              s=xs !! (n-2)
              ys=take (n-2) xs
--opE a (s:t:ys)=opE a ys++[t,s]    --kraÄe, ali nije po formuli iz teksta

opF :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opF a=(opD a).(opE a)

-- permutations
opI :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opI a xs=l xs:xs++[d xs]

-- |negation operator
opK :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opK a xs=l' a xs:xs++[d' a xs]

opG :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opG a xs=d xs:xs++[l xs]

opH :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opH a xs=d' a xs:xs++[l' a xs]

-- serial and parallel conjecture operators
opS :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a -&gt; Rijec a
opS a xs ys = inf a (l xs) (l ys) : inf a (l xs) (l ys) : xs ++
              [sup a (d xs) (l ys),inf a (d xs) (l ys)] ++ ys ++
              [sup a (d xs) (d ys),sup a (d xs) (d ys)]

opP :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a -&gt; Rijec a
opP a xs ys = sup a (l xs) (l ys) : sup a (l xs) (l ys) : xs ++
              [inf a (d xs) (l ys),sup a (d xs) (l ys)] ++ ys ++
              [inf a (d xs) (d ys),inf a (d xs) (d ys)]

-- |partitions
particija :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Char
particija a xs | lijevi&gt;=*lijevi' &amp;&amp; desni&lt;=*desni' &amp;&amp; lijevi&gt;*desni ='T'
               | lijevi&lt;=*lijevi' &amp;&amp; desni&lt;=*desni' &amp;&amp; not (lijevi==lijevi' || desni==desni') ='A'
               | lijevi==lijevi' &amp;&amp; desni==desni' ='0'
               | lijevi&gt;=*lijevi' &amp;&amp; desni&gt;=*desni' &amp;&amp; not (lijevi==lijevi' || desni==desni')  ='Z'
               | lijevi&lt;=*lijevi' &amp;&amp; desni&gt;=*desni' &amp;&amp; lijevi&lt;*desni  ='F'
         where lijevi=l xs
               desni=d xs
               lijevi'=l' a xs
               desni'=d' a xs
               x &gt;* y| m==Nothing || n==Nothing =error(&quot;Letter not in alphabet.&quot;)
                     | otherwise = (fromJust m) &gt; (fromJust n)
                      where m=x `elemIndexAbc` a
                            n=y `elemIndexAbc` a
               x &gt;=* y = x &gt;* y || x==y
               x &lt;* y = not (x &gt;=* y)
               x &lt;=* y = not (x &gt;* y)

-- implications
pimp :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a -&gt; Rijec a
pimp a x y=(opK a x) `opP'` y
    where opP'=opP a

simp :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a -&gt; Rijec a
simp a x y=(opK a x) `opS'` y
    where opS'=opS a

-- equivalencies
pekv :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a -&gt; Rijec a
pekv a x y=(x `pimp'` y) `opS'` (y `pimp'` x)
    where opS'=opS a
          pimp'=pimp a

sekv :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a -&gt; Rijec a
sekv a x y=(x `simp'` y) `opP'` (y `simp'` x)
    where opP'=opP a
          simp'=simp a

-- |tautologies and rules
taut :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt;Rijec a -&gt; Rijec a -&gt; [(String,Char)]
taut a x y z= zip
  [&quot;1.ZAKON ISKLJUCENJA TRECEG&quot;,
  &quot;2.DUAL ZAKONA ISKLJUCENJA TRECEG&quot;,
  &quot;3.TRANZITIVNOST IMPLIKACIJE&quot;,
  &quot;4.DUAL TRANZITIVNOSTI IMPLIKACIJE&quot;,
  &quot;5.ZAKON DVOSTRUKE NEGACIJE&quot;,
  &quot;6.ZAKON KONTRAPOZICIJE&quot;,
  &quot;7.DUAL ZAKONA KONTRAPOZICIJE&quot;,
  &quot;8.ZAKON APSORPCIJE ILI UPIJANJA&quot;,
  &quot;9.DUAL ZAKONA APSORPCIJE ILI UPIJANJA&quot;,
  &quot;10.MODUS PONENDO PONENS&quot;,
  &quot;11.DUAL MODUSA PONENDO PONENS&quot;,
  &quot;12.MODUS TOLENDO TOLLENS&quot;,
  &quot;13.DOKAZ NABRAJANJEM&quot;,
  &quot;14.DOVODJENJE DO PROTURJECJA&quot;]
  (map (particija a) [
    x `opP'` (neg x),
    x `opS'` (neg x),
    ((x `pimp'` y) `opS'` (y `pimp'` z)) `pimp'` (x `pimp'` z),
    ((x `simp'` y) `opP'` (y `simp'` z)) `simp'` (x `simp'` z),
    (neg (neg x)) `pekv'` x,
    (x `pimp'` y) `pimp'` ((neg y) `pimp'` (neg x)),
    (x `simp'` y) `simp'` ((neg y) `simp'` (neg x)),
    (x `opP'` (y `opP'` x)) `pimp'` x,
    (x `opS'` (y `opS'` x)) `simp'` x,
    (x `opS'` (x `pimp'` y)) `pimp'` y,
    (x `opP'` (x `simp'` y)) `simp'` y,
    ((neg x) `opS'` ((neg x) `pimp'` (neg y))) `pimp'` (neg y),
    ((x `pimp'` z) `opS'` (y `pimp'` z)) `pimp'` ((x `opP'` y) `pimp'` z),
    ((x `pimp'` y) `opS'` (x `pimp'` (neg y))) `pimp'` (neg x)
    ]
  )
  where opP'=opP a
        opS'=opS a
        pimp'=pimp a
        simp'=simp a
        pekv'=pekv a
        sekv'=sekv a
        neg=opK a
        
{-# START_FILE Main.hs #-}
module Main where
import Linguistic2

main :: IO ()

-- show Alphabet
main=do let {abc=lista2abeceda ([4,7,2,157]::[Int])}     -- &lt;-- CHANGE
-- /show


-- show Word x
        let {x=lista2rijec ([4,4,2,157,4,2]::[Int])}     -- &lt;-- CHANGE
-- /show


-- show Dual
        putStrLn (&quot;x'= &quot;++ ispis (map (dual abc) x))
-- /show


-- show Starting and ending symbols
        putStr (&quot;l(x)= &quot;++ ispis [l x]++&quot;, &quot;)
        putStr (&quot;r(x)= &quot;++ ispis [d x]++&quot;, &quot;)
        putStr (&quot;l'(x)= &quot;++ ispis [l' abc x]++&quot;, &quot;)
        putStrLn (&quot;r'(x)= &quot;++ ispis [d' abc x])
-- /show


-- show Shell
        putStrLn (&quot;q(x)= &quot;++ ispis (ljuska x))
-- /show


-- show Length
        putStrLn (&quot;Î»(x)= &quot;++ show (duljina abc x))
-- /show


-- show Compression
        putStrLn (ispis x ++&quot; =zip= &quot;++ ispis (krati abc x))
-- /show


-- show Infimum and supremum
        putStrLn (&quot;inf(l'(x),r'(x))= &quot;++ ispis [inf abc (l' abc x) (d' abc x)])
        putStrLn (&quot;sup(l'(x),r'(x))= &quot;++ ispis [sup abc (l' abc x) (d' abc x)])
-- /show</code></pre><h2 id="example-2"><a href="#example-2">Example 2</a></h2><p>To visualize the symmetries, we define an alphabet <i>{â¤, |, â¥}</i>. In the logic algebra these symbols correspond to: truth, uncertainty and falsity, but here their role is to help to visualize that the truth and false symbols are symmetric with respect to the horizontal axis, and the uncertainty symbol with respect to the vertical axis. Operators <b>D, E</b> and <b> F </b> act on M-words over this alphabet as follows:</p><pre><code class="active haskell">{-# START_FILE Linguistic2.hs #-}
-- show
-- /show
{-# LANGUAGE UndecidableInstances, FlexibleInstances, OverlappingInstances, IncoherentInstances #-}
module Linguistic2 where

import           Data.Char  (chr, isLower, isUpper, ord, toLower, toUpper)
import           Data.List  (elemIndex, nub)
import           Data.Maybe (fromJust)

-- alphabet type definition and constructors
data Slovo a = Slovo a deriving (Eq, Show)
data Abeceda a = Abeceda {unAbeceda :: [Slovo a]} deriving (Eq, Show)
type Rijec a = [Slovo a]

-- |for a list the function constructs the alphabet containing unique elements of the list
lista2abeceda :: Eq a =&gt; [a] -&gt; Abeceda a
lista2abeceda xs=Abeceda [Slovo x|x&lt;-nub xs]

-- |for 2 Enum types (like Char) the function constructs the alphabet from first to second one
enum2abeceda :: (Eq a, Enum a) =&gt; a -&gt; a -&gt; Abeceda a
enum2abeceda a z=lista2abeceda [a..z]

-- |for a list the function constructs the word containing letters in the list
lista2rijec :: (Show a,Eq a) =&gt; [a] -&gt; Rijec a
lista2rijec xs| even (length xs)= [Slovo x|x&lt;-xs]
              | otherwise= error(&quot;The word &quot;++show xs++&quot; doesn't have an even number of letters.&quot;)

-- |for a word the function returns the list of letters in the word
rijec2lista :: Eq a =&gt; Rijec a -&gt; [a]
rijec2lista xs= [x|Slovo x&lt;-xs]

elemAbc :: Eq a =&gt; Slovo a -&gt; Abeceda a -&gt; Bool
elemAbc s (Abeceda a) = elem s a

elemIndexAbc :: Eq a =&gt; Slovo a -&gt; Abeceda a -&gt; Maybe Int
elemIndexAbc s (Abeceda a) = elemIndex s a

sup :: Eq a =&gt; Abeceda a -&gt; Slovo a -&gt; Slovo a -&gt; Slovo a
sup a x y| x `elemIndexAbc` a==Nothing || y `elemIndexAbc` a==Nothing = error(&quot;Letter is not from the alphabet.&quot;)
         | fromJust (x `elemIndexAbc` a) &gt; fromJust(y `elemIndexAbc` a) = x
         | otherwise = y

inf :: Eq a =&gt; Abeceda a -&gt; Slovo a -&gt; Slovo a -&gt; Slovo a
inf a x y| x `elemIndexAbc` a==Nothing || y `elemIndexAbc` a==Nothing = error(&quot;Letter is not from the alphabet.&quot;)
         | fromJust (x `elemIndexAbc` a) &lt; fromJust(y `elemIndexAbc` a) = x
         | otherwise = y

-- |function converting two consecutive lowercase letters to an uppercase letter
zapisu :: String-&gt;String
zapisu []=[]
zapisu [x]=[x]
zapisu (x:y:xs)|isLower x &amp;&amp; x==y = toUpper x:zapisu xs
               |otherwise=x:zapisu (y:xs)

-- |function converting uppercase letter to two consecutive lowercase letters
zapisl :: String-&gt;String
zapisl []=[]
zapisl (x:xs)|isUpper x =x':x':zapisl xs
             |otherwise =x:zapisl xs
             where x'=toLower x

-- string output of a word
class Show a =&gt; Ispisiv a where
    ispis :: Show a =&gt; Rijec a -&gt; String
    ispis []=[]
    ispis [Slovo x]=show x
    ispis (Slovo x:xs)=show x++&quot;-&quot;++ispis xs

instance Show a =&gt; Ispisiv a
instance Ispisiv Char where
    ispis=zapisu.ispis'

ispis' :: Rijec Char -&gt; String
ispis' []=[]
ispis' [Slovo x]=[x]
ispis' (Slovo x:xs)=x:ispis' xs

-- functions returning left and right letters of a word
l :: [Slovo a] -&gt; Slovo a
l = head
d :: [Slovo a] -&gt; Slovo a
d = last

-- |function returning a dual of a letter in an alphabet
dual :: Eq a =&gt; Abeceda a -&gt; Slovo a -&gt; Slovo a
dual (Abeceda []) s = error(&quot;Nema duala - slovo nije u abecedi.&quot;)
dual (Abeceda [c]) s | s==c = c
                     | otherwise = error(&quot;No dual - Letter is not from the alphabet.&quot;)
dual (Abeceda cs) s | s==lijevi = desni
                    | s==desni = lijevi
                    | otherwise = dual (Abeceda (tail (init cs))) s
                     where lijevi= l cs
                           desni= d cs

-- functions returning duals of left/right letters of a word
l' :: Eq a =&gt; Abeceda a -&gt; [Slovo a] -&gt; Slovo a
l' a= (dual a).l
d' :: Eq a =&gt; Abeceda a -&gt; [Slovo a] -&gt; Slovo a
d' a= (dual a).d

ljuska :: [Slovo a]-&gt;[Slovo a]
ljuska xs=[l xs,d xs]


-- |distance between letters in an alphabet
dd :: Eq a =&gt; Abeceda a -&gt; Slovo a -&gt; Slovo a -&gt; Int
dd a x y| m==Nothing || n==Nothing = error(&quot;Cannot calculate distance. Letter is not from the alphabet.&quot;)
        | otherwise = abs (fromJust m-fromJust n)
  where m=x `elemIndexAbc` a
        n=y `elemIndexAbc` a

-- |word length
duljina :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Int
duljina a []=0
duljina a [c]=0
duljina a (c1:c2:cs)= - dd a c1 c2 - duljina a (c2:cs)

-- word shortening
krati1 :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a    -- function shortening a 4 letter word
krati1 a [p,r,s,t] | duljina a [p,r,s,t]==duljina a [p,t] = [p,t]
                 | otherwise = [p,r,s,t]
krati1 _ cs = cs

krati2 :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a     -- function shortening a 4 letter sub-word
krati2 _ [] = []
krati2 a(c:cs) | length kr==2 = kr ++ drop 3 cs
               | otherwise = c : krati2 a cs
               where kr = ((krati1 a).(take 4)) (c:cs)

krati :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a    -- function fully shortening a word
krati a cs | cs/=kr = krati a kr
           | otherwise = cs
           where kr = krati2 a cs

-- symmetries
opD :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opD _ []=[]
opD a (s:t:ys)=dual a s:dual a t:opD a ys

opE :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opE _ []=[]
opE a xs=t:s:opE a ys
        where n=length xs
              t=d xs
              s=xs !! (n-2)
              ys=take (n-2) xs
--opE a (s:t:ys)=opE a ys++[t,s]    --kraÄe, ali nije po formuli iz teksta

opF :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opF a=(opD a).(opE a)

-- permutations
opI :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opI a xs=l xs:xs++[d xs]

-- |negation operator
opK :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opK a xs=l' a xs:xs++[d' a xs]

opG :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opG a xs=d xs:xs++[l xs]

opH :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opH a xs=d' a xs:xs++[l' a xs]

-- serial and parallel conjecture operators
opS :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a -&gt; Rijec a
opS a xs ys = inf a (l xs) (l ys) : inf a (l xs) (l ys) : xs ++
              [sup a (d xs) (l ys),inf a (d xs) (l ys)] ++ ys ++
              [sup a (d xs) (d ys),sup a (d xs) (d ys)]

opP :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a -&gt; Rijec a
opP a xs ys = sup a (l xs) (l ys) : sup a (l xs) (l ys) : xs ++
              [inf a (d xs) (l ys),sup a (d xs) (l ys)] ++ ys ++
              [inf a (d xs) (d ys),inf a (d xs) (d ys)]

-- |partitions
particija :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Char
particija a xs | lijevi&gt;=*lijevi' &amp;&amp; desni&lt;=*desni' &amp;&amp; lijevi&gt;*desni ='T'
               | lijevi&lt;=*lijevi' &amp;&amp; desni&lt;=*desni' &amp;&amp; not (lijevi==lijevi' || desni==desni') ='A'
               | lijevi==lijevi' &amp;&amp; desni==desni' ='0'
               | lijevi&gt;=*lijevi' &amp;&amp; desni&gt;=*desni' &amp;&amp; not (lijevi==lijevi' || desni==desni')  ='Z'
               | lijevi&lt;=*lijevi' &amp;&amp; desni&gt;=*desni' &amp;&amp; lijevi&lt;*desni  ='F'
         where lijevi=l xs
               desni=d xs
               lijevi'=l' a xs
               desni'=d' a xs
               x &gt;* y| m==Nothing || n==Nothing =error(&quot;Letter not in alphabet.&quot;)
                     | otherwise = (fromJust m) &gt; (fromJust n)
                      where m=x `elemIndexAbc` a
                            n=y `elemIndexAbc` a
               x &gt;=* y = x &gt;* y || x==y
               x &lt;* y = not (x &gt;=* y)
               x &lt;=* y = not (x &gt;* y)

-- implications
pimp :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a -&gt; Rijec a
pimp a x y=(opK a x) `opP'` y
    where opP'=opP a

simp :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a -&gt; Rijec a
simp a x y=(opK a x) `opS'` y
    where opS'=opS a

-- equivalencies
pekv :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a -&gt; Rijec a
pekv a x y=(x `pimp'` y) `opS'` (y `pimp'` x)
    where opS'=opS a
          pimp'=pimp a

sekv :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a -&gt; Rijec a
sekv a x y=(x `simp'` y) `opP'` (y `simp'` x)
    where opP'=opP a
          simp'=simp a

-- |tautologies and rules
taut :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt;Rijec a -&gt; Rijec a -&gt; [(String,Char)]
taut a x y z= zip
  [&quot;1.ZAKON ISKLJUCENJA TRECEG&quot;,
  &quot;2.DUAL ZAKONA ISKLJUCENJA TRECEG&quot;,
  &quot;3.TRANZITIVNOST IMPLIKACIJE&quot;,
  &quot;4.DUAL TRANZITIVNOSTI IMPLIKACIJE&quot;,
  &quot;5.ZAKON DVOSTRUKE NEGACIJE&quot;,
  &quot;6.ZAKON KONTRAPOZICIJE&quot;,
  &quot;7.DUAL ZAKONA KONTRAPOZICIJE&quot;,
  &quot;8.ZAKON APSORPCIJE ILI UPIJANJA&quot;,
  &quot;9.DUAL ZAKONA APSORPCIJE ILI UPIJANJA&quot;,
  &quot;10.MODUS PONENDO PONENS&quot;,
  &quot;11.DUAL MODUSA PONENDO PONENS&quot;,
  &quot;12.MODUS TOLENDO TOLLENS&quot;,
  &quot;13.DOKAZ NABRAJANJEM&quot;,
  &quot;14.DOVODJENJE DO PROTURJECJA&quot;]
  (map (particija a) [
    x `opP'` (neg x),
    x `opS'` (neg x),
    ((x `pimp'` y) `opS'` (y `pimp'` z)) `pimp'` (x `pimp'` z),
    ((x `simp'` y) `opP'` (y `simp'` z)) `simp'` (x `simp'` z),
    (neg (neg x)) `pekv'` x,
    (x `pimp'` y) `pimp'` ((neg y) `pimp'` (neg x)),
    (x `simp'` y) `simp'` ((neg y) `simp'` (neg x)),
    (x `opP'` (y `opP'` x)) `pimp'` x,
    (x `opS'` (y `opS'` x)) `simp'` x,
    (x `opS'` (x `pimp'` y)) `pimp'` y,
    (x `opP'` (x `simp'` y)) `simp'` y,
    ((neg x) `opS'` ((neg x) `pimp'` (neg y))) `pimp'` (neg y),
    ((x `pimp'` z) `opS'` (y `pimp'` z)) `pimp'` ((x `opP'` y) `pimp'` z),
    ((x `pimp'` y) `opS'` (x `pimp'` (neg y))) `pimp'` (neg x)
    ]
  )
  where opP'=opP a
        opS'=opS a
        pimp'=pimp a
        simp'=simp a
        pekv'=pekv a
        sekv'=sekv a
        neg=opK a
        
{-# START_FILE Main.hs #-}
module Main where
import Linguistic2

main :: IO ()

-- show Alphabet
main=do let {abc=lista2abeceda &quot;â¤|â¥&quot;}         -- &lt;-- CHANGE
-- /show


-- show Words
        let {x=lista2rijec &quot;â¤â¤||â¥â¥||&quot;;
             y=lista2rijec &quot;â¥â¥||â¤â¤||&quot;;        -- &lt;-- CHANGE
             z=lista2rijec &quot;||â¤â¤||â¥â¥&quot;}
-- /show


-- show Symmetry operators D, E and F
        putStrLn (&quot;D(&quot;++ispis x++&quot;)= &quot;++ ispis (opD abc x))
        putStrLn (&quot;E(&quot;++ispis y++&quot;)= &quot;++ ispis (opE abc y))
        putStrLn (&quot;F(&quot;++ispis z++&quot;)= &quot;++ ispis (opF abc z))
-- /show</code></pre><h2 id="example-3"><a href="#example-3">Example 3</a></h2><p>Let the alphabet be the English alphabet <i>{a,... ,z}</i>.
Let <i>x = croatian = croian</i> and  <i>y=language = le</i>.
Unary operators <b>D, E, F, I, K, G, H</b> applied to these words give the following results:</p><pre><code class="active haskell">{-# START_FILE Linguistic2.hs #-}
-- show
-- /show
{-# LANGUAGE UndecidableInstances, FlexibleInstances, OverlappingInstances, IncoherentInstances #-}
module Linguistic2 where

import           Data.Char  (chr, isLower, isUpper, ord, toLower, toUpper)
import           Data.List  (elemIndex, nub)
import           Data.Maybe (fromJust)

-- alphabet type definition and constructors
data Slovo a = Slovo a deriving (Eq, Show)
data Abeceda a = Abeceda {unAbeceda :: [Slovo a]} deriving (Eq, Show)
type Rijec a = [Slovo a]

-- |for a list the function constructs the alphabet containing unique elements of the list
lista2abeceda :: Eq a =&gt; [a] -&gt; Abeceda a
lista2abeceda xs=Abeceda [Slovo x|x&lt;-nub xs]

-- |for 2 Enum types (like Char) the function constructs the alphabet from first to second one
enum2abeceda :: (Eq a, Enum a) =&gt; a -&gt; a -&gt; Abeceda a
enum2abeceda a z=lista2abeceda [a..z]

-- |for a list the function constructs the word containing letters in the list
lista2rijec :: (Show a,Eq a) =&gt; [a] -&gt; Rijec a
lista2rijec xs| even (length xs)= [Slovo x|x&lt;-xs]
              | otherwise= error(&quot;The word &quot;++show xs++&quot; doesn't have an even number of letters.&quot;)

-- |for a word the function returns the list of letters in the word
rijec2lista :: Eq a =&gt; Rijec a -&gt; [a]
rijec2lista xs= [x|Slovo x&lt;-xs]

elemAbc :: Eq a =&gt; Slovo a -&gt; Abeceda a -&gt; Bool
elemAbc s (Abeceda a) = elem s a

elemIndexAbc :: Eq a =&gt; Slovo a -&gt; Abeceda a -&gt; Maybe Int
elemIndexAbc s (Abeceda a) = elemIndex s a

sup :: Eq a =&gt; Abeceda a -&gt; Slovo a -&gt; Slovo a -&gt; Slovo a
sup a x y| x `elemIndexAbc` a==Nothing || y `elemIndexAbc` a==Nothing = error(&quot;Letter is not from the alphabet.&quot;)
         | fromJust (x `elemIndexAbc` a) &gt; fromJust(y `elemIndexAbc` a) = x
         | otherwise = y

inf :: Eq a =&gt; Abeceda a -&gt; Slovo a -&gt; Slovo a -&gt; Slovo a
inf a x y| x `elemIndexAbc` a==Nothing || y `elemIndexAbc` a==Nothing = error(&quot;Letter is not from the alphabet.&quot;)
         | fromJust (x `elemIndexAbc` a) &lt; fromJust(y `elemIndexAbc` a) = x
         | otherwise = y

-- |function converting two consecutive lowercase letters to an uppercase letter
zapisu :: String-&gt;String
zapisu []=[]
zapisu [x]=[x]
zapisu (x:y:xs)|isLower x &amp;&amp; x==y = toUpper x:zapisu xs
               |otherwise=x:zapisu (y:xs)

-- |function converting uppercase letter to two consecutive lowercase letters
zapisl :: String-&gt;String
zapisl []=[]
zapisl (x:xs)|isUpper x =x':x':zapisl xs
             |otherwise =x:zapisl xs
             where x'=toLower x

-- string output of a word
class Show a =&gt; Ispisiv a where
    ispis :: Show a =&gt; Rijec a -&gt; String
    ispis []=[]
    ispis [Slovo x]=show x
    ispis (Slovo x:xs)=show x++&quot;-&quot;++ispis xs

instance Show a =&gt; Ispisiv a
instance Ispisiv Char where
    ispis=zapisu.ispis'

ispis' :: Rijec Char -&gt; String
ispis' []=[]
ispis' [Slovo x]=[x]
ispis' (Slovo x:xs)=x:ispis' xs

-- functions returning left and right letters of a word
l :: [Slovo a] -&gt; Slovo a
l = head
d :: [Slovo a] -&gt; Slovo a
d = last

-- |function returning a dual of a letter in an alphabet
dual :: Eq a =&gt; Abeceda a -&gt; Slovo a -&gt; Slovo a
dual (Abeceda []) s = error(&quot;Nema duala - slovo nije u abecedi.&quot;)
dual (Abeceda [c]) s | s==c = c
                     | otherwise = error(&quot;No dual - Letter is not from the alphabet.&quot;)
dual (Abeceda cs) s | s==lijevi = desni
                    | s==desni = lijevi
                    | otherwise = dual (Abeceda (tail (init cs))) s
                     where lijevi= l cs
                           desni= d cs

-- functions returning duals of left/right letters of a word
l' :: Eq a =&gt; Abeceda a -&gt; [Slovo a] -&gt; Slovo a
l' a= (dual a).l
d' :: Eq a =&gt; Abeceda a -&gt; [Slovo a] -&gt; Slovo a
d' a= (dual a).d

ljuska :: [Slovo a]-&gt;[Slovo a]
ljuska xs=[l xs,d xs]


-- |distance between letters in an alphabet
dd :: Eq a =&gt; Abeceda a -&gt; Slovo a -&gt; Slovo a -&gt; Int
dd a x y| m==Nothing || n==Nothing = error(&quot;Cannot calculate distance. Letter is not from the alphabet.&quot;)
        | otherwise = abs (fromJust m-fromJust n)
  where m=x `elemIndexAbc` a
        n=y `elemIndexAbc` a

-- |word length
duljina :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Int
duljina a []=0
duljina a [c]=0
duljina a (c1:c2:cs)= - dd a c1 c2 - duljina a (c2:cs)

-- word shortening
krati1 :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a    -- function shortening a 4 letter word
krati1 a [p,r,s,t] | duljina a [p,r,s,t]==duljina a [p,t] = [p,t]
                 | otherwise = [p,r,s,t]
krati1 _ cs = cs

krati2 :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a     -- function shortening a 4 letter sub-word
krati2 _ [] = []
krati2 a(c:cs) | length kr==2 = kr ++ drop 3 cs
               | otherwise = c : krati2 a cs
               where kr = ((krati1 a).(take 4)) (c:cs)

krati :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a    -- function fully shortening a word
krati a cs | cs/=kr = krati a kr
           | otherwise = cs
           where kr = krati2 a cs

-- symmetries
opD :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opD _ []=[]
opD a (s:t:ys)=dual a s:dual a t:opD a ys

opE :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opE _ []=[]
opE a xs=t:s:opE a ys
        where n=length xs
              t=d xs
              s=xs !! (n-2)
              ys=take (n-2) xs
--opE a (s:t:ys)=opE a ys++[t,s]    --kraÄe, ali nije po formuli iz teksta

opF :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opF a=(opD a).(opE a)

-- permutations
opI :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opI a xs=l xs:xs++[d xs]

-- |negation operator
opK :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opK a xs=l' a xs:xs++[d' a xs]

opG :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opG a xs=d xs:xs++[l xs]

opH :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opH a xs=d' a xs:xs++[l' a xs]

-- serial and parallel conjecture operators
opS :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a -&gt; Rijec a
opS a xs ys = inf a (l xs) (l ys) : inf a (l xs) (l ys) : xs ++
              [sup a (d xs) (l ys),inf a (d xs) (l ys)] ++ ys ++
              [sup a (d xs) (d ys),sup a (d xs) (d ys)]

opP :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a -&gt; Rijec a
opP a xs ys = sup a (l xs) (l ys) : sup a (l xs) (l ys) : xs ++
              [inf a (d xs) (l ys),sup a (d xs) (l ys)] ++ ys ++
              [inf a (d xs) (d ys),inf a (d xs) (d ys)]

-- |partitions
particija :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Char
particija a xs | lijevi&gt;=*lijevi' &amp;&amp; desni&lt;=*desni' &amp;&amp; lijevi&gt;*desni ='T'
               | lijevi&lt;=*lijevi' &amp;&amp; desni&lt;=*desni' &amp;&amp; not (lijevi==lijevi' || desni==desni') ='A'
               | lijevi==lijevi' &amp;&amp; desni==desni' ='0'
               | lijevi&gt;=*lijevi' &amp;&amp; desni&gt;=*desni' &amp;&amp; not (lijevi==lijevi' || desni==desni')  ='Z'
               | lijevi&lt;=*lijevi' &amp;&amp; desni&gt;=*desni' &amp;&amp; lijevi&lt;*desni  ='F'
         where lijevi=l xs
               desni=d xs
               lijevi'=l' a xs
               desni'=d' a xs
               x &gt;* y| m==Nothing || n==Nothing =error(&quot;Letter not in alphabet.&quot;)
                     | otherwise = (fromJust m) &gt; (fromJust n)
                      where m=x `elemIndexAbc` a
                            n=y `elemIndexAbc` a
               x &gt;=* y = x &gt;* y || x==y
               x &lt;* y = not (x &gt;=* y)
               x &lt;=* y = not (x &gt;* y)

-- implications
pimp :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a -&gt; Rijec a
pimp a x y=(opK a x) `opP'` y
    where opP'=opP a

simp :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a -&gt; Rijec a
simp a x y=(opK a x) `opS'` y
    where opS'=opS a

-- equivalencies
pekv :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a -&gt; Rijec a
pekv a x y=(x `pimp'` y) `opS'` (y `pimp'` x)
    where opS'=opS a
          pimp'=pimp a

sekv :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a -&gt; Rijec a
sekv a x y=(x `simp'` y) `opP'` (y `simp'` x)
    where opP'=opP a
          simp'=simp a

-- |tautologies and rules
taut :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt;Rijec a -&gt; Rijec a -&gt; [(String,Char)]
taut a x y z= zip
  [&quot;1.ZAKON ISKLJUCENJA TRECEG&quot;,
  &quot;2.DUAL ZAKONA ISKLJUCENJA TRECEG&quot;,
  &quot;3.TRANZITIVNOST IMPLIKACIJE&quot;,
  &quot;4.DUAL TRANZITIVNOSTI IMPLIKACIJE&quot;,
  &quot;5.ZAKON DVOSTRUKE NEGACIJE&quot;,
  &quot;6.ZAKON KONTRAPOZICIJE&quot;,
  &quot;7.DUAL ZAKONA KONTRAPOZICIJE&quot;,
  &quot;8.ZAKON APSORPCIJE ILI UPIJANJA&quot;,
  &quot;9.DUAL ZAKONA APSORPCIJE ILI UPIJANJA&quot;,
  &quot;10.MODUS PONENDO PONENS&quot;,
  &quot;11.DUAL MODUSA PONENDO PONENS&quot;,
  &quot;12.MODUS TOLENDO TOLLENS&quot;,
  &quot;13.DOKAZ NABRAJANJEM&quot;,
  &quot;14.DOVODJENJE DO PROTURJECJA&quot;]
  (map (particija a) [
    x `opP'` (neg x),
    x `opS'` (neg x),
    ((x `pimp'` y) `opS'` (y `pimp'` z)) `pimp'` (x `pimp'` z),
    ((x `simp'` y) `opP'` (y `simp'` z)) `simp'` (x `simp'` z),
    (neg (neg x)) `pekv'` x,
    (x `pimp'` y) `pimp'` ((neg y) `pimp'` (neg x)),
    (x `simp'` y) `simp'` ((neg y) `simp'` (neg x)),
    (x `opP'` (y `opP'` x)) `pimp'` x,
    (x `opS'` (y `opS'` x)) `simp'` x,
    (x `opS'` (x `pimp'` y)) `pimp'` y,
    (x `opP'` (x `simp'` y)) `simp'` y,
    ((neg x) `opS'` ((neg x) `pimp'` (neg y))) `pimp'` (neg y),
    ((x `pimp'` z) `opS'` (y `pimp'` z)) `pimp'` ((x `opP'` y) `pimp'` z),
    ((x `pimp'` y) `opS'` (x `pimp'` (neg y))) `pimp'` (neg x)
    ]
  )
  where opP'=opP a
        opS'=opS a
        pimp'=pimp a
        simp'=simp a
        pekv'=pekv a
        sekv'=sekv a
        neg=opK a
        
{-# START_FILE Main.hs #-}
module Main where
import Linguistic2

main :: IO ()

-- show Alphabet
main=do let {abc=lista2abeceda ['a'..'z']}         -- &lt;-- CHANGE
-- /show


-- show Words
        let {x=lista2rijec &quot;croatian&quot;; y=lista2rijec &quot;language&quot;}  -- &lt;-- CHANGE
-- /show


-- show Symmetry operators D, E and F
        putStr (&quot;D(&quot;++ispis x++&quot;)= &quot;++ ispis (opD abc x))
        putStrLn (&quot; =zip= &quot;++ (ispis.(krati abc)) (opD abc x))
        putStr (&quot;E(&quot;++ispis x++&quot;)= &quot;++ ispis (opE abc x))
        putStrLn (&quot; =zip= &quot;++ (ispis.(krati abc)) (opE abc x))
        putStr (&quot;E(&quot;++ispis y++&quot;)= &quot;++ ispis (opE abc y))
        putStrLn (&quot; =zip= &quot;++ (ispis.(krati abc)) (opE abc y))
        putStr (&quot;F(&quot;++ispis x++&quot;)= &quot;++ ispis (opF abc x))
        putStrLn (&quot; =zip= &quot;++ (ispis.(krati abc)) (opF abc x))
-- /show


-- show Symmetry operator E applied to words concatenation
        putStr (&quot;E(&quot;++ispis (x++y)++&quot;)= &quot;++ ispis (opE abc (x++y)))
        putStrLn (&quot; =zip= &quot;++ (ispis.(krati abc)) (opE abc (x++y)))
-- /show


-- show permutation operators I, K, G and H
        putStr (&quot;I(&quot;++ispis x++&quot;)= &quot;++ ispis (opI abc x))
        putStrLn (&quot; =zip= &quot;++ (ispis.(krati abc)) (opI abc x))
        putStr (&quot;K(&quot;++ispis x++&quot;)= &quot;++ ispis (opK abc x))
        putStrLn (&quot; =zip= &quot;++ (ispis.(krati abc)) (opK abc x))
        putStr (&quot;G(&quot;++ispis x++&quot;)= &quot;++ ispis (opG abc x))
        putStrLn (&quot; =zip= &quot;++ (ispis.(krati abc)) (opG abc x))
        putStr (&quot;H(&quot;++ispis x++&quot;)= &quot;++ ispis (opH abc x))
        putStrLn (&quot; =zip= &quot;++ (ispis.(krati abc)) (opH abc x))
-- /show


--  0-inverzivnost
--      putStr (&quot;E(G(&quot;++ispis y++&quot;))= &quot;++ ispis (opE abc (opG abc y)))
--      putStrLn (&quot; =zip= &quot;++ (ispis.(krati abc)) (opE abc (opG abc y)))
--      putStr (&quot;G(E(&quot;++ispis y++&quot;))= &quot;++ ispis (opG abc (opE abc y)))
--      putStrLn (&quot; =zip= &quot;++ (ispis.(krati abc)) (opG abc (opE abc y)))</code></pre><h2 id="example-4"><a href="#example-4">Example 4</a></h2><p>Let the set of symbols be the English alphabet <i>{a,..., z}</i>.
Let <i>x = croatian = croian</i>  and <i>y=language = le</i>. Then the serial and parallel connections are given by:</p><pre><code class="active haskell">{-# START_FILE Linguistic2.hs #-}
-- show
-- /show
{-# LANGUAGE UndecidableInstances, FlexibleInstances, OverlappingInstances, IncoherentInstances #-}
module Linguistic2 where

import           Data.Char  (chr, isLower, isUpper, ord, toLower, toUpper)
import           Data.List  (elemIndex, nub)
import           Data.Maybe (fromJust)

-- alphabet type definition and constructors
data Slovo a = Slovo a deriving (Eq, Show)
data Abeceda a = Abeceda {unAbeceda :: [Slovo a]} deriving (Eq, Show)
type Rijec a = [Slovo a]

-- |for a list the function constructs the alphabet containing unique elements of the list
lista2abeceda :: Eq a =&gt; [a] -&gt; Abeceda a
lista2abeceda xs=Abeceda [Slovo x|x&lt;-nub xs]

-- |for 2 Enum types (like Char) the function constructs the alphabet from first to second one
enum2abeceda :: (Eq a, Enum a) =&gt; a -&gt; a -&gt; Abeceda a
enum2abeceda a z=lista2abeceda [a..z]

-- |for a list the function constructs the word containing letters in the list
lista2rijec :: (Show a,Eq a) =&gt; [a] -&gt; Rijec a
lista2rijec xs| even (length xs)= [Slovo x|x&lt;-xs]
              | otherwise= error(&quot;The word &quot;++show xs++&quot; doesn't have an even number of letters.&quot;)

-- |for a word the function returns the list of letters in the word
rijec2lista :: Eq a =&gt; Rijec a -&gt; [a]
rijec2lista xs= [x|Slovo x&lt;-xs]

elemAbc :: Eq a =&gt; Slovo a -&gt; Abeceda a -&gt; Bool
elemAbc s (Abeceda a) = elem s a

elemIndexAbc :: Eq a =&gt; Slovo a -&gt; Abeceda a -&gt; Maybe Int
elemIndexAbc s (Abeceda a) = elemIndex s a

sup :: Eq a =&gt; Abeceda a -&gt; Slovo a -&gt; Slovo a -&gt; Slovo a
sup a x y| x `elemIndexAbc` a==Nothing || y `elemIndexAbc` a==Nothing = error(&quot;Letter is not from the alphabet.&quot;)
         | fromJust (x `elemIndexAbc` a) &gt; fromJust(y `elemIndexAbc` a) = x
         | otherwise = y

inf :: Eq a =&gt; Abeceda a -&gt; Slovo a -&gt; Slovo a -&gt; Slovo a
inf a x y| x `elemIndexAbc` a==Nothing || y `elemIndexAbc` a==Nothing = error(&quot;Letter is not from the alphabet.&quot;)
         | fromJust (x `elemIndexAbc` a) &lt; fromJust(y `elemIndexAbc` a) = x
         | otherwise = y

-- |function converting two consecutive lowercase letters to an uppercase letter
zapisu :: String-&gt;String
zapisu []=[]
zapisu [x]=[x]
zapisu (x:y:xs)|isLower x &amp;&amp; x==y = toUpper x:zapisu xs
               |otherwise=x:zapisu (y:xs)

-- |function converting uppercase letter to two consecutive lowercase letters
zapisl :: String-&gt;String
zapisl []=[]
zapisl (x:xs)|isUpper x =x':x':zapisl xs
             |otherwise =x:zapisl xs
             where x'=toLower x

-- string output of a word
class Show a =&gt; Ispisiv a where
    ispis :: Show a =&gt; Rijec a -&gt; String
    ispis []=[]
    ispis [Slovo x]=show x
    ispis (Slovo x:xs)=show x++&quot;-&quot;++ispis xs

instance Show a =&gt; Ispisiv a
instance Ispisiv Char where
    ispis=zapisu.ispis'

ispis' :: Rijec Char -&gt; String
ispis' []=[]
ispis' [Slovo x]=[x]
ispis' (Slovo x:xs)=x:ispis' xs

-- functions returning left and right letters of a word
l :: [Slovo a] -&gt; Slovo a
l = head
d :: [Slovo a] -&gt; Slovo a
d = last

-- |function returning a dual of a letter in an alphabet
dual :: Eq a =&gt; Abeceda a -&gt; Slovo a -&gt; Slovo a
dual (Abeceda []) s = error(&quot;Nema duala - slovo nije u abecedi.&quot;)
dual (Abeceda [c]) s | s==c = c
                     | otherwise = error(&quot;No dual - Letter is not from the alphabet.&quot;)
dual (Abeceda cs) s | s==lijevi = desni
                    | s==desni = lijevi
                    | otherwise = dual (Abeceda (tail (init cs))) s
                     where lijevi= l cs
                           desni= d cs

-- functions returning duals of left/right letters of a word
l' :: Eq a =&gt; Abeceda a -&gt; [Slovo a] -&gt; Slovo a
l' a= (dual a).l
d' :: Eq a =&gt; Abeceda a -&gt; [Slovo a] -&gt; Slovo a
d' a= (dual a).d

ljuska :: [Slovo a]-&gt;[Slovo a]
ljuska xs=[l xs,d xs]


-- |distance between letters in an alphabet
dd :: Eq a =&gt; Abeceda a -&gt; Slovo a -&gt; Slovo a -&gt; Int
dd a x y| m==Nothing || n==Nothing = error(&quot;Cannot calculate distance. Letter is not from the alphabet.&quot;)
        | otherwise = abs (fromJust m-fromJust n)
  where m=x `elemIndexAbc` a
        n=y `elemIndexAbc` a

-- |word length
duljina :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Int
duljina a []=0
duljina a [c]=0
duljina a (c1:c2:cs)= - dd a c1 c2 - duljina a (c2:cs)

-- word shortening
krati1 :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a    -- function shortening a 4 letter word
krati1 a [p,r,s,t] | duljina a [p,r,s,t]==duljina a [p,t] = [p,t]
                 | otherwise = [p,r,s,t]
krati1 _ cs = cs

krati2 :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a     -- function shortening a 4 letter sub-word
krati2 _ [] = []
krati2 a(c:cs) | length kr==2 = kr ++ drop 3 cs
               | otherwise = c : krati2 a cs
               where kr = ((krati1 a).(take 4)) (c:cs)

krati :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a    -- function fully shortening a word
krati a cs | cs/=kr = krati a kr
           | otherwise = cs
           where kr = krati2 a cs

-- symmetries
opD :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opD _ []=[]
opD a (s:t:ys)=dual a s:dual a t:opD a ys

opE :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opE _ []=[]
opE a xs=t:s:opE a ys
        where n=length xs
              t=d xs
              s=xs !! (n-2)
              ys=take (n-2) xs
--opE a (s:t:ys)=opE a ys++[t,s]    --kraÄe, ali nije po formuli iz teksta

opF :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opF a=(opD a).(opE a)

-- permutations
opI :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opI a xs=l xs:xs++[d xs]

-- |negation operator
opK :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opK a xs=l' a xs:xs++[d' a xs]

opG :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opG a xs=d xs:xs++[l xs]

opH :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opH a xs=d' a xs:xs++[l' a xs]

-- serial and parallel conjecture operators
opS :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a -&gt; Rijec a
opS a xs ys = inf a (l xs) (l ys) : inf a (l xs) (l ys) : xs ++
              [sup a (d xs) (l ys),inf a (d xs) (l ys)] ++ ys ++
              [sup a (d xs) (d ys),sup a (d xs) (d ys)]

opP :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a -&gt; Rijec a
opP a xs ys = sup a (l xs) (l ys) : sup a (l xs) (l ys) : xs ++
              [inf a (d xs) (l ys),sup a (d xs) (l ys)] ++ ys ++
              [inf a (d xs) (d ys),inf a (d xs) (d ys)]

-- |partitions
particija :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Char
particija a xs | lijevi&gt;=*lijevi' &amp;&amp; desni&lt;=*desni' &amp;&amp; lijevi&gt;*desni ='T'
               | lijevi&lt;=*lijevi' &amp;&amp; desni&lt;=*desni' &amp;&amp; not (lijevi==lijevi' || desni==desni') ='A'
               | lijevi==lijevi' &amp;&amp; desni==desni' ='0'
               | lijevi&gt;=*lijevi' &amp;&amp; desni&gt;=*desni' &amp;&amp; not (lijevi==lijevi' || desni==desni')  ='Z'
               | lijevi&lt;=*lijevi' &amp;&amp; desni&gt;=*desni' &amp;&amp; lijevi&lt;*desni  ='F'
         where lijevi=l xs
               desni=d xs
               lijevi'=l' a xs
               desni'=d' a xs
               x &gt;* y| m==Nothing || n==Nothing =error(&quot;Letter not in alphabet.&quot;)
                     | otherwise = (fromJust m) &gt; (fromJust n)
                      where m=x `elemIndexAbc` a
                            n=y `elemIndexAbc` a
               x &gt;=* y = x &gt;* y || x==y
               x &lt;* y = not (x &gt;=* y)
               x &lt;=* y = not (x &gt;* y)

-- implications
pimp :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a -&gt; Rijec a
pimp a x y=(opK a x) `opP'` y
    where opP'=opP a

simp :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a -&gt; Rijec a
simp a x y=(opK a x) `opS'` y
    where opS'=opS a

-- equivalencies
pekv :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a -&gt; Rijec a
pekv a x y=(x `pimp'` y) `opS'` (y `pimp'` x)
    where opS'=opS a
          pimp'=pimp a

sekv :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a -&gt; Rijec a
sekv a x y=(x `simp'` y) `opP'` (y `simp'` x)
    where opP'=opP a
          simp'=simp a

-- |tautologies and rules
taut :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt;Rijec a -&gt; Rijec a -&gt; [(String,Char)]
taut a x y z= zip
  [&quot;1.ZAKON ISKLJUCENJA TRECEG&quot;,
  &quot;2.DUAL ZAKONA ISKLJUCENJA TRECEG&quot;,
  &quot;3.TRANZITIVNOST IMPLIKACIJE&quot;,
  &quot;4.DUAL TRANZITIVNOSTI IMPLIKACIJE&quot;,
  &quot;5.ZAKON DVOSTRUKE NEGACIJE&quot;,
  &quot;6.ZAKON KONTRAPOZICIJE&quot;,
  &quot;7.DUAL ZAKONA KONTRAPOZICIJE&quot;,
  &quot;8.ZAKON APSORPCIJE ILI UPIJANJA&quot;,
  &quot;9.DUAL ZAKONA APSORPCIJE ILI UPIJANJA&quot;,
  &quot;10.MODUS PONENDO PONENS&quot;,
  &quot;11.DUAL MODUSA PONENDO PONENS&quot;,
  &quot;12.MODUS TOLENDO TOLLENS&quot;,
  &quot;13.DOKAZ NABRAJANJEM&quot;,
  &quot;14.DOVODJENJE DO PROTURJECJA&quot;]
  (map (particija a) [
    x `opP'` (neg x),
    x `opS'` (neg x),
    ((x `pimp'` y) `opS'` (y `pimp'` z)) `pimp'` (x `pimp'` z),
    ((x `simp'` y) `opP'` (y `simp'` z)) `simp'` (x `simp'` z),
    (neg (neg x)) `pekv'` x,
    (x `pimp'` y) `pimp'` ((neg y) `pimp'` (neg x)),
    (x `simp'` y) `simp'` ((neg y) `simp'` (neg x)),
    (x `opP'` (y `opP'` x)) `pimp'` x,
    (x `opS'` (y `opS'` x)) `simp'` x,
    (x `opS'` (x `pimp'` y)) `pimp'` y,
    (x `opP'` (x `simp'` y)) `simp'` y,
    ((neg x) `opS'` ((neg x) `pimp'` (neg y))) `pimp'` (neg y),
    ((x `pimp'` z) `opS'` (y `pimp'` z)) `pimp'` ((x `opP'` y) `pimp'` z),
    ((x `pimp'` y) `opS'` (x `pimp'` (neg y))) `pimp'` (neg x)
    ]
  )
  where opP'=opP a
        opS'=opS a
        pimp'=pimp a
        simp'=simp a
        pekv'=pekv a
        sekv'=sekv a
        neg=opK a
        
{-# START_FILE Main.hs #-}
module Main where
import Linguistic2

main :: IO ()

-- show Alphabet
main=do let {abc=lista2abeceda ['a'..'z']}         -- &lt;-- CHANGE
-- /show


-- show Words
        let {x=lista2rijec &quot;croatian&quot;; y=lista2rijec &quot;language&quot;}   -- &lt;-- CHANGE
-- /show

        let opPa=opP abc; opSa=opS abc

-- show M-conjunction (serial connection, `AND`)
        putStr (ispis x++&quot; `AND` &quot;++ ispis y)
        putStr (&quot; = &quot;++ ispis (x `opSa` y))
        putStrLn (&quot; =zip= &quot;++ (ispis.(krati abc)) (x `opSa` y))
        putStr (ispis y++&quot; `AND` &quot;++ ispis x)
        putStr (&quot; = &quot;++ ispis (y `opSa` x))
        putStrLn (&quot; =zip= &quot;++ (ispis.(krati abc)) (y `opSa` x))
-- /show


-- show M-disjunction (parallel connection, `OR`)
        putStr (ispis x++&quot; `OR` &quot;++ ispis y)
        putStr (&quot; = &quot;++ ispis (x `opPa` y))
        putStr (&quot; =zip= &quot;++ (ispis.(krati abc)) (x `opPa` y))
        putStrLn (&quot; =len= &quot;++ show (duljina abc (x `opPa` y)))
        putStr (ispis y++&quot; `OR` &quot;++ ispis x)
        putStr (&quot; = &quot;++ ispis (y `opPa` x))
        putStr (&quot; =zip= &quot;++ (ispis.(krati abc)) (y `opPa` x))
        putStrLn (&quot; =len= &quot;++ show (duljina abc (y `opPa` x)))
-- /show</code></pre><h2 id="example-5"><a href="#example-5">Example 5</a></h2><p>For alphabet <i>{1,2,3,4,5}</i> partition of base has the following form:</p><pre><code class="active haskell">{-# START_FILE Linguistic2.hs #-}
-- show
-- /show
{-# LANGUAGE UndecidableInstances, FlexibleInstances, OverlappingInstances, IncoherentInstances #-}
module Linguistic2 where

import           Data.Char  (chr, isLower, isUpper, ord, toLower, toUpper)
import           Data.List  (elemIndex, nub)
import           Data.Maybe (fromJust)

-- alphabet type definition and constructors
data Slovo a = Slovo a deriving (Eq, Show)
data Abeceda a = Abeceda {unAbeceda :: [Slovo a]} deriving (Eq, Show)
type Rijec a = [Slovo a]

-- |for a list the function constructs the alphabet containing unique elements of the list
lista2abeceda :: Eq a =&gt; [a] -&gt; Abeceda a
lista2abeceda xs=Abeceda [Slovo x|x&lt;-nub xs]

-- |for 2 Enum types (like Char) the function constructs the alphabet from first to second one
enum2abeceda :: (Eq a, Enum a) =&gt; a -&gt; a -&gt; Abeceda a
enum2abeceda a z=lista2abeceda [a..z]

-- |for a list the function constructs the word containing letters in the list
lista2rijec :: (Show a,Eq a) =&gt; [a] -&gt; Rijec a
lista2rijec xs| even (length xs)= [Slovo x|x&lt;-xs]
              | otherwise= error(&quot;The word &quot;++show xs++&quot; doesn't have an even number of letters.&quot;)

-- |for a word the function returns the list of letters in the word
rijec2lista :: Eq a =&gt; Rijec a -&gt; [a]
rijec2lista xs= [x|Slovo x&lt;-xs]

elemAbc :: Eq a =&gt; Slovo a -&gt; Abeceda a -&gt; Bool
elemAbc s (Abeceda a) = elem s a

elemIndexAbc :: Eq a =&gt; Slovo a -&gt; Abeceda a -&gt; Maybe Int
elemIndexAbc s (Abeceda a) = elemIndex s a

sup :: Eq a =&gt; Abeceda a -&gt; Slovo a -&gt; Slovo a -&gt; Slovo a
sup a x y| x `elemIndexAbc` a==Nothing || y `elemIndexAbc` a==Nothing = error(&quot;Letter is not from the alphabet.&quot;)
         | fromJust (x `elemIndexAbc` a) &gt; fromJust(y `elemIndexAbc` a) = x
         | otherwise = y

inf :: Eq a =&gt; Abeceda a -&gt; Slovo a -&gt; Slovo a -&gt; Slovo a
inf a x y| x `elemIndexAbc` a==Nothing || y `elemIndexAbc` a==Nothing = error(&quot;Letter is not from the alphabet.&quot;)
         | fromJust (x `elemIndexAbc` a) &lt; fromJust(y `elemIndexAbc` a) = x
         | otherwise = y

-- |function converting two consecutive lowercase letters to an uppercase letter
zapisu :: String-&gt;String
zapisu []=[]
zapisu [x]=[x]
zapisu (x:y:xs)|isLower x &amp;&amp; x==y = toUpper x:zapisu xs
               |otherwise=x:zapisu (y:xs)

-- |function converting uppercase letter to two consecutive lowercase letters
zapisl :: String-&gt;String
zapisl []=[]
zapisl (x:xs)|isUpper x =x':x':zapisl xs
             |otherwise =x:zapisl xs
             where x'=toLower x

-- string output of a word
class Show a =&gt; Ispisiv a where
    ispis :: Show a =&gt; Rijec a -&gt; String
    ispis []=[]
    ispis [Slovo x]=show x
    ispis (Slovo x:xs)=show x++&quot;-&quot;++ispis xs

instance Show a =&gt; Ispisiv a
instance Ispisiv Char where
    ispis=zapisu.ispis'

ispis' :: Rijec Char -&gt; String
ispis' []=[]
ispis' [Slovo x]=[x]
ispis' (Slovo x:xs)=x:ispis' xs

-- functions returning left and right letters of a word
l :: [Slovo a] -&gt; Slovo a
l = head
d :: [Slovo a] -&gt; Slovo a
d = last

-- |function returning a dual of a letter in an alphabet
dual :: Eq a =&gt; Abeceda a -&gt; Slovo a -&gt; Slovo a
dual (Abeceda []) s = error(&quot;Nema duala - slovo nije u abecedi.&quot;)
dual (Abeceda [c]) s | s==c = c
                     | otherwise = error(&quot;No dual - Letter is not from the alphabet.&quot;)
dual (Abeceda cs) s | s==lijevi = desni
                    | s==desni = lijevi
                    | otherwise = dual (Abeceda (tail (init cs))) s
                     where lijevi= l cs
                           desni= d cs

-- functions returning duals of left/right letters of a word
l' :: Eq a =&gt; Abeceda a -&gt; [Slovo a] -&gt; Slovo a
l' a= (dual a).l
d' :: Eq a =&gt; Abeceda a -&gt; [Slovo a] -&gt; Slovo a
d' a= (dual a).d

ljuska :: [Slovo a]-&gt;[Slovo a]
ljuska xs=[l xs,d xs]


-- |distance between letters in an alphabet
dd :: Eq a =&gt; Abeceda a -&gt; Slovo a -&gt; Slovo a -&gt; Int
dd a x y| m==Nothing || n==Nothing = error(&quot;Cannot calculate distance. Letter is not from the alphabet.&quot;)
        | otherwise = abs (fromJust m-fromJust n)
  where m=x `elemIndexAbc` a
        n=y `elemIndexAbc` a

-- |word length
duljina :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Int
duljina a []=0
duljina a [c]=0
duljina a (c1:c2:cs)= - dd a c1 c2 - duljina a (c2:cs)

-- word shortening
krati1 :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a    -- function shortening a 4 letter word
krati1 a [p,r,s,t] | duljina a [p,r,s,t]==duljina a [p,t] = [p,t]
                 | otherwise = [p,r,s,t]
krati1 _ cs = cs

krati2 :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a     -- function shortening a 4 letter sub-word
krati2 _ [] = []
krati2 a(c:cs) | length kr==2 = kr ++ drop 3 cs
               | otherwise = c : krati2 a cs
               where kr = ((krati1 a).(take 4)) (c:cs)

krati :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a    -- function fully shortening a word
krati a cs | cs/=kr = krati a kr
           | otherwise = cs
           where kr = krati2 a cs

-- symmetries
opD :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opD _ []=[]
opD a (s:t:ys)=dual a s:dual a t:opD a ys

opE :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opE _ []=[]
opE a xs=t:s:opE a ys
        where n=length xs
              t=d xs
              s=xs !! (n-2)
              ys=take (n-2) xs
--opE a (s:t:ys)=opE a ys++[t,s]    --kraÄe, ali nije po formuli iz teksta

opF :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opF a=(opD a).(opE a)

-- permutations
opI :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opI a xs=l xs:xs++[d xs]

-- |negation operator
opK :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opK a xs=l' a xs:xs++[d' a xs]

opG :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opG a xs=d xs:xs++[l xs]

opH :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opH a xs=d' a xs:xs++[l' a xs]

-- serial and parallel conjecture operators
opS :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a -&gt; Rijec a
opS a xs ys = inf a (l xs) (l ys) : inf a (l xs) (l ys) : xs ++
              [sup a (d xs) (l ys),inf a (d xs) (l ys)] ++ ys ++
              [sup a (d xs) (d ys),sup a (d xs) (d ys)]

opP :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a -&gt; Rijec a
opP a xs ys = sup a (l xs) (l ys) : sup a (l xs) (l ys) : xs ++
              [inf a (d xs) (l ys),sup a (d xs) (l ys)] ++ ys ++
              [inf a (d xs) (d ys),inf a (d xs) (d ys)]

-- |partitions
particija :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Char
particija a xs | lijevi&gt;=*lijevi' &amp;&amp; desni&lt;=*desni' &amp;&amp; lijevi&gt;*desni ='T'
               | lijevi&lt;=*lijevi' &amp;&amp; desni&lt;=*desni' &amp;&amp; not (lijevi==lijevi' || desni==desni') ='A'
               | lijevi==lijevi' &amp;&amp; desni==desni' ='0'
               | lijevi&gt;=*lijevi' &amp;&amp; desni&gt;=*desni' &amp;&amp; not (lijevi==lijevi' || desni==desni')  ='Z'
               | lijevi&lt;=*lijevi' &amp;&amp; desni&gt;=*desni' &amp;&amp; lijevi&lt;*desni  ='F'
         where lijevi=l xs
               desni=d xs
               lijevi'=l' a xs
               desni'=d' a xs
               x &gt;* y| m==Nothing || n==Nothing =error(&quot;Letter not in alphabet.&quot;)
                     | otherwise = (fromJust m) &gt; (fromJust n)
                      where m=x `elemIndexAbc` a
                            n=y `elemIndexAbc` a
               x &gt;=* y = x &gt;* y || x==y
               x &lt;* y = not (x &gt;=* y)
               x &lt;=* y = not (x &gt;* y)

-- implications
pimp :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a -&gt; Rijec a
pimp a x y=(opK a x) `opP'` y
    where opP'=opP a

simp :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a -&gt; Rijec a
simp a x y=(opK a x) `opS'` y
    where opS'=opS a

-- equivalencies
pekv :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a -&gt; Rijec a
pekv a x y=(x `pimp'` y) `opS'` (y `pimp'` x)
    where opS'=opS a
          pimp'=pimp a

sekv :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a -&gt; Rijec a
sekv a x y=(x `simp'` y) `opP'` (y `simp'` x)
    where opP'=opP a
          simp'=simp a

-- |tautologies and rules
taut :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt;Rijec a -&gt; Rijec a -&gt; [(String,Char)]
taut a x y z= zip
  [&quot;1.ZAKON ISKLJUCENJA TRECEG&quot;,
  &quot;2.DUAL ZAKONA ISKLJUCENJA TRECEG&quot;,
  &quot;3.TRANZITIVNOST IMPLIKACIJE&quot;,
  &quot;4.DUAL TRANZITIVNOSTI IMPLIKACIJE&quot;,
  &quot;5.ZAKON DVOSTRUKE NEGACIJE&quot;,
  &quot;6.ZAKON KONTRAPOZICIJE&quot;,
  &quot;7.DUAL ZAKONA KONTRAPOZICIJE&quot;,
  &quot;8.ZAKON APSORPCIJE ILI UPIJANJA&quot;,
  &quot;9.DUAL ZAKONA APSORPCIJE ILI UPIJANJA&quot;,
  &quot;10.MODUS PONENDO PONENS&quot;,
  &quot;11.DUAL MODUSA PONENDO PONENS&quot;,
  &quot;12.MODUS TOLENDO TOLLENS&quot;,
  &quot;13.DOKAZ NABRAJANJEM&quot;,
  &quot;14.DOVODJENJE DO PROTURJECJA&quot;]
  (map (particija a) [
    x `opP'` (neg x),
    x `opS'` (neg x),
    ((x `pimp'` y) `opS'` (y `pimp'` z)) `pimp'` (x `pimp'` z),
    ((x `simp'` y) `opP'` (y `simp'` z)) `simp'` (x `simp'` z),
    (neg (neg x)) `pekv'` x,
    (x `pimp'` y) `pimp'` ((neg y) `pimp'` (neg x)),
    (x `simp'` y) `simp'` ((neg y) `simp'` (neg x)),
    (x `opP'` (y `opP'` x)) `pimp'` x,
    (x `opS'` (y `opS'` x)) `simp'` x,
    (x `opS'` (x `pimp'` y)) `pimp'` y,
    (x `opP'` (x `simp'` y)) `simp'` y,
    ((neg x) `opS'` ((neg x) `pimp'` (neg y))) `pimp'` (neg y),
    ((x `pimp'` z) `opS'` (y `pimp'` z)) `pimp'` ((x `opP'` y) `pimp'` z),
    ((x `pimp'` y) `opS'` (x `pimp'` (neg y))) `pimp'` (neg x)
    ]
  )
  where opP'=opP a
        opS'=opS a
        pimp'=pimp a
        simp'=simp a
        pekv'=pekv a
        sekv'=sekv a
        neg=opK a
        
{-# START_FILE Main.hs #-}
module Main where
import Linguistic2

main :: IO ()

-- show Alphabet
main=do let {abc=lista2abeceda ([1..5]::[Int]);}   -- &lt;-- CHANGE
-- /show


-- show Base
        let {tab=[([x,y],particija abc [x,y])|x &lt;- unAbeceda abc,y &lt;- unAbeceda abc];}
-- /show


-- show Partitioning of base
        putStrLn (filter (/='&quot;') (concat [p:&quot;: &quot;++show [ispis x|(x,y)&lt;-tab,y==p]++&quot;\n&quot;|p&lt;-['T','A','0','Z','F']]))
-- /show</code></pre><h2 id="example-6"><a href="#example-6">Example 6</a></h2><p>Let <i>x=robin</i>, <i>y=chicken</i>, <i>z=penguin</i>, <i>w=cow</i> be animal species, where the first three come from bird species and the last one from mammals. By the evidence of their belonging to the species of birds, we could assign <i>ca</i> to <i>x</i>, <i>ba</i> to <i>y</i>, <i>aa</i> to <i>z</i>, while for <i>w</i>, we can assign the biggest untruth <i>ac</i> from 3-generator M-system.
The truths of certain compound statements are:</p><pre><code class="active haskell">{-# START_FILE Linguistic2.hs #-}
-- show
-- /show
{-# LANGUAGE UndecidableInstances, FlexibleInstances, OverlappingInstances, IncoherentInstances #-}
module Linguistic2 where

import           Data.Char  (chr, isLower, isUpper, ord, toLower, toUpper)
import           Data.List  (elemIndex, nub)
import           Data.Maybe (fromJust)

-- alphabet type definition and constructors
data Slovo a = Slovo {unSlovo :: a} deriving (Eq, Show)
data Abeceda a = Abeceda {unAbeceda :: [Slovo a]} deriving (Eq, Show)
type Rijec a = [Slovo a]

-- |for a list the function constructs the alphabet containing unique elements of the list
lista2abeceda :: Eq a =&gt; [a] -&gt; Abeceda a
lista2abeceda xs=Abeceda [Slovo x|x&lt;-nub xs]

-- |for 2 Enum types (like Char) the function constructs the alphabet from first to second one
enum2abeceda :: (Eq a, Enum a) =&gt; a -&gt; a -&gt; Abeceda a
enum2abeceda a z=lista2abeceda [a..z]

-- |for a list the function constructs the word containing letters in the list
lista2rijec :: (Show a,Eq a) =&gt; [a] -&gt; Rijec a
lista2rijec xs| even (length xs)= [Slovo x|x&lt;-xs]
              | otherwise= error(&quot;The word &quot;++show xs++&quot; doesn't have an even number of letters.&quot;)

-- |for a word the function returns the list of letters in the word
rijec2lista :: Eq a =&gt; Rijec a -&gt; [a]
rijec2lista xs= [x|Slovo x&lt;-xs]

elemAbc :: Eq a =&gt; Slovo a -&gt; Abeceda a -&gt; Bool
elemAbc s (Abeceda a) = elem s a

elemIndexAbc :: Eq a =&gt; Slovo a -&gt; Abeceda a -&gt; Maybe Int
elemIndexAbc s (Abeceda a) = elemIndex s a

sup :: Eq a =&gt; Abeceda a -&gt; Slovo a -&gt; Slovo a -&gt; Slovo a
sup a x y| x `elemIndexAbc` a==Nothing || y `elemIndexAbc` a==Nothing = error(&quot;Letter is not from the alphabet.&quot;)
         | fromJust (x `elemIndexAbc` a) &gt; fromJust(y `elemIndexAbc` a) = x
         | otherwise = y

inf :: Eq a =&gt; Abeceda a -&gt; Slovo a -&gt; Slovo a -&gt; Slovo a
inf a x y| x `elemIndexAbc` a==Nothing || y `elemIndexAbc` a==Nothing = error(&quot;Letter is not from the alphabet.&quot;)
         | fromJust (x `elemIndexAbc` a) &lt; fromJust(y `elemIndexAbc` a) = x
         | otherwise = y

-- |function converting two consecutive lowercase letters to an uppercase letter
zapisu :: String-&gt;String
zapisu []=[]
zapisu [x]=[x]
zapisu (x:y:xs)|isLower x &amp;&amp; x==y = toUpper x:zapisu xs
               |otherwise=x:zapisu (y:xs)

-- |function converting uppercase letter to two consecutive lowercase letters
zapisl :: String-&gt;String
zapisl []=[]
zapisl (x:xs)|isUpper x =x':x':zapisl xs
             |otherwise =x:zapisl xs
             where x'=toLower x

-- string output of a word
class Show a =&gt; Ispisiv a where
    ispis :: Show a =&gt; Rijec a -&gt; String
    ispis []=[]
    ispis [Slovo x]=show x
    ispis (Slovo x:xs)=show x++&quot;-&quot;++ispis xs

instance Show a =&gt; Ispisiv a
instance Ispisiv Char where
    ispis=zapisu.ispis'

ispis' :: Rijec Char -&gt; String
ispis' []=[]
ispis' [Slovo x]=[x]
ispis' (Slovo x:xs)=x:ispis' xs

-- functions returning left and right letters of a word
l :: [Slovo a] -&gt; Slovo a
l = head
d :: [Slovo a] -&gt; Slovo a
d = last

-- |function returning a dual of a letter in an alphabet
dual :: Eq a =&gt; Abeceda a -&gt; Slovo a -&gt; Slovo a
dual (Abeceda []) s = error(&quot;Nema duala - slovo nije u abecedi.&quot;)
dual (Abeceda [c]) s | s==c = c
                     | otherwise = error(&quot;No dual - Letter is not from the alphabet.&quot;)
dual (Abeceda cs) s | s==lijevi = desni
                    | s==desni = lijevi
                    | otherwise = dual (Abeceda (tail (init cs))) s
                     where lijevi= l cs
                           desni= d cs

-- functions returning duals of left/right letters of a word
l' :: Eq a =&gt; Abeceda a -&gt; [Slovo a] -&gt; Slovo a
l' a= (dual a).l
d' :: Eq a =&gt; Abeceda a -&gt; [Slovo a] -&gt; Slovo a
d' a= (dual a).d

ljuska :: [Slovo a]-&gt;[Slovo a]
ljuska xs=[l xs,d xs]


-- |distance between letters in an alphabet
dd :: Eq a =&gt; Abeceda a -&gt; Slovo a -&gt; Slovo a -&gt; Int
dd a x y| m==Nothing || n==Nothing = error(&quot;Cannot calculate distance. Letter is not from the alphabet.&quot;)
        | otherwise = abs (fromJust m-fromJust n)
  where m=x `elemIndexAbc` a
        n=y `elemIndexAbc` a

-- |word length
duljina :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Int
duljina a []=0
duljina a [c]=0
duljina a (c1:c2:cs)= - dd a c1 c2 - duljina a (c2:cs)

-- word shortening
krati1 :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a    -- function shortening a 4 letter word
krati1 a [p,r,s,t] | duljina a [p,r,s,t]==duljina a [p,t] = [p,t]
                 | otherwise = [p,r,s,t]
krati1 _ cs = cs

krati2 :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a     -- function shortening a 4 letter sub-word
krati2 _ [] = []
krati2 a(c:cs) | length kr==2 = kr ++ drop 3 cs
               | otherwise = c : krati2 a cs
               where kr = ((krati1 a).(take 4)) (c:cs)

krati :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a    -- function fully shortening a word
krati a cs | cs/=kr = krati a kr
           | otherwise = cs
           where kr = krati2 a cs

-- symmetries
opD :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opD _ []=[]
opD a (s:t:ys)=dual a s:dual a t:opD a ys

opE :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opE _ []=[]
opE a xs=t:s:opE a ys
        where n=length xs
              t=d xs
              s=xs !! (n-2)
              ys=take (n-2) xs
--opE a (s:t:ys)=opE a ys++[t,s]    --kraÄe, ali nije po formuli iz teksta

opF :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opF a=(opD a).(opE a)

-- permutations
opI :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opI a xs=l xs:xs++[d xs]

-- |negation operator
opK :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opK a xs=l' a xs:xs++[d' a xs]

opG :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opG a xs=d xs:xs++[l xs]

opH :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opH a xs=d' a xs:xs++[l' a xs]

-- serial and parallel conjecture operators
opS :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a -&gt; Rijec a
opS a xs ys = inf a (l xs) (l ys) : inf a (l xs) (l ys) : xs ++
              [sup a (d xs) (l ys),inf a (d xs) (l ys)] ++ ys ++
              [sup a (d xs) (d ys),sup a (d xs) (d ys)]

opP :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a -&gt; Rijec a
opP a xs ys = sup a (l xs) (l ys) : sup a (l xs) (l ys) : xs ++
              [inf a (d xs) (l ys),sup a (d xs) (l ys)] ++ ys ++
              [inf a (d xs) (d ys),inf a (d xs) (d ys)]

-- |partitions
particija :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Char
particija a xs | lijevi&gt;=*lijevi' &amp;&amp; desni&lt;=*desni' &amp;&amp; lijevi&gt;*desni ='T'
               | lijevi&lt;=*lijevi' &amp;&amp; desni&lt;=*desni' &amp;&amp; not (lijevi==lijevi' || desni==desni') ='A'
               | lijevi==lijevi' &amp;&amp; desni==desni' ='0'
               | lijevi&gt;=*lijevi' &amp;&amp; desni&gt;=*desni' &amp;&amp; not (lijevi==lijevi' || desni==desni')  ='Z'
               | lijevi&lt;=*lijevi' &amp;&amp; desni&gt;=*desni' &amp;&amp; lijevi&lt;*desni  ='F'
         where lijevi=l xs
               desni=d xs
               lijevi'=l' a xs
               desni'=d' a xs
               x &gt;* y| m==Nothing || n==Nothing =error(&quot;Letter not in alphabet.&quot;)
                     | otherwise = (fromJust m) &gt; (fromJust n)
                      where m=x `elemIndexAbc` a
                            n=y `elemIndexAbc` a
               x &gt;=* y = x &gt;* y || x==y
               x &lt;* y = not (x &gt;=* y)
               x &lt;=* y = not (x &gt;* y)

-- implications
pimp :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a -&gt; Rijec a
pimp a x y=(opK a x) `opP'` y
    where opP'=opP a

simp :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a -&gt; Rijec a
simp a x y=(opK a x) `opS'` y
    where opS'=opS a

-- equivalencies
pekv :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a -&gt; Rijec a
pekv a x y=(x `pimp'` y) `opS'` (y `pimp'` x)
    where opS'=opS a
          pimp'=pimp a

sekv :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a -&gt; Rijec a
sekv a x y=(x `simp'` y) `opP'` (y `simp'` x)
    where opP'=opP a
          simp'=simp a

-- |tautologies and rules
taut :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt;Rijec a -&gt; Rijec a -&gt; [(String,Char)]
taut a x y z= zip
  [&quot;1.ZAKON ISKLJUCENJA TRECEG&quot;,
  &quot;2.DUAL ZAKONA ISKLJUCENJA TRECEG&quot;,
  &quot;3.TRANZITIVNOST IMPLIKACIJE&quot;,
  &quot;4.DUAL TRANZITIVNOSTI IMPLIKACIJE&quot;,
  &quot;5.ZAKON DVOSTRUKE NEGACIJE&quot;,
  &quot;6.ZAKON KONTRAPOZICIJE&quot;,
  &quot;7.DUAL ZAKONA KONTRAPOZICIJE&quot;,
  &quot;8.ZAKON APSORPCIJE ILI UPIJANJA&quot;,
  &quot;9.DUAL ZAKONA APSORPCIJE ILI UPIJANJA&quot;,
  &quot;10.MODUS PONENDO PONENS&quot;,
  &quot;11.DUAL MODUSA PONENDO PONENS&quot;,
  &quot;12.MODUS TOLENDO TOLLENS&quot;,
  &quot;13.DOKAZ NABRAJANJEM&quot;,
  &quot;14.DOVODJENJE DO PROTURJECJA&quot;]
  (map (particija a) [
    x `opP'` (neg x),
    x `opS'` (neg x),
    ((x `pimp'` y) `opS'` (y `pimp'` z)) `pimp'` (x `pimp'` z),
    ((x `simp'` y) `opP'` (y `simp'` z)) `simp'` (x `simp'` z),
    (neg (neg x)) `pekv'` x,
    (x `pimp'` y) `pimp'` ((neg y) `pimp'` (neg x)),
    (x `simp'` y) `simp'` ((neg y) `simp'` (neg x)),
    (x `opP'` (y `opP'` x)) `pimp'` x,
    (x `opS'` (y `opS'` x)) `simp'` x,
    (x `opS'` (x `pimp'` y)) `pimp'` y,
    (x `opP'` (x `simp'` y)) `simp'` y,
    ((neg x) `opS'` ((neg x) `pimp'` (neg y))) `pimp'` (neg y),
    ((x `pimp'` z) `opS'` (y `pimp'` z)) `pimp'` ((x `opP'` y) `pimp'` z),
    ((x `pimp'` y) `opS'` (x `pimp'` (neg y))) `pimp'` (neg x)
    ]
  )
  where opP'=opP a
        opS'=opS a
        pimp'=pimp a
        simp'=simp a
        pekv'=pekv a
        sekv'=sekv a
        neg=opK a
        
{-# START_FILE Main.hs #-}
module Main where
import Linguistic2
import Data.Char (toUpper)

main :: IO ()

-- show Alphabet
main=do let {abc=lista2abeceda ['a'..'c']}         -- &lt;-- CHANGE
-- /show


-- show Words
        let {x= &quot;robin&quot;;
             y= &quot;chicken&quot;;             -- &lt;-- CHANGE
             z= &quot;penguin&quot;;
             w= &quot;cow&quot;;
             xx=lista2rijec &quot;ca&quot;;
             yy=lista2rijec &quot;ba&quot;;             -- &lt;-- CHANGE
             zz=lista2rijec &quot;aa&quot;;
             ww=lista2rijec &quot;ac&quot;;}
-- /show

        let {opPa=opP abc; opSa=opS abc;
             xxx=head xx:(lista2rijec.zapisl) (map toUpper x)++[last xx];
             yyy=head yy:(lista2rijec.zapisl) (map toUpper y)++[last yy];
             zzz=head zz:(lista2rijec.zapisl) (map toUpper z)++[last zz];
             www=head ww:(lista2rijec.zapisl) (map toUpper w)++[last ww];}

-- show istinitost rijeÄi
        putStrLn (&quot;Ï(&quot;++x++&quot;)= Ï(&quot;++ispis xx++&quot;)= &quot;++[particija abc xx])
        putStrLn (&quot;Ï(&quot;++y++&quot;)= Ï(&quot;++ispis yy++&quot;)= &quot;++[particija abc yy])
        putStrLn (&quot;Ï(&quot;++z++&quot;)= Ï(&quot;++ispis zz++&quot;)= &quot;++[particija abc zz])
        putStrLn (&quot;Ï(&quot;++w++&quot;)= Ï(&quot;++ispis ww++&quot;)= &quot;++[particija abc ww])
-- /show


-- show istinitost logiÄkih funkcija
        putStrLn (&quot;Ï(&quot;++x++&quot;`AND`&quot;++y++&quot;`OR`&quot;++w++&quot;)= Ï(&quot;++ispis xx++&quot;`AND`&quot;++ispis yy++&quot;`OR`&quot;++ispis ww++&quot;)= Ï(&quot;++(ispis.(krati abc)) (xx `opSa` yy)++&quot;`OR`&quot;++ispis ww++&quot;)= Ï(&quot;++(ispis.(krati abc)) (xx `opSa` yy `opPa` ww)++&quot;)= &quot;++[particija abc (xx `opSa` yy `opPa` ww)])
        putStrLn (&quot;Ï(&quot;++z++&quot;`OR`&quot;++y++&quot;`AND`&quot;++w++&quot;)= Ï(&quot;++ispis zz++&quot;`OR`&quot;++ispis yy++&quot;`AND`&quot;++ispis ww++&quot;)= Ï(&quot;++(ispis.(krati abc)) (zz `opPa` yy)++&quot;`AND`&quot;++ispis ww++&quot;)= Ï(&quot;++(ispis.(krati abc)) (zz `opPa` yy `opSa` ww)++&quot;)= &quot;++[particija abc (zz `opPa` yy `opSa` ww)])
-- /show</code></pre><h2 id="example-7"><a href="#example-7">Example 7</a></h2><p>Let us observe the following three statements written in three languages:</p><ul><li>Croatian: SVI LJUDI SU SMRTNI</li><li>English: ALL MEN ARE MORTAL</li><li>French: TOUS LES HOMMES SONT MORTELS</li></ul><hr /><ul><li>Croatian: SOKRAT JE ÄOVJEK</li><li>English: SOCRATES IS A MAN</li><li>French: SOCRATE EST UN HOMME</li></ul><hr /><ul><li>Croatian: SOKRAT JE SMRTAN</li><li>English: SOCRATES IS MORTAL</li><li>French: SOCRATE EST MORTEL</li></ul><p>Processing using  M-system have the following form:</p><pre><code class="active haskell">{-# START_FILE Linguistic2.hs #-}
-- show
-- /show
{-# LANGUAGE UndecidableInstances, FlexibleInstances, OverlappingInstances, IncoherentInstances #-}
module Linguistic2 where

import           Data.Char  (chr, isLower, isUpper, ord, toLower, toUpper)
import           Data.List  (elemIndex, nub)
import           Data.Maybe (fromJust)

-- alphabet type definition and constructors
data Slovo a = Slovo a deriving (Eq, Show)
data Abeceda a = Abeceda {unAbeceda :: [Slovo a]} deriving (Eq, Show)
type Rijec a = [Slovo a]

-- |for a list the function constructs the alphabet containing unique elements of the list
lista2abeceda :: Eq a =&gt; [a] -&gt; Abeceda a
lista2abeceda xs=Abeceda [Slovo x|x&lt;-nub xs]

-- |for 2 Enum types (like Char) the function constructs the alphabet from first to second one
enum2abeceda :: (Eq a, Enum a) =&gt; a -&gt; a -&gt; Abeceda a
enum2abeceda a z=lista2abeceda [a..z]

-- |for a list the function constructs the word containing letters in the list
lista2rijec :: (Show a,Eq a) =&gt; [a] -&gt; Rijec a
lista2rijec xs| even (length xs)= [Slovo x|x&lt;-xs]
              | otherwise= error(&quot;The word &quot;++show xs++&quot; doesn't have an even number of letters.&quot;)

-- |for a word the function returns the list of letters in the word
rijec2lista :: Eq a =&gt; Rijec a -&gt; [a]
rijec2lista xs= [x|Slovo x&lt;-xs]

elemAbc :: Eq a =&gt; Slovo a -&gt; Abeceda a -&gt; Bool
elemAbc s (Abeceda a) = elem s a

elemIndexAbc :: Eq a =&gt; Slovo a -&gt; Abeceda a -&gt; Maybe Int
elemIndexAbc s (Abeceda a) = elemIndex s a

sup :: Eq a =&gt; Abeceda a -&gt; Slovo a -&gt; Slovo a -&gt; Slovo a
sup a x y| x `elemIndexAbc` a==Nothing || y `elemIndexAbc` a==Nothing = error(&quot;Letter is not from the alphabet.&quot;)
         | fromJust (x `elemIndexAbc` a) &gt; fromJust(y `elemIndexAbc` a) = x
         | otherwise = y

inf :: Eq a =&gt; Abeceda a -&gt; Slovo a -&gt; Slovo a -&gt; Slovo a
inf a x y| x `elemIndexAbc` a==Nothing || y `elemIndexAbc` a==Nothing = error(&quot;Letter is not from the alphabet.&quot;)
         | fromJust (x `elemIndexAbc` a) &lt; fromJust(y `elemIndexAbc` a) = x
         | otherwise = y

-- |function converting two consecutive lowercase letters to an uppercase letter
zapisu :: String-&gt;String
zapisu []=[]
zapisu [x]=[x]
zapisu (x:y:xs)|isLower x &amp;&amp; x==y = toUpper x:zapisu xs
               |otherwise=x:zapisu (y:xs)

-- |function converting uppercase letter to two consecutive lowercase letters
zapisl :: String-&gt;String
zapisl []=[]
zapisl (x:xs)|isUpper x =x':x':zapisl xs
             |otherwise =x:zapisl xs
             where x'=toLower x

-- string output of a word
class Show a =&gt; Ispisiv a where
    ispis :: Show a =&gt; Rijec a -&gt; String
    ispis []=[]
    ispis [Slovo x]=show x
    ispis (Slovo x:xs)=show x++&quot;-&quot;++ispis xs

instance Show a =&gt; Ispisiv a
instance Ispisiv Char where
    ispis=zapisu.ispis'

ispis' :: Rijec Char -&gt; String
ispis' []=[]
ispis' [Slovo x]=[x]
ispis' (Slovo x:xs)=x:ispis' xs

-- functions returning left and right letters of a word
l :: [Slovo a] -&gt; Slovo a
l = head
d :: [Slovo a] -&gt; Slovo a
d = last

-- |function returning a dual of a letter in an alphabet
dual :: Eq a =&gt; Abeceda a -&gt; Slovo a -&gt; Slovo a
dual (Abeceda []) s = error(&quot;Nema duala - slovo nije u abecedi.&quot;)
dual (Abeceda [c]) s | s==c = c
                     | otherwise = error(&quot;No dual - Letter is not from the alphabet.&quot;)
dual (Abeceda cs) s | s==lijevi = desni
                    | s==desni = lijevi
                    | otherwise = dual (Abeceda (tail (init cs))) s
                     where lijevi= l cs
                           desni= d cs

-- functions returning duals of left/right letters of a word
l' :: Eq a =&gt; Abeceda a -&gt; [Slovo a] -&gt; Slovo a
l' a= (dual a).l
d' :: Eq a =&gt; Abeceda a -&gt; [Slovo a] -&gt; Slovo a
d' a= (dual a).d

ljuska :: [Slovo a]-&gt;[Slovo a]
ljuska xs=[l xs,d xs]


-- |distance between letters in an alphabet
dd :: Eq a =&gt; Abeceda a -&gt; Slovo a -&gt; Slovo a -&gt; Int
dd a x y| m==Nothing || n==Nothing = error(&quot;Cannot calculate distance. Letter is not from the alphabet.&quot;)
        | otherwise = abs (fromJust m-fromJust n)
  where m=x `elemIndexAbc` a
        n=y `elemIndexAbc` a

-- |word length
duljina :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Int
duljina a []=0
duljina a [c]=0
duljina a (c1:c2:cs)= - dd a c1 c2 - duljina a (c2:cs)

-- word shortening
krati1 :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a    -- function shortening a 4 letter word
krati1 a [p,r,s,t] | duljina a [p,r,s,t]==duljina a [p,t] = [p,t]
                 | otherwise = [p,r,s,t]
krati1 _ cs = cs

krati2 :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a     -- function shortening a 4 letter sub-word
krati2 _ [] = []
krati2 a(c:cs) | length kr==2 = kr ++ drop 3 cs
               | otherwise = c : krati2 a cs
               where kr = ((krati1 a).(take 4)) (c:cs)

krati :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a    -- function fully shortening a word
krati a cs | cs/=kr = krati a kr
           | otherwise = cs
           where kr = krati2 a cs

-- symmetries
opD :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opD _ []=[]
opD a (s:t:ys)=dual a s:dual a t:opD a ys

opE :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opE _ []=[]
opE a xs=t:s:opE a ys
        where n=length xs
              t=d xs
              s=xs !! (n-2)
              ys=take (n-2) xs
--opE a (s:t:ys)=opE a ys++[t,s]    --kraÄe, ali nije po formuli iz teksta

opF :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opF a=(opD a).(opE a)

-- permutations
opI :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opI a xs=l xs:xs++[d xs]

-- |negation operator
opK :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opK a xs=l' a xs:xs++[d' a xs]

opG :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opG a xs=d xs:xs++[l xs]

opH :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opH a xs=d' a xs:xs++[l' a xs]

-- serial and parallel conjecture operators
opS :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a -&gt; Rijec a
opS a xs ys = inf a (l xs) (l ys) : inf a (l xs) (l ys) : xs ++
              [sup a (d xs) (l ys),inf a (d xs) (l ys)] ++ ys ++
              [sup a (d xs) (d ys),sup a (d xs) (d ys)]

opP :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a -&gt; Rijec a
opP a xs ys = sup a (l xs) (l ys) : sup a (l xs) (l ys) : xs ++
              [inf a (d xs) (l ys),sup a (d xs) (l ys)] ++ ys ++
              [inf a (d xs) (d ys),inf a (d xs) (d ys)]

-- |partitions
particija :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Char
particija a xs | lijevi&gt;=*lijevi' &amp;&amp; desni&lt;=*desni' &amp;&amp; lijevi&gt;*desni ='T'
               | lijevi&lt;=*lijevi' &amp;&amp; desni&lt;=*desni' &amp;&amp; not (lijevi==lijevi' || desni==desni') ='A'
               | lijevi==lijevi' &amp;&amp; desni==desni' ='0'
               | lijevi&gt;=*lijevi' &amp;&amp; desni&gt;=*desni' &amp;&amp; not (lijevi==lijevi' || desni==desni')  ='Z'
               | lijevi&lt;=*lijevi' &amp;&amp; desni&gt;=*desni' &amp;&amp; lijevi&lt;*desni  ='F'
         where lijevi=l xs
               desni=d xs
               lijevi'=l' a xs
               desni'=d' a xs
               x &gt;* y| m==Nothing || n==Nothing =error(&quot;Letter not in alphabet.&quot;)
                     | otherwise = (fromJust m) &gt; (fromJust n)
                      where m=x `elemIndexAbc` a
                            n=y `elemIndexAbc` a
               x &gt;=* y = x &gt;* y || x==y
               x &lt;* y = not (x &gt;=* y)
               x &lt;=* y = not (x &gt;* y)

-- implications
pimp :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a -&gt; Rijec a
pimp a x y=(opK a x) `opP'` y
    where opP'=opP a

simp :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a -&gt; Rijec a
simp a x y=(opK a x) `opS'` y
    where opS'=opS a

-- equivalencies
pekv :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a -&gt; Rijec a
pekv a x y=(x `pimp'` y) `opS'` (y `pimp'` x)
    where opS'=opS a
          pimp'=pimp a

sekv :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a -&gt; Rijec a
sekv a x y=(x `simp'` y) `opP'` (y `simp'` x)
    where opP'=opP a
          simp'=simp a

-- |tautologies and rules
taut :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt;Rijec a -&gt; Rijec a -&gt; [(String,Char)]
taut a x y z= zip
  [&quot;1.The law of  excluded middle&quot;,
  &quot;2.Dual law of excluded middle&quot;,
  &quot;3.Transitivity of implication&quot;,
  &quot;4.Dual law of transitivity of implication&quot;,
  &quot;5.Double negation law&quot;,
  &quot;6.Contraposition law&quot;,
  &quot;7.Dual contraposition law&quot;,
  &quot;8.Absorption law&quot;,
  &quot;9.Dual absorption Law&quot;,
  &quot;10.Modus ponendo ponens&quot;,
  &quot;11.Dual modus ponendo ponens&quot;,
  &quot;12.Modus tollendo tollens&quot;,
  &quot;13.Demonstratio per enumerationem&quot;,
  &quot;14.Proof by contradiction&quot;]
  (map (particija a) [
    x `opP'` (neg x),
    x `opS'` (neg x),
    ((x `pimp'` y) `opS'` (y `pimp'` z)) `pimp'` (x `pimp'` z),
    ((x `simp'` y) `opP'` (y `simp'` z)) `simp'` (x `simp'` z),
    (neg (neg x)) `pekv'` x,
    (x `pimp'` y) `pimp'` ((neg y) `pimp'` (neg x)),
    (x `simp'` y) `simp'` ((neg y) `simp'` (neg x)),
    (x `opP'` (y `opS'` x)) `pimp'` x,
    (x `opS'` (y `opP'` x)) `simp'` x,
    (x `opS'` (x `pimp'` y)) `pimp'` y,
    (x `opP'` (x `simp'` y)) `simp'` y,
    ((neg x) `opS'` ((neg x) `pimp'` (neg y))) `pimp'` (neg y),
    ((x `pimp'` z) `opS'` (y `pimp'` z)) `pimp'` ((x `opP'` y) `pimp'` z),
    ((x `pimp'` y) `opS'` (x `pimp'` (neg y))) `pimp'` (neg x)
    ]
  )
  where opP'=opP a
        opS'=opS a
        pimp'=pimp a
        simp'=simp a
        pekv'=pekv a
        sekv'=sekv a
        neg=opK a
        
{-# START_FILE Main.hs #-}
module Main where
import Linguistic2

main :: IO ()

-- show Alphabet
main=do let {abc=lista2abeceda ['a'..'z'];}         -- &lt;-- CHANGE
-- /show


-- show Words
        let {hr=rijeci (&quot;SOKRAT&quot;,&quot;COVJEK&quot;,&quot;SMRTAN&quot;);
             en=rijeci (&quot;SOCRATES&quot;,&quot;MAN&quot;,&quot;MORTALS&quot;);    -- &lt;-- CHANGE
             fr=rijeci (&quot;SOCRATE&quot;,&quot;HOMME&quot;,&quot;MORTELS&quot;);}
-- /show

        let opPa=opP abc; opSa=opS abc; pimpa=pimp abc; simpa=simp abc;

-- show Word partition
        putStrLn (&quot;Ï&quot;++show (fNaTri ispis hr)++&quot; = &quot;++show (fNaTri (particija abc) hr))
        putStrLn (&quot;Ï&quot;++show (fNaTri ispis en)++&quot; = &quot;++show (fNaTri (particija abc) en))
        putStrLn (&quot;Ï&quot;++show (fNaTri ispis fr)++&quot; = &quot;++show (fNaTri (particija abc) fr))
-- /show


        putStrLn &quot;\nThe rule of syllogism&quot;


-- show The rule of syllogism
        putStrLn &quot;Croatian:&quot;
        obrada abc hr
        putStrLn &quot;\nEnglish:&quot;
        obrada abc en
        putStrLn &quot;\nFrench:&quot;
        obrada abc fr
-- /show


        putStrLn &quot;\nFirst fallacy&quot;


-- show Fallacy
        putStrLn &quot;Croatian:&quot;
        obrada2 abc hr
        putStrLn &quot;\nEnglish:&quot;
        obrada2 abc en
        putStrLn &quot;\nFrench:&quot;
        obrada2 abc fr
-- /show


        putStrLn &quot;\nSecond fallacy&quot;


-- show Fallacy
        putStrLn &quot;Croatian:&quot;
        obrada3 abc hr
        putStrLn &quot;\nEnglish:&quot;
        obrada3 abc en
        putStrLn &quot;\nFrench:&quot;
        obrada3 abc fr
-- /show


        putStrLn &quot;\nThird fallacy&quot;


-- show Fallacy
        putStrLn &quot;Croatian:&quot;
        obrada4 abc hr
        putStrLn &quot;\nEnglish:&quot;
        obrada4 abc en
        putStrLn &quot;\nFrench:&quot;
        obrada4 abc fr
-- /show


        putStrLn &quot;\nFourth fallacy&quot;


-- show Fallacy
        putStrLn &quot;Croatian:&quot;
        obrada5 abc hr
        putStrLn &quot;\nEnglish:&quot;
        obrada5 abc en
        putStrLn &quot;\nFrench:&quot;
        obrada5 abc fr
-- /show

-- show Tautologies
        putStrLn (&quot;\nAll tautologies and rules for (x,y,z)=&quot;++show (fNaTri ispis hr)++&quot;:&quot;)
        print ((\a (x,y,z)-&gt;taut a x y z) abc hr)
-- /show


fNaTri::(a-&gt;b)-&gt;(a,a,a)-&gt;(b,b,b)
fNaTri f (x,y,z)=(f x,f y,f z)

rijeci::(String,String,String)-&gt;(Rijec Char,Rijec Char,Rijec Char)
rijeci x=fNaTri (lista2rijec.zapisl) x

obrada :: Abeceda Char-&gt;(Rijec Char,Rijec Char,Rijec Char)-&gt;IO ()
obrada abc (y,z,x)= do let {pimpa=pimp abc;opSa=opS abc;ispiskr=(ispis.(krati abc));}
                       putStrLn (&quot;Ï(((&quot;++ispis y++&quot; -p-&gt; &quot;++ispis z++&quot;) `AND` (&quot;++ispis z++&quot; -p-&gt; &quot;++ispis x++&quot;)) -p-&gt; (&quot;++ispis y++&quot; -p-&gt; &quot;++ispis x++&quot;))\n =Ï((&quot;
                         ++ispiskr (y `pimpa` z)++&quot; `AND` &quot;++ispiskr (z `pimpa` x)++&quot;) -p-&gt; &quot;++ispiskr (y `pimpa` x)++&quot;)\n =Ï(&quot;
                         ++ispiskr ((y `pimpa` z) `opSa` (z `pimpa` x))++&quot; -p-&gt; &quot;++ispiskr (y `pimpa` x)++&quot;)\n =Ï(&quot;
                         ++ispiskr (((y `pimpa` z) `opSa` (z `pimpa` x)) `pimpa` (y `pimpa` x))++&quot;)\n =&quot;
                         ++[particija abc (((y `pimpa` z) `opSa` (z `pimpa` x)) `pimpa` (y `pimpa` x))])

obrada2 :: Abeceda Char-&gt;(Rijec Char,Rijec Char,Rijec Char)-&gt;IO ()
obrada2 abc (y,z,x)= do let {pimpa=pimp abc;simpa=simp abc;opSa=opS abc;ispiskr=(ispis.(krati abc));}
                        putStrLn (&quot;Ï(((&quot;++ispis y++&quot; -p-&gt; &quot;++ispis z++&quot;) `AND` (&quot;++ispis z++&quot; -p-&gt; &quot;++ispis x++&quot;)) -s-&gt; (&quot;++ispis y++&quot; -p-&gt; &quot;++ispis x++&quot;))\n =Ï((&quot;
                          ++ispiskr (y `pimpa` z)++&quot; `AND` &quot;++ispiskr (z `pimpa` x)++&quot;) -s-&gt; &quot;++ispiskr (y `pimpa` x)++&quot;)\n =Ï(&quot;
                          ++ispiskr ((y `pimpa` z) `opSa` (z `pimpa` x))++&quot; -s-&gt; &quot;++ispiskr (y `pimpa` x)++&quot;)\n =Ï(&quot;
                          ++ispiskr (((y `pimpa` z) `opSa` (z `pimpa` x)) `simpa` (y `pimpa` x))++&quot;)\n =&quot;
                          ++[particija abc (((y `pimpa` z) `opSa` (z `pimpa` x)) `simpa` (y `pimpa` x))])

obrada3 :: Abeceda Char-&gt;(Rijec Char,Rijec Char,Rijec Char)-&gt;IO ()
obrada3 abc (y,z,x)= do let {pimpa=pimp abc;simpa=simp abc;opSa=opS abc;ispiskr=(ispis.(krati abc));}
                        putStrLn (&quot;Ï(((&quot;++ispis y++&quot; -p-&gt; &quot;++ispis z++&quot;) `AND` (&quot;++ispis z++&quot; -p-&gt; &quot;++ispis x++&quot;)) -p-&gt; (&quot;++ispis y++&quot; -s-&gt; &quot;++ispis x++&quot;))\n =Ï((&quot;
                          ++ispiskr (y `pimpa` z)++&quot; `AND` &quot;++ispiskr (z `pimpa` x)++&quot;) -p-&gt; &quot;++ispiskr (y `simpa` x)++&quot;)\n =Ï(&quot;
                          ++ispiskr ((y `pimpa` z) `opSa` (z `pimpa` x))++&quot; -p-&gt; &quot;++ispiskr (y `simpa` x)++&quot;)\n =Ï(&quot;
                          ++ispiskr (((y `pimpa` z) `opSa` (z `pimpa` x)) `pimpa` (y `simpa` x))++&quot;)\n =&quot;
                          ++[particija abc (((y `pimpa` z) `opSa` (z `pimpa` x)) `pimpa` (y `simpa` x))])

obrada4 :: Abeceda Char-&gt;(Rijec Char,Rijec Char,Rijec Char)-&gt;IO ()
obrada4 abc (y,z,x)= do let {pimpa=pimp abc;simpa=simp abc;opSa=opS abc;nega=opK abc;ispiskr=(ispis.(krati abc));}
                        putStrLn (&quot;Ï(((&quot;++ispis y++&quot; -p-&gt; &quot;++ispis z++&quot;) `AND` (&quot;++ispis z++&quot; -p-&gt; &quot;++ispis x++&quot;)) -p-&gt; Â¬(&quot;++ispis y++&quot; -p-&gt; &quot;++ispis x++&quot;))\n =Ï((&quot;
                          ++ispiskr (y `pimpa` z)++&quot; `AND` &quot;++ispiskr (z `pimpa` x)++&quot;) -p-&gt; Â¬&quot;++ispiskr (y `pimpa` x)++&quot;)\n =Ï(&quot;
                          ++ispiskr ((y `pimpa` z) `opSa` (z `pimpa` x))++&quot; -p-&gt; &quot;++ispiskr (nega (y `pimpa` x))++&quot;)\n =Ï(&quot;
                          ++ispiskr (((y `pimpa` z) `opSa` (z `pimpa` x)) `pimpa` (nega (y `pimpa` x)))++&quot;)\n =&quot;
                          ++[particija abc (((y `pimpa` z) `opSa` (z `pimpa` x)) `pimpa` (nega (y `pimpa` x)))])

obrada5 :: Abeceda Char-&gt;(Rijec Char,Rijec Char,Rijec Char)-&gt;IO ()
obrada5 abc (y,z,x)= do let {pimpa=pimp abc;simpa=simp abc;opSa=opS abc;nega=opK abc;ispiskr=(ispis.(krati abc));}
                        putStrLn (&quot;Ï(((&quot;++ispis y++&quot; -p-&gt; &quot;++ispis z++&quot;) `AND` (&quot;++ispis z++&quot; -p-&gt; &quot;++ispis x++&quot;)) -p-&gt; (&quot;++ispis y++&quot; -p-&gt; Â¬(&quot;++ispis x++&quot;)))\n =Ï((&quot;
                          ++ispiskr (y `pimpa` z)++&quot; `AND` &quot;++ispiskr (z `pimpa` x)++&quot;) -p-&gt; &quot;++ispiskr (y `pimpa` (nega x))++&quot;)\n =Ï(&quot;
                          ++ispiskr ((y `pimpa` z) `opSa` (z `pimpa` x))++&quot; -p-&gt; &quot;++ispiskr (y `pimpa` (nega x))++&quot;)\n =Ï(&quot;
                          ++ispiskr (((y `pimpa` z) `opSa` (z `pimpa` x)) `pimpa` (y `pimpa` (nega x)))++&quot;)\n =&quot;
                          ++[particija abc (((y `pimpa` z) `opSa` (z `pimpa` x)) `pimpa` (y `pimpa` (nega x)))])</code></pre><h2 id="the-rules-of-inference-and-tautologies"><a href="#the-rules-of-inference-and-tautologies">The rules of inference and tautologies</a></h2><pre><code class="active haskell">{-# START_FILE Linguistic2.hs #-}
-- show
-- /show
{-# LANGUAGE UndecidableInstances, FlexibleInstances, OverlappingInstances, IncoherentInstances #-}
module Linguistic2 where

import           Data.Char  (chr, isLower, isUpper, ord, toLower, toUpper)
import           Data.List  (elemIndex, nub)
import           Data.Maybe (fromJust)

-- alphabet type definition and constructors
data Slovo a = Slovo a deriving (Eq, Show)
data Abeceda a = Abeceda {unAbeceda :: [Slovo a]} deriving (Eq, Show)
type Rijec a = [Slovo a]

-- |for a list the function constructs the alphabet containing unique elements of the list
lista2abeceda :: Eq a =&gt; [a] -&gt; Abeceda a
lista2abeceda xs=Abeceda [Slovo x|x&lt;-nub xs]

-- |for 2 Enum types (like Char) the function constructs the alphabet from first to second one
enum2abeceda :: (Eq a, Enum a) =&gt; a -&gt; a -&gt; Abeceda a
enum2abeceda a z=lista2abeceda [a..z]

-- |for a list the function constructs the word containing letters in the list
lista2rijec :: (Show a,Eq a) =&gt; [a] -&gt; Rijec a
lista2rijec xs| even (length xs)= [Slovo x|x&lt;-xs]
              | otherwise= error(&quot;The word &quot;++show xs++&quot; doesn't have an even number of letters.&quot;)

-- |for a word the function returns the list of letters in the word
rijec2lista :: Eq a =&gt; Rijec a -&gt; [a]
rijec2lista xs= [x|Slovo x&lt;-xs]

elemAbc :: Eq a =&gt; Slovo a -&gt; Abeceda a -&gt; Bool
elemAbc s (Abeceda a) = elem s a

elemIndexAbc :: Eq a =&gt; Slovo a -&gt; Abeceda a -&gt; Maybe Int
elemIndexAbc s (Abeceda a) = elemIndex s a

sup :: Eq a =&gt; Abeceda a -&gt; Slovo a -&gt; Slovo a -&gt; Slovo a
sup a x y| x `elemIndexAbc` a==Nothing || y `elemIndexAbc` a==Nothing = error(&quot;Letter is not from the alphabet.&quot;)
         | fromJust (x `elemIndexAbc` a) &gt; fromJust(y `elemIndexAbc` a) = x
         | otherwise = y

inf :: Eq a =&gt; Abeceda a -&gt; Slovo a -&gt; Slovo a -&gt; Slovo a
inf a x y| x `elemIndexAbc` a==Nothing || y `elemIndexAbc` a==Nothing = error(&quot;Letter is not from the alphabet.&quot;)
         | fromJust (x `elemIndexAbc` a) &lt; fromJust(y `elemIndexAbc` a) = x
         | otherwise = y

-- |function converting two consecutive lowercase letters to an uppercase letter
zapisu :: String-&gt;String
zapisu []=[]
zapisu [x]=[x]
zapisu (x:y:xs)|isLower x &amp;&amp; x==y = toUpper x:zapisu xs
               |otherwise=x:zapisu (y:xs)

-- |function converting uppercase letter to two consecutive lowercase letters
zapisl :: String-&gt;String
zapisl []=[]
zapisl (x:xs)|isUpper x =x':x':zapisl xs
             |otherwise =x:zapisl xs
             where x'=toLower x

-- string output of a word
class Show a =&gt; Ispisiv a where
    ispis :: Show a =&gt; Rijec a -&gt; String
    ispis []=[]
    ispis [Slovo x]=show x
    ispis (Slovo x:xs)=show x++&quot;-&quot;++ispis xs

instance Show a =&gt; Ispisiv a
instance Ispisiv Char where
    ispis=zapisu.ispis'

ispis' :: Rijec Char -&gt; String
ispis' []=[]
ispis' [Slovo x]=[x]
ispis' (Slovo x:xs)=x:ispis' xs

-- functions returning left and right letters of a word
l :: [Slovo a] -&gt; Slovo a
l = head
d :: [Slovo a] -&gt; Slovo a
d = last

-- |function returning a dual of a letter in an alphabet
dual :: Eq a =&gt; Abeceda a -&gt; Slovo a -&gt; Slovo a
dual (Abeceda []) s = error(&quot;Nema duala - slovo nije u abecedi.&quot;)
dual (Abeceda [c]) s | s==c = c
                     | otherwise = error(&quot;No dual - Letter is not from the alphabet.&quot;)
dual (Abeceda cs) s | s==lijevi = desni
                    | s==desni = lijevi
                    | otherwise = dual (Abeceda (tail (init cs))) s
                     where lijevi= l cs
                           desni= d cs

-- functions returning duals of left/right letters of a word
l' :: Eq a =&gt; Abeceda a -&gt; [Slovo a] -&gt; Slovo a
l' a= (dual a).l
d' :: Eq a =&gt; Abeceda a -&gt; [Slovo a] -&gt; Slovo a
d' a= (dual a).d

ljuska :: [Slovo a]-&gt;[Slovo a]
ljuska xs=[l xs,d xs]


-- |distance between letters in an alphabet
dd :: Eq a =&gt; Abeceda a -&gt; Slovo a -&gt; Slovo a -&gt; Int
dd a x y| m==Nothing || n==Nothing = error(&quot;Cannot calculate distance. Letter is not from the alphabet.&quot;)
        | otherwise = abs (fromJust m-fromJust n)
  where m=x `elemIndexAbc` a
        n=y `elemIndexAbc` a

-- |word length
duljina :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Int
duljina a []=0
duljina a [c]=0
duljina a (c1:c2:cs)= - dd a c1 c2 - duljina a (c2:cs)

-- word shortening
krati1 :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a    -- function shortening a 4 letter word
krati1 a [p,r,s,t] | duljina a [p,r,s,t]==duljina a [p,t] = [p,t]
                 | otherwise = [p,r,s,t]
krati1 _ cs = cs

krati2 :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a     -- function shortening a 4 letter sub-word
krati2 _ [] = []
krati2 a(c:cs) | length kr==2 = kr ++ drop 3 cs
               | otherwise = c : krati2 a cs
               where kr = ((krati1 a).(take 4)) (c:cs)

krati :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a    -- function fully shortening a word
krati a cs | cs/=kr = krati a kr
           | otherwise = cs
           where kr = krati2 a cs

-- symmetries
opD :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opD _ []=[]
opD a (s:t:ys)=dual a s:dual a t:opD a ys

opE :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opE _ []=[]
opE a xs=t:s:opE a ys
        where n=length xs
              t=d xs
              s=xs !! (n-2)
              ys=take (n-2) xs
--opE a (s:t:ys)=opE a ys++[t,s]    --kraÄe, ali nije po formuli iz teksta

opF :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opF a=(opD a).(opE a)

-- permutations
opI :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opI a xs=l xs:xs++[d xs]

-- |negation operator
opK :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opK a xs=l' a xs:xs++[d' a xs]

opG :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opG a xs=d xs:xs++[l xs]

opH :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opH a xs=d' a xs:xs++[l' a xs]

-- serial and parallel conjecture operators
opS :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a -&gt; Rijec a
opS a xs ys = inf a (l xs) (l ys) : inf a (l xs) (l ys) : xs ++
              [sup a (d xs) (l ys),inf a (d xs) (l ys)] ++ ys ++
              [sup a (d xs) (d ys),sup a (d xs) (d ys)]

opP :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a -&gt; Rijec a
opP a xs ys = sup a (l xs) (l ys) : sup a (l xs) (l ys) : xs ++
              [inf a (d xs) (l ys),sup a (d xs) (l ys)] ++ ys ++
              [inf a (d xs) (d ys),inf a (d xs) (d ys)]

-- |partitions
particija :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Char
particija a xs | lijevi&gt;=*lijevi' &amp;&amp; desni&lt;=*desni' &amp;&amp; lijevi&gt;*desni ='T'
               | lijevi&lt;=*lijevi' &amp;&amp; desni&lt;=*desni' &amp;&amp; not (lijevi==lijevi' || desni==desni') ='A'
               | lijevi==lijevi' &amp;&amp; desni==desni' ='0'
               | lijevi&gt;=*lijevi' &amp;&amp; desni&gt;=*desni' &amp;&amp; not (lijevi==lijevi' || desni==desni')  ='Z'
               | lijevi&lt;=*lijevi' &amp;&amp; desni&gt;=*desni' &amp;&amp; lijevi&lt;*desni  ='F'
         where lijevi=l xs
               desni=d xs
               lijevi'=l' a xs
               desni'=d' a xs
               x &gt;* y| m==Nothing || n==Nothing =error(&quot;Letter not in alphabet.&quot;)
                     | otherwise = (fromJust m) &gt; (fromJust n)
                      where m=x `elemIndexAbc` a
                            n=y `elemIndexAbc` a
               x &gt;=* y = x &gt;* y || x==y
               x &lt;* y = not (x &gt;=* y)
               x &lt;=* y = not (x &gt;* y)

-- implications
pimp :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a -&gt; Rijec a
pimp a x y=(opK a x) `opP'` y
    where opP'=opP a

simp :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a -&gt; Rijec a
simp a x y=(opK a x) `opS'` y
    where opS'=opS a

-- equivalencies
pekv :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a -&gt; Rijec a
pekv a x y=(x `pimp'` y) `opS'` (y `pimp'` x)
    where opS'=opS a
          pimp'=pimp a

sekv :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a -&gt; Rijec a
sekv a x y=(x `simp'` y) `opP'` (y `simp'` x)
    where opP'=opP a
          simp'=simp a

-- |tautologies and rules
taut :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt;Rijec a -&gt; Rijec a -&gt; [(String,Char)]
taut a x y z= zip
  [&quot;1.The law of excluded middle (Tertium non datur)&quot;,
  &quot;2.Dual law of excluded middle (The law of non-contradiction)&quot;,
  &quot;3.Transitivity of implication (The rule of syllogism)&quot;,
  &quot;4.Dual low of transitivity of implication&quot;,
  &quot;5.Double negation row&quot;,
  &quot;6.Contraposition law&quot;,
  &quot;7.Dual contraposition law&quot;,
  &quot;8.Absorption law&quot;,
  &quot;9.Dual absorption Law&quot;,
  &quot;10.Modus ponendo ponens&quot;,
  &quot;11.Dual modus ponendo ponens&quot;,
  &quot;12.Modus tollendo tollens&quot;,
  &quot;13.Demonstratio per enumerationem&quot;,
  &quot;14.Proof by contradiction (Reductio ad apsurdum)&quot;]
  (map (particija a) [
    x `opP'` (neg x),
    x `opS'` (neg x),
    ((x `pimp'` y) `opS'` (y `pimp'` z)) `pimp'` (x `pimp'` z),
    ((x `simp'` y) `opP'` (y `simp'` z)) `simp'` (x `simp'` z),
    (neg (neg x)) `pekv'` x,
    (x `pimp'` y) `pimp'` ((neg y) `pimp'` (neg x)),
    (x `simp'` y) `simp'` ((neg y) `simp'` (neg x)),
    (x `opP'` (y `opP'` x)) `pimp'` x,
    (x `opS'` (y `opS'` x)) `simp'` x,
    (x `opS'` (x `pimp'` y)) `pimp'` y,
    (x `opP'` (x `simp'` y)) `simp'` y,
    ((neg x) `opS'` ((neg x) `pimp'` (neg y))) `pimp'` (neg y),
    ((x `pimp'` z) `opS'` (y `pimp'` z)) `pimp'` ((x `opP'` y) `pimp'` z),
    ((x `pimp'` y) `opS'` (x `pimp'` (neg y))) `pimp'` (neg x)
    ]
  )
  where opP'=opP a
        opS'=opS a
        pimp'=pimp a
        simp'=simp a
        pekv'=pekv a
        sekv'=sekv a
        neg=opK a
        
{-# START_FILE Main.hs #-}
module Main where
import Linguistic2

main :: IO ()

-- show Alphabet
main=do let {abc=lista2abeceda ['a'..'z']}         -- &lt;-- CHANGE
-- /show


-- show Words
        let {x=lista2rijec (zapisl &quot;BIRD&quot;);
             y=lista2rijec (zapisl &quot;PINGU&quot;);   -- &lt;-- CHANGE
             z=lista2rijec (zapisl &quot;PENGUIN&quot;);
             w=lista2rijec (zapisl &quot;CHICKEN&quot;);}
-- /show

        let {opPa=opP abc; opSa=opS abc; pimpa=pimp abc; simpa=simp abc; pekva=pekv abc; nega=opK abc; ispiskr=(ispis.(krati abc));}

-- show Word partition
        putStrLn (&quot;Ï(&quot;++ispis x++&quot;)= &quot;++[particija abc x])
        putStrLn (&quot;Ï(&quot;++ispis y++&quot;)= &quot;++[particija abc y])
        putStrLn (&quot;Ï(&quot;++ispis z++&quot;)= &quot;++[particija abc z])
        putStrLn (&quot;Ï(&quot;++ispis w++&quot;)= &quot;++[particija abc w])
-- /show


-- show 1. The law of excluded middle
        putStrLn &quot;The law of excluded middle&quot;
        putStrLn (&quot;Ï(&quot;++ispis x++&quot; `OR` Â¬(&quot;++ispis x++&quot;))\n =Ï(&quot;
          ++ispis x++&quot; `OR` &quot;++ispiskr (nega x)++&quot;)\n =Ï(&quot;
          ++ispiskr (x `opPa` (nega x))++&quot;)\n =&quot;
          ++[particija abc (x `opPa` (nega x))])
-- /show


-- show 2. Dual law of excluded middle
        putStrLn &quot;Dual law of excluded middle&quot;
        putStrLn (&quot;Ï(&quot;++ispis x++&quot; `AND` Â¬(&quot;++ispis x++&quot;))\n =Ï(&quot;
          ++ispis x++&quot; `AND` &quot;++ispiskr (nega x)++&quot;)\n =Ï(&quot;
          ++ispiskr (x `opSa` (nega x))++&quot;)\n =&quot;
          ++[particija abc (x `opSa` (nega x))])
-- /show


-- show 3. Transitivity of implication
        putStrLn &quot;Transitivity of implication&quot;
        putStrLn (&quot;Ï(((&quot;++ispis y++&quot; -p-&gt; &quot;++ispis z++&quot;) `AND` (&quot;++ispis z++&quot; -p-&gt; &quot;++ispis x++&quot;)) -p-&gt; (&quot;++ispis y++&quot; -p-&gt; &quot;++ispis x++&quot;))\n =Ï((&quot;
          ++ispiskr (y `pimpa` z)++&quot; `AND` &quot;++ispiskr (z `pimpa` x)++&quot;) -p-&gt; &quot;++ispiskr (y `pimpa` x)++&quot;)\n =Ï(&quot;
          ++ispiskr ((y `pimpa` z) `opSa` (z `pimpa` x))++&quot; -p-&gt; &quot;++ispiskr (y `pimpa` x)++&quot;)\n =Ï(&quot;
          ++ispiskr (((y `pimpa` z) `opSa` (z `pimpa` x)) `pimpa` (y `pimpa` x))++&quot;)\n =&quot;
          ++[particija abc (((y `pimpa` z) `opSa` (z `pimpa` x)) `pimpa` (y `pimpa` x))])
-- /show


-- show 4. Dual law of transitivity of implication
        putStrLn &quot;Dual law of transitivity of implication&quot;
        putStrLn (&quot;Ï(((&quot;++ispis y++&quot; -s-&gt; &quot;++ispis z++&quot;) `OR` (&quot;++ispis z++&quot; -s-&gt; &quot;++ispis x++&quot;)) -s-&gt; (&quot;++ispis y++&quot; -s-&gt; &quot;++ispis x++&quot;))\n =Ï((&quot;
          ++ispiskr (y `simpa` z)++&quot; `OR` &quot;++ispiskr (z `simpa` x)++&quot;) -s-&gt; &quot;++ispiskr (y `simpa` x)++&quot;)\n =Ï(&quot;
          ++ispiskr ((y `simpa` z) `opPa` (z `simpa` x))++&quot; -s-&gt; &quot;++ispiskr (y `simpa` x)++&quot;)\n =Ï(&quot;
          ++ispiskr (((y `simpa` z) `opPa` (z `simpa` x)) `pimpa` (y `pimpa` x))++&quot;)\n =&quot;
          ++[particija abc (((y `simpa` z) `opPa` (z `simpa` x)) `simpa` (y `simpa` x))])
-- /show


-- show 5. Double negation law
        putStrLn &quot;Double negation law&quot;
        putStrLn (&quot;Ï(Â¬(Â¬(&quot;++ispis x++&quot;)) &lt;=p=&gt; &quot;++ispis x++&quot;)\n =Ï(Â¬(&quot;
          ++ispiskr (nega x)++&quot;) &lt;=p=&gt; &quot;++ispis x++&quot;)\n =Ï(&quot;
          ++ispiskr (nega (nega x))++&quot; &lt;=p=&gt; &quot;++ispis x++&quot;)\n =Ï(&quot;
          ++ispiskr ((nega (nega x)) `pekva` x)++&quot;)\n =&quot;
          ++[particija abc ((nega (nega x)) `pekva` x)])
-- /show


-- show 6. Contraposition law
        putStrLn &quot;Contraposition law&quot;
        putStrLn (&quot;Ï((&quot;++ispis w++&quot; -p-&gt; &quot;++ispis x++&quot;) -p-&gt; (Â¬(&quot;++ispis x++&quot;) -p-&gt; Â¬(&quot;++ispis w++&quot;)))\n =Ï(&quot;
          ++ispiskr (w `pimpa` x)++&quot; -p-&gt; (&quot;++ispis (nega x)++&quot; -p-&gt; &quot;++ispis (nega w)++&quot;))\n =Ï(&quot;
          ++ispiskr (w `pimpa` x)++&quot; -p-&gt; &quot;++ispiskr ((nega x) `pimpa` (nega w))++&quot;)\n =Ï(&quot;
          ++ispiskr ((w `pimpa` x) `pimpa` ((nega x) `pimpa` (nega w)))++&quot;)\n =&quot;
          ++[particija abc ((w `pimpa` x) `pimpa` ((nega x) `pimpa` (nega w)))])
-- /show


-- show 7. Dual contraposition law
        putStrLn &quot;Dual contraposition law&quot;
        putStrLn (&quot;Ï((&quot;++ispis w++&quot; -s-&gt; &quot;++ispis x++&quot;) -s-&gt; (Â¬(&quot;++ispis x++&quot;) -s-&gt; Â¬(&quot;++ispis w++&quot;)))\n =Ï(&quot;
          ++ispiskr (w `simpa` x)++&quot; -s-&gt; (&quot;++ispis (nega x)++&quot; -s-&gt; &quot;++ispis (nega w)++&quot;))\n =Ï(&quot;
          ++ispiskr (w `simpa` x)++&quot; -s-&gt; &quot;++ispiskr ((nega x) `simpa` (nega w))++&quot;)\n =Ï(&quot;
          ++ispiskr ((w `simpa` x) `simpa` ((nega x) `simpa` (nega w)))++&quot;)\n =&quot;
          ++[particija abc ((w `simpa` x) `simpa` ((nega x) `simpa` (nega w)))])
-- /show


-- show 8. Absorption law
        putStrLn &quot;Absorption law&quot;
        putStrLn (&quot;Ï((&quot;++ispis x++&quot; `OR` (&quot;++ispis y++&quot; `AND` &quot;++ispis x++&quot;)) -p-&gt; &quot;++ispis x++&quot;)\n =Ï((&quot;
          ++ispis x++&quot; `OR` &quot;++ispiskr (y `opSa` x)++&quot;) -p-&gt; &quot;++ispis x++&quot;)\n =Ï(&quot;
          ++ispiskr (x `opPa` (y `opSa` x))++&quot;) -p-&gt; &quot;++ispis x++&quot;)\n =Ï(&quot;
          ++ispiskr ((x `opPa` (y `opSa` x)) `pimpa` x)++&quot;)\n =&quot;
          ++[particija abc ((x `opPa` (y `opSa` x)) `pimpa` x)])
-- /show


-- show 9. Dual absorption law
        putStrLn (&quot;Ï((&quot;++ispis x++&quot; `AND` (&quot;++ispis y++&quot; `OR` &quot;++ispis x++&quot;)) -s-&gt; &quot;++ispis x++&quot;)\n =Ï((&quot;
          ++ispis x++&quot; `AND` &quot;++ispiskr (y `opPa` x)++&quot;) -s-&gt; &quot;++ispis x++&quot;)\n =Ï(&quot;
          ++ispiskr (x `opSa` (y `opPa` x))++&quot;) -s-&gt; &quot;++ispis x++&quot;)\n =Ï(&quot;
          ++ispiskr ((x `opSa` (y `opPa` x)) `simpa` x)++&quot;)\n =&quot;
          ++[particija abc ((x `opSa` (y `opPa` x)) `simpa` x)])
-- /show


-- show 10. Modus ponendo ponens
        putStrLn &quot;Modus ponendo ponens&quot;
        putStrLn (&quot;Ï((&quot;++ispis w++&quot; `AND` (&quot;++ispis w++&quot; -p-&gt; &quot;++ispis x++&quot;)) -p-&gt; &quot;++ispis x++&quot;)\n =Ï((&quot;
          ++ispis w++&quot; `AND` &quot;++ispiskr (w `pimpa` x)++&quot;) -p-&gt; &quot;++ispis x++&quot;)\n =Ï((&quot;
          ++ispiskr (w `opSa` (w `pimpa` x))++&quot;) -p-&gt; &quot;++ispis x++&quot;)\n =Ï(&quot;
          ++ispiskr ((w `opSa` (w `pimpa` x)) `pimpa` x)++&quot;)\n =&quot;
          ++[particija abc ((w `opSa` (w `pimpa` x)) `pimpa` x)])
-- /show


-- show 11. Dual modus ponendo ponens
        putStrLn &quot;Dual modus ponendo ponens&quot;
        putStrLn (&quot;Ï((&quot;++ispis w++&quot; `OR` (&quot;++ispis w++&quot; -s-&gt; &quot;++ispis x++&quot;)) -s-&gt; &quot;++ispis x++&quot;)\n =Ï((&quot;
          ++ispis w++&quot; `OR` &quot;++ispiskr (w `simpa` x)++&quot;) -s-&gt; &quot;++ispis x++&quot;)\n =Ï((&quot;
          ++ispiskr (w `opPa` (w `simpa` x))++&quot;) -s-&gt; &quot;++ispis x++&quot;)\n =Ï(&quot;
          ++ispiskr ((w `opPa` (w `simpa` x)) `simpa` x)++&quot;)\n =&quot;
          ++[particija abc ((w `opPa` (w `simpa` x)) `simpa` x)])
-- /show


-- show 12. Modus tollendo tollens
        putStrLn &quot;Modus tollendo tollens&quot;
        putStrLn (&quot;Ï((Â¬(&quot;++ispis w++&quot;) `AND` (Â¬(&quot;++ispis w++&quot;) -p-&gt; Â¬(&quot;++ispis x++&quot;))) -p-&gt; Â¬(&quot;++ispis x++&quot;))\n =Ï((&quot;
                  ++ispis (nega w)++&quot; `AND` (&quot;++ispis (nega w)++&quot; -p-&gt; &quot;++ispis (nega x)++&quot;)) -p-&gt; &quot;++ispis (nega x)++&quot;)\n =Ï((&quot;
          ++ispis (nega w)++&quot; `AND` &quot;++ispiskr ((nega w) `pimpa` (nega x))++&quot;) -p-&gt; &quot;++ispis (nega x)++&quot;)\n =Ï((&quot;
          ++ispiskr ((nega w) `opSa` ((nega w) `pimpa` (nega x)))++&quot;) -p-&gt; &quot;++ispis (nega x)++&quot;)\n =Ï(&quot;
          ++ispiskr (((nega w) `opSa` ((nega w) `pimpa` (nega x))) `pimpa` (nega x))++&quot;)\n =&quot;
          ++[particija abc (((nega w) `opSa` ((nega w) `pimpa` (nega x))) `pimpa` (nega x))])
-- /show


-- show 13. Demonstratio per enumerationem
        putStrLn &quot;Demonstratio per enumerationem&quot;
        putStrLn (&quot;Ï(((&quot;++ispis z++&quot; -p-&gt; &quot;++ispis x++&quot;) `AND` (&quot;++ispis w++&quot; -p-&gt; &quot;++ispis x++&quot;)) -p-&gt; ((&quot;++ispis z++&quot; `OR` &quot;++ispis w++&quot;) -p-&gt; &quot;++ispis x++&quot;))\n =Ï((&quot;
          ++ispiskr (z `pimpa` x)++&quot; `AND` &quot;++ispiskr (w `pimpa` x)++&quot;) -p-&gt; (&quot;++ispiskr (z `opPa` w)++&quot; -p-&gt; &quot;++ispis x++&quot;))\n =Ï(&quot;
          ++ispiskr ((z `pimpa` x) `opSa` (w `pimpa` x))++&quot; -p-&gt; &quot;++ispiskr ((z `opPa` w) `pimpa` x)++&quot;)\n =Ï(&quot;
          ++ispiskr (((z `pimpa` x) `opSa` (w `pimpa` x)) `pimpa` ((z `opPa` w) `pimpa` x))++&quot;)\n =&quot;
          ++[particija abc (((z `pimpa` x) `opSa` (w `pimpa` x)) `pimpa` ((z `opPa` w) `pimpa` x))])
-- /show


-- show 14. Proof by contradiction
        putStrLn &quot;Proof by contradiction&quot;
        putStrLn (&quot;Ï(((&quot;++ispis x++&quot; -p-&gt; &quot;++ispis y++&quot;) `AND` (&quot;++ispis x++&quot; -p-&gt; Â¬(&quot;++ispis y++&quot;))) -p-&gt; Â¬(&quot;++ispis x++&quot;))\n =Ï(((&quot;
          ++ispis x++&quot; -p-&gt; &quot;++ispis y++&quot;) `AND` (&quot;++ispis x++&quot; -p-&gt; &quot;++ispis (nega y)++&quot;)) -p-&gt; Â¬(&quot;++ispis x++&quot;))\n =Ï((&quot;
          ++ispiskr (x `pimpa` y)++&quot;) `AND` (&quot;++ispiskr (x `pimpa` (nega y))++&quot;)) -p-&gt; &quot;++ispis (nega x)++&quot;)\n =Ï(&quot;
          ++ispiskr ((x `pimpa` y) `opSa` (x `pimpa` (nega y)))++&quot;)) -p-&gt; &quot;++ispis (nega x)++&quot;)\n =Ï(&quot;
                  ++ispiskr (((x `pimpa` y) `opSa` (x `pimpa` (nega y))) `pimpa` (nega x))++&quot;)\n =&quot;
          ++[particija abc (((x `pimpa` y) `opSa` (x `pimpa` (nega y))) `pimpa` (nega x))])
-- /show</code></pre><h2 id="appendix"><a href="#appendix">Appendix</a></h2><h3 id="operator-tables"><a href="#operator-tables">Operator tables</a></h3><pre><code class="active haskell">{-# START_FILE Linguistic2.hs #-}
-- show
-- /show
{-# LANGUAGE UndecidableInstances, FlexibleInstances, OverlappingInstances, IncoherentInstances #-}
module Linguistic2 where

import           Data.Char  (chr, isLower, isUpper, ord, toLower, toUpper)
import           Data.List  (elemIndex, nub)
import           Data.Maybe (fromJust)

-- alphabet type definition and constructors
data Slovo a = Slovo a deriving (Eq, Show)
data Abeceda a = Abeceda {unAbeceda :: [Slovo a]} deriving (Eq, Show)
type Rijec a = [Slovo a]

-- |for a list the function constructs the alphabet containing unique elements of the list
lista2abeceda :: Eq a =&gt; [a] -&gt; Abeceda a
lista2abeceda xs=Abeceda [Slovo x|x&lt;-nub xs]

-- |for 2 Enum types (like Char) the function constructs the alphabet from first to second one
enum2abeceda :: (Eq a, Enum a) =&gt; a -&gt; a -&gt; Abeceda a
enum2abeceda a z=lista2abeceda [a..z]

-- |for a list the function constructs the word containing letters in the list
lista2rijec :: (Show a,Eq a) =&gt; [a] -&gt; Rijec a
lista2rijec xs| even (length xs)= [Slovo x|x&lt;-xs]
              | otherwise= error(&quot;The word &quot;++show xs++&quot; doesn't have an even number of letters.&quot;)

-- |for a word the function returns the list of letters in the word
rijec2lista :: Eq a =&gt; Rijec a -&gt; [a]
rijec2lista xs= [x|Slovo x&lt;-xs]

elemAbc :: Eq a =&gt; Slovo a -&gt; Abeceda a -&gt; Bool
elemAbc s (Abeceda a) = elem s a

elemIndexAbc :: Eq a =&gt; Slovo a -&gt; Abeceda a -&gt; Maybe Int
elemIndexAbc s (Abeceda a) = elemIndex s a

sup :: Eq a =&gt; Abeceda a -&gt; Slovo a -&gt; Slovo a -&gt; Slovo a
sup a x y| x `elemIndexAbc` a==Nothing || y `elemIndexAbc` a==Nothing = error(&quot;Letter is not from the alphabet.&quot;)
         | fromJust (x `elemIndexAbc` a) &gt; fromJust(y `elemIndexAbc` a) = x
         | otherwise = y

inf :: Eq a =&gt; Abeceda a -&gt; Slovo a -&gt; Slovo a -&gt; Slovo a
inf a x y| x `elemIndexAbc` a==Nothing || y `elemIndexAbc` a==Nothing = error(&quot;Letter is not from the alphabet.&quot;)
         | fromJust (x `elemIndexAbc` a) &lt; fromJust(y `elemIndexAbc` a) = x
         | otherwise = y

-- |function converting two consecutive lowercase letters to an uppercase letter
zapisu :: String-&gt;String
zapisu []=[]
zapisu [x]=[x]
zapisu (x:y:xs)|isLower x &amp;&amp; x==y = toUpper x:zapisu xs
               |otherwise=x:zapisu (y:xs)

-- |function converting uppercase letter to two consecutive lowercase letters
zapisl :: String-&gt;String
zapisl []=[]
zapisl (x:xs)|isUpper x =x':x':zapisl xs
             |otherwise =x:zapisl xs
             where x'=toLower x

-- string output of a word
class Show a =&gt; Ispisiv a where
    ispis :: Show a =&gt; Rijec a -&gt; String
    ispis []=[]
    ispis [Slovo x]=show x
    ispis (Slovo x:xs)=show x++&quot;-&quot;++ispis xs

instance Show a =&gt; Ispisiv a
instance Ispisiv Char where
    ispis=zapisu.ispis'

ispis' :: Rijec Char -&gt; String
ispis' []=[]
ispis' [Slovo x]=[x]
ispis' (Slovo x:xs)=x:ispis' xs

-- functions returning left and right letters of a word
l :: [Slovo a] -&gt; Slovo a
l = head
d :: [Slovo a] -&gt; Slovo a
d = last

-- |function returning a dual of a letter in an alphabet
dual :: Eq a =&gt; Abeceda a -&gt; Slovo a -&gt; Slovo a
dual (Abeceda []) s = error(&quot;Nema duala - slovo nije u abecedi.&quot;)
dual (Abeceda [c]) s | s==c = c
                     | otherwise = error(&quot;No dual - Letter is not from the alphabet.&quot;)
dual (Abeceda cs) s | s==lijevi = desni
                    | s==desni = lijevi
                    | otherwise = dual (Abeceda (tail (init cs))) s
                     where lijevi= l cs
                           desni= d cs

-- functions returning duals of left/right letters of a word
l' :: Eq a =&gt; Abeceda a -&gt; [Slovo a] -&gt; Slovo a
l' a= (dual a).l
d' :: Eq a =&gt; Abeceda a -&gt; [Slovo a] -&gt; Slovo a
d' a= (dual a).d

ljuska :: [Slovo a]-&gt;[Slovo a]
ljuska xs=[l xs,d xs]


-- |distance between letters in an alphabet
dd :: Eq a =&gt; Abeceda a -&gt; Slovo a -&gt; Slovo a -&gt; Int
dd a x y| m==Nothing || n==Nothing = error(&quot;Cannot calculate distance. Letter is not from the alphabet.&quot;)
        | otherwise = abs (fromJust m-fromJust n)
  where m=x `elemIndexAbc` a
        n=y `elemIndexAbc` a

-- |word length
duljina :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Int
duljina a []=0
duljina a [c]=0
duljina a (c1:c2:cs)= - dd a c1 c2 - duljina a (c2:cs)

-- word shortening
krati1 :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a    -- function shortening a 4 letter word
krati1 a [p,r,s,t] | duljina a [p,r,s,t]==duljina a [p,t] = [p,t]
                 | otherwise = [p,r,s,t]
krati1 _ cs = cs

krati2 :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a     -- function shortening a 4 letter sub-word
krati2 _ [] = []
krati2 a(c:cs) | length kr==2 = kr ++ drop 3 cs
               | otherwise = c : krati2 a cs
               where kr = ((krati1 a).(take 4)) (c:cs)

krati :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a    -- function fully shortening a word
krati a cs | cs/=kr = krati a kr
           | otherwise = cs
           where kr = krati2 a cs

-- symmetries
opD :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opD _ []=[]
opD a (s:t:ys)=dual a s:dual a t:opD a ys

opE :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opE _ []=[]
opE a xs=t:s:opE a ys
        where n=length xs
              t=d xs
              s=xs !! (n-2)
              ys=take (n-2) xs
--opE a (s:t:ys)=opE a ys++[t,s]    --kraÄe, ali nije po formuli iz teksta

opF :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opF a=(opD a).(opE a)

-- permutations
opI :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opI a xs=l xs:xs++[d xs]

-- |negation operator
opK :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opK a xs=l' a xs:xs++[d' a xs]

opG :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opG a xs=d xs:xs++[l xs]

opH :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opH a xs=d' a xs:xs++[l' a xs]

-- serial and parallel conjecture operators
opS :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a -&gt; Rijec a
opS a xs ys = inf a (l xs) (l ys) : inf a (l xs) (l ys) : xs ++
              [sup a (d xs) (l ys),inf a (d xs) (l ys)] ++ ys ++
              [sup a (d xs) (d ys),sup a (d xs) (d ys)]

opP :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a -&gt; Rijec a
opP a xs ys = sup a (l xs) (l ys) : sup a (l xs) (l ys) : xs ++
              [inf a (d xs) (l ys),sup a (d xs) (l ys)] ++ ys ++
              [inf a (d xs) (d ys),inf a (d xs) (d ys)]

-- |partitions
particija :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Char
particija a xs | lijevi&gt;=*lijevi' &amp;&amp; desni&lt;=*desni' &amp;&amp; lijevi&gt;*desni ='T'
               | lijevi&lt;=*lijevi' &amp;&amp; desni&lt;=*desni' &amp;&amp; not (lijevi==lijevi' || desni==desni') ='A'
               | lijevi==lijevi' &amp;&amp; desni==desni' ='0'
               | lijevi&gt;=*lijevi' &amp;&amp; desni&gt;=*desni' &amp;&amp; not (lijevi==lijevi' || desni==desni')  ='Z'
               | lijevi&lt;=*lijevi' &amp;&amp; desni&gt;=*desni' &amp;&amp; lijevi&lt;*desni  ='F'
         where lijevi=l xs
               desni=d xs
               lijevi'=l' a xs
               desni'=d' a xs
               x &gt;* y| m==Nothing || n==Nothing =error(&quot;Letter not in alphabet.&quot;)
                     | otherwise = (fromJust m) &gt; (fromJust n)
                      where m=x `elemIndexAbc` a
                            n=y `elemIndexAbc` a
               x &gt;=* y = x &gt;* y || x==y
               x &lt;* y = not (x &gt;=* y)
               x &lt;=* y = not (x &gt;* y)

-- implications
pimp :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a -&gt; Rijec a
pimp a x y=(opK a x) `opP'` y
    where opP'=opP a

simp :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a -&gt; Rijec a
simp a x y=(opK a x) `opS'` y
    where opS'=opS a

-- equivalencies
pekv :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a -&gt; Rijec a
pekv a x y=(x `pimp'` y) `opS'` (y `pimp'` x)
    where opS'=opS a
          pimp'=pimp a

sekv :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a -&gt; Rijec a
sekv a x y=(x `simp'` y) `opP'` (y `simp'` x)
    where opP'=opP a
          simp'=simp a

-- |tautologies and rules
taut :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt;Rijec a -&gt; Rijec a -&gt; [(String,Char)]
taut a x y z= zip
  [&quot;1.ZAKON ISKLJUCENJA TRECEG&quot;,
  &quot;2.DUAL ZAKONA ISKLJUCENJA TRECEG&quot;,
  &quot;3.TRANZITIVNOST IMPLIKACIJE&quot;,
  &quot;4.DUAL TRANZITIVNOSTI IMPLIKACIJE&quot;,
  &quot;5.ZAKON DVOSTRUKE NEGACIJE&quot;,
  &quot;6.ZAKON KONTRAPOZICIJE&quot;,
  &quot;7.DUAL ZAKONA KONTRAPOZICIJE&quot;,
  &quot;8.ZAKON APSORPCIJE ILI UPIJANJA&quot;,
  &quot;9.DUAL ZAKONA APSORPCIJE ILI UPIJANJA&quot;,
  &quot;10.MODUS PONENDO PONENS&quot;,
  &quot;11.DUAL MODUSA PONENDO PONENS&quot;,
  &quot;12.MODUS TOLENDO TOLLENS&quot;,
  &quot;13.DOKAZ NABRAJANJEM&quot;,
  &quot;14.DOVODJENJE DO PROTURJECJA&quot;]
  (map (particija a) [
    x `opP'` (neg x),
    x `opS'` (neg x),
    ((x `pimp'` y) `opS'` (y `pimp'` z)) `pimp'` (x `pimp'` z),
    ((x `simp'` y) `opP'` (y `simp'` z)) `simp'` (x `simp'` z),
    (neg (neg x)) `pekv'` x,
    (x `pimp'` y) `pimp'` ((neg y) `pimp'` (neg x)),
    (x `simp'` y) `simp'` ((neg y) `simp'` (neg x)),
    (x `opP'` (y `opP'` x)) `pimp'` x,
    (x `opS'` (y `opS'` x)) `simp'` x,
    (x `opS'` (x `pimp'` y)) `pimp'` y,
    (x `opP'` (x `simp'` y)) `simp'` y,
    ((neg x) `opS'` ((neg x) `pimp'` (neg y))) `pimp'` (neg y),
    ((x `pimp'` z) `opS'` (y `pimp'` z)) `pimp'` ((x `opP'` y) `pimp'` z),
    ((x `pimp'` y) `opS'` (x `pimp'` (neg y))) `pimp'` (neg x)
    ]
  )
  where opP'=opP a
        opS'=opS a
        pimp'=pimp a
        simp'=simp a
        pekv'=pekv a
        sekv'=sekv a
        neg=opK a
        
{-# START_FILE Main.hs #-}
{-# LANGUAGE UndecidableInstances, FlexibleInstances, OverlappingInstances, IncoherentInstances #-}
module Main where
import Linguistic2

main :: IO ()

-- show Set alphabet, row and column headers and the binary operator for the table.
main=do let {abc = lista2abeceda ['a'..'c'];                  -- &lt;-- CHANGE
             red = map lista2rijec [&quot;aa&quot;,&quot;bb&quot;,&quot;cc&quot;];         -- &lt;-- CHANGE
             stupac = map lista2rijec [&quot;aa&quot;,&quot;bb&quot;,&quot;cc&quot;];      -- &lt;-- CHANGE
             opName = &quot;OP&quot;;
             operator = (\a x y-&gt;let opDa=opD a; opEa=opE a; opFa=opF a; neg=opK a; opPa=opP a; opSa=opS a; pimpa=pimp a; simpa=simp a; pekva=pekv a; sekva=sekv a; in 
                                        ((x `opSa` y) `simpa` y)   -- &lt;-- CHANGE
                                        );}
-- /show


-- show Formatting (latex -&gt; regular table or LaTeX; printShell -&gt; show just shell or the whole result)
        let {latex=False;            -- &lt;-- CHANGE
             printShell=True;}      -- &lt;-- CHANGE
-- /show

        let {operator'=(if printShell then (opLjuska operator) else operator);
             n=length stupac;
             prije=(if latex then &quot;\\begin{tabular}{|c|&quot;++replicate n 'c'++&quot;|}\n\\hline\n&quot; else &quot;&quot;);
             sep=(if latex then &quot;&amp; &quot; else &quot; &quot;);
             sepRed=(if latex then &quot;\\hline\n&quot; else (replicate ((n+1)*11) '-'++&quot;\n&quot;));
             eol=(if latex then &quot;\\\\\n&quot; else &quot;\n&quot;);
             poslije=(if latex then &quot;\\hline\n\\end{tabular}&quot; else &quot;&quot;);
             tablica=[(zapisl.ispis) x:[(zapisl.ispis.(krati abc)) (operator' abc x y)|y&lt;-stupac]|x&lt;-red];
             ispisKraj=prije++redIspis (sep,eol) (opName:(map (zapisl.ispis) stupac))++sepRed++concat [redIspis (sep,eol) x|x&lt;-tablica]++poslije;
             }
        putStrLn ispisKraj

opLjuska op=(\a x y-&gt;ljuska (op a x y)) -- funkcija koja na operator joÅ¡ primjenjuje ljusku
-- opBroj op=(fst op, (\a x y-&gt;perm2broj a (ljuska ((snd op) a x y)))) -- funkcija koja na operator joÅ¡ primjenjuje ljusku i zamjenjuje elemente brojevima

perm :: Abeceda a -&gt; [Rijec a]
perm abc = [[x,y]|x&lt;-a,y&lt;-a]
           where a=unAbeceda abc

perm' :: Abeceda a -&gt; [Rijec a]
perm' abc = [[x,y]|x&lt;-reverse a,y&lt;-a]
           where a=unAbeceda abc

-- perm2broj :: Eq a =&gt; Abeceda a-&gt;Rijec a-&gt;String
-- perm2broj a xs=head [c|(b,c)&lt;-zip (perm a) [show n|n&lt;-[1..]],b==xs]

-- |for a given separator, end of line string and list returns a line string
redIspis::(String,String)-&gt;[String]-&gt;String
redIspis (_,eol) [xs]=make10 xs++eol
redIspis (sep,eol) (xs:xss)=make10 xs ++ sep ++ redIspis (sep,eol) xss

make10::String-&gt;String
make10 xs| n&lt;10      =xs++replicate (10-n) ' '
         | otherwise =xs
  where n=length xs</code></pre><h3 id="example"><a href="#example">Example</a></h3><p>This example shows partitions of a 2-generator alphabet and truth tables for the set operator</p><pre><code class="active haskell">{-# START_FILE Linguistic2.hs #-}
-- show
-- /show
{-# LANGUAGE UndecidableInstances, FlexibleInstances, OverlappingInstances, IncoherentInstances #-}
module Linguistic2 where

import           Data.Char  (chr, isLower, isUpper, ord, toLower, toUpper)
import           Data.List  (elemIndex, nub)
import           Data.Maybe (fromJust)

-- alphabet type definition and constructors
data Slovo a = Slovo a deriving (Eq, Show)
data Abeceda a = Abeceda {unAbeceda :: [Slovo a]} deriving (Eq, Show)
type Rijec a = [Slovo a]

-- |for a list the function constructs the alphabet containing unique elements of the list
lista2abeceda :: Eq a =&gt; [a] -&gt; Abeceda a
lista2abeceda xs=Abeceda [Slovo x|x&lt;-nub xs]

-- |for 2 Enum types (like Char) the function constructs the alphabet from first to second one
enum2abeceda :: (Eq a, Enum a) =&gt; a -&gt; a -&gt; Abeceda a
enum2abeceda a z=lista2abeceda [a..z]

-- |for a list the function constructs the word containing letters in the list
lista2rijec :: (Show a,Eq a) =&gt; [a] -&gt; Rijec a
lista2rijec xs| even (length xs)= [Slovo x|x&lt;-xs]
              | otherwise= error(&quot;The word &quot;++show xs++&quot; doesn't have an even number of letters.&quot;)

-- |for a word the function returns the list of letters in the word
rijec2lista :: Eq a =&gt; Rijec a -&gt; [a]
rijec2lista xs= [x|Slovo x&lt;-xs]

elemAbc :: Eq a =&gt; Slovo a -&gt; Abeceda a -&gt; Bool
elemAbc s (Abeceda a) = elem s a

elemIndexAbc :: Eq a =&gt; Slovo a -&gt; Abeceda a -&gt; Maybe Int
elemIndexAbc s (Abeceda a) = elemIndex s a

sup :: Eq a =&gt; Abeceda a -&gt; Slovo a -&gt; Slovo a -&gt; Slovo a
sup a x y| x `elemIndexAbc` a==Nothing || y `elemIndexAbc` a==Nothing = error(&quot;Letter is not from the alphabet.&quot;)
         | fromJust (x `elemIndexAbc` a) &gt; fromJust(y `elemIndexAbc` a) = x
         | otherwise = y

inf :: Eq a =&gt; Abeceda a -&gt; Slovo a -&gt; Slovo a -&gt; Slovo a
inf a x y| x `elemIndexAbc` a==Nothing || y `elemIndexAbc` a==Nothing = error(&quot;Letter is not from the alphabet.&quot;)
         | fromJust (x `elemIndexAbc` a) &lt; fromJust(y `elemIndexAbc` a) = x
         | otherwise = y

-- |function converting two consecutive lowercase letters to an uppercase letter
zapisu :: String-&gt;String
zapisu []=[]
zapisu [x]=[x]
zapisu (x:y:xs)|isLower x &amp;&amp; x==y = toUpper x:zapisu xs
               |otherwise=x:zapisu (y:xs)

-- |function converting uppercase letter to two consecutive lowercase letters
zapisl :: String-&gt;String
zapisl []=[]
zapisl (x:xs)|isUpper x =x':x':zapisl xs
             |otherwise =x:zapisl xs
             where x'=toLower x

-- string output of a word
class Show a =&gt; Ispisiv a where
    ispis :: Show a =&gt; Rijec a -&gt; String
    ispis []=[]
    ispis [Slovo x]=show x
    ispis (Slovo x:xs)=show x++&quot;-&quot;++ispis xs

instance Show a =&gt; Ispisiv a
instance Ispisiv Char where
    ispis=zapisu.ispis'

ispis' :: Rijec Char -&gt; String
ispis' []=[]
ispis' [Slovo x]=[x]
ispis' (Slovo x:xs)=x:ispis' xs

-- functions returning left and right letters of a word
l :: [Slovo a] -&gt; Slovo a
l = head
d :: [Slovo a] -&gt; Slovo a
d = last

-- |function returning a dual of a letter in an alphabet
dual :: Eq a =&gt; Abeceda a -&gt; Slovo a -&gt; Slovo a
dual (Abeceda []) s = error(&quot;Nema duala - slovo nije u abecedi.&quot;)
dual (Abeceda [c]) s | s==c = c
                     | otherwise = error(&quot;No dual - Letter is not from the alphabet.&quot;)
dual (Abeceda cs) s | s==lijevi = desni
                    | s==desni = lijevi
                    | otherwise = dual (Abeceda (tail (init cs))) s
                     where lijevi= l cs
                           desni= d cs

-- functions returning duals of left/right letters of a word
l' :: Eq a =&gt; Abeceda a -&gt; [Slovo a] -&gt; Slovo a
l' a= (dual a).l
d' :: Eq a =&gt; Abeceda a -&gt; [Slovo a] -&gt; Slovo a
d' a= (dual a).d

ljuska :: [Slovo a]-&gt;[Slovo a]
ljuska xs=[l xs,d xs]


-- |distance between letters in an alphabet
dd :: Eq a =&gt; Abeceda a -&gt; Slovo a -&gt; Slovo a -&gt; Int
dd a x y| m==Nothing || n==Nothing = error(&quot;Cannot calculate distance. Letter is not from the alphabet.&quot;)
        | otherwise = abs (fromJust m-fromJust n)
  where m=x `elemIndexAbc` a
        n=y `elemIndexAbc` a

-- |word length
duljina :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Int
duljina a []=0
duljina a [c]=0
duljina a (c1:c2:cs)= - dd a c1 c2 - duljina a (c2:cs)

-- word shortening
krati1 :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a    -- function shortening a 4 letter word
krati1 a [p,r,s,t] | duljina a [p,r,s,t]==duljina a [p,t] = [p,t]
                 | otherwise = [p,r,s,t]
krati1 _ cs = cs

krati2 :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a     -- function shortening a 4 letter sub-word
krati2 _ [] = []
krati2 a(c:cs) | length kr==2 = kr ++ drop 3 cs
               | otherwise = c : krati2 a cs
               where kr = ((krati1 a).(take 4)) (c:cs)

krati :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a    -- function fully shortening a word
krati a cs | cs/=kr = krati a kr
           | otherwise = cs
           where kr = krati2 a cs

-- symmetries
opD :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opD _ []=[]
opD a (s:t:ys)=dual a s:dual a t:opD a ys

opE :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opE _ []=[]
opE a xs=t:s:opE a ys
        where n=length xs
              t=d xs
              s=xs !! (n-2)
              ys=take (n-2) xs
--opE a (s:t:ys)=opE a ys++[t,s]    --kraÄe, ali nije po formuli iz teksta

opF :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opF a=(opD a).(opE a)

-- permutations
opI :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opI a xs=l xs:xs++[d xs]

-- |negation operator
opK :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opK a xs=l' a xs:xs++[d' a xs]

opG :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opG a xs=d xs:xs++[l xs]

opH :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opH a xs=d' a xs:xs++[l' a xs]

-- serial and parallel conjecture operators
opS :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a -&gt; Rijec a
opS a xs ys = inf a (l xs) (l ys) : inf a (l xs) (l ys) : xs ++
              [sup a (d xs) (l ys),inf a (d xs) (l ys)] ++ ys ++
              [sup a (d xs) (d ys),sup a (d xs) (d ys)]

opP :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a -&gt; Rijec a
opP a xs ys = sup a (l xs) (l ys) : sup a (l xs) (l ys) : xs ++
              [inf a (d xs) (l ys),sup a (d xs) (l ys)] ++ ys ++
              [inf a (d xs) (d ys),inf a (d xs) (d ys)]

-- |partitions
particija :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Char
particija a xs | lijevi&gt;=*lijevi' &amp;&amp; desni&lt;=*desni' &amp;&amp; lijevi&gt;*desni ='T'
               | lijevi&lt;=*lijevi' &amp;&amp; desni&lt;=*desni' &amp;&amp; not (lijevi==lijevi' || desni==desni') ='A'
               | lijevi==lijevi' &amp;&amp; desni==desni' ='0'
               | lijevi&gt;=*lijevi' &amp;&amp; desni&gt;=*desni' &amp;&amp; not (lijevi==lijevi' || desni==desni')  ='Z'
               | lijevi&lt;=*lijevi' &amp;&amp; desni&gt;=*desni' &amp;&amp; lijevi&lt;*desni  ='F'
         where lijevi=l xs
               desni=d xs
               lijevi'=l' a xs
               desni'=d' a xs
               x &gt;* y| m==Nothing || n==Nothing =error(&quot;Letter not in alphabet.&quot;)
                     | otherwise = (fromJust m) &gt; (fromJust n)
                      where m=x `elemIndexAbc` a
                            n=y `elemIndexAbc` a
               x &gt;=* y = x &gt;* y || x==y
               x &lt;* y = not (x &gt;=* y)
               x &lt;=* y = not (x &gt;* y)

-- implications
pimp :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a -&gt; Rijec a
pimp a x y=(opK a x) `opP'` y
    where opP'=opP a

simp :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a -&gt; Rijec a
simp a x y=(opK a x) `opS'` y
    where opS'=opS a

-- equivalencies
pekv :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a -&gt; Rijec a
pekv a x y=(x `pimp'` y) `opS'` (y `pimp'` x)
    where opS'=opS a
          pimp'=pimp a

sekv :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a -&gt; Rijec a
sekv a x y=(x `simp'` y) `opP'` (y `simp'` x)
    where opP'=opP a
          simp'=simp a

-- |tautologies and rules
taut :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt;Rijec a -&gt; Rijec a -&gt; [(String,Char)]
taut a x y z= zip
  [&quot;1.ZAKON ISKLJUCENJA TRECEG&quot;,
  &quot;2.DUAL ZAKONA ISKLJUCENJA TRECEG&quot;,
  &quot;3.TRANZITIVNOST IMPLIKACIJE&quot;,
  &quot;4.DUAL TRANZITIVNOSTI IMPLIKACIJE&quot;,
  &quot;5.ZAKON DVOSTRUKE NEGACIJE&quot;,
  &quot;6.ZAKON KONTRAPOZICIJE&quot;,
  &quot;7.DUAL ZAKONA KONTRAPOZICIJE&quot;,
  &quot;8.ZAKON APSORPCIJE ILI UPIJANJA&quot;,
  &quot;9.DUAL ZAKONA APSORPCIJE ILI UPIJANJA&quot;,
  &quot;10.MODUS PONENDO PONENS&quot;,
  &quot;11.DUAL MODUSA PONENDO PONENS&quot;,
  &quot;12.MODUS TOLENDO TOLLENS&quot;,
  &quot;13.DOKAZ NABRAJANJEM&quot;,
  &quot;14.DOVODJENJE DO PROTURJECJA&quot;]
  (map (particija a) [
    x `opP'` (neg x),
    x `opS'` (neg x),
    ((x `pimp'` y) `opS'` (y `pimp'` z)) `pimp'` (x `pimp'` z),
    ((x `simp'` y) `opP'` (y `simp'` z)) `simp'` (x `simp'` z),
    (neg (neg x)) `pekv'` x,
    (x `pimp'` y) `pimp'` ((neg y) `pimp'` (neg x)),
    (x `simp'` y) `simp'` ((neg y) `simp'` (neg x)),
    (x `opP'` (y `opP'` x)) `pimp'` x,
    (x `opS'` (y `opS'` x)) `simp'` x,
    (x `opS'` (x `pimp'` y)) `pimp'` y,
    (x `opP'` (x `simp'` y)) `simp'` y,
    ((neg x) `opS'` ((neg x) `pimp'` (neg y))) `pimp'` (neg y),
    ((x `pimp'` z) `opS'` (y `pimp'` z)) `pimp'` ((x `opP'` y) `pimp'` z),
    ((x `pimp'` y) `opS'` (x `pimp'` (neg y))) `pimp'` (neg x)
    ]
  )
  where opP'=opP a
        opS'=opS a
        pimp'=pimp a
        simp'=simp a
        pekv'=pekv a
        sekv'=sekv a
        neg=opK a
        
{-# START_FILE Main.hs #-}
{-# LANGUAGE UndecidableInstances, FlexibleInstances, OverlappingInstances, IncoherentInstances #-}
module Main where
import Linguistic2

main :: IO ()

-- show Set alphabet, row and column headers and the binary operator for the table.
main=do let {abc = lista2abeceda ['a'..'b'];                  -- &lt;-- CHANGE
             red = [map lista2rijec x| x&lt;-[[&quot;ba&quot;],[&quot;aa&quot;,&quot;bb&quot;],[&quot;ab&quot;]]];         -- &lt;-- CHANGE
             stupac = red;       -- &lt;-- CHANGE
             opName = &quot;AND&quot;;
             operator = (\a x y-&gt;let opDa=opD a; opEa=opE a; opFa=opF a; neg=opK a; opPa=opP a; opSa=opS a; pimpa=pimp a; simpa=simp a; pekva=pekv a; sekva=sekv a; in 
                                        (x `opSa` y)   -- &lt;-- CHANGE
                                        );}
-- /show


-- show Formatting (latex -&gt; regular table or LaTeX; printShell -&gt; show just shell or the whole result)
        let {latex=False;            -- &lt;-- CHANGE
             printShell=True;        -- &lt;-- CHANGE
             printPartition=False;}  -- &lt;-- CHANGE
-- /show

        let {tab=[([x,y],particija abc [x,y])|x &lt;- unAbeceda abc,y &lt;- unAbeceda abc];
             operator'=(if printShell then (opLjuska operator) else operator);
             n=length (concat stupac);
             prije=(if latex then &quot;%% requires 'tabu' package\n\\begin{tabu}{c|&quot;++concatWith &quot;|[on 2pt off 2pt]&quot; [replicate (length ygr) 'l'|ygr&lt;-stupac]++&quot;}\n&quot; else &quot;&quot;);
             sepCol=(if latex then &quot;&amp; &quot; else &quot; &quot;);
             sepColGr=(if latex then &quot;&amp; &quot; else &quot;| &quot;);
             eol=(if latex then &quot;\\\\\n&quot; else &quot;\n&quot;);
             sepHeadRow=(if latex then &quot;\\tabucline{-}\n&quot; else (replicate ((n+1)*11) '-'++&quot;\n&quot;));
             sepRowGr=(if latex then &quot;\\tabucline[on 2pt off 2pt]{-}\n&quot; else (replicate ((n+1)*11) '-'++&quot;\n&quot;));
             poslije=(if latex then &quot;\\end{tabu}&quot; else &quot;&quot;);
             printPartFunc a x=(if printPartition then (&quot;:&quot;++[particija a x]) else &quot;&quot;);
             tablica=[[[(zapisl.ispis) x++(printPartFunc abc x)]:[[(zapisl.ispis.(krati abc)) (operator' abc x y)++(printPartFunc abc (operator' abc x y))|y&lt;-ygr]|ygr&lt;-stupac]|x&lt;-xgr]|xgr&lt;-red];
             ispisKraj=prije++redIspis (sepCol,sepColGr,eol) ([opName]:[map (\x-&gt;(zapisl.ispis) x++(printPartFunc  abc x)) ygr|ygr&lt;-stupac])++sepHeadRow++concatWith sepRowGr [concat [redIspis (sepCol,sepColGr,eol) x|x&lt;-xgr]|xgr&lt;-tablica]++poslije;
             --ispisKraj=prije++redIspis (sepCol,eol) (opName:(map (\x-&gt;(zapisl.ispis) x++(printPartFunc abc x)) (concat stupac)))++sepHeadRow++concat [redIspis (sepCol,eol) x|x&lt;-tablica]++poslije;
             }
        putStrLn (filter (/='&quot;') (concat [p:&quot;: &quot;++show [ispis x|(x,y)&lt;-tab,y==p]++&quot;\n&quot;|p&lt;-['T','A','0','Z','F']]))
        putStrLn ispisKraj

opLjuska op=(\a x y-&gt;ljuska (op a x y)) -- funkcija koja na operator joÅ¡ primjenjuje ljusku
-- opBroj op=(fst op, (\a x y-&gt;perm2broj a (ljuska ((snd op) a x y)))) -- funkcija koja na operator joÅ¡ primjenjuje ljusku i zamjenjuje elemente brojevima

perm :: Abeceda a -&gt; [Rijec a]
perm abc = [[x,y]|x&lt;-a,y&lt;-a]
           where a=unAbeceda abc

perm' :: Abeceda a -&gt; [Rijec a]
perm' abc = [[x,y]|x&lt;-reverse a,y&lt;-a]
           where a=unAbeceda abc

-- perm2broj :: Eq a =&gt; Abeceda a-&gt;Rijec a-&gt;String
-- perm2broj a xs=head [c|(b,c)&lt;-zip (perm a) [show n|n&lt;-[1..]],b==xs]

-- |for a given separator, end of line string and list returns a line string
redIspis::(String,String,String)-&gt;[[String]]-&gt;String
redIspis (sepCol,_,eol) [xss]=concatWith sepCol [make10 xs|xs&lt;-xss]++eol
redIspis (sepCol,sepColGr,eol) (xss:xsss)=(concatWith sepCol [make10 xs|xs&lt;-xss]) ++ sepColGr ++ redIspis (sepCol,sepColGr,eol) xsss

concatWith::String-&gt;[String]-&gt;String
concatWith _ [x]=x
concatWith s (x:xs)=x++s++concatWith s xs

make10::String-&gt;String
make10 xs| n&lt;10      =xs++replicate (10-n) ' '
         | otherwise =xs
  where n=length xs</code></pre><h3 id="integer-type-example"><a href="#integer-type-example">Integer type example</a></h3><pre><code class="active haskell">{-# START_FILE Linguistic2.hs #-}
-- show
-- /show
{-# LANGUAGE UndecidableInstances, FlexibleInstances, OverlappingInstances, IncoherentInstances #-}
module Linguistic2 where

import           Data.Char  (chr, isLower, isUpper, ord, toLower, toUpper)
import           Data.List  (elemIndex, nub)
import           Data.Maybe (fromJust)

-- alphabet type definition and constructors
data Slovo a = Slovo a deriving (Eq, Show)
data Abeceda a = Abeceda {unAbeceda :: [Slovo a]} deriving (Eq, Show)
type Rijec a = [Slovo a]

-- |for a list the function constructs the alphabet containing unique elements of the list
lista2abeceda :: Eq a =&gt; [a] -&gt; Abeceda a
lista2abeceda xs=Abeceda [Slovo x|x&lt;-nub xs]

-- |for 2 Enum types (like Char) the function constructs the alphabet from first to second one
enum2abeceda :: (Eq a, Enum a) =&gt; a -&gt; a -&gt; Abeceda a
enum2abeceda a z=lista2abeceda [a..z]

-- |for a list the function constructs the word containing letters in the list
lista2rijec :: (Show a,Eq a) =&gt; [a] -&gt; Rijec a
lista2rijec xs| even (length xs)= [Slovo x|x&lt;-xs]
              | otherwise= error(&quot;The word &quot;++show xs++&quot; doesn't have an even number of letters.&quot;)

-- |for a word the function returns the list of letters in the word
rijec2lista :: Eq a =&gt; Rijec a -&gt; [a]
rijec2lista xs= [x|Slovo x&lt;-xs]

elemAbc :: Eq a =&gt; Slovo a -&gt; Abeceda a -&gt; Bool
elemAbc s (Abeceda a) = elem s a

elemIndexAbc :: Eq a =&gt; Slovo a -&gt; Abeceda a -&gt; Maybe Int
elemIndexAbc s (Abeceda a) = elemIndex s a

sup :: Eq a =&gt; Abeceda a -&gt; Slovo a -&gt; Slovo a -&gt; Slovo a
sup a x y| x `elemIndexAbc` a==Nothing || y `elemIndexAbc` a==Nothing = error(&quot;Letter is not from the alphabet.&quot;)
         | fromJust (x `elemIndexAbc` a) &gt; fromJust(y `elemIndexAbc` a) = x
         | otherwise = y

inf :: Eq a =&gt; Abeceda a -&gt; Slovo a -&gt; Slovo a -&gt; Slovo a
inf a x y| x `elemIndexAbc` a==Nothing || y `elemIndexAbc` a==Nothing = error(&quot;Letter is not from the alphabet.&quot;)
         | fromJust (x `elemIndexAbc` a) &lt; fromJust(y `elemIndexAbc` a) = x
         | otherwise = y

-- |function converting two consecutive lowercase letters to an uppercase letter
zapisu :: String-&gt;String
zapisu []=[]
zapisu [x]=[x]
zapisu (x:y:xs)|isLower x &amp;&amp; x==y = toUpper x:zapisu xs
               |otherwise=x:zapisu (y:xs)

-- |function converting uppercase letter to two consecutive lowercase letters
zapisl :: String-&gt;String
zapisl []=[]
zapisl (x:xs)|isUpper x =x':x':zapisl xs
             |otherwise =x:zapisl xs
             where x'=toLower x

-- string output of a word
class Show a =&gt; Ispisiv a where
    ispis :: Show a =&gt; Rijec a -&gt; String
    ispis []=[]
    ispis [Slovo x]=show x
    ispis (Slovo x:xs)=show x++&quot;-&quot;++ispis xs

instance Show a =&gt; Ispisiv a
instance Ispisiv Char where
    ispis=zapisu.ispis'

ispis' :: Rijec Char -&gt; String
ispis' []=[]
ispis' [Slovo x]=[x]
ispis' (Slovo x:xs)=x:ispis' xs

-- functions returning left and right letters of a word
l :: [Slovo a] -&gt; Slovo a
l = head
d :: [Slovo a] -&gt; Slovo a
d = last

-- |function returning a dual of a letter in an alphabet
dual :: Eq a =&gt; Abeceda a -&gt; Slovo a -&gt; Slovo a
dual (Abeceda []) s = error(&quot;Nema duala - slovo nije u abecedi.&quot;)
dual (Abeceda [c]) s | s==c = c
                     | otherwise = error(&quot;No dual - Letter is not from the alphabet.&quot;)
dual (Abeceda cs) s | s==lijevi = desni
                    | s==desni = lijevi
                    | otherwise = dual (Abeceda (tail (init cs))) s
                     where lijevi= l cs
                           desni= d cs

-- functions returning duals of left/right letters of a word
l' :: Eq a =&gt; Abeceda a -&gt; [Slovo a] -&gt; Slovo a
l' a= (dual a).l
d' :: Eq a =&gt; Abeceda a -&gt; [Slovo a] -&gt; Slovo a
d' a= (dual a).d

ljuska :: [Slovo a]-&gt;[Slovo a]
ljuska xs=[l xs,d xs]


-- |distance between letters in an alphabet
dd :: Eq a =&gt; Abeceda a -&gt; Slovo a -&gt; Slovo a -&gt; Int
dd a x y| m==Nothing || n==Nothing = error(&quot;Cannot calculate distance. Letter is not from the alphabet.&quot;)
        | otherwise = abs (fromJust m-fromJust n)
  where m=x `elemIndexAbc` a
        n=y `elemIndexAbc` a

-- |word length
duljina :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Int
duljina a []=0
duljina a [c]=0
duljina a (c1:c2:cs)= - dd a c1 c2 - duljina a (c2:cs)

-- word shortening
krati1 :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a    -- function shortening a 4 letter word
krati1 a [p,r,s,t] | duljina a [p,r,s,t]==duljina a [p,t] = [p,t]
                 | otherwise = [p,r,s,t]
krati1 _ cs = cs

krati2 :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a     -- function shortening a 4 letter sub-word
krati2 _ [] = []
krati2 a(c:cs) | length kr==2 = kr ++ drop 3 cs
               | otherwise = c : krati2 a cs
               where kr = ((krati1 a).(take 4)) (c:cs)

krati :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a    -- function fully shortening a word
krati a cs | cs/=kr = krati a kr
           | otherwise = cs
           where kr = krati2 a cs

-- symmetries
opD :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opD _ []=[]
opD a (s:t:ys)=dual a s:dual a t:opD a ys

opE :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opE _ []=[]
opE a xs=t:s:opE a ys
        where n=length xs
              t=d xs
              s=xs !! (n-2)
              ys=take (n-2) xs
--opE a (s:t:ys)=opE a ys++[t,s]    --kraÄe, ali nije po formuli iz teksta

opF :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opF a=(opD a).(opE a)

-- permutations
opI :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opI a xs=l xs:xs++[d xs]

-- |negation operator
opK :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opK a xs=l' a xs:xs++[d' a xs]

opG :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opG a xs=d xs:xs++[l xs]

opH :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opH a xs=d' a xs:xs++[l' a xs]

-- serial and parallel conjecture operators
opS :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a -&gt; Rijec a
opS a xs ys = inf a (l xs) (l ys) : inf a (l xs) (l ys) : xs ++
              [sup a (d xs) (l ys),inf a (d xs) (l ys)] ++ ys ++
              [sup a (d xs) (d ys),sup a (d xs) (d ys)]

opP :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a -&gt; Rijec a
opP a xs ys = sup a (l xs) (l ys) : sup a (l xs) (l ys) : xs ++
              [inf a (d xs) (l ys),sup a (d xs) (l ys)] ++ ys ++
              [inf a (d xs) (d ys),inf a (d xs) (d ys)]

-- |partitions
particija :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Char
particija a xs | lijevi&gt;=*lijevi' &amp;&amp; desni&lt;=*desni' &amp;&amp; lijevi&gt;*desni ='T'
               | lijevi&lt;=*lijevi' &amp;&amp; desni&lt;=*desni' &amp;&amp; not (lijevi==lijevi' || desni==desni') ='A'
               | lijevi==lijevi' &amp;&amp; desni==desni' ='0'
               | lijevi&gt;=*lijevi' &amp;&amp; desni&gt;=*desni' &amp;&amp; not (lijevi==lijevi' || desni==desni')  ='Z'
               | lijevi&lt;=*lijevi' &amp;&amp; desni&gt;=*desni' &amp;&amp; lijevi&lt;*desni  ='F'
         where lijevi=l xs
               desni=d xs
               lijevi'=l' a xs
               desni'=d' a xs
               x &gt;* y| m==Nothing || n==Nothing =error(&quot;Letter not in alphabet.&quot;)
                     | otherwise = (fromJust m) &gt; (fromJust n)
                      where m=x `elemIndexAbc` a
                            n=y `elemIndexAbc` a
               x &gt;=* y = x &gt;* y || x==y
               x &lt;* y = not (x &gt;=* y)
               x &lt;=* y = not (x &gt;* y)

-- implications
pimp :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a -&gt; Rijec a
pimp a x y=(opK a x) `opP'` y
    where opP'=opP a

simp :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a -&gt; Rijec a
simp a x y=(opK a x) `opS'` y
    where opS'=opS a

-- equivalencies
pekv :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a -&gt; Rijec a
pekv a x y=(x `pimp'` y) `opS'` (y `pimp'` x)
    where opS'=opS a
          pimp'=pimp a

sekv :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a -&gt; Rijec a
sekv a x y=(x `simp'` y) `opP'` (y `simp'` x)
    where opP'=opP a
          simp'=simp a

-- |tautologies and rules
taut :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt;Rijec a -&gt; Rijec a -&gt; [(String,Char)]
taut a x y z= zip
  [&quot;1.ZAKON ISKLJUCENJA TRECEG&quot;,
  &quot;2.DUAL ZAKONA ISKLJUCENJA TRECEG&quot;,
  &quot;3.TRANZITIVNOST IMPLIKACIJE&quot;,
  &quot;4.DUAL TRANZITIVNOSTI IMPLIKACIJE&quot;,
  &quot;5.ZAKON DVOSTRUKE NEGACIJE&quot;,
  &quot;6.ZAKON KONTRAPOZICIJE&quot;,
  &quot;7.DUAL ZAKONA KONTRAPOZICIJE&quot;,
  &quot;8.ZAKON APSORPCIJE ILI UPIJANJA&quot;,
  &quot;9.DUAL ZAKONA APSORPCIJE ILI UPIJANJA&quot;,
  &quot;10.MODUS PONENDO PONENS&quot;,
  &quot;11.DUAL MODUSA PONENDO PONENS&quot;,
  &quot;12.MODUS TOLENDO TOLLENS&quot;,
  &quot;13.DOKAZ NABRAJANJEM&quot;,
  &quot;14.DOVODJENJE DO PROTURJECJA&quot;]
  (map (particija a) [
    x `opP'` (neg x),
    x `opS'` (neg x),
    ((x `pimp'` y) `opS'` (y `pimp'` z)) `pimp'` (x `pimp'` z),
    ((x `simp'` y) `opP'` (y `simp'` z)) `simp'` (x `simp'` z),
    (neg (neg x)) `pekv'` x,
    (x `pimp'` y) `pimp'` ((neg y) `pimp'` (neg x)),
    (x `simp'` y) `simp'` ((neg y) `simp'` (neg x)),
    (x `opP'` (y `opP'` x)) `pimp'` x,
    (x `opS'` (y `opS'` x)) `simp'` x,
    (x `opS'` (x `pimp'` y)) `pimp'` y,
    (x `opP'` (x `simp'` y)) `simp'` y,
    ((neg x) `opS'` ((neg x) `pimp'` (neg y))) `pimp'` (neg y),
    ((x `pimp'` z) `opS'` (y `pimp'` z)) `pimp'` ((x `opP'` y) `pimp'` z),
    ((x `pimp'` y) `opS'` (x `pimp'` (neg y))) `pimp'` (neg x)
    ]
  )
  where opP'=opP a
        opS'=opS a
        pimp'=pimp a
        simp'=simp a
        pekv'=pekv a
        sekv'=sekv a
        neg=opK a
        
{-# START_FILE Main.hs #-}
{-# LANGUAGE UndecidableInstances, FlexibleInstances, OverlappingInstances, IncoherentInstances #-}
module Main where
import Linguistic2

main :: IO ()

-- show Set alphabet, row and column headers and the binary operator for the table.
main=do let {abc = lista2abeceda ([1..2]::[Int]);                  -- &lt;-- CHANGE
             red = [map lista2rijec x| x&lt;-([[[2,1],[2,2]],[[1,1],[1,2]]]::[[[Int]]])];         -- &lt;-- CHANGE
             stupac = [map lista2rijec x| x&lt;-([[[2,1],[2,2]],[[1,1],[1,2]]]::[[[Int]]])];      -- &lt;-- CHANGE
             opName = &quot;OR&quot;;
             operator = (\a x y-&gt;let opDa=opD a; opEa=opE a; opFa=opF a; neg=opK a; opPa=opP a; opSa=opS a; pimpa=pimp a; simpa=simp a; pekva=pekv a; sekva=sekv a; in 
                                        (x `opPa` y)   -- &lt;-- CHANGE
                                        );}
-- /show


-- show Formatting (latex -&gt; regular table or LaTeX; printShell -&gt; show just shell or the whole result)
        let {latex=False;            -- &lt;-- CHANGE
             printShell=True;        -- &lt;-- CHANGE
             printPartition=False;}  -- &lt;-- CHANGE
-- /show

        let {tab=[([x,y],particija abc [x,y])|x &lt;- unAbeceda abc,y &lt;- unAbeceda abc];
             operator'=(if printShell then (opLjuska operator) else operator);
             n=length (concat stupac);
             prije=(if latex then &quot;%% requires 'tabu' package\n\\begin{tabu}{c|&quot;++concatWith &quot;|[on 2pt off 2pt]&quot; [replicate (length ygr) 'l'|ygr&lt;-stupac]++&quot;}\n&quot; else &quot;&quot;);
             sepCol=(if latex then &quot;&amp; &quot; else &quot; &quot;);
             sepColGr=(if latex then &quot;&amp; &quot; else &quot;| &quot;);
             eol=(if latex then &quot;\\\\\n&quot; else &quot;\n&quot;);
             sepHeadRow=(if latex then &quot;\\tabucline{-}\n&quot; else (replicate ((n+1)*11) '-'++&quot;\n&quot;));
             sepRowGr=(if latex then &quot;\\tabucline[on 2pt off 2pt]{-}\n&quot; else (replicate ((n+1)*11) '-'++&quot;\n&quot;));
             poslije=(if latex then &quot;\\end{tabu}&quot; else &quot;&quot;);
             printPartFunc a x=(if printPartition then (&quot;:&quot;++[particija a x]) else &quot;&quot;);
             tablica=[[[(zapisl.ispis) x++(printPartFunc abc x)]:[[(zapisl.ispis.(krati abc)) (operator' abc x y)++(printPartFunc abc (operator' abc x y))|y&lt;-ygr]|ygr&lt;-stupac]|x&lt;-xgr]|xgr&lt;-red];
             ispisKraj=prije++redIspis (sepCol,sepColGr,eol) ([opName]:[map (\x-&gt;(zapisl.ispis) x++(printPartFunc  abc x)) ygr|ygr&lt;-stupac])++sepHeadRow++concatWith sepRowGr [concat [redIspis (sepCol,sepColGr,eol) x|x&lt;-xgr]|xgr&lt;-tablica]++poslije;
             --ispisKraj=prije++redIspis (sepCol,eol) (opName:(map (\x-&gt;(zapisl.ispis) x++(printPartFunc abc x)) (concat stupac)))++sepHeadRow++concat [redIspis (sepCol,eol) x|x&lt;-tablica]++poslije;
             }
        putStrLn (filter (/='&quot;') (concat [p:&quot;: &quot;++show [ispis x|(x,y)&lt;-tab,y==p]++&quot;\n&quot;|p&lt;-['T','A','0','Z','F']]))
        putStrLn ispisKraj

opLjuska op=(\a x y-&gt;ljuska (op a x y)) -- funkcija koja na operator joÅ¡ primjenjuje ljusku
-- opBroj op=(fst op, (\a x y-&gt;perm2broj a (ljuska ((snd op) a x y)))) -- funkcija koja na operator joÅ¡ primjenjuje ljusku i zamjenjuje elemente brojevima

perm :: Abeceda a -&gt; [Rijec a]
perm abc = [[x,y]|x&lt;-a,y&lt;-a]
           where a=unAbeceda abc

perm' :: Abeceda a -&gt; [Rijec a]
perm' abc = [[x,y]|x&lt;-reverse a,y&lt;-a]
           where a=unAbeceda abc

-- perm2broj :: Eq a =&gt; Abeceda a-&gt;Rijec a-&gt;String
-- perm2broj a xs=head [c|(b,c)&lt;-zip (perm a) [show n|n&lt;-[1..]],b==xs]

-- |for a given separator, end of line string and list returns a line string
redIspis::(String,String,String)-&gt;[[String]]-&gt;String
redIspis (sepCol,_,eol) [xss]=concatWith sepCol [make10 xs|xs&lt;-xss]++eol
redIspis (sepCol,sepColGr,eol) (xss:xsss)=(concatWith sepCol [make10 xs|xs&lt;-xss]) ++ sepColGr ++ redIspis (sepCol,sepColGr,eol) xsss

concatWith::String-&gt;[String]-&gt;String
concatWith _ [x]=x
concatWith s (x:xs)=x++s++concatWith s xs

make10::String-&gt;String
make10 xs| n&lt;10      =xs++replicate (10-n) ' '
         | otherwise =xs
  where n=length xs</code></pre><h3 id="expression-calculator"><a href="#expression-calculator">Expression calculator</a></h3><pre><code class="active haskell">{-# START_FILE Linguistic2.hs #-}
-- show
-- /show
{-# LANGUAGE UndecidableInstances, FlexibleInstances, OverlappingInstances, IncoherentInstances #-}
module Linguistic2 where

import           Data.Char  (chr, isLower, isUpper, ord, toLower, toUpper)
import           Data.List  (elemIndex, nub)
import           Data.Maybe (fromJust)

-- alphabet type definition and constructors
data Slovo a = Slovo a deriving (Eq, Show)
data Abeceda a = Abeceda {unAbeceda :: [Slovo a]} deriving (Eq, Show)
type Rijec a = [Slovo a]

-- |for a list the function constructs the alphabet containing unique elements of the list
lista2abeceda :: Eq a =&gt; [a] -&gt; Abeceda a
lista2abeceda xs=Abeceda [Slovo x|x&lt;-nub xs]

-- |for 2 Enum types (like Char) the function constructs the alphabet from first to second one
enum2abeceda :: (Eq a, Enum a) =&gt; a -&gt; a -&gt; Abeceda a
enum2abeceda a z=lista2abeceda [a..z]

-- |for a list the function constructs the word containing letters in the list
lista2rijec :: (Show a,Eq a) =&gt; [a] -&gt; Rijec a
lista2rijec xs| even (length xs)= [Slovo x|x&lt;-xs]
              | otherwise= error(&quot;The word &quot;++show xs++&quot; doesn't have an even number of letters.&quot;)

-- |for a word the function returns the list of letters in the word
rijec2lista :: Eq a =&gt; Rijec a -&gt; [a]
rijec2lista xs= [x|Slovo x&lt;-xs]

elemAbc :: Eq a =&gt; Slovo a -&gt; Abeceda a -&gt; Bool
elemAbc s (Abeceda a) = elem s a

elemIndexAbc :: Eq a =&gt; Slovo a -&gt; Abeceda a -&gt; Maybe Int
elemIndexAbc s (Abeceda a) = elemIndex s a

ggeq :: Eq a =&gt; Abeceda a -&gt; Slovo a -&gt; Slovo a -&gt; Bool
ggeq a x y| x `elemIndexAbc` a==Nothing || y `elemIndexAbc` a==Nothing = error(&quot;Letter is not from the alphabet.&quot;)
          | fromJust (x `elemIndexAbc` a) &gt;= fromJust(y `elemIndexAbc` a) = True
          | otherwise = False

gleq :: Eq a =&gt; Abeceda a -&gt; Slovo a -&gt; Slovo a -&gt; Bool
gleq a x y| x `elemIndexAbc` a==Nothing || y `elemIndexAbc` a==Nothing = error(&quot;Letter is not from the alphabet.&quot;)
          | fromJust (x `elemIndexAbc` a) &lt;= fromJust(y `elemIndexAbc` a) = True
          | otherwise = False

geq :: Eq a =&gt; Abeceda a -&gt; Slovo a -&gt; Slovo a -&gt; Bool
geq a x y=(ggeq a x y) &amp;&amp; (gleq a x y)

sup :: Eq a =&gt; Abeceda a -&gt; Slovo a -&gt; Slovo a -&gt; Slovo a
sup a x y| ggeq a x y = x
         | otherwise = y

inf :: Eq a =&gt; Abeceda a -&gt; Slovo a -&gt; Slovo a -&gt; Slovo a
inf a x y| gleq a x y = x
         | otherwise = y

-- |function converting two consecutive lowercase letters to an uppercase letter
zapisu :: String-&gt;String
zapisu []=[]
zapisu [x]=[x]
zapisu (x:y:xs)|isLower x &amp;&amp; x==y = toUpper x:zapisu xs
               |otherwise=x:zapisu (y:xs)

-- |function converting uppercase letter to two consecutive lowercase letters
zapisl :: String-&gt;String
zapisl []=[]
zapisl (x:xs)|isUpper x =x':x':zapisl xs
             |otherwise =x:zapisl xs
             where x'=toLower x

-- string output of a word
class Show a =&gt; Ispisiv a where
    ispis :: Show a =&gt; Rijec a -&gt; String
    ispis []=[]
    ispis [Slovo x]=show x
    ispis (Slovo x:xs)=show x++&quot;-&quot;++ispis xs

instance Show a =&gt; Ispisiv a
instance Ispisiv Char where
    ispis=zapisu.ispis'

ispis' :: Rijec Char -&gt; String
ispis' []=[]
ispis' [Slovo x]=[x]
ispis' (Slovo x:xs)=x:ispis' xs

-- functions returning left and right letters of a word
l :: [Slovo a] -&gt; Slovo a
l = head
d :: [Slovo a] -&gt; Slovo a
d = last

-- |function returning a dual of a letter in an alphabet
dual :: Eq a =&gt; Abeceda a -&gt; Slovo a -&gt; Slovo a
dual (Abeceda []) s = error(&quot;Nema duala - slovo nije u abecedi.&quot;)
dual (Abeceda [c]) s | s==c = c
                     | otherwise = error(&quot;No dual - Letter is not from the alphabet.&quot;)
dual (Abeceda cs) s | s==lijevi = desni
                    | s==desni = lijevi
                    | otherwise = dual (Abeceda (tail (init cs))) s
                     where lijevi= l cs
                           desni= d cs

-- functions returning duals of left/right letters of a word
l' :: Eq a =&gt; Abeceda a -&gt; [Slovo a] -&gt; Slovo a
l' a= (dual a).l
d' :: Eq a =&gt; Abeceda a -&gt; [Slovo a] -&gt; Slovo a
d' a= (dual a).d

ljuska :: [Slovo a]-&gt;[Slovo a]
ljuska xs=[l xs,d xs]


-- |distance between letters in an alphabet
dd :: Eq a =&gt; Abeceda a -&gt; Slovo a -&gt; Slovo a -&gt; Int
dd a x y| m==Nothing || n==Nothing = error(&quot;Cannot calculate distance. Letter is not from the alphabet.&quot;)
        | otherwise = abs (fromJust m-fromJust n)
  where m=x `elemIndexAbc` a
        n=y `elemIndexAbc` a

-- |word length
duljina :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Int
duljina a []=0
duljina a [c]=0
duljina a (c1:c2:cs)= - dd a c1 c2 - duljina a (c2:cs)

defekt :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Int
defekt a x| (d x) `elemIndexAbc` a==Nothing || (l x) `elemIndexAbc` a==Nothing = error(&quot;Letter is not from the alphabet.&quot;)
          | otherwise = fromJust ((d x) `elemIndexAbc` a) - fromJust((l x) `elemIndexAbc` a)

sDuljina :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rational
sDuljina a x=(fromIntegral (duljina a x)-fromIntegral (defekt a x))/2

pDuljina :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rational
pDuljina a x=(fromIntegral (duljina a x)+fromIntegral (defekt a x))/2

-- word shortening
krati1 :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a    -- function shortening a 4 letter word
krati1 a [p,r,s,t] | duljina a [p,r,s,t]==duljina a [p,t] = [p,t]
                 | otherwise = [p,r,s,t]
krati1 _ cs = cs

krati2 :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a     -- function shortening a 4 letter sub-word
krati2 _ [] = []
krati2 a(c:cs) | length kr==2 = kr ++ drop 3 cs
               | otherwise = c : krati2 a cs
               where kr = ((krati1 a).(take 4)) (c:cs)

krati :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a    -- function fully shortening a word
krati a cs | cs/=kr = krati a kr
           | otherwise = cs
           where kr = krati2 a cs

oBaza :: Abeceda a -&gt; [Rijec a]
oBaza abc = [[x,y]|x &lt;- unAbeceda abc,y &lt;- unAbeceda abc]

-- quasi-order
qleq :: Eq a =&gt; Abeceda a-&gt;Rijec a-&gt; Rijec a-&gt;Bool
qleq a x y |(ggeq a (l x) (l y)) &amp;&amp; (gleq a (d x) (d y)) = True
           | otherwise = False

qgeq :: Eq a =&gt; Abeceda a-&gt;Rijec a-&gt; Rijec a-&gt;Bool
qgeq a x y |(gleq a (l x) (l y)) &amp;&amp; (ggeq a (d x) (d y)) = True
           | otherwise = False

qeq :: Eq a =&gt; Abeceda a-&gt;Rijec a-&gt; Rijec a-&gt;Bool
qeq a x y |(qleq a x y) &amp;&amp; (qleq a y x) = True
          | otherwise = False

sNula :: Abeceda a-&gt;Rijec a
sNula (Abeceda a)=[d a,l a]

pNula :: Abeceda a-&gt;Rijec a
pNula (Abeceda a)=[l a,d a]

-- jezgre
opJs :: Abeceda a-&gt;Rijec a-&gt;Rijec a
opJs a x=sNula a++x++sNula a

opJp :: Abeceda a-&gt;Rijec a-&gt;Rijec a
opJp a x=pNula a++x++pNula a

-- ljuske
sLjuska :: Eq a =&gt; Abeceda a-&gt;Rijec a-&gt;Rijec a
sLjuska a x=l x:(inf a (l x) (d x)):(sup a (l x) (d x)):d x:[]

pLjuska :: Eq a =&gt; Abeceda a-&gt;Rijec a-&gt;Rijec a
pLjuska a x=l x:(sup a (l x) (d x)):(inf a (l x) (d x)):d x:[]

-- operatori inverzivnosti
opIs :: Eq a =&gt; Abeceda a-&gt;Rijec a-&gt;Rijec a
opIs a x=l x:infx:infx:x++supx:infx:infx:supx:d x:[]
           where infx=(inf a (l x) (d x))
                 supx=(sup a (l x) (d x))

opIp :: Eq a =&gt; Abeceda a-&gt;Rijec a-&gt;Rijec a
opIp a x=l x:supx:supx:x++infx:supx:supx:infx:d x:[]
           where infx=(inf a (l x) (d x))
                 supx=(sup a (l x) (d x))

opSminus :: Eq a =&gt; Abeceda a-&gt;Rijec a-&gt;Rijec a-&gt;Rijec a
opSminus a x y=opS a x (opIs a y)

opPminus :: Eq a =&gt; Abeceda a-&gt;Rijec a-&gt;Rijec a-&gt;Rijec a
opPminus a x y=opP a x (opIp a y)

-- operatori komplementarnosti
opKs :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opKs (Abeceda a) xs=l a:xs++[d a]

opKp :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opKp (Abeceda a) xs=d a:xs++[l a]  

-- symmetries
opD :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opD _ []=[]
opD a (s:t:ys)=dual a s:dual a t:opD a ys

opE :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opE _ []=[]
opE a xs=t:s:opE a ys
        where n=length xs
              t=d xs
              s=xs !! (n-2)
              ys=take (n-2) xs
--opE a (s:t:ys)=opE a ys++[t,s]    --kraÄe, ali nije po formuli iz teksta

opF :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opF a=(opD a).(opE a)

-- permutations
opI :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opI a xs=l xs:xs++[d xs]

-- |negation operator
opK :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opK a xs=l' a xs:xs++[d' a xs]

opG :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opG a xs=d xs:xs++[l xs]

opH :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a
opH a xs=d' a xs:xs++[l' a xs]

-- serial (union) and parallel (intersection) conjecture operators
opS :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a -&gt; Rijec a
opS a xs ys = inf a (l xs) (l ys) : inf a (l xs) (l ys) : xs ++
              [sup a (d xs) (l ys),inf a (d xs) (l ys)] ++ ys ++
              [sup a (d xs) (d ys),sup a (d xs) (d ys)]

opP :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a -&gt; Rijec a
opP a xs ys = sup a (l xs) (l ys) : sup a (l xs) (l ys) : xs ++
              [inf a (d xs) (l ys),sup a (d xs) (l ys)] ++ ys ++
              [inf a (d xs) (d ys),inf a (d xs) (d ys)]

-- |partitions
particija :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Char
particija a xs | lijevi&gt;=*lijevi' &amp;&amp; desni&lt;=*desni' &amp;&amp; lijevi&gt;*desni ='T'
               | lijevi&lt;=*lijevi' &amp;&amp; desni&lt;=*desni' &amp;&amp; not (lijevi==lijevi' || desni==desni') ='A'
               | lijevi==lijevi' &amp;&amp; desni==desni' ='0'
               | lijevi&gt;=*lijevi' &amp;&amp; desni&gt;=*desni' &amp;&amp; not (lijevi==lijevi' || desni==desni')  ='Z'
               | lijevi&lt;=*lijevi' &amp;&amp; desni&gt;=*desni' &amp;&amp; lijevi&lt;*desni  ='F'
         where lijevi=l xs
               desni=d xs
               lijevi'=l' a xs
               desni'=d' a xs
               x &gt;* y| m==Nothing || n==Nothing =error(&quot;Letter not in alphabet.&quot;)
                     | otherwise = (fromJust m) &gt; (fromJust n)
                      where m=x `elemIndexAbc` a
                            n=y `elemIndexAbc` a
               x &gt;=* y = x &gt;* y || x==y
               x &lt;* y = not (x &gt;=* y)
               x &lt;=* y = not (x &gt;* y)

-- implications
pimp :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a -&gt; Rijec a
pimp a x y=(opK a x) `opP'` y
    where opP'=opP a

simp :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a -&gt; Rijec a
simp a x y=(opK a x) `opS'` y
    where opS'=opS a

-- equivalencies
pekv :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a -&gt; Rijec a
pekv a x y=(x `pimp'` y) `opS'` (y `pimp'` x)
    where opS'=opS a
          pimp'=pimp a

sekv :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt; Rijec a -&gt; Rijec a
sekv a x y=(x `simp'` y) `opP'` (y `simp'` x)
    where opP'=opP a
          simp'=simp a

-- |tautologies and rules
taut :: Eq a =&gt; Abeceda a -&gt; Rijec a -&gt;Rijec a -&gt; Rijec a -&gt; [(String,Char)]
taut a x y z= zip
  [&quot;1.ZAKON ISKLJUCENJA TRECEG&quot;,
  &quot;2.DUAL ZAKONA ISKLJUCENJA TRECEG&quot;,
  &quot;3.TRANZITIVNOST IMPLIKACIJE&quot;,
  &quot;4.DUAL TRANZITIVNOSTI IMPLIKACIJE&quot;,
  &quot;5.ZAKON DVOSTRUKE NEGACIJE&quot;,
  &quot;6.ZAKON KONTRAPOZICIJE&quot;,
  &quot;7.DUAL ZAKONA KONTRAPOZICIJE&quot;,
  &quot;8.ZAKON APSORPCIJE ILI UPIJANJA&quot;,
  &quot;9.DUAL ZAKONA APSORPCIJE ILI UPIJANJA&quot;,
  &quot;10.MODUS PONENDO PONENS&quot;,
  &quot;11.DUAL MODUSA PONENDO PONENS&quot;,
  &quot;12.MODUS TOLENDO TOLLENS&quot;,
  &quot;13.DOKAZ NABRAJANJEM&quot;,
  &quot;14.DOVODJENJE DO PROTURJECJA&quot;]
  (map (particija a) [
    x `opP'` (neg x),
    x `opS'` (neg x),
    ((x `pimp'` y) `opS'` (y `pimp'` z)) `pimp'` (x `pimp'` z),
    ((x `simp'` y) `opP'` (y `simp'` z)) `simp'` (x `simp'` z),
    (neg (neg x)) `pekv'` x,
    (x `pimp'` y) `pimp'` ((neg y) `pimp'` (neg x)),
    (x `simp'` y) `simp'` ((neg y) `simp'` (neg x)),
    (x `opP'` (y `opP'` x)) `pimp'` x,
    (x `opS'` (y `opS'` x)) `simp'` x,
    (x `opS'` (x `pimp'` y)) `pimp'` y,
    (x `opP'` (x `simp'` y)) `simp'` y,
    ((neg x) `opS'` ((neg x) `pimp'` (neg y))) `pimp'` (neg y),
    ((x `pimp'` z) `opS'` (y `pimp'` z)) `pimp'` ((x `opP'` y) `pimp'` z),
    ((x `pimp'` y) `opS'` (x `pimp'` (neg y))) `pimp'` (neg x)
    ]
  )
  where opP'=opP a
        opS'=opS a
        pimp'=pimp a
        simp'=simp a
        pekv'=pekv a
        sekv'=sekv a
        neg=opK a
        
{-# START_FILE Main.hs #-}
{-# LANGUAGE UndecidableInstances, FlexibleInstances, OverlappingInstances, IncoherentInstances #-}
module Main where
import Linguistic2

main :: IO ()

-- show Set alphabet and variables.
main=do let {a = lista2abeceda ['a'..'z'];                  -- &lt;-- CHANGE
             x = lista2rijec &quot;ante&quot;;                      -- &lt;-- CHANGE
             y = lista2rijec &quot;koba&quot;;                        -- &lt;-- CHANGE
             -- ADD MORE VARIABLES IF NECESSARY
             }
-- /show


-- show Operators that can be used in the expression
        let opDa =opD a;         -- unary
            opEa =opE a;         -- unary
            opFa =opF a;         -- unary
            opIa =opI a;         -- unary
            opGa =opG a;         -- unary
            opHa =opH a;         -- unary
            neg =opK a;          -- unary
            opKsa =opKs a;       -- unary
            opKpa =opKp a;       -- unary
            opJsa =opJs a;       -- unary
            opJpa =opJp a;       -- unary
            sLjuskaa =sLjuska a; -- unary
            pLjuskaa =pLjuska a; -- unary
            opIsa =opIs a;       -- unary
            opIpa =opIp a;       -- unary
            opSa =opS a;           -- binary
            opPa =opP a;           -- binary
            opSminusa =opSminus a; -- binary
            opPminusa =opPminus a; -- binary
            pimpa =pimp a;         -- binary
            simpa =simp a;         -- binary
            pekva =pekv a;         -- binary
            sekva =sekv a;         -- binary
            kratia =krati a;     -- unary
-- /show

        let izraz=

-- show Set the expression
              opIsa y                        -- &lt;-- CHANGE
-- /show

        putStrLn (ispis izraz);
        putStrLn (&quot;Length:&quot;++show (duljina a izraz));
        putStrLn (&quot;Defect:&quot;++show (defekt a izraz));
        putStrLn (&quot;s-length:&quot;++show (sDuljina a izraz));
        putStrLn (&quot;p-length:&quot;++show (pDuljina a izraz));</code></pre></article>


</div>
</div>
<div class="row article-footer"><div class="span7 meta"><span class="sociallinksunicode social">
<a href="https://twitter.com/home?status=$url$" target="_blank"><i class="icon-twitter"></i></a>&nbsp;
<a href="http://www.facebook.com/sharer/sharer.php?u=$url$" target="_blank"><i class="icon-facebook"></i></a>&nbsp;
<a href="https://plus.google.com/share?url=$url$" target="_blank"><i class="icon-google-plus"></i></a></span>
</div>
</div>
</div>
<div class="footer"><div class="container"><div class="row"><div class="span12"><ul class="menu"><li><a href="https://www.schoolofhaskell.com/">School</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user">Users</a>
</li>

<li><a class="brand" href="https://fpcomplete.com">Sponsored by:
<img src="/static/img/logo.png" title="FPComplete">
</a>
</li>
</ul>
</div>
</div>
<div class="row"><div class="span12"></div>
</div>
</div>
</div>
<link rel="stylesheet" type="text/css" href="/static/bootstrap/css/bootstrap-responsive.css" />
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script><script src="https://www.schoolofhaskell.com/static/combined/Y-3k9_tW.js"></script><script>$(function(){
  $("a.logout").click(function(){
    var form = $("<form method='post'/>");
    form.attr("action", $(this).attr("href"));
    $("body").append(form);
    form.submit();
    return false;
  });
});

$(function(){
    $('.sociallinksunicode a').each(function(){
        $(this).attr('href',$(this).attr('href').replace('$url$',document.location));
    });
});

$(function(){
  // If we need to select a user/select a password then show the
  // details confirmation form, otherwise enable the getting started
  // section.
  if($('.alert-block a').text().match(/(selected a username|change your password)/)) {
    $("#confirm-details").show();
    $("#confirm-details #inputUsername").focus();
  } else {
    $("#get-started").removeClass('disabled').addClass('enabled');
  }

  // For lack of a plain HTML validation story this will do.
  $('.welcome-page').each(function(){
    $('form').submit(check);
  });
  function check(){
    setTimeout(check,500);
    var error = false;
    $('.error').removeClass('error');
    $('#enter-details input').each(function(){
      if($(this).val() == '') {
        $(this).parent().parent().addClass('error');
        error = true;
      }
    });
    if(error) return false;
    if($('[name=password]').val() == $('[name=confirm]').val()) {
      $('#confirm').removeClass('error');
      return true;
    } else {
      $('#confirm').addClass('error');
      return false;
    }
  }
});

$(function(){
  // When scrolling over a snippet editor, activate the "clone in IDE" popovers
  $('article').each(function(){
    var n = 100;
    var wait = 10000;
    function check(){
      if($('.clone').length == 0) {
        setTimeout(check,n);
        return;
      }
      var activated = $.cookie('clone-popover');
      if (activated) return;
      var activate = false;
      $('.controlsRun:onScreen').each(function(){
        $.cookie('clone-popover', 'true', { expires: 30, path: '/' });
        activate = true;
        return false;
      });
      if(activate) {
          $('.clone').each(function(){
              // The bootstrap API is rather unreasonable to say the
              // least.
              next = $(this).parent();
              var title = next.attr('title');
              next.attr('data-content',$(this).attr('data-content'));
              next.attr('title',$(this).attr('title'));
              next.popover('show',{
                  title: $(this).attr('title')
              });
              next.attr('title',title);
          });
          setTimeout(function(){
              $('.clone').each(function(){
                  $(this).parent().popover('hide');
              });
          },wait);
      } else {
        setTimeout(check,n);
      }
    }
    setTimeout(check,n);
  });
});

// onScreen jQuery plugin v0.2.1
// (c) 2011-2013 Ben Pickles
//
// http://benpickles.github.com/onScreen
//
// Released under MIT license.
(function(a){a.expr[":"].onScreen=function(b){var c=a(window),d=c.scrollTop(),e=c.height(),f=d+e,g=a(b),h=g.offset().top,i=g.height(),j=h+i;return h>=d&&h<f||j>d&&j<=f||i>e&&h<=d&&j>=f}})(jQuery);

/*!
 * jQuery Cookie Plugin v1.1
 * https://github.com/carhartl/jquery-cookie
 *
 * Copyright 2011, Klaus Hartl
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.opensource.org/licenses/GPL-2.0
 */
(function($, document) {

  var pluses = /\+/g;
  function raw(s) {
    return s;
  }
  function decoded(s) {
    return decodeURIComponent(s.replace(pluses, ' '));
  }

  $.cookie = function(key, value, options) {

    // key and at least value given, set cookie...
    if (arguments.length > 1 && (!/Object/.test(Object.prototype.toString.call(value)) || value == null)) {
      options = $.extend({}, $.cookie.defaults, options);

      if (value == null) {
	options.expires = -1;
      }

      if (typeof options.expires === 'number') {
	var days = options.expires, t = options.expires = new Date();
	t.setDate(t.getDate() + days);
      }

      value = String(value);

      return (document.cookie = [
	encodeURIComponent(key), '=', options.raw ? value : encodeURIComponent(value),
	options.expires ? '; expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE
	options.path    ? '; path=' + options.path : '',
	options.domain  ? '; domain=' + options.domain : '',
	options.secure  ? '; secure' : ''
      ].join(''));
    }

    // key and possibly options given, get cookie...
    options = value || $.cookie.defaults || {};
    var decode = options.raw ? raw : decoded;
    var cookies = document.cookie.split('; ');
    for (var i = 0, parts; (parts = cookies[i] && cookies[i].split('=')); i++) {
      if (decode(parts.shift()) === key) {
	return decode(parts.join('='));
      }
    }
    return null;
  };
  $.cookie.defaults = {};})(jQuery, document);
</script><!--[if lt IE 10]><script src="https://www.schoolofhaskell.com/static/design/js/ie.js?etag=ayV2DuJ0"></script><![endif]--><script>if(!window.location.href.match(/localhost/)){var track = '/tutorial/user/ivazler/linguistic';
window._gaq = [['_setAccount','UA-36928035-1'],track != ''? ['_trackPageview',track] : ['_trackPageview']
,['_trackPageLoadTime']];window._gaq.push(['_setCustomVar',1,'Section','School of Haskell',3]);
window._gaq.push(['_setCustomVar',2,'User Type','Visitor',1]);
(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);

})();}</script>
<!-- Prompt IE 6 users to install Chrome Frame. Remove this if you want to support IE 6.  chromium.org/developers/how-tos/chrome-frame-getting-started --><!--[if lt IE 7 ]><script src="//ajax.googleapis.com/ajax/libs/chrome-frame/1.0.3/CFInstall.min.js"></script><script>window.attachEvent('onload',function(){CFInstall.check({mode:'overlay'})})</script><![endif]--></body></html>