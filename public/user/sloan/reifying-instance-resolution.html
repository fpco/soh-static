<!DOCTYPE html>
<html><head><title>Reifying Instance Resolution - School of Haskell | School of Haskell</title><meta http-equiv="x-ua-compatible" content="IE=9"><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="google-site-verification" content="Rfxk2TdeMMXEXHgJ2_OO8Rt3hPbQSDao0OXQV_n6z_s" /><link href="//fonts.googleapis.com/css?family=Merriweather" rel="stylesheet" type="text/css"><link href="https://www.schoolofhaskell.com/recent-content/feed" type="application/rss+xml" rel="alternate" title="Recently published content">
<link rel="stylesheet" href="https://www.schoolofhaskell.com/static/combined/UlwEHVcM.css"><style>.social{margin-right:1em}h1{font-family:Merriweather !important}article{font-family:Merriweather !important}article li{font-family:Merriweather !important;line-height:1.6em}h1,h2,h3,h4,h4,h5{font-family:Merriweather !important}.editor p{font-family:Frutiger, "Frutiger Linotype", Univers, Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans Condensed", "Liberation Sans", "Nimbus Sans L", Tahoma, Geneva, "Helvetica Neue", Helvetica, Arial, sans-serif}.article-footer{border-top:1px solid #ddd;padding-top:1em;margin-top:1em}body{font-size:16px !important}.navbar .navbar-inner{background:#3c3f41}.navbar .brand{font-size:14px}.navbar .brand img{width:6em}.navbar .icon-wrench{margin:0 -0.5em 0 -0.5em;padding:0 1em 0 1em;height:20px}.navbar-inverse .nav .active a{background:#333638}.navbar-inverse .nav > li > a{color:#a7a7a7
}.navbar-inverse .btn-navbar{background:#333638}.navbar-inverse .nav > li a:hover,.navbar-inverse .btn{background:#333537 !important}@media (max-width: 979px) {.icon-wrench{padding-left:1em !important}}.breadcrumb{border-top-left-radius:0;border-top-right-radius:0}h1{margin-top:20px}.breadcrumb-container + .main-content h1{margin-top:0}.footer{padding:30px 0;margin-top:70px;border-top:1px solid #e5e5e5;background-color:#f5f5f5}.footer ul.footer-menu{list-style-type:none}.footer ul.footer-menu li{display:inline-block}.footer ul.footer-menu li + li{margin-left:0.5em}.footer ul.footer-menu li + li:before{margin-right:0.5em;content:"Â·";color:#999}.footer ul.menu li{display:inline-block}.footer ul.menu li + li{margin-left:0.5em}.footer .copyright{margin-left:25px}.main-content{min-height:100%}.gravatar{width:80px;height:80px;border-radius:2px;background:#eee}.empty-gravatar{width:0}.container{font-family:"Segoe UI", Candara, "Bitstream Vera Sans", "DejaVu Sans", "Bitstream Vera Sans", "Trebuchet MS", Verdana, "Verdana Ref", sans-serif}.container h1,.container h2,.container h4,.container h4,.container h5{font-family:"Segoe UI", Candara, "Bitstream Vera Sans", "DejaVu Sans", "Bitstream Vera Sans", "Trebuchet MS", Verdana, "Verdana Ref", sans-serif}article{font-family:Merriweather !important}article h1{font-family:Merriweather !important}article li{font-family:Merriweather !important;line-height:1.6em}article li + li{margin-top:0.5em}article div.code{background:#f9f9f9;border:1px solid #d1d1d1;position:relative;border-radius:0.2em;margin:0.25em 0 0.75em 0;min-height:2.5em}article code{color:#005580;font-size:14px;white-space:pre}article a.hoogle > code{color:#0088cc;font-size:14px;white-space:pre;border:0}article .expand-code{display:none}article pre{overflow:auto;word-wrap:normal}article code.active{display:block;max-height:430px}article h1{font-size:31.5px}article h3{font-size:17.5px}article h4{font-size:14px}article h5,article h6{font-size:11.9px}article p{line-height:1.7em}article h1 code,article h2 code,article h3 code,article h4 code,article h5 code,article h6 code{font-size:inherit !important}article h1 a,article h2 a,article h3 a,article h4 a,article h5 a,article h6 a{color:#444}article h1 a:before,article h2 a:before,article h3 a:before,article h4 a:before,article h5 a:before,article h6 a:before{margin-left:-1.5em;padding-right:0.5em;font-family:fontawesome;content:"\f0c1";font-size:20px;color:#fff}article h1 a:hover,article h2 a:hover,article h3 a:hover,article h4 a:hover,article h5 a:hover,article h6 a:hover{text-decoration:none;color:#0088cc}article h1 a:hover:before,article h2 a:hover:before,article h3 a:hover:before,article h4 a:hover:before,article h5 a:hover:before,article h6 a:hover:before{color:#888}article h2{font-size:24.5px}article .popover{font-family:actor}article .popover h3.popover-title{font-family:actor !important;font-size:1em}article .popover .popover-content{width:15em;font-size:1em}article .controlsRun{display:block;padding:0.5em;text-align:right;background:#f2f2f2}article .controlsRun a.clone{margin-right:1em;font-family:actor;text-decoration:none}article .controlsRun a.clone span{padding-left:0.5em}article .controlsRun a.run,article .controlsRun a.reset,article .controlsRun a.show-code{font-size:16px}article .controlsRun a.run span,article .controlsRun a.reset span,article .controlsRun a.show-code span{display:none}article .controlsRun a.reset{margin-left:0.5em;color:#a2becc}article .controlsRun a.reset{display:none}article .controlsRun a.show-code{margin-right:0.75em}article .controlsRun a.run:hover,article .controlsRun a.show-code:hover{text-decoration:none}article .controlsRun a.show-code.active{color:#DC0D0D}article .controlsRun a[disabled]{color:#a2becc;cursor:default}article .collapse-area .collapse-header{background:#0088cc;color:#fff;padding:0.3em;cursor:pointer}article .collapse-area .hidden-toggle:before{content:"\f0d7";font-family:fontawesome;margin-right:0.5em;margin-left:0.25em}article .collapse-area .collapsed-files{overflow:auto;height:auto}article .collapse-area.collapse-disabled{display:none}article .collapse-area.collapse-area-off .collapsed-files{height:0px;overflow:hidden}article .collapse-area.collapse-area-off .hidden-toggle:before{content:"\f0da"}article .snippet-stdio .stdout{margin:0.5em;padding-right:2em;position:relative;word-wrap:break-word}article .snippet-stdio .stdin{-webkit-box-shadow:none;-moz-box-shadow:none;box-shadow:none;-webkit-transition:none;-moz-transition:none;-o-transition:none;transition:none;padding:0;margin:0}article .hoogle-results{margin:0.25em}article .hoogle-results .hoogle-inner{background:#fff;padding:0.5em;border-radius:3px;border:1px solid #ddd}article .hoogle-results .hoogle-inner .close-link{position:relative;float:right;margin-top:-0.5em;margin-right:-0.5em}article .snippet-output-errors{margin:1em 0.5em 0.5em 0.5em;position:relative}article .snippet-output-errors ul{list-style-type:none;margin:0;position:relative}article .snippet-output-errors pre{border:0;border-radius:0;padding:0.25em;margin:0;background:inherit;color:inherit}article .snippet-output-errors .close-link{color:inherit;background:inherit}article .snippet-editors{z-index:0;padding:0.25em}article .close-link{padding:0.5em;background:#eaeaea;border-bottom-left-radius:0.2em;border-top-right-radius:0.2em;position:absolute;top:0;right:0}article .close-link:hover{text-decoration:none}article .snippet-title{padding:0.5em 0 0 0.5em}article .snippet-title .snippet-icon{font-family:FontAwesome;display:inline-block;margin-right:0.5em}article .fullModuleCode + div .snippet-title{margin-top:0.5em;border-top:1px solid #ccc;padding-top:0.5em}article .CodeMirror{height:auto;min-height:1em;line-height:1.5em;background:transparent;font-size:14px !important}article .CodeMirror .highlighted{background:rgba(250, 210, 0, 0.45) !important}article .CodeMirror-widget{margin-left:2em;line-height:1.8}article .CodeMirror.collapsed{height:10em !important}article .editor .expander{text-align:center;display:block;padding:0.5em;text-decoration:none;border-bottom-left-radius:2px;border-bottom-right-radius:2px}article .editor .expander .ellipsis{background:white;border:1px solid #ccc;padding:0 0.5em;height:1em;line-height:0.5em;display:inline-block;color:#555;cursor:pointer}article .editor .expander .ellipsis:hover{background:#ddd;color:#333}article .web-runner{margin:0.5em;padding:0.5em;border:1px solid #ccc;border-radius:3px;background:#f5f5f5}article .web-runner iframe{border:0;margin-top:0.5em;margin-bottom:0;background:white}article .web-runner .controls i{cursor:pointer;color:#0088cc}article .web-runner .controls i:hover{color:#222}article .web-runner .controls i + i{margin-left:0.5em}article .web-runner .controls .icon-remove{float:right}article .hidden{display:block;visibility:visible}article .controlsShowHide{margin-bottom:0.5em}.tutorial-body{float:left !important}.tutorial-nav{float:right !important}@media (max-width: 979px) {.related-content{float:right}.author-name{display:block;margin-left:20px !important;padding-left:5px;margin-top:5px}article h1 a:hover:before,article h2 a:hover:before,article h3 a:hover:before,article h4 a:hover:before,article h5 a:hover:before,article h6 a:hover:before{color:#fff}.tutorial-nav{float:none !important;width:auto !important}.tutorial-body{float:none !important;width:auto !important}}@media (min-width: 980px) and (max-width: 1199px) {.navbar-search{display:none}.tutorial-nav{width:200px}.tutorial-body{width:720px}}#accountPage h1{margin:20px 0 0 0}#accountPage h2{font-size:20px}.group-contents .span8{float:left}.group-contents .span4{float:right}.container > .alert-block{margin-top:1em}.alert{color:#aa874a
}.social{margin-bottom:.8em;display:block}.social a{text-decoration:none}.social i{font-size:1.1em;color:#fff;padding:0.25em;border-radius:0.25em;width:1em;display:inline-block;text-align:center}.social i.icon-twitter{background:#0088cc}.social i.icon-facebook{background:#3b5998
  }.social i.icon-google-plus{background:#dd4b39
  }.well pre{background:#fcfcfc}.well h2{margin-top:0}code{color:#005580;font-size:14px;white-space:pre}</style><!--[if lt IE 8]><link rel="stylesheet" href="https://www.schoolofhaskell.com/static/design/css/ie7.css?etag=TSMl9x1V"><![endif]--><!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]--></head><body class="not-logged-in" itemscope itemtype="http://schema.org/Product"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-H62P" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-H62P');</script><div class="navbar navbar-inverse navbar-static-top"><div class="navbar-inner"><div class="container"><a class="btn btn-navbar" type="button" data-toggle="collapse" data-target=".nav-collapse"><span class="icon-bar"></span>
<span class="icon-bar"></span>
<span class="icon-bar"></span>
</a>
<a class="brand" href="/"><img src="/static/img/haskell-logo-wide.png" title="School of Haskell">
</a>
<div class="nav-collapse collapse"><ul class="nav"><li><a href="https://www.schoolofhaskell.com/">School</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user">Users</a>
</li>
</ul>
<form class="navbar-search pull-left" action="https://www.schoolofhaskell.com/search"><input class="search-query" type="text" placeholder="Search" name="search">
</form>
</div>
</div>
</div>
</div>
<div class="container breadcrumb-container"><div class="row"><div class="span12"><ul class="breadcrumb"><li><a href="https://www.schoolofhaskell.com/user/sloan">Michael Sloan</a>
<span class="divider">/</span>
</li>
<li><a href="https://www.schoolofhaskell.com/user/sloan/reifying-instance-resolution">Reifying Instance Resolution</a>
</li>
</ul>
</div>
</div>
</div>
<div class="container main-content"><div class="row"><div class="span12"><h1 itemprop="name">Reifying Instance Resolution</h1>
</div>
</div>
<div class="row"><div class="span7 meta"><p><span class="date">21 Dec 2014</span>
<span class="author"><a href="https://www.schoolofhaskell.com/user/sloan">Michael Sloan</a>
</span>
<span class="view-edit-link pull-right"><a class="view-source-link" href="https://www.schoolofhaskell.com/tutorial-raw/5825/7fa7e5df7c7667bab3f4ae3f7e142d758db6819f">View Markdown source</a>
</span>
</p>
<p class="tags"></p>
</div>
</div>
<div class="row"><div class="span7 meta"><span class="sociallinksunicode social">
<a href="https://twitter.com/home?status=$url$" target="_blank"><i class="icon-twitter"></i></a>&nbsp;
<a href="http://www.facebook.com/sharer/sharer.php?u=$url$" target="_blank"><i class="icon-facebook"></i></a>&nbsp;
<a href="https://plus.google.com/share?url=$url$" target="_blank"><i class="icon-google-plus"></i></a></span>
</div>
</div>
<p class="alert">As of March 2020, School of Haskell has been switched to read-only mode.</p>
<div class="row" itemprop="desc"><div class="span4 tutorial-nav"><div class="related-content"><ul class="nav nav-tabs nav-stacked"><li><script>reddit_target='fpcomplete'</script>
<script src="https://redditstatic.s3.amazonaws.com/button/button1.js"></script>
</li>
<li><a href="https://www.schoolofhaskell.com/user/sloan">See all content by Michael Sloan</a>
</li>
</ul>

</div>
<div class="aside"><h3>Sections</h3>
<ul><li><a href="#ord-demo">Ord demo</a></li><li><a href="#printf-demo">Printf demo</a></li><li><a href="#how-it-works">How it works</a></li><li><a href="#explaining-unsatisfied-constraints">Explaining unsatisfied constraints</a></li><li><a href="#limitations">Limitations</a></li></ul></div>
</div>
<div class="span8 tutorial-body" data-environment="def">
<article><p>A week or two ago, <a href="https://github.com/chrisdone">Chris Done</a> and I
were talking about how it'd be excellent if GHC could tell you <i>why</i>
an instance exists.  If this feature was in GHCI, here's roughly what
it might look like:</p><pre><code class="haskell">
Prelude&gt; :explain Ord [Maybe Int]
instance Ord a =&gt; Ord [a] -- Defined in 'GHC.Classes'
  with a ~ Maybe Int

  instance Ord a =&gt; Ord (Maybe a) -- Defined in 'Data.Maybe'
    with a ~ Int

    instance Ord Int -- Defined in 'GHC.Classes'</code></pre><p>This traces GHC's reasoning when resolving instances for a particular
type.  The first line tells us that the <code>Ord a =&gt; Ord [a]</code> instance
will be used for <code>Ord [Maybe Int]</code>.  Nested under this is a <code>with</code>
clause, which shows how the type variables are instantiated.  In this
case, it tells us that <code>a</code> in that instance is instantiated to <code>Maybe Int</code>.</p><p>After the <code>with</code> clause comes the instances that are needed to satisfy
the instance context.  In this case, an instance for <code>Ord (Maybe Int)</code>
is needed due to the <code>Ord a</code> constraint in the instance for <code>Ord [a]</code>.</p><p>Anyway, Chris posed a challenge:</p><blockquote><p>hmm, i wonder if there's some uber general way to debug the way
haskell's types are resolved by generating clever code</p></blockquote><p>I pondered this for a bit, and concluded that this is indeed
possible!  Last weekend I had a crack at implementing it, and it
worked out well beyond my expectations!</p><h1 id="ord-demo"><a href="#ord-demo">Ord demo</a></h1><pre><code class="active haskell">{-# START_FILE Demo.hs #-}
-- Usually not all of these pragmas are necessary. But they are
-- needed for some invocations of 'explainInstance'.
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE PolyKinds #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE OverlappingInstances #-}
{-# LANGUAGE UndecidableInstances #-}
{-# LANGUAGE DeriveDataTypeable #-}

import ExplainInstance
-- show
explainInstance [t| Ord [Maybe Int] |]
-- /show
{-# START_FILE ExplainInstance.hs #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE ViewPatterns #-}

-- show
-- /show
module ExplainInstance where

import qualified Control.Monad.State as State
import qualified Data.Set as S


import           Control.Applicative ((&lt;$&gt;), (&lt;*&gt;))
import           Control.Monad (filterM)
import           Data.Function (on)
import           Data.Generics
import           Data.List (groupBy, sortBy, sort, group, find)
import qualified Data.Map as M
import           Data.Maybe
import           Data.Ord (comparing)
import           Language.Haskell.TH
import           Language.Haskell.TH.Syntax (addTopDecls)

-- TODO:
--
-- * Rename to &quot;explain-instance&quot;
--
-- * Show info about type families by using Typeable
--
-- * Use a parser so that type vars can be provided.  Or, have a
-- wildcard datatype.
--
-- * Apply inverse renaming on output types (relevant to constraints
-- that end up in the types, as well as data types with contexts)

-- Issues due to TH limitations:
--
-- * No ConstraintKinds
--
-- * No PolyKinds
--
-- * No info about whether an instance is overlapping / incoherent
--   (TODO: is this truly an issue?)
--
-- * No GHCI support. This is because 'explainInstances' can't yield
-- an Exp, as:
--
--   Only function, value, and foreign import declarations may be
--   added with addTopDecl
--
-- Which seems to be a rather arbitrary limitation...
--
-- TODO: Followup on these limitations on trac / mailinglists

explainInstance :: Q Type -&gt; Q [Dec]
explainInstance = explainInstance' False

explainInstanceError :: Q Type -&gt; Q [Dec]
explainInstanceError = explainInstance' True

explainInstance' :: Bool -&gt; Q Type -&gt; Q [Dec]
explainInstance' addErrorInstance qty = do
    ty &lt;- qty
    case unAppsT ty of
        (ConT clazz : tys) -&gt; do
            (decs, methodMap, renameMap) &lt;- instanceResolvers addErrorInstance [clazz]
            let tys' = applySubstMap renameMap tys
            decs' &lt;- [d| main = putStrLn (displayInst $(return (invokeResolve methodMap clazz tys'))) |]
            return (decs' ++ decs)
        _ -&gt; fail &quot;explainInstance input should be a constraint&quot;

-- | An explanation of why some constraint is satisfied.
data Inst = Inst
    { -- | Like an instance declaration, but without the declarations.
      instHead :: String
      -- | Describes how type variables are instantiated in the head.
    , instTypes :: [(String, TypeRep)]
      -- | Explanations of how the instance's constraints are satisfied.
    , instConstraints :: [Inst]
    }
    deriving (Show)

-- | Provides an indented string presentation of the instance resolution tree.
displayInst :: Inst -&gt; String
displayInst = go 0
  where
    go i (Inst decl vars cxt) =
        addIndent i (decl ++ displayVars vars) ++
        concatMap ((&quot;\n&quot; ++) . go (i + 2)) cxt
    displayVars [] = &quot;&quot;
    displayVars (var0 : vars) =
        &quot;\n  with &quot; ++ displayVar var0 ++
        &quot;\n&quot; ++ unlines (map ((&quot;       &quot; ++) . displayVar) vars)
    displayVar (n, ty) = n ++ &quot; ~ &quot; ++ showsPrec 9 ty &quot;&quot;

instanceResolvers :: Bool -&gt; [Name] -&gt; Q ([Dec], M.Map Name Name, M.Map Name Name)
instanceResolvers addErrorInstance initial = do
    infos &lt;- reifyMany recurse initial
    methodMap &lt;- M.fromList &lt;$&gt; sequence
        [ (n, ) &lt;$&gt; chooseUnusedName True (&quot;resolve&quot; ++ nameBase n)
        | (n, ClassI {}) &lt;- infos
        ]
    let names = map fst infos ++ concatMap (map conName . infoCons . snd) infos
    renameMap &lt;- M.fromList &lt;$&gt;
        mapM (\n -&gt; (n, ) &lt;$&gt; chooseUnusedName False (nameBase n)) names
    decs &lt;- mapM (resolver methodMap) (concatMap (infoToDecs . snd) infos)
    return (map (applySubst (flip M.lookup renameMap)) decs, methodMap, renameMap)
  where
    -- Recursively enumerate all of the top level declarations which
    -- need to be copied / renamed.
    recurse :: (Name, Info) -&gt; Q (Bool, [Name])
    recurse (name, info) = return $ do
        case info of
            ClassI (ClassD cxt _name tvs _fds decs) insts -&gt;
                (True, allNames (cxt, filter isFamilyDec decs) ++
                       concatMap tvKindNames tvs ++
                       concatMap instNames insts)
            TyConI (TySynD _name tvs ty) -&gt;
                (True, allNames ty ++ concatMap tvKindNames tvs)
            -- Only need to clone data declarations when they have
            -- datatype contexts.
            TyConI (DataD cxt _name _tvs _cons _deriving) -&gt;
                (not (null cxt), allNames cxt)
            TyConI (NewtypeD cxt _name _tvs _con _deriving) -&gt;
                (not (null cxt), allNames cxt)
            -- We might encounter this due to DataKinds.
            DataConI _name _ty typeName _fixity -&gt;
                (False, [typeName])
            -- FamilyI dec insts -&gt; return (True, [])
            _ -&gt; (False, [])
    instNames :: Dec -&gt; [Name]
    instNames (InstanceD cxt ty decs) =
        allNames cxt ++ allNames ty ++ allNames (filter isFamilyDec decs)
    instNames _ = []
    infoToDecs :: Info -&gt; [Dec]
    -- TODO: check fundeps?
    infoToDecs (ClassI dec@(ClassD _ name tvs _ _) insts) =
        case addErrorInstance &amp;&amp; not hasDefaultCase of
            False -&gt; dec : insts
            True -&gt;
                let errInst = InstanceD
                        []
                        (appsT $ ConT name : map (VarT . tvName) tvs)
                        errorInstanceDecs
                in dec : errInst : insts
      where
        -- If true then an overlapping instance like (Class v1 ..),
        -- where all arguments are type variables, already exists.
        -- In this case omit the error instance.
        hasDefaultCase = isJust $ find isDefaultCase insts
        isDefaultCase (InstanceD _ (unAppsT -&gt; (_:tys)) _) =
            all isTyVar tys
        isDefaultCase _ = False
        isTyVar (VarT _) = True
        isTyVar _ = False
    infoToDecs (ClassI _ _) = error &quot;impossible: ClassI which doesn't contain ClassD&quot;
    infoToDecs (TyConI dec) = [dec]
    infoToDecs (FamilyI dec insts) = dec : insts
    infoToDecs (VarI _name _ty mdec _fixity) = maybeToList mdec
    infoToDecs ClassOpI {} = []
    infoToDecs PrimTyConI {} = []
    infoToDecs DataConI {} = []
    infoToDecs TyVarI {} = []
    errorInstanceDecs = [FunD (mkName &quot;x&quot;) []]
    -- Modify a class or instance to instead just have a single
    -- &quot;resolver*&quot; function.
    resolver :: M.Map Name Name -&gt; Dec -&gt; Q Dec
    resolver methodMap (ClassD cxt' name tvs fds decs) = do
        let method = lookupMethod methodMap name
            ty = funT $
                map (AppT (ConT ''Proxy) . VarT . tvName) tvs ++
                [ConT ''Inst]
        cxt &lt;- mapM trimConstraint cxt'
        return $ ClassD cxt name tvs fds $
            filter isFamilyDec decs ++
            [SigD method ty]
    resolver methodMap (InstanceD cxt' ty' decs) = do
        cxt &lt;- mapM trimConstraint cxt'
        ty &lt;- trimInstanceType ty'
        let substs = varTSubsts (cxt, ty)
            cleanTyVars = applySubstMap (M.fromList substs)
        cleanedHead &lt;- cleanTyCons $ cleanTyVars $ InstanceD cxt ty []
        let (ConT clazzName : tvs) = unAppsT ty
            method = lookupMethod methodMap clazzName
            msg = case addErrorInstance of
                True | decs == errorInstanceDecs -&gt; &quot;ERROR &quot; ++ pprint cleanedHead
                _ -&gt; pprint cleanedHead
            expr = appsE'
                [ ConE 'Inst
                , LitE $ StringL msg
                , ListE $ flip map substs $ \(ty, cty) -&gt; TupE
                    [ LitE (StringL (pprint cty))
                    , AppE (VarE 'typeRep) (proxyE (VarT ty))
                    ]
                , ListE $ flip mapMaybe cxt $ \case
                    EqualP {} -&gt; Nothing
                    ClassP n tys -&gt; Just (invokeResolve methodMap n tys)
                ]
            -- Need extra typeable constraints in order to use typeRep.
            extraCxt = map (ClassP ''Typeable . (: []) . VarT . fst) substs
        return $ InstanceD (cxt ++ extraCxt) ty $
            filter isFamilyDec decs ++
            [FunD method [Clause (map (\_ -&gt; WildP) tvs) (NormalB expr) []]]
    resolver _ dec = return dec

invokeResolve :: M.Map Name Name -&gt; Name -&gt; [Type] -&gt; Exp
invokeResolve methodMap name tys =
    appsE' $ VarE (lookupMethod methodMap name) : map proxyE tys

lookupMethod :: M.Map Name Name -&gt; Name -&gt; Name
lookupMethod methodMap name =
    fromMaybe (error (&quot;Couldn't find resolve* method name for &quot; ++ show name))
              (M.lookup name methodMap)

allNames :: Data a =&gt; a -&gt; [Name]
allNames = listify (\_ -&gt; True)

tvKindNames :: TyVarBndr -&gt; [Name]
tvKindNames (KindedTV _name kind) = allNames kind
tvKindNames PlainTV {} = []

tvName :: TyVarBndr -&gt; Name
tvName (KindedTV name _kind) = name
tvName (PlainTV name) = name

isFamilyDec FamilyD {} = True
isFamilyDec DataInstD {} = True
isFamilyDec NewtypeInstD {} = True
isFamilyDec TySynInstD {} = True
isFamilyDec ClosedTypeFamilyD {} = True
isFamilyDec _ = False

-- Work around a TH bug where PolyKinded constraints get too many
-- arguments.
trimConstraint :: Pred -&gt; Q Pred
trimConstraint (ClassP n tys) = do
    ClassI (ClassD _ _ tvs _ _) _ &lt;- reify n
    return $ ClassP n (drop (length tys - length tvs) tys)
trimConstraint x = return x

trimInstanceType :: Type -&gt; Q Type
trimInstanceType (unAppsT -&gt; (ConT n : tys)) = do
    ClassI (ClassD _ _ tvs _ _) _ &lt;- reify n
    return $ appsT (ConT n : (drop (length tys - length tvs) tys))

chooseUnusedName :: Bool -&gt; String -&gt; Q Name
chooseUnusedName allowUnmodified name = do
    -- This will always match, since there can only be finite names.
    Just str &lt;- findM (\str -&gt; not &lt;$&gt; exists str) choices
    return (mkName str)
  where
    choices = map (name ++) $
        (if allowUnmodified then (&quot;&quot; : ) else id) $
        &quot;_&quot; : map ('_':) (map show [1..])
    -- 'recover' is used to handle errors due to ambiguous identifier names.
    exists str = recover (return True) $ do
        mtype &lt;- lookupTypeName str
        mvalue &lt;- lookupValueName str
        return $ isJust mtype || isJust mvalue

findM :: Monad m =&gt; (a -&gt; m Bool) -&gt; [a] -&gt; m (Maybe a)
findM f (x:xs) = do
    b &lt;- f x
    if b
        then return (Just x)
        else findM f xs

applySubst :: (Data a, Typeable b) =&gt; (b -&gt; Maybe b) -&gt; a -&gt; a
applySubst f = everywhere (id `extT` (\x -&gt; fromMaybe x (f x)))

applySubstMap :: (Data a, Ord b, Typeable b) =&gt; M.Map b b -&gt; a -&gt; a
applySubstMap m = applySubst (flip M.lookup m)

funT :: [Type] -&gt; Type
funT [x] = x
funT (x:xs) = AppT (AppT ArrowT x) (funT xs)

appsT :: [Type] -&gt; Type
appsT = go . reverse
  where
    go [x] = x
    go (x:xs) = AppT (go xs) x

unAppsT :: Type -&gt; [Type]
unAppsT ty = go ty []
  where
    go (AppT l r) = go l . (r :)
    go ty = (ty :)

appsE' :: [Exp] -&gt; Exp
appsE' = go . reverse
  where
    go [x] = x
    go (x:xs) = AppE (go xs) x

proxyE :: Type -&gt; Exp
proxyE = SigE (ConE 'Proxy) . AppT (ConT ''Proxy)

freeVarsT :: Type -&gt; [Name]
freeVarsT (ForallT tvs _ ty) = filter (`notElem` (map tvName tvs)) (freeVarsT ty)
freeVarsT (AppT l r) = freeVarsT l ++ freeVarsT r
freeVarsT (SigT ty k) = freeVarsT ty ++ freeVarsT k
freeVarsT (VarT n) = [n]
freeVarsT _ = []

-- Dequalify names which are unambiguous.
cleanTyCons :: Data a =&gt; a -&gt; Q a
cleanTyCons = everywhereM (return `extM` subst1 `extM` subst2)
  where
    rename :: Name -&gt; Q Name
    rename n = do
        inScope &lt;- typeNameInScope n
        return $ if inScope then mkName (nameBase n) else n
    subst1 (ConT n) = ConT &lt;$&gt; rename n
    subst1 x = return x
    subst2 (ClassP n tys) = ClassP &lt;$&gt; rename n &lt;*&gt; return tys
    subst2 x = return x

typeNameInScope :: Name -&gt; Q Bool
typeNameInScope n =
    recover (return False)
            ((Just n ==) &lt;$&gt; lookupTypeName (nameBase n))

-- Chooses prettier names for type variables.  Assumes that all type
-- variable names are unique.
varTSubsts :: Data a =&gt; a -&gt; [(Name, Name)]
varTSubsts =
    concatMap munge . groupSortOn nameBase . sortNub . varTNames
  where
    munge = zipWith (\s x -&gt; (x, mkName (nameBase x ++ s))) (&quot;&quot; : map show [1..])

varTNames :: Data a =&gt; a -&gt; [Name]
varTNames x = [n | VarT n &lt;- listify (\_ -&gt; True) x]

infoCons :: Info -&gt; [Con]
infoCons (TyConI (DataD _ _ _ cons _)) = cons
infoCons (TyConI (NewtypeD _ _ _ con _)) = [con]
infoCons _ = []

conName :: Con -&gt; Name
conName (NormalC name _) = name
conName (RecC name _) = name
conName (InfixC _ name _) = name
conName (ForallC _ _ con) = conName con

groupSortOn :: Ord b =&gt; (a -&gt; b) -&gt; [a] -&gt; [[a]]
groupSortOn f = groupBy ((==) `on` f) . sortBy (comparing f)

sortNub :: Ord a =&gt; [a] -&gt; [a]
sortNub = map head . group . sort

addIndent :: Int -&gt; String -&gt; String
addIndent cnt = unlines . map (replicate cnt ' ' ++) . lines

reifyMany :: ((Name, Info) -&gt; Q (Bool, [Name]))
          -&gt; [Name]
          -&gt; Q [(Name, Info)]
reifyMany recurse initial =
    State.evalStateT (fmap concat $ mapM go initial) S.empty
  where
    go :: Name -&gt; State.StateT (S.Set Name) Q [(Name, Info)]
    go n = do
        seen &lt;- State.get
        if S.member n seen
            then return []
            else do
                State.put (S.insert n seen)
                minfo &lt;- State.lift $ recover (return Nothing) (fmap Just (reify n))
                case minfo of
                    Just info -&gt; do
                        (shouldEmit, ns) &lt;- State.lift $ recurse (n, info)
                        (if shouldEmit
                             then fmap ((n, info):)
                             else id) $ fmap concat $ mapM go ns
                    _ -&gt; return []
</code></pre><p>Neat, it works!</p><p><code>Ord</code> instances are pretty easy to follow since they tend to just be
structurally recursive.  Let's try this out on something a little more
interesting!</p><h1 id="printf-demo"><a href="#printf-demo">Printf demo</a></h1><p>Initially, it can be a bit tricky to grok how typeclasses allow
Haskell to have polyvariadic functions.  Lets see how
<code>explainInstances</code> can clarify!</p><pre><code class="active haskell">{-# START_FILE Demo.hs #-}
-- Usually not all of these pragmas are necessary. But they are
-- needed for some invocations of 'explainInstance'.
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE PolyKinds #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE OverlappingInstances #-}
{-# LANGUAGE UndecidableInstances #-}
{-# LANGUAGE DeriveDataTypeable #-}

import ExplainInstance
-- show
import Text.Printf

explainInstance [t| PrintfType (Int -&gt; Int -&gt; String) |]
-- /show
{-# START_FILE ExplainInstance.hs #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE ViewPatterns #-}

-- show
-- /show
module ExplainInstance where

import qualified Control.Monad.State as State
import qualified Data.Set as S


import           Control.Applicative ((&lt;$&gt;), (&lt;*&gt;))
import           Control.Monad (filterM)
import           Data.Function (on)
import           Data.Generics
import           Data.List (groupBy, sortBy, sort, group, find)
import qualified Data.Map as M
import           Data.Maybe
import           Data.Ord (comparing)
import           Language.Haskell.TH
import           Language.Haskell.TH.Syntax (addTopDecls)

-- TODO:
--
-- * Rename to &quot;explain-instance&quot;
--
-- * Show info about type families by using Typeable
--
-- * Use a parser so that type vars can be provided.  Or, have a
-- wildcard datatype.
--
-- * Apply inverse renaming on output types (relevant to constraints
-- that end up in the types, as well as data types with contexts)

-- Issues due to TH limitations:
--
-- * No ConstraintKinds
--
-- * No PolyKinds
--
-- * No info about whether an instance is overlapping / incoherent
--   (TODO: is this truly an issue?)
--
-- * No GHCI support. This is because 'explainInstances' can't yield
-- an Exp, as:
--
--   Only function, value, and foreign import declarations may be
--   added with addTopDecl
--
-- Which seems to be a rather arbitrary limitation...
--
-- TODO: Followup on these limitations on trac / mailinglists

explainInstance :: Q Type -&gt; Q [Dec]
explainInstance = explainInstance' False

explainInstanceError :: Q Type -&gt; Q [Dec]
explainInstanceError = explainInstance' True

explainInstance' :: Bool -&gt; Q Type -&gt; Q [Dec]
explainInstance' addErrorInstance qty = do
    ty &lt;- qty
    case unAppsT ty of
        (ConT clazz : tys) -&gt; do
            (decs, methodMap, renameMap) &lt;- instanceResolvers addErrorInstance [clazz]
            let tys' = applySubstMap renameMap tys
            decs' &lt;- [d| main = putStrLn (displayInst $(return (invokeResolve methodMap clazz tys'))) |]
            return (decs' ++ decs)
        _ -&gt; fail &quot;explainInstance input should be a constraint&quot;

-- | An explanation of why some constraint is satisfied.
data Inst = Inst
    { -- | Like an instance declaration, but without the declarations.
      instHead :: String
      -- | Describes how type variables are instantiated in the head.
    , instTypes :: [(String, TypeRep)]
      -- | Explanations of how the instance's constraints are satisfied.
    , instConstraints :: [Inst]
    }
    deriving (Show)

-- | Provides an indented string presentation of the instance resolution tree.
displayInst :: Inst -&gt; String
displayInst = go 0
  where
    go i (Inst decl vars cxt) =
        addIndent i (decl ++ displayVars vars) ++
        concatMap ((&quot;\n&quot; ++) . go (i + 2)) cxt
    displayVars [] = &quot;&quot;
    displayVars (var0 : vars) =
        &quot;\n  with &quot; ++ displayVar var0 ++
        &quot;\n&quot; ++ unlines (map ((&quot;       &quot; ++) . displayVar) vars)
    displayVar (n, ty) = n ++ &quot; ~ &quot; ++ showsPrec 9 ty &quot;&quot;

instanceResolvers :: Bool -&gt; [Name] -&gt; Q ([Dec], M.Map Name Name, M.Map Name Name)
instanceResolvers addErrorInstance initial = do
    infos &lt;- reifyMany recurse initial
    methodMap &lt;- M.fromList &lt;$&gt; sequence
        [ (n, ) &lt;$&gt; chooseUnusedName True (&quot;resolve&quot; ++ nameBase n)
        | (n, ClassI {}) &lt;- infos
        ]
    let names = map fst infos ++ concatMap (map conName . infoCons . snd) infos
    renameMap &lt;- M.fromList &lt;$&gt;
        mapM (\n -&gt; (n, ) &lt;$&gt; chooseUnusedName False (nameBase n)) names
    decs &lt;- mapM (resolver methodMap) (concatMap (infoToDecs . snd) infos)
    return (map (applySubst (flip M.lookup renameMap)) decs, methodMap, renameMap)
  where
    -- Recursively enumerate all of the top level declarations which
    -- need to be copied / renamed.
    recurse :: (Name, Info) -&gt; Q (Bool, [Name])
    recurse (name, info) = return $ do
        case info of
            ClassI (ClassD cxt _name tvs _fds decs) insts -&gt;
                (True, allNames (cxt, filter isFamilyDec decs) ++
                       concatMap tvKindNames tvs ++
                       concatMap instNames insts)
            TyConI (TySynD _name tvs ty) -&gt;
                (True, allNames ty ++ concatMap tvKindNames tvs)
            -- Only need to clone data declarations when they have
            -- datatype contexts.
            TyConI (DataD cxt _name _tvs _cons _deriving) -&gt;
                (not (null cxt), allNames cxt)
            TyConI (NewtypeD cxt _name _tvs _con _deriving) -&gt;
                (not (null cxt), allNames cxt)
            -- We might encounter this due to DataKinds.
            DataConI _name _ty typeName _fixity -&gt;
                (False, [typeName])
            -- FamilyI dec insts -&gt; return (True, [])
            _ -&gt; (False, [])
    instNames :: Dec -&gt; [Name]
    instNames (InstanceD cxt ty decs) =
        allNames cxt ++ allNames ty ++ allNames (filter isFamilyDec decs)
    instNames _ = []
    infoToDecs :: Info -&gt; [Dec]
    -- TODO: check fundeps?
    infoToDecs (ClassI dec@(ClassD _ name tvs _ _) insts) =
        case addErrorInstance &amp;&amp; not hasDefaultCase of
            False -&gt; dec : insts
            True -&gt;
                let errInst = InstanceD
                        []
                        (appsT $ ConT name : map (VarT . tvName) tvs)
                        errorInstanceDecs
                in dec : errInst : insts
      where
        -- If true then an overlapping instance like (Class v1 ..),
        -- where all arguments are type variables, already exists.
        -- In this case omit the error instance.
        hasDefaultCase = isJust $ find isDefaultCase insts
        isDefaultCase (InstanceD _ (unAppsT -&gt; (_:tys)) _) =
            all isTyVar tys
        isDefaultCase _ = False
        isTyVar (VarT _) = True
        isTyVar _ = False
    infoToDecs (ClassI _ _) = error &quot;impossible: ClassI which doesn't contain ClassD&quot;
    infoToDecs (TyConI dec) = [dec]
    infoToDecs (FamilyI dec insts) = dec : insts
    infoToDecs (VarI _name _ty mdec _fixity) = maybeToList mdec
    infoToDecs ClassOpI {} = []
    infoToDecs PrimTyConI {} = []
    infoToDecs DataConI {} = []
    infoToDecs TyVarI {} = []
    errorInstanceDecs = [FunD (mkName &quot;x&quot;) []]
    -- Modify a class or instance to instead just have a single
    -- &quot;resolver*&quot; function.
    resolver :: M.Map Name Name -&gt; Dec -&gt; Q Dec
    resolver methodMap (ClassD cxt' name tvs fds decs) = do
        let method = lookupMethod methodMap name
            ty = funT $
                map (AppT (ConT ''Proxy) . VarT . tvName) tvs ++
                [ConT ''Inst]
        cxt &lt;- mapM trimConstraint cxt'
        return $ ClassD cxt name tvs fds $
            filter isFamilyDec decs ++
            [SigD method ty]
    resolver methodMap (InstanceD cxt' ty' decs) = do
        cxt &lt;- mapM trimConstraint cxt'
        ty &lt;- trimInstanceType ty'
        let substs = varTSubsts (cxt, ty)
            cleanTyVars = applySubstMap (M.fromList substs)
        cleanedHead &lt;- cleanTyCons $ cleanTyVars $ InstanceD cxt ty []
        let (ConT clazzName : tvs) = unAppsT ty
            method = lookupMethod methodMap clazzName
            msg = case addErrorInstance of
                True | decs == errorInstanceDecs -&gt; &quot;ERROR &quot; ++ pprint cleanedHead
                _ -&gt; pprint cleanedHead
            expr = appsE'
                [ ConE 'Inst
                , LitE $ StringL msg
                , ListE $ flip map substs $ \(ty, cty) -&gt; TupE
                    [ LitE (StringL (pprint cty))
                    , AppE (VarE 'typeRep) (proxyE (VarT ty))
                    ]
                , ListE $ flip mapMaybe cxt $ \case
                    EqualP {} -&gt; Nothing
                    ClassP n tys -&gt; Just (invokeResolve methodMap n tys)
                ]
            -- Need extra typeable constraints in order to use typeRep.
            extraCxt = map (ClassP ''Typeable . (: []) . VarT . fst) substs
        return $ InstanceD (cxt ++ extraCxt) ty $
            filter isFamilyDec decs ++
            [FunD method [Clause (map (\_ -&gt; WildP) tvs) (NormalB expr) []]]
    resolver _ dec = return dec

invokeResolve :: M.Map Name Name -&gt; Name -&gt; [Type] -&gt; Exp
invokeResolve methodMap name tys =
    appsE' $ VarE (lookupMethod methodMap name) : map proxyE tys

lookupMethod :: M.Map Name Name -&gt; Name -&gt; Name
lookupMethod methodMap name =
    fromMaybe (error (&quot;Couldn't find resolve* method name for &quot; ++ show name))
              (M.lookup name methodMap)

allNames :: Data a =&gt; a -&gt; [Name]
allNames = listify (\_ -&gt; True)

tvKindNames :: TyVarBndr -&gt; [Name]
tvKindNames (KindedTV _name kind) = allNames kind
tvKindNames PlainTV {} = []

tvName :: TyVarBndr -&gt; Name
tvName (KindedTV name _kind) = name
tvName (PlainTV name) = name

isFamilyDec FamilyD {} = True
isFamilyDec DataInstD {} = True
isFamilyDec NewtypeInstD {} = True
isFamilyDec TySynInstD {} = True
isFamilyDec ClosedTypeFamilyD {} = True
isFamilyDec _ = False

-- Work around a TH bug where PolyKinded constraints get too many
-- arguments.
trimConstraint :: Pred -&gt; Q Pred
trimConstraint (ClassP n tys) = do
    ClassI (ClassD _ _ tvs _ _) _ &lt;- reify n
    return $ ClassP n (drop (length tys - length tvs) tys)
trimConstraint x = return x

trimInstanceType :: Type -&gt; Q Type
trimInstanceType (unAppsT -&gt; (ConT n : tys)) = do
    ClassI (ClassD _ _ tvs _ _) _ &lt;- reify n
    return $ appsT (ConT n : (drop (length tys - length tvs) tys))

chooseUnusedName :: Bool -&gt; String -&gt; Q Name
chooseUnusedName allowUnmodified name = do
    -- This will always match, since there can only be finite names.
    Just str &lt;- findM (\str -&gt; not &lt;$&gt; exists str) choices
    return (mkName str)
  where
    choices = map (name ++) $
        (if allowUnmodified then (&quot;&quot; : ) else id) $
        &quot;_&quot; : map ('_':) (map show [1..])
    -- 'recover' is used to handle errors due to ambiguous identifier names.
    exists str = recover (return True) $ do
        mtype &lt;- lookupTypeName str
        mvalue &lt;- lookupValueName str
        return $ isJust mtype || isJust mvalue

findM :: Monad m =&gt; (a -&gt; m Bool) -&gt; [a] -&gt; m (Maybe a)
findM f (x:xs) = do
    b &lt;- f x
    if b
        then return (Just x)
        else findM f xs

applySubst :: (Data a, Typeable b) =&gt; (b -&gt; Maybe b) -&gt; a -&gt; a
applySubst f = everywhere (id `extT` (\x -&gt; fromMaybe x (f x)))

applySubstMap :: (Data a, Ord b, Typeable b) =&gt; M.Map b b -&gt; a -&gt; a
applySubstMap m = applySubst (flip M.lookup m)

funT :: [Type] -&gt; Type
funT [x] = x
funT (x:xs) = AppT (AppT ArrowT x) (funT xs)

appsT :: [Type] -&gt; Type
appsT = go . reverse
  where
    go [x] = x
    go (x:xs) = AppT (go xs) x

unAppsT :: Type -&gt; [Type]
unAppsT ty = go ty []
  where
    go (AppT l r) = go l . (r :)
    go ty = (ty :)

appsE' :: [Exp] -&gt; Exp
appsE' = go . reverse
  where
    go [x] = x
    go (x:xs) = AppE (go xs) x

proxyE :: Type -&gt; Exp
proxyE = SigE (ConE 'Proxy) . AppT (ConT ''Proxy)

freeVarsT :: Type -&gt; [Name]
freeVarsT (ForallT tvs _ ty) = filter (`notElem` (map tvName tvs)) (freeVarsT ty)
freeVarsT (AppT l r) = freeVarsT l ++ freeVarsT r
freeVarsT (SigT ty k) = freeVarsT ty ++ freeVarsT k
freeVarsT (VarT n) = [n]
freeVarsT _ = []

-- Dequalify names which are unambiguous.
cleanTyCons :: Data a =&gt; a -&gt; Q a
cleanTyCons = everywhereM (return `extM` subst1 `extM` subst2)
  where
    rename :: Name -&gt; Q Name
    rename n = do
        inScope &lt;- typeNameInScope n
        return $ if inScope then mkName (nameBase n) else n
    subst1 (ConT n) = ConT &lt;$&gt; rename n
    subst1 x = return x
    subst2 (ClassP n tys) = ClassP &lt;$&gt; rename n &lt;*&gt; return tys
    subst2 x = return x

typeNameInScope :: Name -&gt; Q Bool
typeNameInScope n =
    recover (return False)
            ((Just n ==) &lt;$&gt; lookupTypeName (nameBase n))

-- Chooses prettier names for type variables.  Assumes that all type
-- variable names are unique.
varTSubsts :: Data a =&gt; a -&gt; [(Name, Name)]
varTSubsts =
    concatMap munge . groupSortOn nameBase . sortNub . varTNames
  where
    munge = zipWith (\s x -&gt; (x, mkName (nameBase x ++ s))) (&quot;&quot; : map show [1..])

varTNames :: Data a =&gt; a -&gt; [Name]
varTNames x = [n | VarT n &lt;- listify (\_ -&gt; True) x]

infoCons :: Info -&gt; [Con]
infoCons (TyConI (DataD _ _ _ cons _)) = cons
infoCons (TyConI (NewtypeD _ _ _ con _)) = [con]
infoCons _ = []

conName :: Con -&gt; Name
conName (NormalC name _) = name
conName (RecC name _) = name
conName (InfixC _ name _) = name
conName (ForallC _ _ con) = conName con

groupSortOn :: Ord b =&gt; (a -&gt; b) -&gt; [a] -&gt; [[a]]
groupSortOn f = groupBy ((==) `on` f) . sortBy (comparing f)

sortNub :: Ord a =&gt; [a] -&gt; [a]
sortNub = map head . group . sort

addIndent :: Int -&gt; String -&gt; String
addIndent cnt = unlines . map (replicate cnt ' ' ++) . lines

reifyMany :: ((Name, Info) -&gt; Q (Bool, [Name]))
          -&gt; [Name]
          -&gt; Q [(Name, Info)]
reifyMany recurse initial =
    State.evalStateT (fmap concat $ mapM go initial) S.empty
  where
    go :: Name -&gt; State.StateT (S.Set Name) Q [(Name, Info)]
    go n = do
        seen &lt;- State.get
        if S.member n seen
            then return []
            else do
                State.put (S.insert n seen)
                minfo &lt;- State.lift $ recover (return Nothing) (fmap Just (reify n))
                case minfo of
                    Just info -&gt; do
                        (shouldEmit, ns) &lt;- State.lift $ recurse (n, info)
                        (if shouldEmit
                             then fmap ((n, info):)
                             else id) $ fmap concat $ mapM go ns
                    _ -&gt; return []
</code></pre><h1 id="how-it-works"><a href="#how-it-works">How it works</a></h1><p>This leverages Template Haskell in a rather extreme way - by
duplicating and renaming every top level declaration that could
possibly have anything to do with resolving the instance.  It turns
out that TH's <code>reify</code> function is actually quite sufficient for
recursively enumerating type declarations - something I'd previously
realized with my
<a href="http://hackage.haskell.org/package/th-reify-many">th-reify-many</a>
package.</p><p>For example, lets look at what happens to a made up typeclass and its
instances:</p><pre><code class="active haskell">{-# START_FILE Demo.hs #-}
-- Usually not all of these pragmas are necessary. But they are
-- needed for some invocations of 'explainInstance'.
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE PolyKinds #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE OverlappingInstances #-}
{-# LANGUAGE UndecidableInstances #-}
{-# LANGUAGE DeriveDataTypeable #-}

import ExplainInstance
-- show
class Size a where
    size :: a -&gt; Int

instance Size Int where
    size = id

instance Size a =&gt; Size (Maybe a) where
    size = maybe 0 size

instance (Size a, Size b) =&gt; Size (a, b) where
    size (a, b) = size a + size b

$(explainInstance [t| Size (Maybe Int, Int) |])
-- /show
{-# START_FILE ExplainInstance.hs #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE ViewPatterns #-}

-- show
-- /show
module ExplainInstance where

import qualified Control.Monad.State as State
import qualified Data.Set as S


import           Control.Applicative ((&lt;$&gt;), (&lt;*&gt;))
import           Control.Monad (filterM)
import           Data.Function (on)
import           Data.Generics
import           Data.List (groupBy, sortBy, sort, group, find)
import qualified Data.Map as M
import           Data.Maybe
import           Data.Ord (comparing)
import           Language.Haskell.TH
import           Language.Haskell.TH.Syntax (addTopDecls)

-- TODO:
--
-- * Rename to &quot;explain-instance&quot;
--
-- * Show info about type families by using Typeable
--
-- * Use a parser so that type vars can be provided.  Or, have a
-- wildcard datatype.
--
-- * Apply inverse renaming on output types (relevant to constraints
-- that end up in the types, as well as data types with contexts)

-- Issues due to TH limitations:
--
-- * No ConstraintKinds
--
-- * No PolyKinds
--
-- * No info about whether an instance is overlapping / incoherent
--   (TODO: is this truly an issue?)
--
-- * No GHCI support. This is because 'explainInstances' can't yield
-- an Exp, as:
--
--   Only function, value, and foreign import declarations may be
--   added with addTopDecl
--
-- Which seems to be a rather arbitrary limitation...
--
-- TODO: Followup on these limitations on trac / mailinglists

explainInstance :: Q Type -&gt; Q [Dec]
explainInstance = explainInstance' False

explainInstanceError :: Q Type -&gt; Q [Dec]
explainInstanceError = explainInstance' True

explainInstance' :: Bool -&gt; Q Type -&gt; Q [Dec]
explainInstance' addErrorInstance qty = do
    ty &lt;- qty
    case unAppsT ty of
        (ConT clazz : tys) -&gt; do
            (decs, methodMap, renameMap) &lt;- instanceResolvers addErrorInstance [clazz]
            let tys' = applySubstMap renameMap tys
            decs' &lt;- [d| main = putStrLn (displayInst $(return (invokeResolve methodMap clazz tys'))) |]
            return (decs' ++ decs)
        _ -&gt; fail &quot;explainInstance input should be a constraint&quot;

-- | An explanation of why some constraint is satisfied.
data Inst = Inst
    { -- | Like an instance declaration, but without the declarations.
      instHead :: String
      -- | Describes how type variables are instantiated in the head.
    , instTypes :: [(String, TypeRep)]
      -- | Explanations of how the instance's constraints are satisfied.
    , instConstraints :: [Inst]
    }
    deriving (Show)

-- | Provides an indented string presentation of the instance resolution tree.
displayInst :: Inst -&gt; String
displayInst = go 0
  where
    go i (Inst decl vars cxt) =
        addIndent i (decl ++ displayVars vars) ++
        concatMap ((&quot;\n&quot; ++) . go (i + 2)) cxt
    displayVars [] = &quot;&quot;
    displayVars (var0 : vars) =
        &quot;\n  with &quot; ++ displayVar var0 ++
        &quot;\n&quot; ++ unlines (map ((&quot;       &quot; ++) . displayVar) vars)
    displayVar (n, ty) = n ++ &quot; ~ &quot; ++ showsPrec 9 ty &quot;&quot;

instanceResolvers :: Bool -&gt; [Name] -&gt; Q ([Dec], M.Map Name Name, M.Map Name Name)
instanceResolvers addErrorInstance initial = do
    infos &lt;- reifyMany recurse initial
    methodMap &lt;- M.fromList &lt;$&gt; sequence
        [ (n, ) &lt;$&gt; chooseUnusedName True (&quot;resolve&quot; ++ nameBase n)
        | (n, ClassI {}) &lt;- infos
        ]
    let names = map fst infos ++ concatMap (map conName . infoCons . snd) infos
    renameMap &lt;- M.fromList &lt;$&gt;
        mapM (\n -&gt; (n, ) &lt;$&gt; chooseUnusedName False (nameBase n)) names
    decs &lt;- mapM (resolver methodMap) (concatMap (infoToDecs . snd) infos)
    return (map (applySubst (flip M.lookup renameMap)) decs, methodMap, renameMap)
  where
    -- Recursively enumerate all of the top level declarations which
    -- need to be copied / renamed.
    recurse :: (Name, Info) -&gt; Q (Bool, [Name])
    recurse (name, info) = return $ do
        case info of
            ClassI (ClassD cxt _name tvs _fds decs) insts -&gt;
                (True, allNames (cxt, filter isFamilyDec decs) ++
                       concatMap tvKindNames tvs ++
                       concatMap instNames insts)
            TyConI (TySynD _name tvs ty) -&gt;
                (True, allNames ty ++ concatMap tvKindNames tvs)
            -- Only need to clone data declarations when they have
            -- datatype contexts.
            TyConI (DataD cxt _name _tvs _cons _deriving) -&gt;
                (not (null cxt), allNames cxt)
            TyConI (NewtypeD cxt _name _tvs _con _deriving) -&gt;
                (not (null cxt), allNames cxt)
            -- We might encounter this due to DataKinds.
            DataConI _name _ty typeName _fixity -&gt;
                (False, [typeName])
            -- FamilyI dec insts -&gt; return (True, [])
            _ -&gt; (False, [])
    instNames :: Dec -&gt; [Name]
    instNames (InstanceD cxt ty decs) =
        allNames cxt ++ allNames ty ++ allNames (filter isFamilyDec decs)
    instNames _ = []
    infoToDecs :: Info -&gt; [Dec]
    -- TODO: check fundeps?
    infoToDecs (ClassI dec@(ClassD _ name tvs _ _) insts) =
        case addErrorInstance &amp;&amp; not hasDefaultCase of
            False -&gt; dec : insts
            True -&gt;
                let errInst = InstanceD
                        []
                        (appsT $ ConT name : map (VarT . tvName) tvs)
                        errorInstanceDecs
                in dec : errInst : insts
      where
        -- If true then an overlapping instance like (Class v1 ..),
        -- where all arguments are type variables, already exists.
        -- In this case omit the error instance.
        hasDefaultCase = isJust $ find isDefaultCase insts
        isDefaultCase (InstanceD _ (unAppsT -&gt; (_:tys)) _) =
            all isTyVar tys
        isDefaultCase _ = False
        isTyVar (VarT _) = True
        isTyVar _ = False
    infoToDecs (ClassI _ _) = error &quot;impossible: ClassI which doesn't contain ClassD&quot;
    infoToDecs (TyConI dec) = [dec]
    infoToDecs (FamilyI dec insts) = dec : insts
    infoToDecs (VarI _name _ty mdec _fixity) = maybeToList mdec
    infoToDecs ClassOpI {} = []
    infoToDecs PrimTyConI {} = []
    infoToDecs DataConI {} = []
    infoToDecs TyVarI {} = []
    errorInstanceDecs = [FunD (mkName &quot;x&quot;) []]
    -- Modify a class or instance to instead just have a single
    -- &quot;resolver*&quot; function.
    resolver :: M.Map Name Name -&gt; Dec -&gt; Q Dec
    resolver methodMap (ClassD cxt' name tvs fds decs) = do
        let method = lookupMethod methodMap name
            ty = funT $
                map (AppT (ConT ''Proxy) . VarT . tvName) tvs ++
                [ConT ''Inst]
        cxt &lt;- mapM trimConstraint cxt'
        return $ ClassD cxt name tvs fds $
            filter isFamilyDec decs ++
            [SigD method ty]
    resolver methodMap (InstanceD cxt' ty' decs) = do
        cxt &lt;- mapM trimConstraint cxt'
        ty &lt;- trimInstanceType ty'
        let substs = varTSubsts (cxt, ty)
            cleanTyVars = applySubstMap (M.fromList substs)
        cleanedHead &lt;- cleanTyCons $ cleanTyVars $ InstanceD cxt ty []
        let (ConT clazzName : tvs) = unAppsT ty
            method = lookupMethod methodMap clazzName
            msg = case addErrorInstance of
                True | decs == errorInstanceDecs -&gt; &quot;ERROR &quot; ++ pprint cleanedHead
                _ -&gt; pprint cleanedHead
            expr = appsE'
                [ ConE 'Inst
                , LitE $ StringL msg
                , ListE $ flip map substs $ \(ty, cty) -&gt; TupE
                    [ LitE (StringL (pprint cty))
                    , AppE (VarE 'typeRep) (proxyE (VarT ty))
                    ]
                , ListE $ flip mapMaybe cxt $ \case
                    EqualP {} -&gt; Nothing
                    ClassP n tys -&gt; Just (invokeResolve methodMap n tys)
                ]
            -- Need extra typeable constraints in order to use typeRep.
            extraCxt = map (ClassP ''Typeable . (: []) . VarT . fst) substs
        return $ InstanceD (cxt ++ extraCxt) ty $
            filter isFamilyDec decs ++
            [FunD method [Clause (map (\_ -&gt; WildP) tvs) (NormalB expr) []]]
    resolver _ dec = return dec

invokeResolve :: M.Map Name Name -&gt; Name -&gt; [Type] -&gt; Exp
invokeResolve methodMap name tys =
    appsE' $ VarE (lookupMethod methodMap name) : map proxyE tys

lookupMethod :: M.Map Name Name -&gt; Name -&gt; Name
lookupMethod methodMap name =
    fromMaybe (error (&quot;Couldn't find resolve* method name for &quot; ++ show name))
              (M.lookup name methodMap)

allNames :: Data a =&gt; a -&gt; [Name]
allNames = listify (\_ -&gt; True)

tvKindNames :: TyVarBndr -&gt; [Name]
tvKindNames (KindedTV _name kind) = allNames kind
tvKindNames PlainTV {} = []

tvName :: TyVarBndr -&gt; Name
tvName (KindedTV name _kind) = name
tvName (PlainTV name) = name

isFamilyDec FamilyD {} = True
isFamilyDec DataInstD {} = True
isFamilyDec NewtypeInstD {} = True
isFamilyDec TySynInstD {} = True
isFamilyDec ClosedTypeFamilyD {} = True
isFamilyDec _ = False

-- Work around a TH bug where PolyKinded constraints get too many
-- arguments.
trimConstraint :: Pred -&gt; Q Pred
trimConstraint (ClassP n tys) = do
    ClassI (ClassD _ _ tvs _ _) _ &lt;- reify n
    return $ ClassP n (drop (length tys - length tvs) tys)
trimConstraint x = return x

trimInstanceType :: Type -&gt; Q Type
trimInstanceType (unAppsT -&gt; (ConT n : tys)) = do
    ClassI (ClassD _ _ tvs _ _) _ &lt;- reify n
    return $ appsT (ConT n : (drop (length tys - length tvs) tys))

chooseUnusedName :: Bool -&gt; String -&gt; Q Name
chooseUnusedName allowUnmodified name = do
    -- This will always match, since there can only be finite names.
    Just str &lt;- findM (\str -&gt; not &lt;$&gt; exists str) choices
    return (mkName str)
  where
    choices = map (name ++) $
        (if allowUnmodified then (&quot;&quot; : ) else id) $
        &quot;_&quot; : map ('_':) (map show [1..])
    -- 'recover' is used to handle errors due to ambiguous identifier names.
    exists str = recover (return True) $ do
        mtype &lt;- lookupTypeName str
        mvalue &lt;- lookupValueName str
        return $ isJust mtype || isJust mvalue

findM :: Monad m =&gt; (a -&gt; m Bool) -&gt; [a] -&gt; m (Maybe a)
findM f (x:xs) = do
    b &lt;- f x
    if b
        then return (Just x)
        else findM f xs

applySubst :: (Data a, Typeable b) =&gt; (b -&gt; Maybe b) -&gt; a -&gt; a
applySubst f = everywhere (id `extT` (\x -&gt; fromMaybe x (f x)))

applySubstMap :: (Data a, Ord b, Typeable b) =&gt; M.Map b b -&gt; a -&gt; a
applySubstMap m = applySubst (flip M.lookup m)

funT :: [Type] -&gt; Type
funT [x] = x
funT (x:xs) = AppT (AppT ArrowT x) (funT xs)

appsT :: [Type] -&gt; Type
appsT = go . reverse
  where
    go [x] = x
    go (x:xs) = AppT (go xs) x

unAppsT :: Type -&gt; [Type]
unAppsT ty = go ty []
  where
    go (AppT l r) = go l . (r :)
    go ty = (ty :)

appsE' :: [Exp] -&gt; Exp
appsE' = go . reverse
  where
    go [x] = x
    go (x:xs) = AppE (go xs) x

proxyE :: Type -&gt; Exp
proxyE = SigE (ConE 'Proxy) . AppT (ConT ''Proxy)

freeVarsT :: Type -&gt; [Name]
freeVarsT (ForallT tvs _ ty) = filter (`notElem` (map tvName tvs)) (freeVarsT ty)
freeVarsT (AppT l r) = freeVarsT l ++ freeVarsT r
freeVarsT (SigT ty k) = freeVarsT ty ++ freeVarsT k
freeVarsT (VarT n) = [n]
freeVarsT _ = []

-- Dequalify names which are unambiguous.
cleanTyCons :: Data a =&gt; a -&gt; Q a
cleanTyCons = everywhereM (return `extM` subst1 `extM` subst2)
  where
    rename :: Name -&gt; Q Name
    rename n = do
        inScope &lt;- typeNameInScope n
        return $ if inScope then mkName (nameBase n) else n
    subst1 (ConT n) = ConT &lt;$&gt; rename n
    subst1 x = return x
    subst2 (ClassP n tys) = ClassP &lt;$&gt; rename n &lt;*&gt; return tys
    subst2 x = return x

typeNameInScope :: Name -&gt; Q Bool
typeNameInScope n =
    recover (return False)
            ((Just n ==) &lt;$&gt; lookupTypeName (nameBase n))

-- Chooses prettier names for type variables.  Assumes that all type
-- variable names are unique.
varTSubsts :: Data a =&gt; a -&gt; [(Name, Name)]
varTSubsts =
    concatMap munge . groupSortOn nameBase . sortNub . varTNames
  where
    munge = zipWith (\s x -&gt; (x, mkName (nameBase x ++ s))) (&quot;&quot; : map show [1..])

varTNames :: Data a =&gt; a -&gt; [Name]
varTNames x = [n | VarT n &lt;- listify (\_ -&gt; True) x]

infoCons :: Info -&gt; [Con]
infoCons (TyConI (DataD _ _ _ cons _)) = cons
infoCons (TyConI (NewtypeD _ _ _ con _)) = [con]
infoCons _ = []

conName :: Con -&gt; Name
conName (NormalC name _) = name
conName (RecC name _) = name
conName (InfixC _ name _) = name
conName (ForallC _ _ con) = conName con

groupSortOn :: Ord b =&gt; (a -&gt; b) -&gt; [a] -&gt; [[a]]
groupSortOn f = groupBy ((==) `on` f) . sortBy (comparing f)

sortNub :: Ord a =&gt; [a] -&gt; [a]
sortNub = map head . group . sort

addIndent :: Int -&gt; String -&gt; String
addIndent cnt = unlines . map (replicate cnt ' ' ++) . lines

reifyMany :: ((Name, Info) -&gt; Q (Bool, [Name]))
          -&gt; [Name]
          -&gt; Q [(Name, Info)]
reifyMany recurse initial =
    State.evalStateT (fmap concat $ mapM go initial) S.empty
  where
    go :: Name -&gt; State.StateT (S.Set Name) Q [(Name, Info)]
    go n = do
        seen &lt;- State.get
        if S.member n seen
            then return []
            else do
                State.put (S.insert n seen)
                minfo &lt;- State.lift $ recover (return Nothing) (fmap Just (reify n))
                case minfo of
                    Just info -&gt; do
                        (shouldEmit, ns) &lt;- State.lift $ recurse (n, info)
                        (if shouldEmit
                             then fmap ((n, info):)
                             else id) $ fmap concat $ mapM go ns
                    _ -&gt; return []
</code></pre><p>Here are the declarations generated by the <code>explainInstance</code> TH
splice, with comments and syntax sugar added:</p><pre><code class="haskell">-- Calling 'resolveSize' yields an instance resolution tree which
-- explains concrete instances of the 'Size' typeclass.  Its first
-- argument is a Proxy type, allowing the caller to specify 'a', even
-- if its kind is not *.
class Size_ a where
    resolveSize :: Proxy a -&gt; Inst

-- Prints out the instance resolution tree for (Size (Maybe Int, Int)).
main = putStrLn $ displayInst $ resolveSize (Proxy :: Proxy (Maybe Int, Int))</code></pre><p>The following are exported by ExplainInstance:</p><pre><code class="haskell">-- | An explanation of why some constraint is satisfied.
data Inst = Inst
    { -- | Like an instance declaration, but without the method declarations.
      instHead :: String
      -- | Describes how type variables are instantiated in the head.
    , instTypes :: [(String, TypeRep)]
      -- | Explanations of how the instance's constraints are satisfied.
    , instConstraints :: [Inst]
    }
    deriving (Show)

-- | Provides an indented string presentation of the instance resolution tree.
displayInst :: Inst -&gt; String</code></pre><p>Ok, so that's how the main function / class works.  Here's how the
actual instances look:</p><pre><code class="haskell">instance Size_ Int where
  -- The explanation for (Size Int) is simple - there are no type
  -- variables or constraints, so it just needs to provide the
  -- instance head.
  resolveSize _ = Inst &quot;instance Size Int&quot; [] []

-- Here, things get a little more complicated as there's a type
-- variable and a constraint.
instance (Size_ a, Typeable a) =&gt; Size_ (Maybe a) where
  resolveSize _
    = Inst
        &quot;instance Size a =&gt; Size (Maybe a)&quot;
        -- We use the added 'Typeable' constraint to create a runtime
        -- representation of the type that 'a' got instantiated to.
        -- This provides the &quot;with&quot; clause in the output.
        [(&quot;a&quot;, typeRep (Proxy :: Proxy a))]
        -- We use the 'Size_' constraint to recursively explain why
        -- (Size a) has an instance.
        [resolveSize (Proxy :: Proxy a)]

instance (Size_ a, Size_ b, Typeable a, Typeable b) =&gt;
         Size_ (a, b) where
  resolveSize _
    = Inst
        &quot;instance (Size a, Size b) =&gt; Size ((a, b))&quot;
        [(&quot;a&quot;, typeRep (Proxy :: Proxy a)),
         (&quot;b&quot;, typeRep (Proxy :: Proxy b))]
        [resolveSize (Proxy :: Proxy a),
         resolveSize (Proxy :: Proxy b)]</code></pre><p>So, in summary, the trick here is to copy and rename typeclass
hierarchies, giving all of them a single <code>resolve*</code> method.  Calling
this method provides a value representing the instance resolution
tree.  By directly piggy backing GHC's instance resolution, we can be
sure that this tool never gives misinformation!</p><h1 id="explaining-unsatisfied-constraints"><a href="#explaining-unsatisfied-constraints">Explaining unsatisfied constraints</a></h1><p>While the above is quite handy for explaining instances used in code
that compiles, it isn't so handy when you're faced with a compilation
error.</p><p>Turns out that with <code>OverlappingInstances</code>, it's possible to catch a
subset of such errors in a much more descriptive way than GHC.  Take,
for example, the type error in this code:</p><pre><code class="active haskell">import Text.Printf

data Thing = Thing

main = printf &quot;&quot; Thing</code></pre><p>This yields the error</p><pre><code>No instance for (PrintfArg Thing) arising from a use of printf
In the expression: printf &quot;&quot; Thing
In an equation for âmainâ: main = printf &quot;&quot; Thing</code></pre><p>While the error itself is pretty good, if you're new to printf, one
might wonder &quot;where the heck did this (PrintfArg Thing) constraint
come from anyway?&quot;.  With <code>explainInstanceError</code>, we can answer this
question!</p><pre><code class="active haskell">{-# START_FILE Demo.hs #-}
-- Usually not all of these pragmas are necessary. But they are
-- needed for some invocations of 'explainInstance'.
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE PolyKinds #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE OverlappingInstances #-}
{-# LANGUAGE UndecidableInstances #-}
{-# LANGUAGE DeriveDataTypeable #-}

import ExplainInstance
-- show
import Data.Typeable
import Text.Printf

data Thing = Thing deriving (Typeable)

$(explainInstanceError [t| PrintfType (Thing -&gt; IO ()) |])
-- /show
{-# START_FILE ExplainInstance.hs #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE ViewPatterns #-}

-- show
-- /show
module ExplainInstance where

import qualified Control.Monad.State as State
import qualified Data.Set as S


import           Control.Applicative ((&lt;$&gt;), (&lt;*&gt;))
import           Control.Monad (filterM)
import           Data.Function (on)
import           Data.Generics
import           Data.List (groupBy, sortBy, sort, group, find)
import qualified Data.Map as M
import           Data.Maybe
import           Data.Ord (comparing)
import           Language.Haskell.TH
import           Language.Haskell.TH.Syntax (addTopDecls)

-- TODO:
--
-- * Rename to &quot;explain-instance&quot;
--
-- * Show info about type families by using Typeable
--
-- * Use a parser so that type vars can be provided.  Or, have a
-- wildcard datatype.
--
-- * Apply inverse renaming on output types (relevant to constraints
-- that end up in the types, as well as data types with contexts)

-- Issues due to TH limitations:
--
-- * No ConstraintKinds
--
-- * No PolyKinds
--
-- * No info about whether an instance is overlapping / incoherent
--   (TODO: is this truly an issue?)
--
-- * No GHCI support. This is because 'explainInstances' can't yield
-- an Exp, as:
--
--   Only function, value, and foreign import declarations may be
--   added with addTopDecl
--
-- Which seems to be a rather arbitrary limitation...
--
-- TODO: Followup on these limitations on trac / mailinglists

explainInstance :: Q Type -&gt; Q [Dec]
explainInstance = explainInstance' False

explainInstanceError :: Q Type -&gt; Q [Dec]
explainInstanceError = explainInstance' True

explainInstance' :: Bool -&gt; Q Type -&gt; Q [Dec]
explainInstance' addErrorInstance qty = do
    ty &lt;- qty
    case unAppsT ty of
        (ConT clazz : tys) -&gt; do
            (decs, methodMap, renameMap) &lt;- instanceResolvers addErrorInstance [clazz]
            let tys' = applySubstMap renameMap tys
            decs' &lt;- [d| main = putStrLn (displayInst $(return (invokeResolve methodMap clazz tys'))) |]
            return (decs' ++ decs)
        _ -&gt; fail &quot;explainInstance input should be a constraint&quot;

-- | An explanation of why some constraint is satisfied.
data Inst = Inst
    { -- | Like an instance declaration, but without the declarations.
      instHead :: String
      -- | Describes how type variables are instantiated in the head.
    , instTypes :: [(String, TypeRep)]
      -- | Explanations of how the instance's constraints are satisfied.
    , instConstraints :: [Inst]
    }
    deriving (Show)

-- | Provides an indented string presentation of the instance resolution tree.
displayInst :: Inst -&gt; String
displayInst = go 0
  where
    go i (Inst decl vars cxt) =
        addIndent i (decl ++ displayVars vars) ++
        concatMap ((&quot;\n&quot; ++) . go (i + 2)) cxt
    displayVars [] = &quot;&quot;
    displayVars (var0 : vars) =
        &quot;\n  with &quot; ++ displayVar var0 ++
        &quot;\n&quot; ++ unlines (map ((&quot;       &quot; ++) . displayVar) vars)
    displayVar (n, ty) = n ++ &quot; ~ &quot; ++ showsPrec 9 ty &quot;&quot;

instanceResolvers :: Bool -&gt; [Name] -&gt; Q ([Dec], M.Map Name Name, M.Map Name Name)
instanceResolvers addErrorInstance initial = do
    infos &lt;- reifyMany recurse initial
    methodMap &lt;- M.fromList &lt;$&gt; sequence
        [ (n, ) &lt;$&gt; chooseUnusedName True (&quot;resolve&quot; ++ nameBase n)
        | (n, ClassI {}) &lt;- infos
        ]
    let names = map fst infos ++ concatMap (map conName . infoCons . snd) infos
    renameMap &lt;- M.fromList &lt;$&gt;
        mapM (\n -&gt; (n, ) &lt;$&gt; chooseUnusedName False (nameBase n)) names
    decs &lt;- mapM (resolver methodMap) (concatMap (infoToDecs . snd) infos)
    return (map (applySubst (flip M.lookup renameMap)) decs, methodMap, renameMap)
  where
    -- Recursively enumerate all of the top level declarations which
    -- need to be copied / renamed.
    recurse :: (Name, Info) -&gt; Q (Bool, [Name])
    recurse (name, info) = return $ do
        case info of
            ClassI (ClassD cxt _name tvs _fds decs) insts -&gt;
                (True, allNames (cxt, filter isFamilyDec decs) ++
                       concatMap tvKindNames tvs ++
                       concatMap instNames insts)
            TyConI (TySynD _name tvs ty) -&gt;
                (True, allNames ty ++ concatMap tvKindNames tvs)
            -- Only need to clone data declarations when they have
            -- datatype contexts.
            TyConI (DataD cxt _name _tvs _cons _deriving) -&gt;
                (not (null cxt), allNames cxt)
            TyConI (NewtypeD cxt _name _tvs _con _deriving) -&gt;
                (not (null cxt), allNames cxt)
            -- We might encounter this due to DataKinds.
            DataConI _name _ty typeName _fixity -&gt;
                (False, [typeName])
            -- FamilyI dec insts -&gt; return (True, [])
            _ -&gt; (False, [])
    instNames :: Dec -&gt; [Name]
    instNames (InstanceD cxt ty decs) =
        allNames cxt ++ allNames ty ++ allNames (filter isFamilyDec decs)
    instNames _ = []
    infoToDecs :: Info -&gt; [Dec]
    -- TODO: check fundeps?
    infoToDecs (ClassI dec@(ClassD _ name tvs _ _) insts) =
        case addErrorInstance &amp;&amp; not hasDefaultCase of
            False -&gt; dec : insts
            True -&gt;
                let errInst = InstanceD
                        []
                        (appsT $ ConT name : map (VarT . tvName) tvs)
                        errorInstanceDecs
                in dec : errInst : insts
      where
        -- If true then an overlapping instance like (Class v1 ..),
        -- where all arguments are type variables, already exists.
        -- In this case omit the error instance.
        hasDefaultCase = isJust $ find isDefaultCase insts
        isDefaultCase (InstanceD _ (unAppsT -&gt; (_:tys)) _) =
            all isTyVar tys
        isDefaultCase _ = False
        isTyVar (VarT _) = True
        isTyVar _ = False
    infoToDecs (ClassI _ _) = error &quot;impossible: ClassI which doesn't contain ClassD&quot;
    infoToDecs (TyConI dec) = [dec]
    infoToDecs (FamilyI dec insts) = dec : insts
    infoToDecs (VarI _name _ty mdec _fixity) = maybeToList mdec
    infoToDecs ClassOpI {} = []
    infoToDecs PrimTyConI {} = []
    infoToDecs DataConI {} = []
    infoToDecs TyVarI {} = []
    errorInstanceDecs = [FunD (mkName &quot;x&quot;) []]
    -- Modify a class or instance to instead just have a single
    -- &quot;resolver*&quot; function.
    resolver :: M.Map Name Name -&gt; Dec -&gt; Q Dec
    resolver methodMap (ClassD cxt' name tvs fds decs) = do
        let method = lookupMethod methodMap name
            ty = funT $
                map (AppT (ConT ''Proxy) . VarT . tvName) tvs ++
                [ConT ''Inst]
        cxt &lt;- mapM trimConstraint cxt'
        return $ ClassD cxt name tvs fds $
            filter isFamilyDec decs ++
            [SigD method ty]
    resolver methodMap (InstanceD cxt' ty' decs) = do
        cxt &lt;- mapM trimConstraint cxt'
        ty &lt;- trimInstanceType ty'
        let substs = varTSubsts (cxt, ty)
            cleanTyVars = applySubstMap (M.fromList substs)
        cleanedHead &lt;- cleanTyCons $ cleanTyVars $ InstanceD cxt ty []
        let (ConT clazzName : tvs) = unAppsT ty
            method = lookupMethod methodMap clazzName
            msg = case addErrorInstance of
                True | decs == errorInstanceDecs -&gt; &quot;ERROR &quot; ++ pprint cleanedHead
                _ -&gt; pprint cleanedHead
            expr = appsE'
                [ ConE 'Inst
                , LitE $ StringL msg
                , ListE $ flip map substs $ \(ty, cty) -&gt; TupE
                    [ LitE (StringL (pprint cty))
                    , AppE (VarE 'typeRep) (proxyE (VarT ty))
                    ]
                , ListE $ flip mapMaybe cxt $ \case
                    EqualP {} -&gt; Nothing
                    ClassP n tys -&gt; Just (invokeResolve methodMap n tys)
                ]
            -- Need extra typeable constraints in order to use typeRep.
            extraCxt = map (ClassP ''Typeable . (: []) . VarT . fst) substs
        return $ InstanceD (cxt ++ extraCxt) ty $
            filter isFamilyDec decs ++
            [FunD method [Clause (map (\_ -&gt; WildP) tvs) (NormalB expr) []]]
    resolver _ dec = return dec

invokeResolve :: M.Map Name Name -&gt; Name -&gt; [Type] -&gt; Exp
invokeResolve methodMap name tys =
    appsE' $ VarE (lookupMethod methodMap name) : map proxyE tys

lookupMethod :: M.Map Name Name -&gt; Name -&gt; Name
lookupMethod methodMap name =
    fromMaybe (error (&quot;Couldn't find resolve* method name for &quot; ++ show name))
              (M.lookup name methodMap)

allNames :: Data a =&gt; a -&gt; [Name]
allNames = listify (\_ -&gt; True)

tvKindNames :: TyVarBndr -&gt; [Name]
tvKindNames (KindedTV _name kind) = allNames kind
tvKindNames PlainTV {} = []

tvName :: TyVarBndr -&gt; Name
tvName (KindedTV name _kind) = name
tvName (PlainTV name) = name

isFamilyDec FamilyD {} = True
isFamilyDec DataInstD {} = True
isFamilyDec NewtypeInstD {} = True
isFamilyDec TySynInstD {} = True
isFamilyDec ClosedTypeFamilyD {} = True
isFamilyDec _ = False

-- Work around a TH bug where PolyKinded constraints get too many
-- arguments.
trimConstraint :: Pred -&gt; Q Pred
trimConstraint (ClassP n tys) = do
    ClassI (ClassD _ _ tvs _ _) _ &lt;- reify n
    return $ ClassP n (drop (length tys - length tvs) tys)
trimConstraint x = return x

trimInstanceType :: Type -&gt; Q Type
trimInstanceType (unAppsT -&gt; (ConT n : tys)) = do
    ClassI (ClassD _ _ tvs _ _) _ &lt;- reify n
    return $ appsT (ConT n : (drop (length tys - length tvs) tys))

chooseUnusedName :: Bool -&gt; String -&gt; Q Name
chooseUnusedName allowUnmodified name = do
    -- This will always match, since there can only be finite names.
    Just str &lt;- findM (\str -&gt; not &lt;$&gt; exists str) choices
    return (mkName str)
  where
    choices = map (name ++) $
        (if allowUnmodified then (&quot;&quot; : ) else id) $
        &quot;_&quot; : map ('_':) (map show [1..])
    -- 'recover' is used to handle errors due to ambiguous identifier names.
    exists str = recover (return True) $ do
        mtype &lt;- lookupTypeName str
        mvalue &lt;- lookupValueName str
        return $ isJust mtype || isJust mvalue

findM :: Monad m =&gt; (a -&gt; m Bool) -&gt; [a] -&gt; m (Maybe a)
findM f (x:xs) = do
    b &lt;- f x
    if b
        then return (Just x)
        else findM f xs

applySubst :: (Data a, Typeable b) =&gt; (b -&gt; Maybe b) -&gt; a -&gt; a
applySubst f = everywhere (id `extT` (\x -&gt; fromMaybe x (f x)))

applySubstMap :: (Data a, Ord b, Typeable b) =&gt; M.Map b b -&gt; a -&gt; a
applySubstMap m = applySubst (flip M.lookup m)

funT :: [Type] -&gt; Type
funT [x] = x
funT (x:xs) = AppT (AppT ArrowT x) (funT xs)

appsT :: [Type] -&gt; Type
appsT = go . reverse
  where
    go [x] = x
    go (x:xs) = AppT (go xs) x

unAppsT :: Type -&gt; [Type]
unAppsT ty = go ty []
  where
    go (AppT l r) = go l . (r :)
    go ty = (ty :)

appsE' :: [Exp] -&gt; Exp
appsE' = go . reverse
  where
    go [x] = x
    go (x:xs) = AppE (go xs) x

proxyE :: Type -&gt; Exp
proxyE = SigE (ConE 'Proxy) . AppT (ConT ''Proxy)

freeVarsT :: Type -&gt; [Name]
freeVarsT (ForallT tvs _ ty) = filter (`notElem` (map tvName tvs)) (freeVarsT ty)
freeVarsT (AppT l r) = freeVarsT l ++ freeVarsT r
freeVarsT (SigT ty k) = freeVarsT ty ++ freeVarsT k
freeVarsT (VarT n) = [n]
freeVarsT _ = []

-- Dequalify names which are unambiguous.
cleanTyCons :: Data a =&gt; a -&gt; Q a
cleanTyCons = everywhereM (return `extM` subst1 `extM` subst2)
  where
    rename :: Name -&gt; Q Name
    rename n = do
        inScope &lt;- typeNameInScope n
        return $ if inScope then mkName (nameBase n) else n
    subst1 (ConT n) = ConT &lt;$&gt; rename n
    subst1 x = return x
    subst2 (ClassP n tys) = ClassP &lt;$&gt; rename n &lt;*&gt; return tys
    subst2 x = return x

typeNameInScope :: Name -&gt; Q Bool
typeNameInScope n =
    recover (return False)
            ((Just n ==) &lt;$&gt; lookupTypeName (nameBase n))

-- Chooses prettier names for type variables.  Assumes that all type
-- variable names are unique.
varTSubsts :: Data a =&gt; a -&gt; [(Name, Name)]
varTSubsts =
    concatMap munge . groupSortOn nameBase . sortNub . varTNames
  where
    munge = zipWith (\s x -&gt; (x, mkName (nameBase x ++ s))) (&quot;&quot; : map show [1..])

varTNames :: Data a =&gt; a -&gt; [Name]
varTNames x = [n | VarT n &lt;- listify (\_ -&gt; True) x]

infoCons :: Info -&gt; [Con]
infoCons (TyConI (DataD _ _ _ cons _)) = cons
infoCons (TyConI (NewtypeD _ _ _ con _)) = [con]
infoCons _ = []

conName :: Con -&gt; Name
conName (NormalC name _) = name
conName (RecC name _) = name
conName (InfixC _ name _) = name
conName (ForallC _ _ con) = conName con

groupSortOn :: Ord b =&gt; (a -&gt; b) -&gt; [a] -&gt; [[a]]
groupSortOn f = groupBy ((==) `on` f) . sortBy (comparing f)

sortNub :: Ord a =&gt; [a] -&gt; [a]
sortNub = map head . group . sort

addIndent :: Int -&gt; String -&gt; String
addIndent cnt = unlines . map (replicate cnt ' ' ++) . lines

reifyMany :: ((Name, Info) -&gt; Q (Bool, [Name]))
          -&gt; [Name]
          -&gt; Q [(Name, Info)]
reifyMany recurse initial =
    State.evalStateT (fmap concat $ mapM go initial) S.empty
  where
    go :: Name -&gt; State.StateT (S.Set Name) Q [(Name, Info)]
    go n = do
        seen &lt;- State.get
        if S.member n seen
            then return []
            else do
                State.put (S.insert n seen)
                minfo &lt;- State.lift $ recover (return Nothing) (fmap Just (reify n))
                case minfo of
                    Just info -&gt; do
                        (shouldEmit, ns) &lt;- State.lift $ recurse (n, info)
                        (if shouldEmit
                             then fmap ((n, info):)
                             else id) $ fmap concat $ mapM go ns
                    _ -&gt; return []
</code></pre><p>This gives us a clear picture of why the <code>PrintfArg</code> came to exist.
This works by adding additional typeclass instances like:</p><pre><code class="haskell">instance Typeable t =&gt; PrintfType_ t where
  resolvePrintfType _ = Inst &quot;ERROR instance PrintfType t&quot;
                             [(&quot;t&quot;, typeRep (Proxy :: Proxy t))]
                             []</code></pre><p>One cool thing about this is that it can tell you about multiple
failing constraints at once:</p><pre><code class="active haskell">{-# START_FILE Demo.hs #-}
-- Usually not all of these pragmas are necessary. But they are
-- needed for some invocations of 'explainInstance'.
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE PolyKinds #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE OverlappingInstances #-}
{-# LANGUAGE UndecidableInstances #-}
{-# LANGUAGE DeriveDataTypeable #-}

import ExplainInstance
-- show
import Data.Typeable
import Text.Printf

data Thing = Thing deriving (Typeable)

$(explainInstanceError [t| PrintfType (Thing -&gt; Int -&gt; Maybe (IO ())) |])
-- /show
{-# START_FILE ExplainInstance.hs #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE ViewPatterns #-}

-- show
-- /show
module ExplainInstance where

import qualified Control.Monad.State as State
import qualified Data.Set as S


import           Control.Applicative ((&lt;$&gt;), (&lt;*&gt;))
import           Control.Monad (filterM)
import           Data.Function (on)
import           Data.Generics
import           Data.List (groupBy, sortBy, sort, group, find)
import qualified Data.Map as M
import           Data.Maybe
import           Data.Ord (comparing)
import           Language.Haskell.TH
import           Language.Haskell.TH.Syntax (addTopDecls)

-- TODO:
--
-- * Rename to &quot;explain-instance&quot;
--
-- * Show info about type families by using Typeable
--
-- * Use a parser so that type vars can be provided.  Or, have a
-- wildcard datatype.
--
-- * Apply inverse renaming on output types (relevant to constraints
-- that end up in the types, as well as data types with contexts)

-- Issues due to TH limitations:
--
-- * No ConstraintKinds
--
-- * No PolyKinds
--
-- * No info about whether an instance is overlapping / incoherent
--   (TODO: is this truly an issue?)
--
-- * No GHCI support. This is because 'explainInstances' can't yield
-- an Exp, as:
--
--   Only function, value, and foreign import declarations may be
--   added with addTopDecl
--
-- Which seems to be a rather arbitrary limitation...
--
-- TODO: Followup on these limitations on trac / mailinglists

explainInstance :: Q Type -&gt; Q [Dec]
explainInstance = explainInstance' False

explainInstanceError :: Q Type -&gt; Q [Dec]
explainInstanceError = explainInstance' True

explainInstance' :: Bool -&gt; Q Type -&gt; Q [Dec]
explainInstance' addErrorInstance qty = do
    ty &lt;- qty
    case unAppsT ty of
        (ConT clazz : tys) -&gt; do
            (decs, methodMap, renameMap) &lt;- instanceResolvers addErrorInstance [clazz]
            let tys' = applySubstMap renameMap tys
            decs' &lt;- [d| main = putStrLn (displayInst $(return (invokeResolve methodMap clazz tys'))) |]
            return (decs' ++ decs)
        _ -&gt; fail &quot;explainInstance input should be a constraint&quot;

-- | An explanation of why some constraint is satisfied.
data Inst = Inst
    { -- | Like an instance declaration, but without the declarations.
      instHead :: String
      -- | Describes how type variables are instantiated in the head.
    , instTypes :: [(String, TypeRep)]
      -- | Explanations of how the instance's constraints are satisfied.
    , instConstraints :: [Inst]
    }
    deriving (Show)

-- | Provides an indented string presentation of the instance resolution tree.
displayInst :: Inst -&gt; String
displayInst = go 0
  where
    go i (Inst decl vars cxt) =
        addIndent i (decl ++ displayVars vars) ++
        concatMap ((&quot;\n&quot; ++) . go (i + 2)) cxt
    displayVars [] = &quot;&quot;
    displayVars (var0 : vars) =
        &quot;\n  with &quot; ++ displayVar var0 ++
        &quot;\n&quot; ++ unlines (map ((&quot;       &quot; ++) . displayVar) vars)
    displayVar (n, ty) = n ++ &quot; ~ &quot; ++ showsPrec 9 ty &quot;&quot;

instanceResolvers :: Bool -&gt; [Name] -&gt; Q ([Dec], M.Map Name Name, M.Map Name Name)
instanceResolvers addErrorInstance initial = do
    infos &lt;- reifyMany recurse initial
    methodMap &lt;- M.fromList &lt;$&gt; sequence
        [ (n, ) &lt;$&gt; chooseUnusedName True (&quot;resolve&quot; ++ nameBase n)
        | (n, ClassI {}) &lt;- infos
        ]
    let names = map fst infos ++ concatMap (map conName . infoCons . snd) infos
    renameMap &lt;- M.fromList &lt;$&gt;
        mapM (\n -&gt; (n, ) &lt;$&gt; chooseUnusedName False (nameBase n)) names
    decs &lt;- mapM (resolver methodMap) (concatMap (infoToDecs . snd) infos)
    return (map (applySubst (flip M.lookup renameMap)) decs, methodMap, renameMap)
  where
    -- Recursively enumerate all of the top level declarations which
    -- need to be copied / renamed.
    recurse :: (Name, Info) -&gt; Q (Bool, [Name])
    recurse (name, info) = return $ do
        case info of
            ClassI (ClassD cxt _name tvs _fds decs) insts -&gt;
                (True, allNames (cxt, filter isFamilyDec decs) ++
                       concatMap tvKindNames tvs ++
                       concatMap instNames insts)
            TyConI (TySynD _name tvs ty) -&gt;
                (True, allNames ty ++ concatMap tvKindNames tvs)
            -- Only need to clone data declarations when they have
            -- datatype contexts.
            TyConI (DataD cxt _name _tvs _cons _deriving) -&gt;
                (not (null cxt), allNames cxt)
            TyConI (NewtypeD cxt _name _tvs _con _deriving) -&gt;
                (not (null cxt), allNames cxt)
            -- We might encounter this due to DataKinds.
            DataConI _name _ty typeName _fixity -&gt;
                (False, [typeName])
            -- FamilyI dec insts -&gt; return (True, [])
            _ -&gt; (False, [])
    instNames :: Dec -&gt; [Name]
    instNames (InstanceD cxt ty decs) =
        allNames cxt ++ allNames ty ++ allNames (filter isFamilyDec decs)
    instNames _ = []
    infoToDecs :: Info -&gt; [Dec]
    -- TODO: check fundeps?
    infoToDecs (ClassI dec@(ClassD _ name tvs _ _) insts) =
        case addErrorInstance &amp;&amp; not hasDefaultCase of
            False -&gt; dec : insts
            True -&gt;
                let errInst = InstanceD
                        []
                        (appsT $ ConT name : map (VarT . tvName) tvs)
                        errorInstanceDecs
                in dec : errInst : insts
      where
        -- If true then an overlapping instance like (Class v1 ..),
        -- where all arguments are type variables, already exists.
        -- In this case omit the error instance.
        hasDefaultCase = isJust $ find isDefaultCase insts
        isDefaultCase (InstanceD _ (unAppsT -&gt; (_:tys)) _) =
            all isTyVar tys
        isDefaultCase _ = False
        isTyVar (VarT _) = True
        isTyVar _ = False
    infoToDecs (ClassI _ _) = error &quot;impossible: ClassI which doesn't contain ClassD&quot;
    infoToDecs (TyConI dec) = [dec]
    infoToDecs (FamilyI dec insts) = dec : insts
    infoToDecs (VarI _name _ty mdec _fixity) = maybeToList mdec
    infoToDecs ClassOpI {} = []
    infoToDecs PrimTyConI {} = []
    infoToDecs DataConI {} = []
    infoToDecs TyVarI {} = []
    errorInstanceDecs = [FunD (mkName &quot;x&quot;) []]
    -- Modify a class or instance to instead just have a single
    -- &quot;resolver*&quot; function.
    resolver :: M.Map Name Name -&gt; Dec -&gt; Q Dec
    resolver methodMap (ClassD cxt' name tvs fds decs) = do
        let method = lookupMethod methodMap name
            ty = funT $
                map (AppT (ConT ''Proxy) . VarT . tvName) tvs ++
                [ConT ''Inst]
        cxt &lt;- mapM trimConstraint cxt'
        return $ ClassD cxt name tvs fds $
            filter isFamilyDec decs ++
            [SigD method ty]
    resolver methodMap (InstanceD cxt' ty' decs) = do
        cxt &lt;- mapM trimConstraint cxt'
        ty &lt;- trimInstanceType ty'
        let substs = varTSubsts (cxt, ty)
            cleanTyVars = applySubstMap (M.fromList substs)
        cleanedHead &lt;- cleanTyCons $ cleanTyVars $ InstanceD cxt ty []
        let (ConT clazzName : tvs) = unAppsT ty
            method = lookupMethod methodMap clazzName
            msg = case addErrorInstance of
                True | decs == errorInstanceDecs -&gt; &quot;ERROR &quot; ++ pprint cleanedHead
                _ -&gt; pprint cleanedHead
            expr = appsE'
                [ ConE 'Inst
                , LitE $ StringL msg
                , ListE $ flip map substs $ \(ty, cty) -&gt; TupE
                    [ LitE (StringL (pprint cty))
                    , AppE (VarE 'typeRep) (proxyE (VarT ty))
                    ]
                , ListE $ flip mapMaybe cxt $ \case
                    EqualP {} -&gt; Nothing
                    ClassP n tys -&gt; Just (invokeResolve methodMap n tys)
                ]
            -- Need extra typeable constraints in order to use typeRep.
            extraCxt = map (ClassP ''Typeable . (: []) . VarT . fst) substs
        return $ InstanceD (cxt ++ extraCxt) ty $
            filter isFamilyDec decs ++
            [FunD method [Clause (map (\_ -&gt; WildP) tvs) (NormalB expr) []]]
    resolver _ dec = return dec

invokeResolve :: M.Map Name Name -&gt; Name -&gt; [Type] -&gt; Exp
invokeResolve methodMap name tys =
    appsE' $ VarE (lookupMethod methodMap name) : map proxyE tys

lookupMethod :: M.Map Name Name -&gt; Name -&gt; Name
lookupMethod methodMap name =
    fromMaybe (error (&quot;Couldn't find resolve* method name for &quot; ++ show name))
              (M.lookup name methodMap)

allNames :: Data a =&gt; a -&gt; [Name]
allNames = listify (\_ -&gt; True)

tvKindNames :: TyVarBndr -&gt; [Name]
tvKindNames (KindedTV _name kind) = allNames kind
tvKindNames PlainTV {} = []

tvName :: TyVarBndr -&gt; Name
tvName (KindedTV name _kind) = name
tvName (PlainTV name) = name

isFamilyDec FamilyD {} = True
isFamilyDec DataInstD {} = True
isFamilyDec NewtypeInstD {} = True
isFamilyDec TySynInstD {} = True
isFamilyDec ClosedTypeFamilyD {} = True
isFamilyDec _ = False

-- Work around a TH bug where PolyKinded constraints get too many
-- arguments.
trimConstraint :: Pred -&gt; Q Pred
trimConstraint (ClassP n tys) = do
    ClassI (ClassD _ _ tvs _ _) _ &lt;- reify n
    return $ ClassP n (drop (length tys - length tvs) tys)
trimConstraint x = return x

trimInstanceType :: Type -&gt; Q Type
trimInstanceType (unAppsT -&gt; (ConT n : tys)) = do
    ClassI (ClassD _ _ tvs _ _) _ &lt;- reify n
    return $ appsT (ConT n : (drop (length tys - length tvs) tys))

chooseUnusedName :: Bool -&gt; String -&gt; Q Name
chooseUnusedName allowUnmodified name = do
    -- This will always match, since there can only be finite names.
    Just str &lt;- findM (\str -&gt; not &lt;$&gt; exists str) choices
    return (mkName str)
  where
    choices = map (name ++) $
        (if allowUnmodified then (&quot;&quot; : ) else id) $
        &quot;_&quot; : map ('_':) (map show [1..])
    -- 'recover' is used to handle errors due to ambiguous identifier names.
    exists str = recover (return True) $ do
        mtype &lt;- lookupTypeName str
        mvalue &lt;- lookupValueName str
        return $ isJust mtype || isJust mvalue

findM :: Monad m =&gt; (a -&gt; m Bool) -&gt; [a] -&gt; m (Maybe a)
findM f (x:xs) = do
    b &lt;- f x
    if b
        then return (Just x)
        else findM f xs

applySubst :: (Data a, Typeable b) =&gt; (b -&gt; Maybe b) -&gt; a -&gt; a
applySubst f = everywhere (id `extT` (\x -&gt; fromMaybe x (f x)))

applySubstMap :: (Data a, Ord b, Typeable b) =&gt; M.Map b b -&gt; a -&gt; a
applySubstMap m = applySubst (flip M.lookup m)

funT :: [Type] -&gt; Type
funT [x] = x
funT (x:xs) = AppT (AppT ArrowT x) (funT xs)

appsT :: [Type] -&gt; Type
appsT = go . reverse
  where
    go [x] = x
    go (x:xs) = AppT (go xs) x

unAppsT :: Type -&gt; [Type]
unAppsT ty = go ty []
  where
    go (AppT l r) = go l . (r :)
    go ty = (ty :)

appsE' :: [Exp] -&gt; Exp
appsE' = go . reverse
  where
    go [x] = x
    go (x:xs) = AppE (go xs) x

proxyE :: Type -&gt; Exp
proxyE = SigE (ConE 'Proxy) . AppT (ConT ''Proxy)

freeVarsT :: Type -&gt; [Name]
freeVarsT (ForallT tvs _ ty) = filter (`notElem` (map tvName tvs)) (freeVarsT ty)
freeVarsT (AppT l r) = freeVarsT l ++ freeVarsT r
freeVarsT (SigT ty k) = freeVarsT ty ++ freeVarsT k
freeVarsT (VarT n) = [n]
freeVarsT _ = []

-- Dequalify names which are unambiguous.
cleanTyCons :: Data a =&gt; a -&gt; Q a
cleanTyCons = everywhereM (return `extM` subst1 `extM` subst2)
  where
    rename :: Name -&gt; Q Name
    rename n = do
        inScope &lt;- typeNameInScope n
        return $ if inScope then mkName (nameBase n) else n
    subst1 (ConT n) = ConT &lt;$&gt; rename n
    subst1 x = return x
    subst2 (ClassP n tys) = ClassP &lt;$&gt; rename n &lt;*&gt; return tys
    subst2 x = return x

typeNameInScope :: Name -&gt; Q Bool
typeNameInScope n =
    recover (return False)
            ((Just n ==) &lt;$&gt; lookupTypeName (nameBase n))

-- Chooses prettier names for type variables.  Assumes that all type
-- variable names are unique.
varTSubsts :: Data a =&gt; a -&gt; [(Name, Name)]
varTSubsts =
    concatMap munge . groupSortOn nameBase . sortNub . varTNames
  where
    munge = zipWith (\s x -&gt; (x, mkName (nameBase x ++ s))) (&quot;&quot; : map show [1..])

varTNames :: Data a =&gt; a -&gt; [Name]
varTNames x = [n | VarT n &lt;- listify (\_ -&gt; True) x]

infoCons :: Info -&gt; [Con]
infoCons (TyConI (DataD _ _ _ cons _)) = cons
infoCons (TyConI (NewtypeD _ _ _ con _)) = [con]
infoCons _ = []

conName :: Con -&gt; Name
conName (NormalC name _) = name
conName (RecC name _) = name
conName (InfixC _ name _) = name
conName (ForallC _ _ con) = conName con

groupSortOn :: Ord b =&gt; (a -&gt; b) -&gt; [a] -&gt; [[a]]
groupSortOn f = groupBy ((==) `on` f) . sortBy (comparing f)

sortNub :: Ord a =&gt; [a] -&gt; [a]
sortNub = map head . group . sort

addIndent :: Int -&gt; String -&gt; String
addIndent cnt = unlines . map (replicate cnt ' ' ++) . lines

reifyMany :: ((Name, Info) -&gt; Q (Bool, [Name]))
          -&gt; [Name]
          -&gt; Q [(Name, Info)]
reifyMany recurse initial =
    State.evalStateT (fmap concat $ mapM go initial) S.empty
  where
    go :: Name -&gt; State.StateT (S.Set Name) Q [(Name, Info)]
    go n = do
        seen &lt;- State.get
        if S.member n seen
            then return []
            else do
                State.put (S.insert n seen)
                minfo &lt;- State.lift $ recover (return Nothing) (fmap Just (reify n))
                case minfo of
                    Just info -&gt; do
                        (shouldEmit, ns) &lt;- State.lift $ recurse (n, info)
                        (if shouldEmit
                             then fmap ((n, info):)
                             else id) $ fmap concat $ mapM go ns
                    _ -&gt; return []
</code></pre><p>This project is quite new, and this is the newest part, so I imagine
there's still some problems with it to be worked out.  One problem I
know of is that it doesn't work for equality constraints.  For
example:</p><pre><code class="active haskell">import Text.Printf

main = putStrLn &quot;hi&quot;
  where
    foo :: Int -&gt; IO String
    foo = printf &quot;%i&quot;</code></pre><p>and we get:</p><pre><code>Couldn't match type [Char] with ()
In the expression: printf &quot;%i&quot;</code></pre><p>Where did that come from?? Why is <code>()</code> correct and <code>String</code> not?  The
answer is that it comes from an equality constraint:</p><pre><code>instance (a ~ ()) =&gt; PrintfType (IO a)</code></pre><p>I haven't really given this much thought yet, but a general solution
to this hasn't yet occurred to me.</p><h1 id="limitations"><a href="#limitations">Limitations</a></h1><p>TODO</p></article>


</div>
</div>
<div class="row article-footer"><div class="span7 meta"><span class="sociallinksunicode social">
<a href="https://twitter.com/home?status=$url$" target="_blank"><i class="icon-twitter"></i></a>&nbsp;
<a href="http://www.facebook.com/sharer/sharer.php?u=$url$" target="_blank"><i class="icon-facebook"></i></a>&nbsp;
<a href="https://plus.google.com/share?url=$url$" target="_blank"><i class="icon-google-plus"></i></a></span>
</div>
</div>
</div>
<div class="footer"><div class="container"><div class="row"><div class="span12"><ul class="menu"><li><a href="https://www.schoolofhaskell.com/">School</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user">Users</a>
</li>

<li><a class="brand" href="https://fpcomplete.com">Sponsored by:
<img src="/static/img/logo.png" title="FPComplete">
</a>
</li>
</ul>
</div>
</div>
<div class="row"><div class="span12"></div>
</div>
</div>
</div>
<link rel="stylesheet" type="text/css" href="/static/bootstrap/css/bootstrap-responsive.css" />
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script><script src="https://www.schoolofhaskell.com/static/combined/Y-3k9_tW.js"></script><script>$(function(){
  $("a.logout").click(function(){
    var form = $("<form method='post'/>");
    form.attr("action", $(this).attr("href"));
    $("body").append(form);
    form.submit();
    return false;
  });
});

$(function(){
    $('.sociallinksunicode a').each(function(){
        $(this).attr('href',$(this).attr('href').replace('$url$',document.location));
    });
});

$(function(){
  // If we need to select a user/select a password then show the
  // details confirmation form, otherwise enable the getting started
  // section.
  if($('.alert-block a').text().match(/(selected a username|change your password)/)) {
    $("#confirm-details").show();
    $("#confirm-details #inputUsername").focus();
  } else {
    $("#get-started").removeClass('disabled').addClass('enabled');
  }

  // For lack of a plain HTML validation story this will do.
  $('.welcome-page').each(function(){
    $('form').submit(check);
  });
  function check(){
    setTimeout(check,500);
    var error = false;
    $('.error').removeClass('error');
    $('#enter-details input').each(function(){
      if($(this).val() == '') {
        $(this).parent().parent().addClass('error');
        error = true;
      }
    });
    if(error) return false;
    if($('[name=password]').val() == $('[name=confirm]').val()) {
      $('#confirm').removeClass('error');
      return true;
    } else {
      $('#confirm').addClass('error');
      return false;
    }
  }
});

$(function(){
  // When scrolling over a snippet editor, activate the "clone in IDE" popovers
  $('article').each(function(){
    var n = 100;
    var wait = 10000;
    function check(){
      if($('.clone').length == 0) {
        setTimeout(check,n);
        return;
      }
      var activated = $.cookie('clone-popover');
      if (activated) return;
      var activate = false;
      $('.controlsRun:onScreen').each(function(){
        $.cookie('clone-popover', 'true', { expires: 30, path: '/' });
        activate = true;
        return false;
      });
      if(activate) {
          $('.clone').each(function(){
              // The bootstrap API is rather unreasonable to say the
              // least.
              next = $(this).parent();
              var title = next.attr('title');
              next.attr('data-content',$(this).attr('data-content'));
              next.attr('title',$(this).attr('title'));
              next.popover('show',{
                  title: $(this).attr('title')
              });
              next.attr('title',title);
          });
          setTimeout(function(){
              $('.clone').each(function(){
                  $(this).parent().popover('hide');
              });
          },wait);
      } else {
        setTimeout(check,n);
      }
    }
    setTimeout(check,n);
  });
});

// onScreen jQuery plugin v0.2.1
// (c) 2011-2013 Ben Pickles
//
// http://benpickles.github.com/onScreen
//
// Released under MIT license.
(function(a){a.expr[":"].onScreen=function(b){var c=a(window),d=c.scrollTop(),e=c.height(),f=d+e,g=a(b),h=g.offset().top,i=g.height(),j=h+i;return h>=d&&h<f||j>d&&j<=f||i>e&&h<=d&&j>=f}})(jQuery);

/*!
 * jQuery Cookie Plugin v1.1
 * https://github.com/carhartl/jquery-cookie
 *
 * Copyright 2011, Klaus Hartl
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.opensource.org/licenses/GPL-2.0
 */
(function($, document) {

  var pluses = /\+/g;
  function raw(s) {
    return s;
  }
  function decoded(s) {
    return decodeURIComponent(s.replace(pluses, ' '));
  }

  $.cookie = function(key, value, options) {

    // key and at least value given, set cookie...
    if (arguments.length > 1 && (!/Object/.test(Object.prototype.toString.call(value)) || value == null)) {
      options = $.extend({}, $.cookie.defaults, options);

      if (value == null) {
	options.expires = -1;
      }

      if (typeof options.expires === 'number') {
	var days = options.expires, t = options.expires = new Date();
	t.setDate(t.getDate() + days);
      }

      value = String(value);

      return (document.cookie = [
	encodeURIComponent(key), '=', options.raw ? value : encodeURIComponent(value),
	options.expires ? '; expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE
	options.path    ? '; path=' + options.path : '',
	options.domain  ? '; domain=' + options.domain : '',
	options.secure  ? '; secure' : ''
      ].join(''));
    }

    // key and possibly options given, get cookie...
    options = value || $.cookie.defaults || {};
    var decode = options.raw ? raw : decoded;
    var cookies = document.cookie.split('; ');
    for (var i = 0, parts; (parts = cookies[i] && cookies[i].split('=')); i++) {
      if (decode(parts.shift()) === key) {
	return decode(parts.join('='));
      }
    }
    return null;
  };
  $.cookie.defaults = {};})(jQuery, document);
</script><!--[if lt IE 10]><script src="https://www.schoolofhaskell.com/static/design/js/ie.js?etag=ayV2DuJ0"></script><![endif]--><script>if(!window.location.href.match(/localhost/)){var track = '/tutorial/user/sloan/reifying-instance-resolution';
window._gaq = [['_setAccount','UA-36928035-1'],track != ''? ['_trackPageview',track] : ['_trackPageview']
,['_trackPageLoadTime']];window._gaq.push(['_setCustomVar',1,'Section','School of Haskell',3]);
window._gaq.push(['_setCustomVar',2,'User Type','Visitor',1]);
(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);

})();}</script>
<!-- Prompt IE 6 users to install Chrome Frame. Remove this if you want to support IE 6.  chromium.org/developers/how-tos/chrome-frame-getting-started --><!--[if lt IE 7 ]><script src="//ajax.googleapis.com/ajax/libs/chrome-frame/1.0.3/CFInstall.min.js"></script><script>window.attachEvent('onload',function(){CFInstall.check({mode:'overlay'})})</script><![endif]--></body></html>