<!DOCTYPE html>
<html><head><title>6 Recursive Types - School of Haskell | School of Haskell</title><meta http-equiv="x-ua-compatible" content="IE=9"><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="google-site-verification" content="Rfxk2TdeMMXEXHgJ2_OO8Rt3hPbQSDao0OXQV_n6z_s" /><link href="//fonts.googleapis.com/css?family=Merriweather" rel="stylesheet" type="text/css"><link href="https://www.schoolofhaskell.com/recent-content/feed" type="application/rss+xml" rel="alternate" title="Recently published content">
<link rel="stylesheet" href="https://www.schoolofhaskell.com/static/combined/UlwEHVcM.css"><style>.social{margin-right:1em}h1{font-family:Merriweather !important}article{font-family:Merriweather !important}article li{font-family:Merriweather !important;line-height:1.6em}h1,h2,h3,h4,h4,h5{font-family:Merriweather !important}.editor p{font-family:Frutiger, "Frutiger Linotype", Univers, Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans Condensed", "Liberation Sans", "Nimbus Sans L", Tahoma, Geneva, "Helvetica Neue", Helvetica, Arial, sans-serif}.article-footer{border-top:1px solid #ddd;padding-top:1em;margin-top:1em}body{font-size:16px !important}.navbar .navbar-inner{background:#3c3f41}.navbar .brand{font-size:14px}.navbar .brand img{width:6em}.navbar .icon-wrench{margin:0 -0.5em 0 -0.5em;padding:0 1em 0 1em;height:20px}.navbar-inverse .nav .active a{background:#333638}.navbar-inverse .nav > li > a{color:#a7a7a7
}.navbar-inverse .btn-navbar{background:#333638}.navbar-inverse .nav > li a:hover,.navbar-inverse .btn{background:#333537 !important}@media (max-width: 979px) {.icon-wrench{padding-left:1em !important}}.breadcrumb{border-top-left-radius:0;border-top-right-radius:0}h1{margin-top:20px}.breadcrumb-container + .main-content h1{margin-top:0}.footer{padding:30px 0;margin-top:70px;border-top:1px solid #e5e5e5;background-color:#f5f5f5}.footer ul.footer-menu{list-style-type:none}.footer ul.footer-menu li{display:inline-block}.footer ul.footer-menu li + li{margin-left:0.5em}.footer ul.footer-menu li + li:before{margin-right:0.5em;content:"Â·";color:#999}.footer ul.menu li{display:inline-block}.footer ul.menu li + li{margin-left:0.5em}.footer .copyright{margin-left:25px}.main-content{min-height:100%}.gravatar{width:80px;height:80px;border-radius:2px;background:#eee}.empty-gravatar{width:0}.container{font-family:"Segoe UI", Candara, "Bitstream Vera Sans", "DejaVu Sans", "Bitstream Vera Sans", "Trebuchet MS", Verdana, "Verdana Ref", sans-serif}.container h1,.container h2,.container h4,.container h4,.container h5{font-family:"Segoe UI", Candara, "Bitstream Vera Sans", "DejaVu Sans", "Bitstream Vera Sans", "Trebuchet MS", Verdana, "Verdana Ref", sans-serif}article{font-family:Merriweather !important}article h1{font-family:Merriweather !important}article li{font-family:Merriweather !important;line-height:1.6em}article li + li{margin-top:0.5em}article div.code{background:#f9f9f9;border:1px solid #d1d1d1;position:relative;border-radius:0.2em;margin:0.25em 0 0.75em 0;min-height:2.5em}article code{color:#005580;font-size:14px;white-space:pre}article a.hoogle > code{color:#0088cc;font-size:14px;white-space:pre;border:0}article .expand-code{display:none}article pre{overflow:auto;word-wrap:normal}article code.active{display:block;max-height:430px}article h1{font-size:31.5px}article h3{font-size:17.5px}article h4{font-size:14px}article h5,article h6{font-size:11.9px}article p{line-height:1.7em}article h1 code,article h2 code,article h3 code,article h4 code,article h5 code,article h6 code{font-size:inherit !important}article h1 a,article h2 a,article h3 a,article h4 a,article h5 a,article h6 a{color:#444}article h1 a:before,article h2 a:before,article h3 a:before,article h4 a:before,article h5 a:before,article h6 a:before{margin-left:-1.5em;padding-right:0.5em;font-family:fontawesome;content:"\f0c1";font-size:20px;color:#fff}article h1 a:hover,article h2 a:hover,article h3 a:hover,article h4 a:hover,article h5 a:hover,article h6 a:hover{text-decoration:none;color:#0088cc}article h1 a:hover:before,article h2 a:hover:before,article h3 a:hover:before,article h4 a:hover:before,article h5 a:hover:before,article h6 a:hover:before{color:#888}article h2{font-size:24.5px}article .popover{font-family:actor}article .popover h3.popover-title{font-family:actor !important;font-size:1em}article .popover .popover-content{width:15em;font-size:1em}article .controlsRun{display:block;padding:0.5em;text-align:right;background:#f2f2f2}article .controlsRun a.clone{margin-right:1em;font-family:actor;text-decoration:none}article .controlsRun a.clone span{padding-left:0.5em}article .controlsRun a.run,article .controlsRun a.reset,article .controlsRun a.show-code{font-size:16px}article .controlsRun a.run span,article .controlsRun a.reset span,article .controlsRun a.show-code span{display:none}article .controlsRun a.reset{margin-left:0.5em;color:#a2becc}article .controlsRun a.reset{display:none}article .controlsRun a.show-code{margin-right:0.75em}article .controlsRun a.run:hover,article .controlsRun a.show-code:hover{text-decoration:none}article .controlsRun a.show-code.active{color:#DC0D0D}article .controlsRun a[disabled]{color:#a2becc;cursor:default}article .collapse-area .collapse-header{background:#0088cc;color:#fff;padding:0.3em;cursor:pointer}article .collapse-area .hidden-toggle:before{content:"\f0d7";font-family:fontawesome;margin-right:0.5em;margin-left:0.25em}article .collapse-area .collapsed-files{overflow:auto;height:auto}article .collapse-area.collapse-disabled{display:none}article .collapse-area.collapse-area-off .collapsed-files{height:0px;overflow:hidden}article .collapse-area.collapse-area-off .hidden-toggle:before{content:"\f0da"}article .snippet-stdio .stdout{margin:0.5em;padding-right:2em;position:relative;word-wrap:break-word}article .snippet-stdio .stdin{-webkit-box-shadow:none;-moz-box-shadow:none;box-shadow:none;-webkit-transition:none;-moz-transition:none;-o-transition:none;transition:none;padding:0;margin:0}article .hoogle-results{margin:0.25em}article .hoogle-results .hoogle-inner{background:#fff;padding:0.5em;border-radius:3px;border:1px solid #ddd}article .hoogle-results .hoogle-inner .close-link{position:relative;float:right;margin-top:-0.5em;margin-right:-0.5em}article .snippet-output-errors{margin:1em 0.5em 0.5em 0.5em;position:relative}article .snippet-output-errors ul{list-style-type:none;margin:0;position:relative}article .snippet-output-errors pre{border:0;border-radius:0;padding:0.25em;margin:0;background:inherit;color:inherit}article .snippet-output-errors .close-link{color:inherit;background:inherit}article .snippet-editors{z-index:0;padding:0.25em}article .close-link{padding:0.5em;background:#eaeaea;border-bottom-left-radius:0.2em;border-top-right-radius:0.2em;position:absolute;top:0;right:0}article .close-link:hover{text-decoration:none}article .snippet-title{padding:0.5em 0 0 0.5em}article .snippet-title .snippet-icon{font-family:FontAwesome;display:inline-block;margin-right:0.5em}article .fullModuleCode + div .snippet-title{margin-top:0.5em;border-top:1px solid #ccc;padding-top:0.5em}article .CodeMirror{height:auto;min-height:1em;line-height:1.5em;background:transparent;font-size:14px !important}article .CodeMirror .highlighted{background:rgba(250, 210, 0, 0.45) !important}article .CodeMirror-widget{margin-left:2em;line-height:1.8}article .CodeMirror.collapsed{height:10em !important}article .editor .expander{text-align:center;display:block;padding:0.5em;text-decoration:none;border-bottom-left-radius:2px;border-bottom-right-radius:2px}article .editor .expander .ellipsis{background:white;border:1px solid #ccc;padding:0 0.5em;height:1em;line-height:0.5em;display:inline-block;color:#555;cursor:pointer}article .editor .expander .ellipsis:hover{background:#ddd;color:#333}article .web-runner{margin:0.5em;padding:0.5em;border:1px solid #ccc;border-radius:3px;background:#f5f5f5}article .web-runner iframe{border:0;margin-top:0.5em;margin-bottom:0;background:white}article .web-runner .controls i{cursor:pointer;color:#0088cc}article .web-runner .controls i:hover{color:#222}article .web-runner .controls i + i{margin-left:0.5em}article .web-runner .controls .icon-remove{float:right}article .hidden{display:block;visibility:visible}article .controlsShowHide{margin-bottom:0.5em}.tutorial-body{float:left !important}.tutorial-nav{float:right !important}@media (max-width: 979px) {.related-content{float:right}.author-name{display:block;margin-left:20px !important;padding-left:5px;margin-top:5px}article h1 a:hover:before,article h2 a:hover:before,article h3 a:hover:before,article h4 a:hover:before,article h5 a:hover:before,article h6 a:hover:before{color:#fff}.tutorial-nav{float:none !important;width:auto !important}.tutorial-body{float:none !important;width:auto !important}}@media (min-width: 980px) and (max-width: 1199px) {.navbar-search{display:none}.tutorial-nav{width:200px}.tutorial-body{width:720px}}#accountPage h1{margin:20px 0 0 0}#accountPage h2{font-size:20px}.group-contents .span8{float:left}.group-contents .span4{float:right}.container > .alert-block{margin-top:1em}.alert{color:#aa874a
}.social{margin-bottom:.8em;display:block}.social a{text-decoration:none}.social i{font-size:1.1em;color:#fff;padding:0.25em;border-radius:0.25em;width:1em;display:inline-block;text-align:center}.social i.icon-twitter{background:#0088cc}.social i.icon-facebook{background:#3b5998
  }.social i.icon-google-plus{background:#dd4b39
  }.well pre{background:#fcfcfc}.well h2{margin-top:0}code{color:#005580;font-size:14px;white-space:pre}</style><!--[if lt IE 8]><link rel="stylesheet" href="https://www.schoolofhaskell.com/static/design/css/ie7.css?etag=TSMl9x1V"><![endif]--><!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]--></head><body class="not-logged-in" itemscope itemtype="http://schema.org/Product"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-H62P" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-H62P');</script><div class="navbar navbar-inverse navbar-static-top"><div class="navbar-inner"><div class="container"><a class="btn btn-navbar" type="button" data-toggle="collapse" data-target=".nav-collapse"><span class="icon-bar"></span>
<span class="icon-bar"></span>
<span class="icon-bar"></span>
</a>
<a class="brand" href="/"><img src="/static/img/haskell-logo-wide.png" title="School of Haskell">
</a>
<div class="nav-collapse collapse"><ul class="nav"><li><a href="https://www.schoolofhaskell.com/">School</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user">Users</a>
</li>
</ul>
<form class="navbar-search pull-left" action="https://www.schoolofhaskell.com/search"><input class="search-query" type="text" placeholder="Search" name="search">
</form>
</div>
</div>
</div>
</div>
<div class="container breadcrumb-container"><div class="row"><div class="span12"><ul class="breadcrumb"><li><a href="https://www.schoolofhaskell.com/user/mutjida">mutjida</a>
<span class="divider">/</span>
</li>
<li><a href="https://www.schoolofhaskell.com/user/mutjida/typed-tagless-final-linear-lambda-calculus">Typed Tagless-Final Linear Lambda Calculus</a>
<span class="divider">/</span>
</li>
<li><a href="https://www.schoolofhaskell.com/user/mutjida/typed-tagless-final-linear-lambda-calculus/6-recursive-types">6 Recursive Types</a>
</li>
</ul>
</div>
</div>
</div>
<div class="container main-content"><div class="row"><div class="span12"><h1 itemprop="name">6 Recursive Types</h1>
</div>
</div>
<div class="row"><div class="span7 meta"><p><span class="date">25 Apr 2013</span>
<span class="author"><a href="https://www.schoolofhaskell.com/user/mutjida">mutjida</a>
</span>
<span class="view-edit-link pull-right"><a class="view-source-link" href="https://www.schoolofhaskell.com/tutorial-raw/3838/6742280f959f06e4c402fb16228b980adf4a58e8">View Markdown source</a>
</span>
</p>
<p class="tags"></p>
</div>
</div>
<div class="row"><div class="span7 meta"><span class="sociallinksunicode social">
<a href="https://twitter.com/home?status=$url$" target="_blank"><i class="icon-twitter"></i></a>&nbsp;
<a href="http://www.facebook.com/sharer/sharer.php?u=$url$" target="_blank"><i class="icon-facebook"></i></a>&nbsp;
<a href="https://plus.google.com/share?url=$url$" target="_blank"><i class="icon-google-plus"></i></a></span>
</div>
</div>
<p class="alert">As of March 2020, School of Haskell has been switched to read-only mode.</p>
<div class="row" itemprop="desc"><div class="span4 tutorial-nav"><div class="related-content"><ul class="nav nav-tabs nav-stacked"><li><script>reddit_target='fpcomplete'</script>
<script src="https://redditstatic.s3.amazonaws.com/button/button1.js"></script>
</li>
<li><a href="https://www.schoolofhaskell.com/user/mutjida/typed-tagless-final-linear-lambda-calculus/5-efficient-resource-management">Previous content: 5 Efficient Resource Management</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user/mutjida/typed-tagless-final-linear-lambda-calculus">Go up to: Typed Tagless-Final Linear Lambda Calculus</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user/mutjida">See all content by mutjida</a>
</li>
</ul>

</div>
<div class="aside"><h3>Sections</h3>
<ul><li><a href="#adding-recursive-types">Adding Recursive Types</a></li></ul></div>
</div>
<div class="span8 tutorial-body" data-environment="ghc-7.8-stable-14.09">
<article><h2 id="adding-recursive-types"><a href="#adding-recursive-types">Adding Recursive Types</a></h2><p>Up to this point, the language is neat-- at least there are some interesting types to play with-- but it is difficult to use for computation since there is no way to define recursive data types. Although recursive types are relatively straightforward, it is an interesting exercise to add them to a typed tagless-final interpreter; it also results in a language rich enough to write toy programs. This section is mostly an adaption of section 6.4 of Frank Pfenning's <a href="http://www.cs.cmu.edu/~fp/courses/15816-f01/handouts/linfp.pdf">notes</a>.</p><p>The goal is to be able to define, and use, types such as</p><pre><code>MyNat = One :+: MyNat

MyList a = One :+: (a :*: MyList a)</code></pre><p>but even Haskell can't deal with such unrestricted recursion at the type level. Instead, I have to use an explicit type-level fixpoint, and include terms for manipulating such types:</p><pre><code class="haskell">-- show Type-level fixpoint
newtype Mu a = Mu {unMu :: a (Mu a)}
-- show Terms for manipulating Mu types
class LinRec (repr :: Nat -&gt; Bool -&gt; [Maybe Nat] -&gt; [Maybe Nat] -&gt; * -&gt; *) where

    wrap :: repr vid tf i o (a (Mu a)) -&gt; repr vid tf i o (Mu a)

    unwrap :: repr vid tf i o (Mu a) -&gt; repr vid tf i o (a (Mu a))</code></pre><p>I have introduced a new class, <code>LinRec</code>, in order to show off the extensibility of tagless-final encodings.</p><p>I can then represent my recursive type via <code>Mu</code></p><pre><code class="haskell">type MyNat = Mu ((:+:) One)

zero :: DefnRec False MyNat
zero = wrap (inl one)

succ :: DefnRec False (MyNat :-&lt;&gt;: MyNat)
succ = llam $ \x -&gt; wrap (inr x)</code></pre><p>The fact that GHC accepts the <code>MyNat</code> declaration is a bit of an anomaly since Haskell disallows partially applied type synonyms; so a similar trick can't be employed for <code>MyList a</code>.</p><p>In order to implement <code>MyList a</code>, I am forced to use a newtype to untie the knot:</p><pre><code class="haskell">newtype MyListF a lst = MLF {unMLF :: One :+: (a :*: lst)}

type MyList a = Mu (MyListF a)</code></pre><p>However, this is problematic since my language constructs, <code>wrap</code> and <code>unwrap</code>, only have one wrapper/unwrapper (<code>Mu</code>/<code>unMu</code>), but I now need to stick another wrapper/unwrapper inside the <code>repr</code> type, i.e. I need to use <code>MLF</code> to get from <code>One :+: (a :*: lst)</code> to <code>MyListF a lst</code> before I can use <code>Mu</code> to get <code>MyList a</code>. I could reflect <code>MLF</code> and <code>unMLF</code> into the object language:</p><pre><code class="haskell">class LinRec (repr :: Nat -&gt; Bool -&gt; [Maybe Nat] -&gt; [Maybe Nat] -&gt; * -&gt; *) where
    wrap :: repr vid tf i o (a (Mu a)) -&gt; repr vid tf i o (Mu a)
    unwrap :: repr vid tf i o (Mu a) -&gt; repr vid tf i o (a (Mu a))
    
    wrapMLF :: repr vid tf i o (One :+: (a :*: lst)) -&gt; repr vid tf i o (MyListF a lst)
    unwrapMLF :: repr vid tf i o (MyListF a lst) -&gt; repr vid tf i o (One :+: (a :*: lst))
    
nil :: DefnRec False (MyList a)
nil = wrap $ wrapMLF $ inl one

cons :: DefnRec False (a :-&lt;&gt;: (MyList a :-&lt;&gt;: MyList a))
cons = llam (\x -&gt; llam (\xs -&gt; wrap $ wrapMLF $ inr $ x &lt;*&gt; xs))</code></pre><p>But this is a poor solution as it requires adding an extra wrap/unwrap for (almost) every recursive type I wish to define; which means I have effectively lost my general recursive type. 
Though I can't get around the need for newtypes to declare my recursive types, I can get by with one wrap (unwrap) by generalizing the type to take the extra wrapper/unwrapper.</p><pre><code class="haskell">wrap :: (b -&gt; a (Mu a)) -&gt; repr vid tf i o b -&gt; repr vid tf i o (Mu a)
unwrap :: (a (Mu a) -&gt; b) -&gt; repr vid tf i o (Mu a) -&gt; repr vid tf i o b

nil = wrap MLF $ inl one</code></pre><p>Finally, I will add a term-level fixpoint construction so that I can write recursive functions to compute with recursive types; this is not really necessary as I could just use Haskell's own built-in term level fixpoints, but I will include it for completeness.</p><pre><code class="haskell">class LinRec (repr :: Nat -&gt; Bool -&gt; [Maybe Nat] -&gt; [Maybe Nat] -&gt; * -&gt; *) where
    wrap :: (b -&gt; a (Mu a)) -&gt; repr vid tf i o b -&gt; repr vid tf i o (Mu a)

    unwrap :: (a (Mu a) -&gt; b) -&gt; repr vid tf i o (Mu a) -&gt; repr vid tf i o b

    fix :: ((forall vid h . repr vid False h h a) -&gt; repr vid tf h h a) -&gt; repr vid tf h h a </code></pre><p>Note that recursive functions cannot depend upon linear variables.</p><p>As with all the constructs in this interpreter, a concrete instance for evaluation of the terms is trivial:</p><pre><code class="haskell">instance LinRec (R :: Nat -&gt; Bool -&gt; [Maybe Nat] -&gt; [Maybe Nat] -&gt; * -&gt; *) where
    wrap f = R . Mu . f . unR 
    unwrap f = R . f . unMu . unR 
    fix f = f (R $ unR $ fix f)</code></pre><p>Also, as before, I will add a type synonym, <code>DefnRec</code>, to give the type checker some hints to allow better type inference. <code>DefnRec</code> will be identical to the previous <code>Defn</code> except that it will require an additional <code>LinRec</code> constraint.</p><pre><code class="active haskell">-- /show
{-# LANGUAGE 
  DataKinds,
  FlexibleContexts,
  FlexibleInstances,
  FunctionalDependencies,
  KindSignatures,
  MultiParamTypeClasses,
  NoMonomorphismRestriction,
  OverlappingInstances,
  RankNTypes, 
  TypeFamilies,
  TypeOperators,
  UndecidableInstances
 #-}

import Prelude hiding(succ)

{---------------------------------------------------------------------

Type level machinery

---------------------------------------------------------------------}

--
-- Type level Or
--
type family Or (x::Bool) (y::Bool) :: Bool
type instance Or False False = False
type instance Or True False = True
type instance Or False True = True
type instance Or True True = True

--
-- Type level Nats
--
data Nat = Z | S Nat

--
-- Type level Nat equality
--
class EQ (x::Nat) (y::Nat) (b::Bool) | x y -&gt; b
instance EQ x x True
instance (b ~ False) =&gt; EQ x y b

--
-- Type level machinery for consuming a variable in a list of variables.
--
class Consume (v::Nat) (i::[Maybe Nat]) (o::[Maybe Nat]) | v i -&gt; o
class Consume1 (b::Bool) (v::Nat) (x::Nat) (i::[Maybe Nat]) (o::[Maybe Nat]) | b v x i -&gt; o
instance (Consume v i o) =&gt; Consume v (Nothing ': i) (Nothing ': o)
instance (EQ v x b, Consume1 b v x i o) =&gt; Consume v (Just x ': i) o
instance Consume1 True v x i (Nothing ': i)
instance (Consume v i o) =&gt; Consume1 False v x i (Just x ': o)

--
-- Machinery needed to check/enforce conditions for additive conjunction/disjunction to correctly deal with Top.
--
class VarOk (tf :: Bool) (v :: Maybe Nat)
instance VarOk True (Just v)
instance VarOk True Nothing 
instance VarOk False Nothing

type family (:&lt;:) (x::[Maybe Nat]) (y::[Maybe Nat]) :: Bool 
type instance '[] :&lt;: '[] = True
type instance (Nothing ': xs) :&lt;: (Nothing ': ys) = xs :&lt;: ys
type instance (Nothing ': xs) :&lt;: (Just y ': ys) = xs :&lt;: ys
type instance (Just x ': xs) :&lt;: (Nothing ': ys) =  False
type instance (Just x ': xs) :&lt;: (Just x ': ys) =  xs :&lt;: ys

type family Intersect (xs::[Maybe Nat]) (ys::[Maybe Nat]) :: [Maybe Nat]
type instance Intersect '[] '[] = '[]
type instance Intersect (Nothing ': xs) (Nothing ': ys) = (Nothing ': Intersect xs ys)
type instance Intersect (Nothing ': xs) (Just y ': ys) = (Nothing ': Intersect xs ys)
type instance Intersect (Just x ': xs) (Nothing ': ys) = (Nothing ': Intersect xs ys)
type instance Intersect (Just x ': xs) (Just x ': ys) = (Just x ': Intersect xs ys)

type family When (x::Bool) (y::Bool) :: Bool
type instance When True y = y

type family AdditiveAnd (tf0::Bool) (tf1::Bool) (h0::[Maybe Nat]) (h1::[Maybe Nat]) :: Bool
type instance AdditiveAnd False False h h = False 
type instance AdditiveAnd False True h0 h1 = When (h0 :&lt;: h1) False
type instance AdditiveAnd True False h0 h1 = When (h1 :&lt;: h0) False 
type instance AdditiveAnd True True h0 h1 = True 


{---------------------------------------------------------------------

Final tagless HOAS linear lambda calculus.

---------------------------------------------------------------------}

--
-- Linear types
--
newtype a :-&lt;&gt;: b = Lolli {unLolli :: a -&gt; b}
data a :*: b = Tensor a b
data One = One
type a :&amp;: b = (a, b)
type Top = ()
data a :+: b = Inl a | Inr b
data Zero 
newtype Bang a = Bang {unBang :: a}


type LinVar repr (vid::Nat) a = 
     forall (v::Nat) (i::[Maybe Nat]) (o::[Maybe Nat]) . (Consume vid i o) =&gt; 
     repr v False i o a

type RegVar repr a = 
     forall (v::Nat) (i::[Maybe Nat]) . repr v False i i a

class Lin (repr :: Nat -&gt; Bool -&gt; [Maybe Nat] -&gt; [Maybe Nat] -&gt; * -&gt; *) where
    llam :: (VarOk tf var) =&gt; 
            (LinVar repr vid a -&gt; repr (S vid) tf (Just vid ': hi) (var ': ho) b) -&gt; 
            repr vid tf hi ho (a :-&lt;&gt;: b)
    (&lt;^&gt;) :: repr vid tf0 hi h (a :-&lt;&gt;: b) -&gt; repr vid tf1 h ho a -&gt; 
             repr vid (Or tf0 tf1) hi ho b

    (!) :: repr vid tf h h a -&gt; repr vid False h h (Bang a)
    letBang :: repr vid tf0 hi h (Bang a) -&gt; 
               (RegVar repr a -&gt; repr vid tf1 h ho b) -&gt; 
               repr vid (Or tf0 tf1) hi ho b

    lam :: (RegVar repr a -&gt; repr vid tf hi ho b) -&gt; repr vid tf hi ho (a -&gt; b)
    (&lt;$&gt;) :: repr vid tf0 hi ho (a -&gt; b) -&gt; repr vid tf1 ho ho a -&gt; repr vid tf0 hi ho b

    one :: repr vid False h h One
    letOne :: repr vid tf0 hi h One -&gt; repr vid tf1 h ho a -&gt; 
              repr vid (Or tf0 tf1) hi ho a

    (&lt;*&gt;) :: repr vid tf0 hi h a -&gt; repr vid tf1 h ho b -&gt; 
             repr vid (Or tf0 tf1) hi ho (a :*: b)
    letStar :: (VarOk tf1 var0, VarOk tf1 var1) =&gt; 
               repr vid tf0 hi h (a :*: b) -&gt; 
               (LinVar repr vid a -&gt; 
                  LinVar repr (S vid) b -&gt; 
                    repr (S (S vid)) 
                         tf1 
                         (Just vid ': Just (S vid) ': h) 
                         (var0 ': var1 ': ho) c
               ) -&gt; 
               repr vid (Or tf0 tf1) hi ho c
                    
    top :: repr vid True h h Top

    (&lt;&amp;&gt;) :: repr vid tf0 hi h0 a -&gt; repr vid tf1 hi h1 b -&gt; 
             repr vid (AdditiveAnd tf0 tf1 h0 h1) hi (Intersect h0 h1) (a :&amp;: b)
    pi1 :: repr vid tf hi ho (a :&amp;: b) -&gt; repr vid tf hi ho a 
    pi2 :: repr vid tf hi ho (a :&amp;: b) -&gt; repr vid tf hi ho b 

    inl :: repr vid tf hi ho a -&gt; repr vid tf hi ho (a :+: b)
    inr :: repr vid tf hi ho b -&gt; repr vid tf hi ho (a :+: b)
    letPlus :: (VarOk tf1 var1, VarOk tf2 var2) =&gt; 
               repr vid tf0 hi h (a :+: b) -&gt;
               (LinVar repr vid a -&gt; repr (S vid) tf1 (Just vid ': h) (var1 ': ho1) c) -&gt;
               (LinVar repr vid b -&gt; repr (S vid) tf2 (Just vid ': h) (var2 ': ho2) c) -&gt;
               repr vid (Or tf0 (AdditiveAnd tf1 tf2 ho1 ho2)) hi (Intersect ho1 ho2) c

    abort :: repr vid tf hi ho Zero -&gt; repr vid True hi ho a


type Defn tf a = forall repr vid h . 
                 (Lin repr, Intersect h h ~ h, (h :&lt;: h) ~ True) =&gt; 
                 repr vid tf h h a
defn :: Defn tf a -&gt; Defn tf a
defn x = x


newtype R (vid::Nat) (tf::Bool) (hi::[Maybe Nat]) (ho::[Maybe Nat]) a = R {unR :: a}

instance Lin (R :: Nat -&gt; Bool -&gt; [Maybe Nat] -&gt; [Maybe Nat] -&gt; * -&gt; *) where
    llam f = R $ Lolli $ \x -&gt; unR (f (R x))
    f &lt;^&gt; x = R $ unLolli (unR f) (unR x)

    (!) = R . Bang . unR
    letBang x f = R $ unR $ f' (unR x)
      where f' (Bang x) = f (R x)

    lam f = R $ \x -&gt; unR (f (R x))
    f &lt;$&gt; x = R $ unR f (unR x)

    x &lt;*&gt; y = R $ Tensor (unR x) (unR y)
    letStar xy f = R $ unR $ f' (unR xy)
      where f' (Tensor x y) = f (R x) (R y)

    one = R One
    letOne x y = R $ unR $ (\One -&gt; y) $ unR x

    top = R ()

    x &lt;&amp;&gt; y = R $ (unR x, unR y)
    pi1 = R . fst . unR
    pi2 = R . snd . unR

    inl = R . Inl . unR
    inr = R . Inr . unR
    letPlus xy fInl fInr = case unR xy of
                             Inl x -&gt; R $ unR $ fInl (R x)
                             Inr y -&gt; R $ unR $ fInr (R y)

    abort x = R $ error &quot;abort&quot;


eval :: R Z tf '[] '[] a -&gt; a
eval = unR


newtype Mu a = Mu {unMu :: a (Mu a)}

class LinRec (repr :: Nat -&gt; Bool -&gt; [Maybe Nat] -&gt; [Maybe Nat] -&gt; * -&gt; *) where
    wrap :: (b -&gt; a (Mu a)) -&gt; repr vid tf i o b -&gt; repr vid tf i o (Mu a)
    unwrap :: (a (Mu a) -&gt; b) -&gt; repr vid tf i o (Mu a) -&gt; repr vid tf i o b
    fix :: ((forall vid h . repr vid False h h a) -&gt; repr vid tf h h a) -&gt; repr vid tf h h a 

instance LinRec (R :: Nat -&gt; Bool -&gt; [Maybe Nat] -&gt; [Maybe Nat] -&gt; * -&gt; *) where
    wrap f = R . Mu . f . unR 
    unwrap f = R . f . unMu . unR 
    fix f = f (R $ unR $ fix f)

-- show Hints for the type checker.
type DefnRec tf a = 
    forall repr vid h . 
    (Lin repr, LinRec repr, Intersect h h ~ h, (h :&lt;: h) ~ True) =&gt; 
    repr vid tf h h a
defnRec :: DefnRec tf a -&gt; DefnRec tf a
defnRec x = x


-- show Nat examples
type MyNat = Mu ((:+:) One)

instance Show MyNat where
    show (Mu (Inl _)) = &quot;z&quot;
    show (Mu (Inr n)) = &quot;s &quot;++show n

zero :: DefnRec False MyNat
zero = wrap id (inl one)

succ :: DefnRec False (MyNat :-&lt;&gt;: MyNat)
succ = llam $ \x -&gt; wrap id (inr x)

nat1 = succ &lt;^&gt; zero
nat2 = succ &lt;^&gt; nat1
nat3 = succ &lt;^&gt; nat2
nat4 = succ &lt;^&gt; nat3

plus :: DefnRec False (MyNat :-&lt;&gt;: (MyNat :-&lt;&gt;: MyNat))
plus = fix $ \p -&gt; llam $ \x -&gt; llam $ \y -&gt; 
       letPlus (unwrap id x) 
               (\x -&gt; letOne x y) 
               (\x -&gt; succ &lt;^&gt; (p &lt;^&gt; x &lt;^&gt; y))

mult :: DefnRec False (MyNat :-&lt;&gt;: (MyNat -&gt; MyNat))
mult = fix $ \m -&gt; llam $ \x -&gt; lam $ \y -&gt; 
       letPlus (unwrap id x) 
               (\x -&gt; letOne x zero) 
               (\x -&gt; plus &lt;^&gt; (m &lt;^&gt; x &lt;$&gt; y) &lt;^&gt; y)


-- show List examples
newtype MyListF a lst = MLF {unMLF :: One :+: (a :*: lst)}
type MyList a = Mu (MyListF a)

instance Show a =&gt; Show (MyList a) where
    show (Mu (MLF (Inl _))) = &quot;nil&quot;
    show (Mu (MLF (Inr (Tensor x xs)))) = show x ++ &quot;:&quot; ++ show xs

nil :: DefnRec False (MyList a)
nil = wrap MLF (inl one)

cons :: DefnRec False (a :-&lt;&gt;: (MyList a :-&lt;&gt;: MyList a))
cons = llam $ \x -&gt; llam $ \xs -&gt; wrap MLF (inr (x &lt;*&gt; xs))

rev :: DefnRec False (MyList a :-&lt;&gt;: (MyList a :-&lt;&gt;: MyList a))
rev = fix $ \r -&gt; llam $ \l -&gt; llam $ \k -&gt; 
      letPlus (unwrap unMLF l) 
              (\x -&gt; letOne x k) 
              (\xs -&gt; letStar xs (\x xs -&gt; r &lt;^&gt; xs &lt;^&gt; (cons &lt;^&gt; x &lt;^&gt; k)))

-- Example using Haskell's recursion.
rev' :: DefnRec False (MyList a :-&lt;&gt;: (MyList a :-&lt;&gt;: MyList a))
rev' = llam $ \l -&gt; llam $ \k -&gt; 
       letPlus (unwrap unMLF l) 
              (\x -&gt; letOne x k) 
              (\xs -&gt; letStar xs (\x xs -&gt; rev' &lt;^&gt; xs &lt;^&gt; (cons &lt;^&gt; x &lt;^&gt; k)))

l0 :: DefnRec False (MyList MyNat)
l0 = cons &lt;^&gt; zero &lt;^&gt; (cons &lt;^&gt; nat1 &lt;^&gt; (cons &lt;^&gt; nat2 &lt;^&gt; nil))


main = do
  putStrLn $ show $ eval $ mult &lt;^&gt; nat2 &lt;$&gt; (plus &lt;^&gt; nat3 &lt;^&gt; nat4)
  putStrLn $ show $ eval $ rev &lt;^&gt; l0 &lt;^&gt; nil
  putStrLn $ show $ eval $ rev' &lt;^&gt; (cons &lt;^&gt; nat3 &lt;^&gt; l0) &lt;^&gt; nil
  putStrLn &quot;ok&quot;</code></pre></article>


</div>
</div>
<div class="row article-footer"><div class="span7 meta"><span class="sociallinksunicode social">
<a href="https://twitter.com/home?status=$url$" target="_blank"><i class="icon-twitter"></i></a>&nbsp;
<a href="http://www.facebook.com/sharer/sharer.php?u=$url$" target="_blank"><i class="icon-facebook"></i></a>&nbsp;
<a href="https://plus.google.com/share?url=$url$" target="_blank"><i class="icon-google-plus"></i></a></span>
</div>
</div>
</div>
<div class="footer"><div class="container"><div class="row"><div class="span12"><ul class="menu"><li><a href="https://www.schoolofhaskell.com/">School</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user">Users</a>
</li>

<li><a class="brand" href="https://fpcomplete.com">Sponsored by:
<img src="/static/img/logo.png" title="FPComplete">
</a>
</li>
</ul>
</div>
</div>
<div class="row"><div class="span12"></div>
</div>
</div>
</div>
<link rel="stylesheet" type="text/css" href="/static/bootstrap/css/bootstrap-responsive.css" />
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script><script src="https://www.schoolofhaskell.com/static/combined/Y-3k9_tW.js"></script><script>$(function(){
  $("a.logout").click(function(){
    var form = $("<form method='post'/>");
    form.attr("action", $(this).attr("href"));
    $("body").append(form);
    form.submit();
    return false;
  });
});

$(function(){
    $('.sociallinksunicode a').each(function(){
        $(this).attr('href',$(this).attr('href').replace('$url$',document.location));
    });
});

$(function(){
  // If we need to select a user/select a password then show the
  // details confirmation form, otherwise enable the getting started
  // section.
  if($('.alert-block a').text().match(/(selected a username|change your password)/)) {
    $("#confirm-details").show();
    $("#confirm-details #inputUsername").focus();
  } else {
    $("#get-started").removeClass('disabled').addClass('enabled');
  }

  // For lack of a plain HTML validation story this will do.
  $('.welcome-page').each(function(){
    $('form').submit(check);
  });
  function check(){
    setTimeout(check,500);
    var error = false;
    $('.error').removeClass('error');
    $('#enter-details input').each(function(){
      if($(this).val() == '') {
        $(this).parent().parent().addClass('error');
        error = true;
      }
    });
    if(error) return false;
    if($('[name=password]').val() == $('[name=confirm]').val()) {
      $('#confirm').removeClass('error');
      return true;
    } else {
      $('#confirm').addClass('error');
      return false;
    }
  }
});

$(function(){
  // When scrolling over a snippet editor, activate the "clone in IDE" popovers
  $('article').each(function(){
    var n = 100;
    var wait = 10000;
    function check(){
      if($('.clone').length == 0) {
        setTimeout(check,n);
        return;
      }
      var activated = $.cookie('clone-popover');
      if (activated) return;
      var activate = false;
      $('.controlsRun:onScreen').each(function(){
        $.cookie('clone-popover', 'true', { expires: 30, path: '/' });
        activate = true;
        return false;
      });
      if(activate) {
          $('.clone').each(function(){
              // The bootstrap API is rather unreasonable to say the
              // least.
              next = $(this).parent();
              var title = next.attr('title');
              next.attr('data-content',$(this).attr('data-content'));
              next.attr('title',$(this).attr('title'));
              next.popover('show',{
                  title: $(this).attr('title')
              });
              next.attr('title',title);
          });
          setTimeout(function(){
              $('.clone').each(function(){
                  $(this).parent().popover('hide');
              });
          },wait);
      } else {
        setTimeout(check,n);
      }
    }
    setTimeout(check,n);
  });
});

// onScreen jQuery plugin v0.2.1
// (c) 2011-2013 Ben Pickles
//
// http://benpickles.github.com/onScreen
//
// Released under MIT license.
(function(a){a.expr[":"].onScreen=function(b){var c=a(window),d=c.scrollTop(),e=c.height(),f=d+e,g=a(b),h=g.offset().top,i=g.height(),j=h+i;return h>=d&&h<f||j>d&&j<=f||i>e&&h<=d&&j>=f}})(jQuery);

/*!
 * jQuery Cookie Plugin v1.1
 * https://github.com/carhartl/jquery-cookie
 *
 * Copyright 2011, Klaus Hartl
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.opensource.org/licenses/GPL-2.0
 */
(function($, document) {

  var pluses = /\+/g;
  function raw(s) {
    return s;
  }
  function decoded(s) {
    return decodeURIComponent(s.replace(pluses, ' '));
  }

  $.cookie = function(key, value, options) {

    // key and at least value given, set cookie...
    if (arguments.length > 1 && (!/Object/.test(Object.prototype.toString.call(value)) || value == null)) {
      options = $.extend({}, $.cookie.defaults, options);

      if (value == null) {
	options.expires = -1;
      }

      if (typeof options.expires === 'number') {
	var days = options.expires, t = options.expires = new Date();
	t.setDate(t.getDate() + days);
      }

      value = String(value);

      return (document.cookie = [
	encodeURIComponent(key), '=', options.raw ? value : encodeURIComponent(value),
	options.expires ? '; expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE
	options.path    ? '; path=' + options.path : '',
	options.domain  ? '; domain=' + options.domain : '',
	options.secure  ? '; secure' : ''
      ].join(''));
    }

    // key and possibly options given, get cookie...
    options = value || $.cookie.defaults || {};
    var decode = options.raw ? raw : decoded;
    var cookies = document.cookie.split('; ');
    for (var i = 0, parts; (parts = cookies[i] && cookies[i].split('=')); i++) {
      if (decode(parts.shift()) === key) {
	return decode(parts.join('='));
      }
    }
    return null;
  };
  $.cookie.defaults = {};})(jQuery, document);
</script><!--[if lt IE 10]><script src="https://www.schoolofhaskell.com/static/design/js/ie.js?etag=ayV2DuJ0"></script><![endif]--><script>if(!window.location.href.match(/localhost/)){var track = '/tutorial/user/mutjida/typed-tagless-final-linear-lambda-calculus/6-recursive-types';
window._gaq = [['_setAccount','UA-36928035-1'],track != ''? ['_trackPageview',track] : ['_trackPageview']
,['_trackPageLoadTime']];window._gaq.push(['_setCustomVar',1,'Section','School of Haskell',3]);
window._gaq.push(['_setCustomVar',2,'User Type','Visitor',1]);
(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);

})();}</script>
<!-- Prompt IE 6 users to install Chrome Frame. Remove this if you want to support IE 6.  chromium.org/developers/how-tos/chrome-frame-getting-started --><!--[if lt IE 7 ]><script src="//ajax.googleapis.com/ajax/libs/chrome-frame/1.0.3/CFInstall.min.js"></script><script>window.attachEvent('onload',function(){CFInstall.check({mode:'overlay'})})</script><![endif]--></body></html>