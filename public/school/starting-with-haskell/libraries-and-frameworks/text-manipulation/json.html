<!DOCTYPE html>
<html><head><title>Parsing JSON with Aeson - School of Haskell | School of Haskell</title><meta http-equiv="x-ua-compatible" content="IE=9"><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="google-site-verification" content="Rfxk2TdeMMXEXHgJ2_OO8Rt3hPbQSDao0OXQV_n6z_s" /><link href="//fonts.googleapis.com/css?family=Merriweather" rel="stylesheet" type="text/css"><link href="https://www.schoolofhaskell.com/recent-content/feed" type="application/rss+xml" rel="alternate" title="Recently published content">
<link rel="stylesheet" href="https://www.schoolofhaskell.com/static/combined/UlwEHVcM.css"><style>.social{margin-right:1em}h1{font-family:Merriweather !important}article{font-family:Merriweather !important}article li{font-family:Merriweather !important;line-height:1.6em}h1,h2,h3,h4,h4,h5{font-family:Merriweather !important}.editor p{font-family:Frutiger, "Frutiger Linotype", Univers, Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans Condensed", "Liberation Sans", "Nimbus Sans L", Tahoma, Geneva, "Helvetica Neue", Helvetica, Arial, sans-serif}.article-footer{border-top:1px solid #ddd;padding-top:1em;margin-top:1em}body{font-size:16px !important}.navbar .navbar-inner{background:#3c3f41}.navbar .brand{font-size:14px}.navbar .brand img{width:6em}.navbar .icon-wrench{margin:0 -0.5em 0 -0.5em;padding:0 1em 0 1em;height:20px}.navbar-inverse .nav .active a{background:#333638}.navbar-inverse .nav > li > a{color:#a7a7a7
}.navbar-inverse .btn-navbar{background:#333638}.navbar-inverse .nav > li a:hover,.navbar-inverse .btn{background:#333537 !important}@media (max-width: 979px) {.icon-wrench{padding-left:1em !important}}.breadcrumb{border-top-left-radius:0;border-top-right-radius:0}h1{margin-top:20px}.breadcrumb-container + .main-content h1{margin-top:0}.footer{padding:30px 0;margin-top:70px;border-top:1px solid #e5e5e5;background-color:#f5f5f5}.footer ul.footer-menu{list-style-type:none}.footer ul.footer-menu li{display:inline-block}.footer ul.footer-menu li + li{margin-left:0.5em}.footer ul.footer-menu li + li:before{margin-right:0.5em;content:"·";color:#999}.footer ul.menu li{display:inline-block}.footer ul.menu li + li{margin-left:0.5em}.footer .copyright{margin-left:25px}.main-content{min-height:100%}.gravatar{width:80px;height:80px;border-radius:2px;background:#eee}.empty-gravatar{width:0}.container{font-family:"Segoe UI", Candara, "Bitstream Vera Sans", "DejaVu Sans", "Bitstream Vera Sans", "Trebuchet MS", Verdana, "Verdana Ref", sans-serif}.container h1,.container h2,.container h4,.container h4,.container h5{font-family:"Segoe UI", Candara, "Bitstream Vera Sans", "DejaVu Sans", "Bitstream Vera Sans", "Trebuchet MS", Verdana, "Verdana Ref", sans-serif}article{font-family:Merriweather !important}article h1{font-family:Merriweather !important}article li{font-family:Merriweather !important;line-height:1.6em}article li + li{margin-top:0.5em}article div.code{background:#f9f9f9;border:1px solid #d1d1d1;position:relative;border-radius:0.2em;margin:0.25em 0 0.75em 0;min-height:2.5em}article code{color:#005580;font-size:14px;white-space:pre}article a.hoogle > code{color:#0088cc;font-size:14px;white-space:pre;border:0}article .expand-code{display:none}article pre{overflow:auto;word-wrap:normal}article code.active{display:block;max-height:430px}article h1{font-size:31.5px}article h3{font-size:17.5px}article h4{font-size:14px}article h5,article h6{font-size:11.9px}article p{line-height:1.7em}article h1 code,article h2 code,article h3 code,article h4 code,article h5 code,article h6 code{font-size:inherit !important}article h1 a,article h2 a,article h3 a,article h4 a,article h5 a,article h6 a{color:#444}article h1 a:before,article h2 a:before,article h3 a:before,article h4 a:before,article h5 a:before,article h6 a:before{margin-left:-1.5em;padding-right:0.5em;font-family:fontawesome;content:"\f0c1";font-size:20px;color:#fff}article h1 a:hover,article h2 a:hover,article h3 a:hover,article h4 a:hover,article h5 a:hover,article h6 a:hover{text-decoration:none;color:#0088cc}article h1 a:hover:before,article h2 a:hover:before,article h3 a:hover:before,article h4 a:hover:before,article h5 a:hover:before,article h6 a:hover:before{color:#888}article h2{font-size:24.5px}article .popover{font-family:actor}article .popover h3.popover-title{font-family:actor !important;font-size:1em}article .popover .popover-content{width:15em;font-size:1em}article .controlsRun{display:block;padding:0.5em;text-align:right;background:#f2f2f2}article .controlsRun a.clone{margin-right:1em;font-family:actor;text-decoration:none}article .controlsRun a.clone span{padding-left:0.5em}article .controlsRun a.run,article .controlsRun a.reset,article .controlsRun a.show-code{font-size:16px}article .controlsRun a.run span,article .controlsRun a.reset span,article .controlsRun a.show-code span{display:none}article .controlsRun a.reset{margin-left:0.5em;color:#a2becc}article .controlsRun a.reset{display:none}article .controlsRun a.show-code{margin-right:0.75em}article .controlsRun a.run:hover,article .controlsRun a.show-code:hover{text-decoration:none}article .controlsRun a.show-code.active{color:#DC0D0D}article .controlsRun a[disabled]{color:#a2becc;cursor:default}article .collapse-area .collapse-header{background:#0088cc;color:#fff;padding:0.3em;cursor:pointer}article .collapse-area .hidden-toggle:before{content:"\f0d7";font-family:fontawesome;margin-right:0.5em;margin-left:0.25em}article .collapse-area .collapsed-files{overflow:auto;height:auto}article .collapse-area.collapse-disabled{display:none}article .collapse-area.collapse-area-off .collapsed-files{height:0px;overflow:hidden}article .collapse-area.collapse-area-off .hidden-toggle:before{content:"\f0da"}article .snippet-stdio .stdout{margin:0.5em;padding-right:2em;position:relative;word-wrap:break-word}article .snippet-stdio .stdin{-webkit-box-shadow:none;-moz-box-shadow:none;box-shadow:none;-webkit-transition:none;-moz-transition:none;-o-transition:none;transition:none;padding:0;margin:0}article .hoogle-results{margin:0.25em}article .hoogle-results .hoogle-inner{background:#fff;padding:0.5em;border-radius:3px;border:1px solid #ddd}article .hoogle-results .hoogle-inner .close-link{position:relative;float:right;margin-top:-0.5em;margin-right:-0.5em}article .snippet-output-errors{margin:1em 0.5em 0.5em 0.5em;position:relative}article .snippet-output-errors ul{list-style-type:none;margin:0;position:relative}article .snippet-output-errors pre{border:0;border-radius:0;padding:0.25em;margin:0;background:inherit;color:inherit}article .snippet-output-errors .close-link{color:inherit;background:inherit}article .snippet-editors{z-index:0;padding:0.25em}article .close-link{padding:0.5em;background:#eaeaea;border-bottom-left-radius:0.2em;border-top-right-radius:0.2em;position:absolute;top:0;right:0}article .close-link:hover{text-decoration:none}article .snippet-title{padding:0.5em 0 0 0.5em}article .snippet-title .snippet-icon{font-family:FontAwesome;display:inline-block;margin-right:0.5em}article .fullModuleCode + div .snippet-title{margin-top:0.5em;border-top:1px solid #ccc;padding-top:0.5em}article .CodeMirror{height:auto;min-height:1em;line-height:1.5em;background:transparent;font-size:14px !important}article .CodeMirror .highlighted{background:rgba(250, 210, 0, 0.45) !important}article .CodeMirror-widget{margin-left:2em;line-height:1.8}article .CodeMirror.collapsed{height:10em !important}article .editor .expander{text-align:center;display:block;padding:0.5em;text-decoration:none;border-bottom-left-radius:2px;border-bottom-right-radius:2px}article .editor .expander .ellipsis{background:white;border:1px solid #ccc;padding:0 0.5em;height:1em;line-height:0.5em;display:inline-block;color:#555;cursor:pointer}article .editor .expander .ellipsis:hover{background:#ddd;color:#333}article .web-runner{margin:0.5em;padding:0.5em;border:1px solid #ccc;border-radius:3px;background:#f5f5f5}article .web-runner iframe{border:0;margin-top:0.5em;margin-bottom:0;background:white}article .web-runner .controls i{cursor:pointer;color:#0088cc}article .web-runner .controls i:hover{color:#222}article .web-runner .controls i + i{margin-left:0.5em}article .web-runner .controls .icon-remove{float:right}article .hidden{display:block;visibility:visible}article .controlsShowHide{margin-bottom:0.5em}.tutorial-body{float:left !important}.tutorial-nav{float:right !important}@media (max-width: 979px) {.related-content{float:right}.author-name{display:block;margin-left:20px !important;padding-left:5px;margin-top:5px}article h1 a:hover:before,article h2 a:hover:before,article h3 a:hover:before,article h4 a:hover:before,article h5 a:hover:before,article h6 a:hover:before{color:#fff}.tutorial-nav{float:none !important;width:auto !important}.tutorial-body{float:none !important;width:auto !important}}@media (min-width: 980px) and (max-width: 1199px) {.navbar-search{display:none}.tutorial-nav{width:200px}.tutorial-body{width:720px}}#accountPage h1{margin:20px 0 0 0}#accountPage h2{font-size:20px}.group-contents .span8{float:left}.group-contents .span4{float:right}.container > .alert-block{margin-top:1em}.alert{color:#aa874a
}.social{margin-bottom:.8em;display:block}.social a{text-decoration:none}.social i{font-size:1.1em;color:#fff;padding:0.25em;border-radius:0.25em;width:1em;display:inline-block;text-align:center}.social i.icon-twitter{background:#0088cc}.social i.icon-facebook{background:#3b5998
  }.social i.icon-google-plus{background:#dd4b39
  }.well pre{background:#fcfcfc}.well h2{margin-top:0}code{color:#005580;font-size:14px;white-space:pre}</style><!--[if lt IE 8]><link rel="stylesheet" href="https://www.schoolofhaskell.com/static/design/css/ie7.css?etag=TSMl9x1V"><![endif]--><!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]--></head><body class="not-logged-in" itemscope itemtype="http://schema.org/Product"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-H62P" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-H62P');</script><div class="navbar navbar-inverse navbar-static-top"><div class="navbar-inner"><div class="container"><a class="btn btn-navbar" type="button" data-toggle="collapse" data-target=".nav-collapse"><span class="icon-bar"></span>
<span class="icon-bar"></span>
<span class="icon-bar"></span>
</a>
<a class="brand" href="/"><img src="/static/img/haskell-logo-wide.png" title="School of Haskell">
</a>
<div class="nav-collapse collapse"><ul class="nav"><li><a href="https://www.schoolofhaskell.com/">School</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user">Users</a>
</li>
</ul>
<form class="navbar-search pull-left" action="https://www.schoolofhaskell.com/search"><input class="search-query" type="text" placeholder="Search" name="search">
</form>
</div>
</div>
</div>
</div>
<div class="container breadcrumb-container"><div class="row"><div class="span12"><ul class="breadcrumb"><li><a href="https://www.schoolofhaskell.com/">School of Haskell</a>
<span class="divider">/</span>
</li>
<li><a href="https://www.schoolofhaskell.com/school/starting-with-haskell">Starting with Haskell</a>
<span class="divider">/</span>
</li>
<li><a href="https://www.schoolofhaskell.com/school/starting-with-haskell/libraries-and-frameworks">Libraries and Frameworks</a>
<span class="divider">/</span>
</li>
<li><a href="https://www.schoolofhaskell.com/school/starting-with-haskell/libraries-and-frameworks/text-manipulation">Text manipulation</a>
<span class="divider">/</span>
</li>
<li><a href="https://www.schoolofhaskell.com/school/starting-with-haskell/libraries-and-frameworks/text-manipulation/json">Parsing JSON with Aeson</a>
</li>
</ul>
</div>
</div>
</div>
<div class="container main-content"><div class="row"><div class="span12"><h1 itemprop="name">Parsing JSON with Aeson</h1>
</div>
</div>
<div class="row"><div class="span7 meta"><p><span class="date"> 1 Feb 2015</span>
<span class="author"><a href="https://www.schoolofhaskell.com/user/school">School of Haskell</a>
</span>
<span class="view-edit-link pull-right"><a class="view-source-link" href="https://www.schoolofhaskell.com/tutorial-raw/30/0a48b1265c0af417b3881bbd9d261be7c8503ac8">View Markdown source</a>
</span>
</p>
<p class="tags"></p>
</div>
</div>
<div class="row"><div class="span7 meta"><span class="sociallinksunicode social">
<a href="https://twitter.com/home?status=$url$" target="_blank"><i class="icon-twitter"></i></a>&nbsp;
<a href="http://www.facebook.com/sharer/sharer.php?u=$url$" target="_blank"><i class="icon-facebook"></i></a>&nbsp;
<a href="https://plus.google.com/share?url=$url$" target="_blank"><i class="icon-google-plus"></i></a></span>
</div>
</div>
<p class="alert">As of March 2020, School of Haskell has been switched to read-only mode.</p>
<div class="row" itemprop="desc"><div class="span4 tutorial-nav"><div class="related-content"><ul class="nav nav-tabs nav-stacked"><li><script>reddit_target='fpcomplete'</script>
<script src="https://redditstatic.s3.amazonaws.com/button/button1.js"></script>
</li>
<li><a href="https://www.schoolofhaskell.com/user/school/starting-with-haskell/libraries-and-frameworks/text-manipulation/tagsoup">Next content: HTML Parsing</a>
</li>
<li><a href="https://www.schoolofhaskell.com/school/starting-with-haskell/libraries-and-frameworks/text-manipulation">Go up to: Text manipulation</a>
</li>
</ul>

</div>
<div class="aside"><h3>Sections</h3>
<ul><li><a href="#introduction">Introduction</a></li><li><a href="#json-in-haskell">JSON in Haskell</a></li><li><a href="#a-tasteful-example">A tasteful example</a><ul><li><a href="#step-1--define-your-type--collect-your-data">Step 1: Define your type, collect your data</a></li><li><a href="#step-2--write-instances-for-fromjson-and-tojson-">Step 2: Write instances for FromJSON and ToJSON.</a></li><li><a href="#step-2--the-smart-alternative">Step 2: The smart alternative</a></li><li><a href="#step-3--get-the-data-in-haskell">Step 3: Get the data in Haskell</a><ul><li><a href="#from-a-file">From a file</a></li><li><a href="#from-a-url">From a URL</a></li><li><a href="#other-sources">Other sources</a></li></ul></li><li><a href="#for-the-lazy--pre-made-working-program">For the lazy: pre-made working program</a></li></ul></li><li><a href="#application--rate-exchange-json-api">Application: Rate Exchange JSON API</a><ul><li><a href="#step-1--define-a-type-for-currency-conversions">Step 1: Define a type for currency conversions</a></li><li><a href="#step-2--obtaining-the-data-from-the-url">Step 2: Obtaining the data from the URL</a></li><li><a href="#ready-to-use-currency-converter">Ready-to-use currency converter</a></li></ul></li><li><a href="#further-application--reading-twitter-timelines">Further application: Reading Twitter timelines</a><ul><li><a href="#step-1--register-your-application-in-twitter">Step 1: Register your application in Twitter</a></li><li><a href="#step-2--create-your-oauth-and-credential-values">Step 2: Create your OAuth and Credential values</a></li><li><a href="#step-3--define-a-type-for-tweets">Step 3: Define a type for tweets</a></li><li><a href="#step-4--timeline-request-and-parsing">Step 4: Timeline request and parsing</a></li><li><a href="#putting-everything-together">Putting everything together</a></li></ul></li><li><a href="#conclusion">Conclusion</a></li></ul></div>
</div>
<div class="span8 tutorial-body" data-environment="ghc-7.8-stable-14.09">
<article><h1 id="introduction"><a href="#introduction">Introduction</a></h1><p>Plenty of data across the web is shared using the <a href="http://tools.ietf.org/html/rfc4627">JSON format</a>,
which is intended to be a simple and human-readable way to store data. It was designed to be a subset
of JavaScript, so it defines objects as a list of name/value pairs.</p><p>Possible values in JSON are strings, numbers, booleans, null, arrays (one-dimensional) and objects.
This is pretty much all you should know of JSON to work with it. Read the RFC 4627 linked before for
more details about JSON.</p><h1 id="json-in-haskell"><a href="#json-in-haskell">JSON in Haskell</a></h1><p>Many languages define parsers for JSON data, and Haskell is not an exception. The library we are using
in this tutorial to parse JSON is <a href="http://hackage.haskell.org/package/aeson"><code>aeson</code></a>. Designed by
Bryan O'Sullivan, <code>aeson</code> is a highly tuned, easy to use library. The module <code>Data.Aeson</code> contains further examples and
explanations about the library. I encourage you to not stick to this tutorial and read the original
documentation as well.</p><p>Alternatives and more tools for the use of JSON in Haskell exist. In fact, there is a separate category
in Hackage with <a href="http://hackage.haskell.org/package/#cat:json">JSON libraries</a>. In particular, the
package <code>aeson-pretty</code> is useful to print JSON values in a more human-friendly way.</p><h1 id="a-tasteful-example"><a href="#a-tasteful-example">A tasteful example</a></h1><p>An example of a JSON problem is now provided. We solve it paying attention to each step, so any newcomer
in this topic can understand and reproduce the solution.</p><p>Suppose that we are running a survey about the relation between the age of a person and his/her taste for
pizzas. <i>A priori</i>, our guess is that young people like pizzas more frequently than older people. However,
we need data to verify or reject our hypothesis. We are storing this data in JSON format, and we want to
run our statistical test in Haskell. Therefore, we need a way to read JSON to Haskell. This is exactly
the kind of problem we are about to learn to solve!</p><h2 id="step-1--define-your-type--collect-your-data"><a href="#step-1--define-your-type--collect-your-data">Step 1: Define your type, collect your data</a></h2><p>Probably, as in many others Haskell problems, it is a good idea to start defining types. We use types to describe the objects we are working with. Then we manipulate and transform these objects.</p><p>We begin then by defining the type <code>Person</code>, which will contain the information from a single person
that we ask in the survey. In this case, first name, last name, age and whether if he/she likes
pizzas or not using a Haskell record:</p><pre><code class="haskell">data Person =
  Person { firstName  :: !Text
         , lastName   :: !Text
         , age        :: Int
         , likesPizza :: Bool
           } deriving Show</code></pre><p>In the other hand, we have the JSON data of the survey (conveniently hidden because of its length).</p><div class="hidden"><pre><code>[ 
   { &quot;firstName&quot;  : &quot;Daniel&quot;
   , &quot;lastName&quot;   : &quot;Díaz&quot;
   , &quot;age&quot;        :  24
   , &quot;likesPizza&quot; :  true
     }
,
   { &quot;firstName&quot;  : &quot;Rose&quot;
   , &quot;lastName&quot;   : &quot;Red&quot;
   , &quot;age&quot;        :  39
   , &quot;likesPizza&quot; :  false
     }
,  { &quot;firstName&quot;  : &quot;John&quot;
   , &quot;lastName&quot;   : &quot;Doe&quot;
   , &quot;age&quot;        :  45
   , &quot;likesPizza&quot; :  false
     }
,  { &quot;firstName&quot;  : &quot;Vladimir&quot;
   , &quot;lastName&quot;   : &quot;Vygodsky&quot;
   , &quot;age&quot;        :  27
   , &quot;likesPizza&quot; :  false
     }
,  { &quot;firstName&quot;  : &quot;Foo&quot;
   , &quot;lastName&quot;   : &quot;Bar&quot;
   , &quot;age&quot;        :  32
   , &quot;likesPizza&quot; :  true
     }
,  { &quot;firstName&quot;  : &quot;María&quot;
   , &quot;lastName&quot;   : &quot;Delaoh&quot;
   , &quot;age&quot;        :  52
   , &quot;likesPizza&quot; :  false
     }
,  { &quot;firstName&quot;  : &quot;Victoria&quot;
   , &quot;lastName&quot;   : &quot;Haskell&quot;
   , &quot;age&quot;        :  23
   , &quot;likesPizza&quot; :  true
     }
,  { &quot;firstName&quot;  : &quot;François&quot;
   , &quot;lastName&quot;   : &quot;Beaulieu&quot;
   , &quot;age&quot;        :  42
   , &quot;likesPizza&quot; :  false
     }
,  { &quot;firstName&quot;  : &quot;Amalie&quot;
   , &quot;lastName&quot;   : &quot;Baumann&quot;
   , &quot;age&quot;        :  28
   , &quot;likesPizza&quot; :  true
     }
,  { &quot;firstName&quot;  : &quot;Rachel&quot;
   , &quot;lastName&quot;   : &quot;Scott&quot;
   , &quot;age&quot;        :  23
   , &quot;likesPizza&quot; :  true
     }
]</code></pre></div><p>The <code>Data.Aeson</code> module of the <code>aeson</code> package exports the following functions:</p><pre><code class="haskell">decode :: FromJSON a =&gt; ByteString -&gt; Maybe a
encode :: ToJSON a =&gt; a -&gt; ByteString
eitherDecode :: FromJSON a =&gt; ByteString -&gt; Either String a</code></pre><p>Their names are pretty descriptive. The function <code>decode</code> will <i>decode</i> a JSON input
stored as a <code>ByteString</code> value to a JSON type. The <code>encode</code> function will <i>encode</i> a value of
JSON type <code>a</code> to a <code>ByteString</code> output value. The function <code>decodeEither</code> is similar to
<code>decode</code>. Instead of returning the output inside the <code>Maybe</code>
type, it does it inside the <code>Either String</code> type. This way, in case of unsuccessful
decoding, it returns a <code>String</code> describing the error.</p><h2 id="step-2--write-instances-for-fromjson-and-tojson-"><a href="#step-2--write-instances-for-fromjson-and-tojson-">Step 2: Write instances for <code>FromJSON</code> and <code>ToJSON</code>.</a></h2><p>However, looking at the type signatures, we see that to use these functions, our type
must be an instance of the <code>FromJSON</code> class to decode, and of the <code>ToJSON</code> class to
encode. Once we define these two instances for our type, we will be able to read/write
JSON to/from Haskell.</p><p>No problem. Writing these instances is a straightforward process. In fact, the instances
are similar to the type definition.</p><pre><code class="haskell">instance FromJSON Person where
 parseJSON (Object v) =
    Person &lt;$&gt; v .: &quot;firstName&quot;
           &lt;*&gt; v .: &quot;lastName&quot;
           &lt;*&gt; v .: &quot;age&quot;
           &lt;*&gt; v .: &quot;likesPizza&quot;
 parseJSON _ = mzero

instance ToJSON Person where
 toJSON (Person firstName lastName age likesPizza) =
    object [ &quot;firstName&quot;  .= firstName
           , &quot;lastName&quot;   .= lastName
           , &quot;age&quot;        .= age
           , &quot;likesPizza&quot; .= likesPizza
             ]</code></pre><p>Remember to enable the <a href="http://www.haskell.org/ghc/docs/7.6.2/html/users_guide/type-class-extensions.html#overloaded-strings"><code>OverloadedStrings</code></a> language extension in the top of your source file,
which allows <i>stringy</i> types like <code>Text</code> to be written using string literals with no explicit
conversion. Note also that, even if the JSON data
you are parsing contains additional fields, the parser will succeed, ignoring unknown fields.
However, if a field in <i>your type</i> is not present in the JSON data, an error will arise.
If you want to have optional records, use (<code>.:?</code>) instead of (<code>.:</code>) in the JSON parser.
For example, if the <code>firstName</code> field were optional, we would write:</p><pre><code class="haskell">instance FromJSON Person where
 parseJSON (Object v) =
    Person &lt;$&gt; v .:? &quot;firstName&quot;
           &lt;*&gt; v .:  &quot;lastName&quot;
           &lt;*&gt; v .:  &quot;age&quot;
           &lt;*&gt; v .:  &quot;likesPizza&quot;</code></pre><h2 id="step-2--the-smart-alternative"><a href="#step-2--the-smart-alternative">Step 2: The smart alternative</a></h2><p>While writing instances yourself is powerful and flexible, if they are simple mechanical translations like those above, then writing these instances is not only mechanical, but straightforward and boring. Even a machine could do it. Wait... That's it! Let the computer do it for you!</p><p>Haskell has a language extension called <a href="http://www.haskell.org/ghc/docs/7.6.2/html/users_guide/deriving.html#deriving-typeable"><code>DeriveGeneric</code></a>. Using this extension will allow you
to tell Haskell to write the instance for you. Of course, code has been written previously to
automatize this process for each different type class. To <i>derive</i> an instance for our type
<code>Person</code> all we need to do is make it an instance of the <code>Generic</code> typeclass. No worries, this will be
done automatically if you ask it to!</p><pre><code class="haskell">data Person =
  Person { firstName  :: !Text
         , lastName   :: !Text
         , age        :: Int
         , likesPizza :: Bool
           } deriving (Show,Generic)

instance FromJSON Person
instance ToJSON Person</code></pre><p>I strongly recommend you derive the instances this way to avoid some trivial work and focus
on other (probably harder) problems.</p><h2 id="step-3--get-the-data-in-haskell"><a href="#step-3--get-the-data-in-haskell">Step 3: Get the data in Haskell</a></h2><p>So far, we know how to encode/decode Haskell values to/from <code>ByteString</code>s. We also have some JSON
data somewhere, in a local file or over the network. It is time to learn how to bring our JSON file
to Haskell to be able to parse it.</p><h3 id="from-a-file"><a href="#from-a-file">From a file</a></h3><p>If the JSON data is currently stored in a local file, all we need to do is to specify the path to the file
and read it using the <code>ByteString</code>s <code>readFile</code> function. We have to import the <code>Data.ByteString.Lazy</code> module
qualified in order to avoid <code>ByteString</code>s <code>readFile</code> function name to clashes with the <code>Prelude</code>s <code>readFile</code>.</p><pre><code class="haskell">import qualified Data.ByteString.Lazy as B

jsonFile :: FilePath
jsonFile = &quot;pizza.json&quot;

getJSON :: IO B.ByteString
getJSON = B.readFile jsonFile</code></pre><h3 id="from-a-url"><a href="#from-a-url">From a URL</a></h3><p>If the JSON data is stored under a URL in the web, the procedure is similar. Instead of using <code>readFile</code> we
use <code>simpleHttp</code> from the <code>http-conduit</code> package. This function will read the <i>response body</i> after following
a given URL.</p><pre><code class="haskell">import qualified Data.ByteString.Lazy as B
import Network.HTTP.Conduit (simpleHttp)

jsonURL :: String
jsonURL = &quot;http://daniel-diaz.github.io/misc/pizza.json&quot;

getJSON :: IO B.ByteString
getJSON = simpleHttp jsonURL</code></pre><h3 id="other-sources"><a href="#other-sources">Other sources</a></h3><p>It should be clear that in each use case the way of getting the JSON data can vary enormously. Files and URL's
are two very common ways, but it may not be enough for you. For example, it is very common to need some kind of
authentication before requesting the JSON data. You can find below an example request for Twitter, which uses
OAuth for the authentication.</p><h2 id="for-the-lazy--pre-made-working-program"><a href="#for-the-lazy--pre-made-working-program">For the lazy: pre-made working program</a></h2><p>Here you have a working example, putting everything together.
Feel free to make any changes, since the code is editable.
By default, the code reads the data from a URL. You may change the URL
to any other JSON source, but note that you will have to change
the type definition accordingly.</p><pre><code class="active haskell">{-# START_FILE pizza.json #-}
[ 
   { &quot;firstName&quot;  : &quot;Daniel&quot;
   , &quot;lastName&quot;   : &quot;Díaz&quot;
   , &quot;age&quot;        :  24
   , &quot;likesPizza&quot; :  true
     }
,
   { &quot;firstName&quot;  : &quot;Rose&quot;
   , &quot;lastName&quot;   : &quot;Red&quot;
   , &quot;age&quot;        :  39
   , &quot;likesPizza&quot; :  false
     }
,  { &quot;firstName&quot;  : &quot;John&quot;
   , &quot;lastName&quot;   : &quot;Doe&quot;
   , &quot;age&quot;        :  45
   , &quot;likesPizza&quot; :  false
     }
,  { &quot;firstName&quot;  : &quot;Vladimir&quot;
   , &quot;lastName&quot;   : &quot;Vygodsky&quot;
   , &quot;age&quot;        :  27
   , &quot;likesPizza&quot; :  false
     }
,  { &quot;firstName&quot;  : &quot;Foo&quot;
   , &quot;lastName&quot;   : &quot;Bar&quot;
   , &quot;age&quot;        :  32
   , &quot;likesPizza&quot; :  true
     }
,  { &quot;firstName&quot;  : &quot;María&quot;
   , &quot;lastName&quot;   : &quot;Delaoh&quot;
   , &quot;age&quot;        :  52
   , &quot;likesPizza&quot; :  false
     }
,  { &quot;firstName&quot;  : &quot;Victoria&quot;
   , &quot;lastName&quot;   : &quot;Haskell&quot;
   , &quot;age&quot;        :  23
   , &quot;likesPizza&quot; :  true
     }
,  { &quot;firstName&quot;  : &quot;François&quot;
   , &quot;lastName&quot;   : &quot;Beaulieu&quot;
   , &quot;age&quot;        :  42
   , &quot;likesPizza&quot; :  false
     }
,  { &quot;firstName&quot;  : &quot;Amalie&quot;
   , &quot;lastName&quot;   : &quot;Baumann&quot;
   , &quot;age&quot;        :  28
   , &quot;likesPizza&quot; :  true
     }
,  { &quot;firstName&quot;  : &quot;Rachel&quot;
   , &quot;lastName&quot;   : &quot;Scott&quot;
   , &quot;age&quot;        :  23
   , &quot;likesPizza&quot; :  true
     }
]
-- show
-- /show
{-# START_FILE main.hs #-}
{-# LANGUAGE OverloadedStrings, DeriveGeneric #-}

import Data.Aeson
import Data.Text
import Control.Applicative
import Control.Monad
import qualified Data.ByteString.Lazy as B
import Network.HTTP.Conduit (simpleHttp)
import GHC.Generics

-- | Type of each JSON entry in record syntax.
data Person =
  Person { firstName  :: !Text
         , lastName   :: !Text
         , age        :: Int
         , likesPizza :: Bool
           } deriving (Show,Generic)

-- Instances to convert our type to/from JSON.

instance FromJSON Person
instance ToJSON Person

-- | Location of the local copy, in case you have it,
--   of the JSON file.
jsonFile :: FilePath
jsonFile = &quot;pizza.json&quot;

-- | URL that points to the remote JSON file, in case
--   you have it.
jsonURL :: String
jsonURL = &quot;http://daniel-diaz.github.io/misc/pizza.json&quot;

-- Move the right brace (}) from one comment to another
-- to switch from local to remote.

{--
-- Read the local copy of the JSON file.
getJSON :: IO B.ByteString
getJSON = B.readFile jsonFile
--}

{--}
-- Read the remote copy of the JSON file.
getJSON :: IO B.ByteString
getJSON = simpleHttp jsonURL
--}

main :: IO ()
main = do
 -- Get JSON data and decode it
 d &lt;- (eitherDecode &lt;$&gt; getJSON) :: IO (Either String [Person])
 -- If d is Left, the JSON was malformed.
 -- In that case, we report the error.
 -- Otherwise, we perform the operation of
 -- our choice. In this case, just print it.
 case d of
  Left err -&gt; putStrLn err
  Right ps -&gt; print ps</code></pre><h1 id="application--rate-exchange-json-api"><a href="#application--rate-exchange-json-api">Application: Rate Exchange JSON API</a></h1><p>The web page <a href="http://rate-exchange.appspot.com">http://rate-exchange.appspot.com</a>
provides a publicly available currency converter with output in
JSON format and is obtained via URL's. For example, the URL</p><pre><code>http://rate-exchange.appspot.com/currency?from=USD&amp;to=EUR&amp;q=1</code></pre><p>gives us the following output:</p><pre><code>{&quot;to&quot;: &quot;EUR&quot;, &quot;rate&quot;: 0.74962518700000003, &quot;from&quot;: &quot;USD&quot;, &quot;v&quot;: 0.74962518700000003}</code></pre><p>This means that $1 is equivalent (in this moment) to 0.75€. Of course, we expect
these values to change over time.</p><h2 id="step-1--define-a-type-for-currency-conversions"><a href="#step-1--define-a-type-for-currency-conversions">Step 1: Define a type for currency conversions</a></h2><p>The meaning of the JSON output is:</p><ul><li><code>to</code>:   Target currency.</li><li><code>rate</code>: Rate of conversion.</li><li><code>from</code>: Currency of origin.</li><li><code>v</code>:    Converted value in the target currency.</li></ul><p>Therefore, a coherent type for this JSON would be:</p><pre><code class="haskell">{-# LANGUAGE DeriveGeneric #-}

import Data.Aeson
import GHC.Generics

data Conversion =
  Conversion { to :: !Text
             , rate :: Double
             , from :: !Text
             , v :: Double
               } deriving (Show, Generic)

instance FromJSON Conversion
instance ToJSON Conversion</code></pre><h2 id="step-2--obtaining-the-data-from-the-url"><a href="#step-2--obtaining-the-data-from-the-url">Step 2: Obtaining the data from the URL</a></h2><p>As we have seen before, it is easy to download the content from a URL using the
function <code>simpleHttp</code> from the module <code>Network.HTTP.Conduit</code> of the <code>http-conduit</code>
package. Therefore, given two strings representing the original and target
currencies, and a quantity in the original currency, we get the JSON data of
the conversion as follows.</p><pre><code class="haskell">getConversion :: Text -&gt; Text -&gt; Double -&gt; IO (Maybe Conversion)
getConversion from to q =
  fmap decode $ simpleHttp $
      &quot;http://rate-exchange.appspot.com/currency?from=&quot;
    ++ from ++ &quot;&amp;to=&quot; ++ to ++ &quot;&amp;q=&quot; ++ show q</code></pre><p>It suffices now to extract the field <code>v</code> from the result to get the value in the
converted currency.</p><pre><code class="haskell">-- | Convert a monetary value from one currency to another.
convert :: Double -- ^ Initial quantity.
        -&gt; Text -- ^ Initial currency.
        -&gt; Text -- ^ Target currency.
        -&gt; IO (Maybe Double) -- ^ Result.
convert q from to = fmap (fmap v) $ getConversion from to q</code></pre><h2 id="ready-to-use-currency-converter"><a href="#ready-to-use-currency-converter">Ready-to-use currency converter</a></h2><p>We now have all the ingredients to have a working application that converts money
within different currencies.</p><pre><code class="active haskell">{-# LANGUAGE DeriveGeneric #-}

import Data.Aeson
import GHC.Generics
import Network.HTTP.Conduit (simpleHttp)
import Data.Text (Text)

-- | Type of conversion, analogous to the JSON data obtainable
--   from the URL.
data Conversion =
  Conversion { to :: !Text
             , rate :: Double
             , from :: !Text
             , v :: Double
               } deriving (Show, Generic)

-- Automatically generated instances

instance FromJSON Conversion
instance ToJSON Conversion

-- | Read the JSON data from the URL of a conversion, decoding it
--   based in the 'Conversion' type.
getConversion :: String -&gt; String -&gt; Double -&gt; IO (Maybe Conversion)
getConversion from to q =
  fmap decode $ simpleHttp $
      &quot;http://rate-exchange.appspot.com/currency?from=&quot;
    ++ from ++ &quot;&amp;to=&quot; ++ to ++ &quot;&amp;q=&quot; ++ show q

-- | Convert a monetary value from one currency to another.
convert :: Double -- ^ Initial quantity.
        -&gt; String -- ^ Initial currency.
        -&gt; String -- ^ Target currency.
        -&gt; IO (Maybe Double) -- ^ Result.
convert q from to = fmap (fmap v) $ getConversion from to q

-- | As an example, we show the conversion from euros to dollars.
--   However, feel free to change the initial quantity q and the
--   origin/target currencies.
main :: IO ()
main = do
  let q = 1
  mr &lt;- convert q &quot;EUR&quot; &quot;USD&quot;
  case mr of
   -- In case of error parsing the JSON data, we report it.
   Nothing -&gt; putStrLn &quot;There was an error reading the JSON data.&quot;
   -- Otherwise, we show the results in a human-readable way.
   Just r  -&gt; putStrLn $ show q ++ &quot; euro(s) is equivalent to &quot; ++ show r ++ &quot; dollar(s).&quot;</code></pre><h1 id="further-application--reading-twitter-timelines"><a href="#further-application--reading-twitter-timelines">Further application: Reading Twitter timelines</a></h1><p>Twitter query results use the JSON format. Therefore, we can ask the Twitter API
for the last statuses of a given profile and parse the response in the way we
described above. Interestingly, the main issue here is to get the response, since
Twitter ask us to authenticate using OAuth every single HTTP header. Fortunately,
the package <code>authenticate-oauth</code> is in Hackage to help us.</p><h2 id="step-1--register-your-application-in-twitter"><a href="#step-1--register-your-application-in-twitter">Step 1: Register your application in Twitter</a></h2><p>This is a prerequisite to authenticate our queries from version 1.1 of the Twitter
REST API. If you already have a Twitter account, it will be very easy. Just go to
<a href="https://dev.twitter.com/apps">https://dev.twitter.com/apps</a> and create a new application.
It will automatically create a <i>read only</i> application with a <i>consumer key</i> and a
<i>consumer secret</i>. You will also need to generate an <i>access token</i> and an
<i>access token secret</i>. Once you have these tokens, you are ready to create your
Twitter application.</p><h2 id="step-2--create-your-oauth-and-credential-values"><a href="#step-2--create-your-oauth-and-credential-values">Step 2: Create your <code>OAuth</code> and <code>Credential</code> values</a></h2><p>We now group together our keys using the <code>authenticate-oauth</code> package. Particularly, using
the <code>OAuth</code> and <code>Credential</code> types.</p><pre><code class="haskell">import Web.Authenticate.OAuth

myoauth :: OAuth
myoauth =
  newOAuth { oauthServerName     = &quot;api.twitter.com&quot;
           , oauthConsumerKey    = &quot;your consumer key here&quot;
           , oauthConsumerSecret = &quot;your consumer secret here&quot;
             }

mycred :: Credential
mycred = newCredential &quot;your access token here&quot;
                       &quot;your access token secret here&quot;</code></pre><h2 id="step-3--define-a-type-for-tweets"><a href="#step-3--define-a-type-for-tweets">Step 3: Define a type for tweets</a></h2><p>As we before parsed the JSON data to a list of <code>Person</code> type values, we need
to define a type for each tweet (naturally named <code>Tweet</code>). When requesting
the timeline statuses of a Twitter profile, the response JSON will contain a
list of tweets. It is our job to select the information we want from each tweet,
and to define a type to store them in Haskell. Depending on your needs, you
will include different fields in the <code>Tweet</code> type. I have included only the
<code>text</code> and <code>created_at</code> fields to keep the example simple.</p><pre><code class="haskell">import Data.Text (Text)
import Data.Time.Clock (UTCTime)
import Data.Aeson
import GHC.Generics

data Tweet =
  Tweet { text :: !Text
        , created_at :: !UTCTime
          } deriving (Show, Generic)

instance FromJSON Tweet
instance ToJSON Tweet</code></pre><p>The nice thing here is that, when parsing the JSON data, our parser will ignore
the fields we didn't define in our type.</p><h2 id="step-4--timeline-request-and-parsing"><a href="#step-4--timeline-request-and-parsing">Step 4: Timeline request and parsing</a></h2><p>We are going to check for the five latest uploaded packages to Hackage using the
<a href="https://twitter.com/Hackage">Hackage twitter</a>. The URL we make the request
to is <code>https://api.twitter.com/1.1/statuses/user_timeline.json?screen_name=Hackage</code>.
You can see more info about this request
<a href="https://dev.twitter.com/docs/api/1.1/get/statuses/user_timeline">here</a>.
Using the <code>Network.HTTP.Conduit</code> interface, we send the GET HTTP request.</p><pre><code class="haskell">import Network.HTTP.Conduit

timeline :: String -- ^ Screen name of the user
         -&gt; IO (Either String [Tweet]) -- ^ If there is any error parsing the JSON data, it
                                       --   will return 'Left String', where the 'String'
                                       --   contains the error information.
timeline name = do
  -- Firstly, we create a HTTP request with method GET (it is the default so we don't have to change that).
  req &lt;- parseUrl $ &quot;https://api.twitter.com/1.1/statuses/user_timeline.json?screen_name=&quot; ++ name
  -- Using a HTTP manager, we authenticate the request and send it to get a response.
  res &lt;- withManager $ \m -&gt; do
           -- OAuth Authentication.
           signedreq &lt;- signOAuth myoauth mycred req
           -- Send request.
           httpLbs signedreq m
  -- Decode the response body.
  return $ decodeEither $ responseBody res</code></pre><p>The function we have created reads the timeline of any user who shares his/her timeline publicly.
Now we read the timeline from Hackage and restrict the result to the last five tweets.</p><pre><code class="haskell">main :: IO ()
main = do
  -- Read the timeline from Hackage user.
  ets &lt;- timeline &quot;Hackage&quot;
  case ets of
   -- When the parsing of the JSON data fails, we report it.
   Left err -&gt; putStrLn err
   -- When successful, print in the screen the first 5 tweets.
   Right ts  -&gt; mapM_ print $ take 5 ts</code></pre><h2 id="putting-everything-together"><a href="#putting-everything-together">Putting everything together</a></h2><p>Here is an editable version of the code above, that will allow you to read any Twitter timeline,
using Haskell and our JSON parsing techniques. We have learnt that the JSON data can come from
very different sources, but the process of parsing it is always similar. Define a type corresponding
to the JSON data you are reading (or even a subset of it), and use <code>decode</code> or <code>decodeEither</code> to
transform the JSON input to Haskell values you can handle.</p><pre><code class="active haskell">{-# LANGUAGE OverloadedStrings, DeriveGeneric #-}

import Data.ByteString (ByteString)
import Network.HTTP.Conduit
import Web.Authenticate.OAuth
import Data.Aeson
import Data.Time.Clock (UTCTime)
import Data.Text (Text)
import GHC.Generics

-- Insert here your own credentials

myoauth :: OAuth
myoauth =
  newOAuth { oauthServerName     = &quot;api.twitter.com&quot;
           , oauthConsumerKey    = &quot;your consumer key here&quot;
           , oauthConsumerSecret = &quot;your consumer secret here&quot;
             }

mycred :: Credential
mycred = newCredential &quot;your access token here&quot;
                       &quot;your access token secret here&quot;

-- | Type for tweets. Use only the fields you are interested in.
--   The parser will filter them. To see a list of available fields
--   see &lt;https://dev.twitter.com/docs/platform-objects/tweets&gt;.
data Tweet =
  Tweet { text :: !Text
        , created_at :: !UTCTime
          } deriving (Show, Generic)

instance FromJSON Tweet
instance ToJSON Tweet

-- | This function reads a timeline JSON and parse it using the 'Tweet' type.
timeline :: String -- ^ Screen name of the user
         -&gt; IO (Either String [Tweet]) -- ^ If there is any error parsing the JSON data, it
                                       --   will return 'Left String', where the 'String'
                                       --   contains the error information.
timeline name = do
  -- Firstly, we create a HTTP request with method GET (it is the default so we don't have to change that).
  req &lt;- parseUrl $ &quot;https://api.twitter.com/1.1/statuses/user_timeline.json?screen_name=&quot; ++ name
  -- Using a HTTP manager, we authenticate the request and send it to get a response.
  res &lt;- withManager $ \m -&gt; do
           -- OAuth Authentication. 'signOAuth' modifies the HTTP header adding the
           -- appropriate authentication.
           signedreq &lt;- signOAuth myoauth mycred req
           -- Send request.
           httpLbs signedreq m
  -- Decode the response body.
  return $ eitherDecode $ responseBody res

-- | The main function, as an example of how to use the 'timeline'
--   function.
main :: IO ()
main = do
  -- Read the timeline from Hackage user. Feel free to change the screen
  -- name to any other.
  ets &lt;- timeline &quot;Hackage&quot;
  case ets of
   -- When the parsing of the JSON data fails, we report it.
   Left err -&gt; putStrLn err
   -- When successful, print in the screen the first 5 tweets.
   Right ts  -&gt; mapM_ print $ take 5 ts</code></pre><h1 id="conclusion"><a href="#conclusion">Conclusion</a></h1><p>We have seen how to use <code>aeson</code> to easily parse JSON data, and some examples where we apply this
knowledge. Currently, there are thousands of websites using the JSON format, so you can now think
how to use it in your particular case. The provided examples show the pattern to follow. We define
a datatype using record syntax and fields according to the JSON data. Then we obtain the desired JSON
from a local or remote source. We have seen that there are different approaches to access to sources,
mostly depending on the case. Finally we use <code>decode</code> or <code>decodeEither</code> to do the actual decoding. Haskell
is great at parsing. With little code, you can produce both <i>correct</i> and <i>fast</i> parsers.
The code is also easy to follow, and, as a consequence easy to change, giving
Efficiency in both development and execution.</p></article>

<div id="disqus_thread"><script>var disqus_shortname = "fpcomplete"; (function() { var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true; dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq); })();</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">comments powered by <span class="logo-disqus">Disqus</span></a></a>
</div>

</div>
</div>
<div class="row article-footer"><div class="span7 meta"><span class="sociallinksunicode social">
<a href="https://twitter.com/home?status=$url$" target="_blank"><i class="icon-twitter"></i></a>&nbsp;
<a href="http://www.facebook.com/sharer/sharer.php?u=$url$" target="_blank"><i class="icon-facebook"></i></a>&nbsp;
<a href="https://plus.google.com/share?url=$url$" target="_blank"><i class="icon-google-plus"></i></a></span>
</div>
</div>
</div>
<div class="footer"><div class="container"><div class="row"><div class="span12"><ul class="menu"><li><a href="https://www.schoolofhaskell.com/">School</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user">Users</a>
</li>

<li><a class="brand" href="https://fpcomplete.com">Sponsored by:
<img src="/static/img/logo.png" title="FPComplete">
</a>
</li>
</ul>
</div>
</div>
<div class="row"><div class="span12"></div>
</div>
</div>
</div>
<link rel="stylesheet" type="text/css" href="/static/bootstrap/css/bootstrap-responsive.css" />
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script><script src="https://www.schoolofhaskell.com/static/combined/Y-3k9_tW.js"></script><script>$(function(){
  $("a.logout").click(function(){
    var form = $("<form method='post'/>");
    form.attr("action", $(this).attr("href"));
    $("body").append(form);
    form.submit();
    return false;
  });
});

$(function(){
    $('.sociallinksunicode a').each(function(){
        $(this).attr('href',$(this).attr('href').replace('$url$',document.location));
    });
});

$(function(){
  // If we need to select a user/select a password then show the
  // details confirmation form, otherwise enable the getting started
  // section.
  if($('.alert-block a').text().match(/(selected a username|change your password)/)) {
    $("#confirm-details").show();
    $("#confirm-details #inputUsername").focus();
  } else {
    $("#get-started").removeClass('disabled').addClass('enabled');
  }

  // For lack of a plain HTML validation story this will do.
  $('.welcome-page').each(function(){
    $('form').submit(check);
  });
  function check(){
    setTimeout(check,500);
    var error = false;
    $('.error').removeClass('error');
    $('#enter-details input').each(function(){
      if($(this).val() == '') {
        $(this).parent().parent().addClass('error');
        error = true;
      }
    });
    if(error) return false;
    if($('[name=password]').val() == $('[name=confirm]').val()) {
      $('#confirm').removeClass('error');
      return true;
    } else {
      $('#confirm').addClass('error');
      return false;
    }
  }
});

$(function(){
  // When scrolling over a snippet editor, activate the "clone in IDE" popovers
  $('article').each(function(){
    var n = 100;
    var wait = 10000;
    function check(){
      if($('.clone').length == 0) {
        setTimeout(check,n);
        return;
      }
      var activated = $.cookie('clone-popover');
      if (activated) return;
      var activate = false;
      $('.controlsRun:onScreen').each(function(){
        $.cookie('clone-popover', 'true', { expires: 30, path: '/' });
        activate = true;
        return false;
      });
      if(activate) {
          $('.clone').each(function(){
              // The bootstrap API is rather unreasonable to say the
              // least.
              next = $(this).parent();
              var title = next.attr('title');
              next.attr('data-content',$(this).attr('data-content'));
              next.attr('title',$(this).attr('title'));
              next.popover('show',{
                  title: $(this).attr('title')
              });
              next.attr('title',title);
          });
          setTimeout(function(){
              $('.clone').each(function(){
                  $(this).parent().popover('hide');
              });
          },wait);
      } else {
        setTimeout(check,n);
      }
    }
    setTimeout(check,n);
  });
});

// onScreen jQuery plugin v0.2.1
// (c) 2011-2013 Ben Pickles
//
// http://benpickles.github.com/onScreen
//
// Released under MIT license.
(function(a){a.expr[":"].onScreen=function(b){var c=a(window),d=c.scrollTop(),e=c.height(),f=d+e,g=a(b),h=g.offset().top,i=g.height(),j=h+i;return h>=d&&h<f||j>d&&j<=f||i>e&&h<=d&&j>=f}})(jQuery);

/*!
 * jQuery Cookie Plugin v1.1
 * https://github.com/carhartl/jquery-cookie
 *
 * Copyright 2011, Klaus Hartl
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.opensource.org/licenses/GPL-2.0
 */
(function($, document) {

  var pluses = /\+/g;
  function raw(s) {
    return s;
  }
  function decoded(s) {
    return decodeURIComponent(s.replace(pluses, ' '));
  }

  $.cookie = function(key, value, options) {

    // key and at least value given, set cookie...
    if (arguments.length > 1 && (!/Object/.test(Object.prototype.toString.call(value)) || value == null)) {
      options = $.extend({}, $.cookie.defaults, options);

      if (value == null) {
	options.expires = -1;
      }

      if (typeof options.expires === 'number') {
	var days = options.expires, t = options.expires = new Date();
	t.setDate(t.getDate() + days);
      }

      value = String(value);

      return (document.cookie = [
	encodeURIComponent(key), '=', options.raw ? value : encodeURIComponent(value),
	options.expires ? '; expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE
	options.path    ? '; path=' + options.path : '',
	options.domain  ? '; domain=' + options.domain : '',
	options.secure  ? '; secure' : ''
      ].join(''));
    }

    // key and possibly options given, get cookie...
    options = value || $.cookie.defaults || {};
    var decode = options.raw ? raw : decoded;
    var cookies = document.cookie.split('; ');
    for (var i = 0, parts; (parts = cookies[i] && cookies[i].split('=')); i++) {
      if (decode(parts.shift()) === key) {
	return decode(parts.join('='));
      }
    }
    return null;
  };
  $.cookie.defaults = {};})(jQuery, document);
</script><!--[if lt IE 10]><script src="https://www.schoolofhaskell.com/static/design/js/ie.js?etag=ayV2DuJ0"></script><![endif]--><script>if(!window.location.href.match(/localhost/)){var track = '/tutorial/school/starting-with-haskell/libraries-and-frameworks/text-manipulation/json';
window._gaq = [['_setAccount','UA-36928035-1'],track != ''? ['_trackPageview',track] : ['_trackPageview']
,['_trackPageLoadTime']];window._gaq.push(['_setCustomVar',1,'Section','School of Haskell',3]);
window._gaq.push(['_setCustomVar',2,'User Type','Visitor',1]);
(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);

})();}</script>
<!-- Prompt IE 6 users to install Chrome Frame. Remove this if you want to support IE 6.  chromium.org/developers/how-tos/chrome-frame-getting-started --><!--[if lt IE 7 ]><script src="//ajax.googleapis.com/ajax/libs/chrome-frame/1.0.3/CFInstall.min.js"></script><script>window.attachEvent('onload',function(){CFInstall.check({mode:'overlay'})})</script><![endif]--></body></html>