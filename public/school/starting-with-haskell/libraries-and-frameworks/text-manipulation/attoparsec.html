<!DOCTYPE html>
<html><head><title>Parsing Log FIles in Haskell - School of Haskell | School of Haskell</title><meta http-equiv="x-ua-compatible" content="IE=9"><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="google-site-verification" content="Rfxk2TdeMMXEXHgJ2_OO8Rt3hPbQSDao0OXQV_n6z_s" /><link href="//fonts.googleapis.com/css?family=Merriweather" rel="stylesheet" type="text/css"><link href="https://www.schoolofhaskell.com/recent-content/feed" type="application/rss+xml" rel="alternate" title="Recently published content">
<link rel="stylesheet" href="https://www.schoolofhaskell.com/static/combined/UlwEHVcM.css"><style>.social{margin-right:1em}h1{font-family:Merriweather !important}article{font-family:Merriweather !important}article li{font-family:Merriweather !important;line-height:1.6em}h1,h2,h3,h4,h4,h5{font-family:Merriweather !important}.editor p{font-family:Frutiger, "Frutiger Linotype", Univers, Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans Condensed", "Liberation Sans", "Nimbus Sans L", Tahoma, Geneva, "Helvetica Neue", Helvetica, Arial, sans-serif}.article-footer{border-top:1px solid #ddd;padding-top:1em;margin-top:1em}body{font-size:16px !important}.navbar .navbar-inner{background:#3c3f41}.navbar .brand{font-size:14px}.navbar .brand img{width:6em}.navbar .icon-wrench{margin:0 -0.5em 0 -0.5em;padding:0 1em 0 1em;height:20px}.navbar-inverse .nav .active a{background:#333638}.navbar-inverse .nav > li > a{color:#a7a7a7
}.navbar-inverse .btn-navbar{background:#333638}.navbar-inverse .nav > li a:hover,.navbar-inverse .btn{background:#333537 !important}@media (max-width: 979px) {.icon-wrench{padding-left:1em !important}}.breadcrumb{border-top-left-radius:0;border-top-right-radius:0}h1{margin-top:20px}.breadcrumb-container + .main-content h1{margin-top:0}.footer{padding:30px 0;margin-top:70px;border-top:1px solid #e5e5e5;background-color:#f5f5f5}.footer ul.footer-menu{list-style-type:none}.footer ul.footer-menu li{display:inline-block}.footer ul.footer-menu li + li{margin-left:0.5em}.footer ul.footer-menu li + li:before{margin-right:0.5em;content:"Â·";color:#999}.footer ul.menu li{display:inline-block}.footer ul.menu li + li{margin-left:0.5em}.footer .copyright{margin-left:25px}.main-content{min-height:100%}.gravatar{width:80px;height:80px;border-radius:2px;background:#eee}.empty-gravatar{width:0}.container{font-family:"Segoe UI", Candara, "Bitstream Vera Sans", "DejaVu Sans", "Bitstream Vera Sans", "Trebuchet MS", Verdana, "Verdana Ref", sans-serif}.container h1,.container h2,.container h4,.container h4,.container h5{font-family:"Segoe UI", Candara, "Bitstream Vera Sans", "DejaVu Sans", "Bitstream Vera Sans", "Trebuchet MS", Verdana, "Verdana Ref", sans-serif}article{font-family:Merriweather !important}article h1{font-family:Merriweather !important}article li{font-family:Merriweather !important;line-height:1.6em}article li + li{margin-top:0.5em}article div.code{background:#f9f9f9;border:1px solid #d1d1d1;position:relative;border-radius:0.2em;margin:0.25em 0 0.75em 0;min-height:2.5em}article code{color:#005580;font-size:14px;white-space:pre}article a.hoogle > code{color:#0088cc;font-size:14px;white-space:pre;border:0}article .expand-code{display:none}article pre{overflow:auto;word-wrap:normal}article code.active{display:block;max-height:430px}article h1{font-size:31.5px}article h3{font-size:17.5px}article h4{font-size:14px}article h5,article h6{font-size:11.9px}article p{line-height:1.7em}article h1 code,article h2 code,article h3 code,article h4 code,article h5 code,article h6 code{font-size:inherit !important}article h1 a,article h2 a,article h3 a,article h4 a,article h5 a,article h6 a{color:#444}article h1 a:before,article h2 a:before,article h3 a:before,article h4 a:before,article h5 a:before,article h6 a:before{margin-left:-1.5em;padding-right:0.5em;font-family:fontawesome;content:"\f0c1";font-size:20px;color:#fff}article h1 a:hover,article h2 a:hover,article h3 a:hover,article h4 a:hover,article h5 a:hover,article h6 a:hover{text-decoration:none;color:#0088cc}article h1 a:hover:before,article h2 a:hover:before,article h3 a:hover:before,article h4 a:hover:before,article h5 a:hover:before,article h6 a:hover:before{color:#888}article h2{font-size:24.5px}article .popover{font-family:actor}article .popover h3.popover-title{font-family:actor !important;font-size:1em}article .popover .popover-content{width:15em;font-size:1em}article .controlsRun{display:block;padding:0.5em;text-align:right;background:#f2f2f2}article .controlsRun a.clone{margin-right:1em;font-family:actor;text-decoration:none}article .controlsRun a.clone span{padding-left:0.5em}article .controlsRun a.run,article .controlsRun a.reset,article .controlsRun a.show-code{font-size:16px}article .controlsRun a.run span,article .controlsRun a.reset span,article .controlsRun a.show-code span{display:none}article .controlsRun a.reset{margin-left:0.5em;color:#a2becc}article .controlsRun a.reset{display:none}article .controlsRun a.show-code{margin-right:0.75em}article .controlsRun a.run:hover,article .controlsRun a.show-code:hover{text-decoration:none}article .controlsRun a.show-code.active{color:#DC0D0D}article .controlsRun a[disabled]{color:#a2becc;cursor:default}article .collapse-area .collapse-header{background:#0088cc;color:#fff;padding:0.3em;cursor:pointer}article .collapse-area .hidden-toggle:before{content:"\f0d7";font-family:fontawesome;margin-right:0.5em;margin-left:0.25em}article .collapse-area .collapsed-files{overflow:auto;height:auto}article .collapse-area.collapse-disabled{display:none}article .collapse-area.collapse-area-off .collapsed-files{height:0px;overflow:hidden}article .collapse-area.collapse-area-off .hidden-toggle:before{content:"\f0da"}article .snippet-stdio .stdout{margin:0.5em;padding-right:2em;position:relative;word-wrap:break-word}article .snippet-stdio .stdin{-webkit-box-shadow:none;-moz-box-shadow:none;box-shadow:none;-webkit-transition:none;-moz-transition:none;-o-transition:none;transition:none;padding:0;margin:0}article .hoogle-results{margin:0.25em}article .hoogle-results .hoogle-inner{background:#fff;padding:0.5em;border-radius:3px;border:1px solid #ddd}article .hoogle-results .hoogle-inner .close-link{position:relative;float:right;margin-top:-0.5em;margin-right:-0.5em}article .snippet-output-errors{margin:1em 0.5em 0.5em 0.5em;position:relative}article .snippet-output-errors ul{list-style-type:none;margin:0;position:relative}article .snippet-output-errors pre{border:0;border-radius:0;padding:0.25em;margin:0;background:inherit;color:inherit}article .snippet-output-errors .close-link{color:inherit;background:inherit}article .snippet-editors{z-index:0;padding:0.25em}article .close-link{padding:0.5em;background:#eaeaea;border-bottom-left-radius:0.2em;border-top-right-radius:0.2em;position:absolute;top:0;right:0}article .close-link:hover{text-decoration:none}article .snippet-title{padding:0.5em 0 0 0.5em}article .snippet-title .snippet-icon{font-family:FontAwesome;display:inline-block;margin-right:0.5em}article .fullModuleCode + div .snippet-title{margin-top:0.5em;border-top:1px solid #ccc;padding-top:0.5em}article .CodeMirror{height:auto;min-height:1em;line-height:1.5em;background:transparent;font-size:14px !important}article .CodeMirror .highlighted{background:rgba(250, 210, 0, 0.45) !important}article .CodeMirror-widget{margin-left:2em;line-height:1.8}article .CodeMirror.collapsed{height:10em !important}article .editor .expander{text-align:center;display:block;padding:0.5em;text-decoration:none;border-bottom-left-radius:2px;border-bottom-right-radius:2px}article .editor .expander .ellipsis{background:white;border:1px solid #ccc;padding:0 0.5em;height:1em;line-height:0.5em;display:inline-block;color:#555;cursor:pointer}article .editor .expander .ellipsis:hover{background:#ddd;color:#333}article .web-runner{margin:0.5em;padding:0.5em;border:1px solid #ccc;border-radius:3px;background:#f5f5f5}article .web-runner iframe{border:0;margin-top:0.5em;margin-bottom:0;background:white}article .web-runner .controls i{cursor:pointer;color:#0088cc}article .web-runner .controls i:hover{color:#222}article .web-runner .controls i + i{margin-left:0.5em}article .web-runner .controls .icon-remove{float:right}article .hidden{display:block;visibility:visible}article .controlsShowHide{margin-bottom:0.5em}.tutorial-body{float:left !important}.tutorial-nav{float:right !important}@media (max-width: 979px) {.related-content{float:right}.author-name{display:block;margin-left:20px !important;padding-left:5px;margin-top:5px}article h1 a:hover:before,article h2 a:hover:before,article h3 a:hover:before,article h4 a:hover:before,article h5 a:hover:before,article h6 a:hover:before{color:#fff}.tutorial-nav{float:none !important;width:auto !important}.tutorial-body{float:none !important;width:auto !important}}@media (min-width: 980px) and (max-width: 1199px) {.navbar-search{display:none}.tutorial-nav{width:200px}.tutorial-body{width:720px}}#accountPage h1{margin:20px 0 0 0}#accountPage h2{font-size:20px}.group-contents .span8{float:left}.group-contents .span4{float:right}.container > .alert-block{margin-top:1em}.alert{color:#aa874a
}.social{margin-bottom:.8em;display:block}.social a{text-decoration:none}.social i{font-size:1.1em;color:#fff;padding:0.25em;border-radius:0.25em;width:1em;display:inline-block;text-align:center}.social i.icon-twitter{background:#0088cc}.social i.icon-facebook{background:#3b5998
  }.social i.icon-google-plus{background:#dd4b39
  }.well pre{background:#fcfcfc}.well h2{margin-top:0}code{color:#005580;font-size:14px;white-space:pre}</style><!--[if lt IE 8]><link rel="stylesheet" href="https://www.schoolofhaskell.com/static/design/css/ie7.css?etag=TSMl9x1V"><![endif]--><!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]--></head><body class="not-logged-in" itemscope itemtype="http://schema.org/Product"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-H62P" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-H62P');</script><div class="navbar navbar-inverse navbar-static-top"><div class="navbar-inner"><div class="container"><a class="btn btn-navbar" type="button" data-toggle="collapse" data-target=".nav-collapse"><span class="icon-bar"></span>
<span class="icon-bar"></span>
<span class="icon-bar"></span>
</a>
<a class="brand" href="/"><img src="/static/img/haskell-logo-wide.png" title="School of Haskell">
</a>
<div class="nav-collapse collapse"><ul class="nav"><li><a href="https://www.schoolofhaskell.com/">School</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user">Users</a>
</li>
</ul>
<form class="navbar-search pull-left" action="https://www.schoolofhaskell.com/search"><input class="search-query" type="text" placeholder="Search" name="search">
</form>
</div>
</div>
</div>
</div>
<div class="container breadcrumb-container"><div class="row"><div class="span12"><ul class="breadcrumb"><li><a href="https://www.schoolofhaskell.com/">School of Haskell</a>
<span class="divider">/</span>
</li>
<li><a href="https://www.schoolofhaskell.com/school/starting-with-haskell">Starting with Haskell</a>
<span class="divider">/</span>
</li>
<li><a href="https://www.schoolofhaskell.com/school/starting-with-haskell/libraries-and-frameworks">Libraries and Frameworks</a>
<span class="divider">/</span>
</li>
<li><a href="https://www.schoolofhaskell.com/school/starting-with-haskell/libraries-and-frameworks/text-manipulation">Text manipulation</a>
<span class="divider">/</span>
</li>
<li><a href="https://www.schoolofhaskell.com/school/starting-with-haskell/libraries-and-frameworks/text-manipulation/attoparsec">Parsing Log FIles in Haskell</a>
</li>
</ul>
</div>
</div>
</div>
<div class="container main-content"><div class="row"><div class="span12"><h1 itemprop="name">Parsing Log FIles in Haskell</h1>
</div>
</div>
<div class="row"><div class="span7 meta"><p><span class="date"> 1 Feb 2015</span>
<span class="author"><a href="https://www.schoolofhaskell.com/user/school">School of Haskell</a>
</span>
<span class="view-edit-link pull-right"><a class="view-source-link" href="https://www.schoolofhaskell.com/tutorial-raw/30/b95b0cd30cf07bb2dacd89361a1d87fa00093c75">View Markdown source</a>
</span>
</p>
<p class="tags"></p>
</div>
</div>
<div class="row"><div class="span7 meta"><span class="sociallinksunicode social">
<a href="https://twitter.com/home?status=$url$" target="_blank"><i class="icon-twitter"></i></a>&nbsp;
<a href="http://www.facebook.com/sharer/sharer.php?u=$url$" target="_blank"><i class="icon-facebook"></i></a>&nbsp;
<a href="https://plus.google.com/share?url=$url$" target="_blank"><i class="icon-google-plus"></i></a></span>
</div>
</div>
<p class="alert">As of March 2020, School of Haskell has been switched to read-only mode.</p>
<div class="row" itemprop="desc"><div class="span4 tutorial-nav"><div class="related-content"><ul class="nav nav-tabs nav-stacked"><li><script>reddit_target='fpcomplete'</script>
<script src="https://redditstatic.s3.amazonaws.com/button/button1.js"></script>
</li>
<li><a href="https://www.schoolofhaskell.com/user/school/starting-with-haskell/libraries-and-frameworks/text-manipulation/tagsoup">Previous content: HTML Parsing</a>
</li>
<li><a href="https://www.schoolofhaskell.com/school/starting-with-haskell/libraries-and-frameworks/text-manipulation">Go up to: Text manipulation</a>
</li>
</ul>

</div>
<div class="aside"><h3>Sections</h3>
<ul><li><a href="#introduction">Introduction</a></li><li><a href="#writing-a-parser">Writing a parser</a></li><li><a href="#parsing-logs">Parsing logs</a><ul><li><a href="#step-1--define-types">Step 1: Define types</a></li><li><a href="#step-2--follow-the-syntax">Step 2: Follow the syntax</a></li><li><a href="#parsing-alternatives">Parsing alternatives</a></li><li><a href="#step-3--combine-small-parsers-to-build-a-bigger-one">Step 3: Combine small parsers to build a bigger one</a></li><li><a href="#full-log-file-parser">Full log file parser</a></li><li><a href="#changes-in-the-log">Changes in the log</a><ul><li><a href="#making-the-changed-parser-compatible-with-the-old-format">Making the changed parser compatible with the old format</a></li></ul></li><li><a href="#merging-data-from-different-logs">Merging data from different logs</a><ul><li><a href="#step-1--write-the-new-parser">Step 1: Write the new parser</a></li><li><a href="#step-2--merge-both-logs-conserving-order">Step 2: Merge both logs conserving order</a></li></ul></li><li><a href="#extracting-information-from-the-log-file">Extracting information from the log file</a></li></ul></li><li><a href="#from-log-file-to-csv">From log file to CSV</a><ul><li><a href="#rendering-to-csv">Rendering to CSV</a></li><li><a href="#parsing-from-csv">Parsing from CSV</a></li><li><a href="#using-csv-across-applications">Using CSV across applications</a></li></ul></li><li><a href="#final-app--read-several-log-files--merge-data-and-render-it-in-csv">Final App: Read several log files, merge data and render it in CSV</a></li><li><a href="#conclusion">Conclusion</a></li></ul></div>
</div>
<div class="span8 tutorial-body" data-environment="ghc-7.8-stable-14.09">
<article><h1 id="introduction"><a href="#introduction">Introduction</a></h1><p>In this tutorial you will learn how to parse log-like files and how to
render a log to a file. Many applications use logs to keep track of some
useful information to be analysed later on. Parsing a log-like file it
is an easy parsing task in comparison with parsing, say, a programming
language, but it is an useful practice for a Haskell parser beginner.
Most of the code in this tutorial is editable and runnable, so take
advantage and experiment with the code yourself.</p><p>While log files do not have a specific format, we are going to output
them as CSV tables. An specification of CSV can be found in the
<a href="http://tools.ietf.org/html/rfc4180">RFC 4180</a>.</p><p>Among the many parser libraries in Haskell we have chosen
<a href="http://hackage.haskell.org/package/attoparsec"><i>attoparsec</i></a>
in this tutorial. Why? Firstly, because it is easy to use and secondly
because it is fast. The other popular choice is
<a href="http://hackage.haskell.org/package/parsec"><i>parsec</i></a>.
<i>Parsec</i> has a similar interface to <i>attoparsec</i>, but share also some differences.
For example, a parser in <i>parsec</i> can be used as a monad transformer, allowing
you to add custom states. Also, when a parsing error arises, <i>parsec</i>
gives you a lot more information than <i>attoparsec</i>. The lack of these
features in <i>attoparsec</i> is precisely what makes it faster.</p><h1 id="writing-a-parser"><a href="#writing-a-parser">Writing a parser</a></h1><p>Writing a parser involves <i>teaching</i> our computer how to read something.
If a human see the string <code>&quot;25&quot;</code> it will quickly concludes that the string
contains a number. In fact, probably you read it as &quot;twenty five&quot; instead of
&quot;two five&quot;. However, for the computer it is just a string of characters.
In Haskell, we would have to write a function from <code>String</code> (or <code>Text</code> or <code>ByteString</code>,
depending on the input type) to <code>Integer</code> in order to use it as a number.
This is what parsing means. But, how we accomplish such task?
Well, say that an application has sent to us the following <code>ByteString</code>:</p><pre><code class="haskell">&quot;131.45.68.123&quot;</code></pre><p>It is the IP of a user that just connected to our server! In our code,
we have the following type definition:</p><pre><code class="haskell">import Data.Word

data IP = IP Word8 Word8 Word8 Word8 deriving Show</code></pre><p>It is a type we defined for IP's. The <code>Word8</code> type represents 8-bit unsigned integer values.
Now it would be great if we could parse the input <code>131.45.68.123</code> to the value
<code>IP 131 45 68 123</code>. The first thing we look is how IP's are written. They follow this pattern:</p><ul><li>An 8-bit integer.</li><li>A <i>dot</i>.</li><li>An 8-bit integer.</li><li>A <i>dot</i>.</li><li>An 8-bit integer.</li><li>A <i>dot</i>.</li><li>An 8-bit integer.</li></ul><p>When we write a parser in Haskell, what we actually do is following the pattern of the input format
from left to right. In this case, the function <code>parseIP</code> defines a parser for our type <code>IP</code> following
the pattern we just described. Note that the <code>decimal</code> parser succeeds for any unsigned integral number
(<code>Word8</code> in this example).</p><pre><code class="active haskell">{-# LANGUAGE OverloadedStrings #-}

-- This attoparsec module is intended for parsing text that is
-- represented using an 8-bit character set, e.g. ASCII or ISO-8859-15.
import Data.Attoparsec.Char8
import Data.Word

-- | Type for IP's.
data IP = IP Word8 Word8 Word8 Word8 deriving Show

parseIP :: Parser IP
parseIP = do
  d1 &lt;- decimal
  char '.'
  d2 &lt;- decimal
  char '.'
  d3 &lt;- decimal
  char '.'
  d4 &lt;- decimal
  return $ IP d1 d2 d3 d4

main :: IO ()
main = print $ parseOnly parseIP &quot;131.45.68.123&quot;</code></pre><p>Note that the output of <code>parseOnly</code>, the function that applies the parser
<code>parseIP</code> to the input <code>&quot;131.45.68.123&quot;</code> returns a value of type
<code>Either String IP</code>. This is because parsing is not a <i>total</i> function, meaning
that not every input has an output. For example, parsing the string
<code>&quot;foo&quot;</code> cannot result in any IP. As a consequence, the parser fails.
Each time the parser fails, it will return <code>Left str</code>, where <code>str</code>
is a value of type <code>String</code> describing the error (in <i>attoparsec</i>, not
very descriptive actually). If the parser ends successfuly, it will
return <code>Right x</code>, where <code>x</code> is the parsed value.</p><p>As you can see, the approach to define a parser is to use simpler parsers
and combine them write parsers for more complex expressions. In the following
example, you will see how to parse a log file, including IP's. We will re-use
the recently created parser.</p><h1 id="parsing-logs"><a href="#parsing-logs">Parsing logs</a></h1><p>In this section, we develop a parser for log files that mixes content of
different types. We use an example to guide the process.</p><h2 id="step-1--define-types"><a href="#step-1--define-types">Step 1: Define types</a></h2><p>Say we have an online shop where we sell computer items
like mouses, keyboards, monitors and speakers. Each time a product is sold,
our application saves some information in a log file, containing the time
when the product was sold, the IP of the client and the name of the product.
Each log entry may be represented by the following type:</p><pre><code class="haskell">import Data.Time

data Product = Mouse | Keyboard | Monitor | Speakers deriving Show

data LogEntry =
  LogEntry { -- A local time contains the date and the time of the day.
             -- For example: 2013-06-29 11:16:23.
             entryTime :: LocalTime
           , entryIP   :: IP
           , entryProduct   :: Product
             } deriving Show</code></pre><p>The log file will therefore contain a list of elements of type <code>LogEntry</code>.</p><pre><code class="haskell">-- | Type synonym of a list of log entries.
type Log = [LogEntry]</code></pre><h2 id="step-2--follow-the-syntax"><a href="#step-2--follow-the-syntax">Step 2: Follow the syntax</a></h2><p>The log file, or anything that we can parse, follows a specific syntax.
For example, here is our today log:</p><pre><code>2013-06-29 11:16:23 124.67.34.60 keyboard
2013-06-29 11:32:12 212.141.23.67 mouse
2013-06-29 11:33:08 212.141.23.67 monitor
2013-06-29 12:12:34 125.80.32.31 speakers
2013-06-29 12:51:50 101.40.50.62 keyboard
2013-06-29 13:10:45 103.29.60.13 mouse</code></pre><p>Each line contains a log entry. The idea is to write a parser for log entries,
and iterate it line by line to get the list of every log entry.
The elements contained in each entry would be of type <code>LocalTime</code>, <code>IP</code> and
<code>Product</code>. We have to write parsers for each one and combine them.
Fortunately, we already have a parser for IP's that we can re-use.
Let's write a parser for the time stamps.</p><p>We notice that the format followed in our log is:</p><pre><code>yyyy-MM-dd hh:mm:ss</code></pre><p>Following this specification, we can easily write the parser as follows.</p><pre><code class="active haskell">{-# LANGUAGE OverloadedStrings #-}

import Data.Time
import Data.Attoparsec.Char8

timeParser :: Parser LocalTime
timeParser = do
  y  &lt;- count 4 digit
  char '-'
  mm &lt;- count 2 digit
  char '-'
  d  &lt;- count 2 digit
  char ' '
  h  &lt;- count 2 digit
  char ':'
  m  &lt;- count 2 digit
  char ':'
  s  &lt;- count 2 digit
  return $
    LocalTime { localDay = fromGregorian (read y) (read mm) (read d)
              , localTimeOfDay = TimeOfDay (read h) (read m) (read s)
                }

main :: IO ()
main = print $ parseOnly timeParser &quot;2013-06-30 14:33:29&quot;</code></pre><p>Note the use of <code>count</code> and <code>digit</code>. The parser <code>digit</code> will get the
following character, in case that this character is a digit, and will fail otherwise.
The combinator <code>count</code> repeats a parser a certain number of times. Since in our format,
a year is written with 4 characters, we use <code>count 4 digit</code> meaning <i>read 4 digits from the input</i>.
The same rationale applies to the rest of the code. At the end, we return a value of type
<code>LocalTime</code>.</p><h2 id="parsing-alternatives"><a href="#parsing-alternatives">Parsing alternatives</a></h2><p>Lastly, we need a parser for <code>Product</code> values. This one is even easier, but it also have something
new. A product is represented by a word. Each word is different, so there is no single syntax to
read. We have different choices. It is either <code>keyboard</code> or <code>mouse</code> or <code>monitor</code> or <code>speaker</code>.
This <i>or</i>, separating different alternatives, it is represented in attoparsec by the <code>&lt;|&gt;</code> combinator.
The <code>&lt;|&gt;</code> operator combines two parsers of the <i>same type</i> in one that first tries to use the first
argument parser. If this one ends without failure, it returns its result. If it fails, it tries with
the second one, returning any result it gives.
This would be the <code>Product</code> parser:</p><pre><code class="active haskell">{-# LANGUAGE OverloadedStrings #-}

import Data.Attoparsec.Char8
import Control.Applicative

data Product = Mouse | Keyboard | Monitor | Speakers deriving Show

productParser :: Parser Product
productParser =
     (string &quot;mouse&quot;    &gt;&gt; return Mouse)
 &lt;|&gt; (string &quot;keyboard&quot; &gt;&gt; return Keyboard)
 &lt;|&gt; (string &quot;monitor&quot;  &gt;&gt; return Monitor)
 &lt;|&gt; (string &quot;speakers&quot; &gt;&gt; return Speakers)

main :: IO ()
main = do
  print $ parseOnly productParser &quot;mouse&quot;
  print $ parseOnly productParser &quot;mouze&quot;
  print $ parseOnly productParser &quot;monitor&quot;
  print $ parseOnly productParser &quot;keyboard&quot;</code></pre><p>Note that we have to import the <code>Control.Applicative</code> module to use the <code>&lt;|&gt;</code> combinator.
Also note that when we try to parse <code>mouze</code> we get a cryptic error message (<i>not enough
bytes</i>) that does not say much about the parsing error. This is one trade-off of attoparsec
in order to get better performance than parsec. The API of parsec is very similar to the
one of attoparsec, but parsec reports much more information when a parsing error arises.</p><h2 id="step-3--combine-small-parsers-to-build-a-bigger-one"><a href="#step-3--combine-small-parsers-to-build-a-bigger-one">Step 3: Combine small parsers to build a bigger one</a></h2><p>It is time to combine our parsers into one that can read a whole log entry. We only have
to invoke them in order.</p><pre><code class="active haskell">{-# LANGUAGE OverloadedStrings #-}

import Data.Word
import Data.Time
import Data.Attoparsec.Char8
import Control.Applicative

-----------------------
-------- TYPES --------
-----------------------

-- | Type for IP's.
data IP = IP Word8 Word8 Word8 Word8 deriving Show

data Product = Mouse | Keyboard | Monitor | Speakers deriving Show

data LogEntry =
  LogEntry { entryTime :: LocalTime
           , entryIP   :: IP
           , entryProduct   :: Product
             } deriving Show

-----------------------
------- PARSING -------
-----------------------

-- | Parser of values of type 'IP'.
parseIP :: Parser IP
parseIP = do
  d1 &lt;- decimal
  char '.'
  d2 &lt;- decimal
  char '.'
  d3 &lt;- decimal
  char '.'
  d4 &lt;- decimal
  return $ IP d1 d2 d3 d4

-- | Parser of values of type 'LocalTime'.
timeParser :: Parser LocalTime
timeParser = do
  y  &lt;- count 4 digit
  char '-'
  mm &lt;- count 2 digit
  char '-'
  d  &lt;- count 2 digit
  char ' '
  h  &lt;- count 2 digit
  char ':'
  m  &lt;- count 2 digit
  char ':'
  s  &lt;- count 2 digit
  return $
    LocalTime { localDay = fromGregorian (read y) (read mm) (read d)
              , localTimeOfDay = TimeOfDay (read h) (read m) (read s)
                }

-- | Parser of values of type 'Product'.
productParser :: Parser Product
productParser =
     (string &quot;mouse&quot;    &gt;&gt; return Mouse)
 &lt;|&gt; (string &quot;keyboard&quot; &gt;&gt; return Keyboard)
 &lt;|&gt; (string &quot;monitor&quot;  &gt;&gt; return Monitor)
 &lt;|&gt; (string &quot;speakers&quot; &gt;&gt; return Speakers)
-- show
-- | Parser of log entries.
logEntryParser :: Parser LogEntry
logEntryParser = do
  -- First, we read the time.
  t &lt;- timeParser
  -- Followed by a space.
  char ' '
  -- And then the IP of the client.
  ip &lt;- parseIP
  -- Followed by another space.
  char ' '
  -- Finally, we read the type of product.
  p &lt;- productParser
  -- And we return the result as a value of type 'LogEntry'.
  return $ LogEntry t ip p

----------------------
-------- TEST --------
----------------------

main :: IO ()
main = print $ parseOnly logEntryParser &quot;2013-06-29 11:16:23 124.67.34.60 keyboard&quot;
-- /show</code></pre><p>In order to read the entire log file, we just need to iterate <code>logEntryParser</code> until
the end of the file is reached. The combinator <code>many</code> will perform a parser <i>zero</i>
or more times, returning a list of continuous successful parsings. It will stop whenever
the given parser fails. For example, <code>many digit</code> applied to the string <code>&quot;123abc&quot;</code> will
return <code>&quot;123&quot;</code> and will leave <code>&quot;abc&quot;</code> as remainding input. Also, <code>many digit</code> applied to
the string <code>&quot;abc&quot;</code> will return the empty list without consuming any input.</p><p>In conclusion, here is our log file parser.</p><pre><code class="haskell">type Log = [LogEntry]

logParser :: Parser Log
logParser = many $ logEntryParser &lt;* endOfLine</code></pre><p>The <code>endOfLine</code> parser succeeds only when the remaining input starts with an end
of line. The <code>&lt;*</code> combinator applies the parser from the left, then the parser from
the right, and then returns the result of the first parser. We use it to get the result
from <code>logEntryParser</code> instead of <code>endOfLine</code>, which returns <code>()</code>.</p><h2 id="full-log-file-parser"><a href="#full-log-file-parser">Full log file parser</a></h2><pre><code class="active haskell">{-# START_FILE sellings.log #-}
2013-06-29 11:16:23 124.67.34.60 keyboard
2013-06-29 11:32:12 212.141.23.67 mouse
2013-06-29 11:33:08 212.141.23.67 monitor
2013-06-29 12:12:34 125.80.32.31 speakers
2013-06-29 12:51:50 101.40.50.62 keyboard
2013-06-29 13:10:45 103.29.60.13 mouse

{-# START_FILE Main.hs #-}
{-# LANGUAGE OverloadedStrings #-}

import Data.Word
import Data.Time
import Data.Attoparsec.Char8
import Control.Applicative
-- We import ByteString qualified because the function
-- 'Data.ByteString.readFile' would clash with
-- 'Prelude.readFile'.
import qualified Data.ByteString as B

-----------------------
------ SETTINGS -------
-----------------------

-- | File where the log is stored.
logFile :: FilePath
logFile = &quot;sellings.log&quot;

-----------------------
-------- TYPES --------
-----------------------

-- | Type for IP's.
data IP = IP Word8 Word8 Word8 Word8 deriving Show

data Product = Mouse | Keyboard | Monitor | Speakers deriving Show

-- | Type for log entries.
--   Add, remove of modify fields to fit your own log file.
data LogEntry =
  LogEntry { entryTime :: LocalTime
           , entryIP   :: IP
           , entryProduct   :: Product
             } deriving Show

type Log = [LogEntry]

-----------------------
------- PARSING -------
-----------------------

-- | Parser of values of type 'IP'.
parseIP :: Parser IP
parseIP = do
  d1 &lt;- decimal
  char '.'
  d2 &lt;- decimal
  char '.'
  d3 &lt;- decimal
  char '.'
  d4 &lt;- decimal
  return $ IP d1 d2 d3 d4

-- | Parser of values of type 'LocalTime'.
timeParser :: Parser LocalTime
timeParser = do
  y  &lt;- count 4 digit
  char '-'
  mm &lt;- count 2 digit
  char '-'
  d  &lt;- count 2 digit
  char ' '
  h  &lt;- count 2 digit
  char ':'
  m  &lt;- count 2 digit
  char ':'
  s  &lt;- count 2 digit
  return $
    LocalTime { localDay = fromGregorian (read y) (read mm) (read d)
              , localTimeOfDay = TimeOfDay (read h) (read m) (read s)
                }

-- | Parser of values of type 'Product'.
productParser :: Parser Product
productParser =
     (string &quot;mouse&quot;    &gt;&gt; return Mouse)
 &lt;|&gt; (string &quot;keyboard&quot; &gt;&gt; return Keyboard)
 &lt;|&gt; (string &quot;monitor&quot;  &gt;&gt; return Monitor)
 &lt;|&gt; (string &quot;speakers&quot; &gt;&gt; return Speakers)

-- | Parser of log entries.
logEntryParser :: Parser LogEntry
logEntryParser = do
  -- First, we read the time.
  t &lt;- timeParser
  -- Followed by a space.
  char ' '
  -- And then the IP of the client.
  ip &lt;- parseIP
  -- Followed by another space.
  char ' '
  -- Finally, we read the type of product.
  p &lt;- productParser
  -- And we return the result as a value of type 'LogEntry'.
  return $ LogEntry t ip p

logParser :: Parser Log
logParser = many $ logEntryParser &lt;* endOfLine

----------------------
-------- MAIN --------
----------------------

main :: IO ()
main = B.readFile logFile &gt;&gt;= print . parseOnly logParser</code></pre><h2 id="changes-in-the-log"><a href="#changes-in-the-log">Changes in the log</a></h2><p>After some time logging our sales, we have the idea of adding a new field
to each log entry. We ask each customer how he/she found about us and keep
this information in our log. We happily update the logger but quickly notice
that the parser does not work anymore. Apart from changing the <code>LogEntry</code> type
we have to modify the parser to work with the new values. We allow our users
to specify the following options:</p><pre><code class="haskell">data Source = Internet | Friend | NoAnswer deriving Show</code></pre><p>We would report <code>NoAnswer</code> in the case that our customer did not answered.
Quickly we write a parser very similar to <code>productParser</code>.</p><pre><code class="active haskell">{-# LANGUAGE OverloadedStrings #-}

import Data.Attoparsec.Char8
import Control.Applicative

data Source = Internet | Friend | NoAnswer deriving Show

sourceParser :: Parser Source
sourceParser =
      (string &quot;internet&quot; &gt;&gt; return Internet)
  &lt;|&gt; (string &quot;friend&quot; &gt;&gt; return Friend)
  &lt;|&gt; (string &quot;noanswer&quot; &gt;&gt; return NoAnswer)
  
main :: IO ()
main = print $ parseOnly sourceParser &quot;internet&quot;</code></pre><p>After checking that this parser works, we add it to our <code>logEntryParser</code>,
upgrading the type definition of <code>LogEntry</code> adding the field <code>source</code>.</p><pre><code class="active haskell">{-# START_FILE sellings.log #-}
2013-06-29 16:40:15 154.41.32.99 monitor internet
2013-06-29 16:51:12 103.29.60.13 keyboard internet
2013-06-29 17:13:21 121.95.68.21 speakers friend
2013-06-29 18:20:10 190.80.70.60 mouse noanswer
2013-06-29 18:51:23 102.42.52.64 speakers friend
2013-06-29 19:01:11 78.46.64.23 mouse internet

{-# START_FILE Main.hs #-}
{-# LANGUAGE OverloadedStrings #-}

import Data.Word
import Data.Time
import Data.Attoparsec.Char8
import Control.Applicative
-- We import ByteString qualified because the function
-- 'Data.ByteString.readFile' would clash with
-- 'Prelude.readFile'.
import qualified Data.ByteString as B

-----------------------
------ SETTINGS -------
-----------------------

-- | File where the log is stored.
logFile :: FilePath
logFile = &quot;sellings.log&quot;

-----------------------
-------- TYPES --------
-----------------------

-- | Type for IP's.
data IP = IP Word8 Word8 Word8 Word8 deriving Show

data Product = Mouse | Keyboard | Monitor | Speakers deriving Show

data Source = Internet | Friend | NoAnswer deriving Show

-- show
data LogEntry =
  LogEntry { entryTime :: LocalTime
           , entryIP   :: IP
           , entryProduct   :: Product
             -- Addition of the 'Source' field
           , source    :: Source
             } deriving Show
-- /show

type Log = [LogEntry]

-----------------------
------- PARSING -------
-----------------------

-- | Parser of values of type 'IP'.
parseIP :: Parser IP
parseIP = do
  d1 &lt;- decimal
  char '.'
  d2 &lt;- decimal
  char '.'
  d3 &lt;- decimal
  char '.'
  d4 &lt;- decimal
  return $ IP d1 d2 d3 d4

-- | Parser of values of type 'LocalTime'.
timeParser :: Parser LocalTime
timeParser = do
  y  &lt;- count 4 digit
  char '-'
  mm &lt;- count 2 digit
  char '-'
  d  &lt;- count 2 digit
  char ' '
  h  &lt;- count 2 digit
  char ':'
  m  &lt;- count 2 digit
  char ':'
  s  &lt;- count 2 digit
  return $
    LocalTime { localDay = fromGregorian (read y) (read mm) (read d)
              , localTimeOfDay = TimeOfDay (read h) (read m) (read s)
                }

-- | Parser of values of type 'Product'.
productParser :: Parser Product
productParser =
     (string &quot;mouse&quot;    &gt;&gt; return Mouse)
 &lt;|&gt; (string &quot;keyboard&quot; &gt;&gt; return Keyboard)
 &lt;|&gt; (string &quot;monitor&quot;  &gt;&gt; return Monitor)
 &lt;|&gt; (string &quot;speakers&quot; &gt;&gt; return Speakers)

sourceParser :: Parser Source
sourceParser =
      (string &quot;internet&quot; &gt;&gt; return Internet)
  &lt;|&gt; (string &quot;friend&quot; &gt;&gt; return Friend)
  &lt;|&gt; (string &quot;noanswer&quot; &gt;&gt; return NoAnswer)

-- show
-- | Parser of log entries.
logEntryParser :: Parser LogEntry
logEntryParser = do
  t &lt;- timeParser
  char ' '
  ip &lt;- parseIP
  char ' '
  p &lt;- productParser
  -- Addition of the 'Source' field
  char ' '
  s &lt;- sourceParser
  --
  return $ LogEntry t ip p s
-- /show

logParser :: Parser Log
logParser = many $ logEntryParser &lt;* endOfLine

----------------------
-------- MAIN --------
----------------------

main :: IO ()
main = B.readFile logFile &gt;&gt;= print . parseOnly logParser</code></pre><h3 id="making-the-changed-parser-compatible-with-the-old-format"><a href="#making-the-changed-parser-compatible-with-the-old-format">Making the changed parser compatible with the old format</a></h3><p>However, this parser only works in the new data, and we do not
want to lose the information we gathered before. The solution
is to add an <i>optional</i> field in the parser and, when no value
is found, return a default value (like <code>NoAnswer</code>). The <code>option</code>
attoparsec combinators has exactly this purpose.</p><pre><code class="active haskell">{-# START_FILE sellings.log #-}
2013-06-29 11:16:23 124.67.34.60 keyboard
2013-06-29 11:32:12 212.141.23.67 mouse
2013-06-29 11:33:08 212.141.23.67 monitor
2013-06-29 12:12:34 125.80.32.31 speakers
2013-06-29 12:51:50 101.40.50.62 keyboard
2013-06-29 13:10:45 103.29.60.13 mouse
2013-06-29 16:40:15 154.41.32.99 monitor internet
2013-06-29 16:51:12 103.29.60.13 keyboard internet
2013-06-29 17:13:21 121.95.68.21 speakers friend
2013-06-29 18:20:10 190.80.70.60 mouse noanswer
2013-06-29 18:51:23 102.42.52.64 speakers friend
2013-06-29 19:01:11 78.46.64.23 mouse internet

{-# START_FILE Main.hs #-}
{-# LANGUAGE OverloadedStrings #-}

import Data.Word
import Data.Time
import Data.Attoparsec.Char8
import Control.Applicative
-- We import ByteString qualified because the function
-- 'Data.ByteString.readFile' would clash with
-- 'Prelude.readFile'.
import qualified Data.ByteString as B

-----------------------
------ SETTINGS -------
-----------------------

-- | File where the log is stored.
logFile :: FilePath
logFile = &quot;sellings.log&quot;

-----------------------
-------- TYPES --------
-----------------------

-- | Type for IP's.
data IP = IP Word8 Word8 Word8 Word8 deriving Show

data Product = Mouse | Keyboard | Monitor | Speakers deriving Show

data Source = Internet | Friend | NoAnswer deriving Show

data LogEntry =
  LogEntry { entryTime :: LocalTime
           , entryIP   :: IP
           , entryProduct   :: Product
           , source    :: Source
             } deriving Show

type Log = [LogEntry]

-----------------------
------- PARSING -------
-----------------------

-- | Parser of values of type 'IP'.
parseIP :: Parser IP
parseIP = do
  d1 &lt;- decimal
  char '.'
  d2 &lt;- decimal
  char '.'
  d3 &lt;- decimal
  char '.'
  d4 &lt;- decimal
  return $ IP d1 d2 d3 d4

-- | Parser of values of type 'LocalTime'.
timeParser :: Parser LocalTime
timeParser = do
  y  &lt;- count 4 digit
  char '-'
  mm &lt;- count 2 digit
  char '-'
  d  &lt;- count 2 digit
  char ' '
  h  &lt;- count 2 digit
  char ':'
  m  &lt;- count 2 digit
  char ':'
  s  &lt;- count 2 digit
  return $
    LocalTime { localDay = fromGregorian (read y) (read mm) (read d)
              , localTimeOfDay = TimeOfDay (read h) (read m) (read s)
                }

-- | Parser of values of type 'Product'.
productParser :: Parser Product
productParser =
     (string &quot;mouse&quot;    &gt;&gt; return Mouse)
 &lt;|&gt; (string &quot;keyboard&quot; &gt;&gt; return Keyboard)
 &lt;|&gt; (string &quot;monitor&quot;  &gt;&gt; return Monitor)
 &lt;|&gt; (string &quot;speakers&quot; &gt;&gt; return Speakers)

sourceParser :: Parser Source
sourceParser =
      (string &quot;internet&quot; &gt;&gt; return Internet)
  &lt;|&gt; (string &quot;friend&quot; &gt;&gt; return Friend)
  &lt;|&gt; (string &quot;noanswer&quot; &gt;&gt; return NoAnswer)

-- show
-- | Parser of log entries.
logEntryParser :: Parser LogEntry
logEntryParser = do
  t &lt;- timeParser
  char ' '
  ip &lt;- parseIP
  char ' '
  p &lt;- productParser
  -- Look for the field 'Source' and return
  -- a default value ('NoAnswer') when missing.
  -- The arguments of 'option' are default value
  -- followed by the parser to try.
  s &lt;- option NoAnswer $ char ' ' &gt;&gt; sourceParser
  --
  return $ LogEntry t ip p s
-- /show

logParser :: Parser Log
logParser = many $ logEntryParser &lt;* endOfLine

----------------------
-------- MAIN --------
----------------------

main :: IO ()
main = B.readFile logFile &gt;&gt;= print . parseOnly logParser</code></pre><h2 id="merging-data-from-different-logs"><a href="#merging-data-from-different-logs">Merging data from different logs</a></h2><p>Our company is growing fast and we decide to open a new online shop based
in French to extend our customer range to Europe. However, after some time,
we note that our engineer in French is using a different log format.</p><pre><code>154.41.32.99 29/06/2013 15:32:23 4 internet
76.125.44.33 29/06/2013 16:56:45 3 noanswer
123.45.67.89 29/06/2013 18:44:29 4 friend
100.23.32.41 29/06/2013 19:01:09 1 internet
151.123.45.67 29/06/2013 20:30:13 2 internet</code></pre><p>It seems that each log entry stores the information in the following order:</p><ul><li>IP.</li><li>Date (in a different format).</li><li>A number representing the product sold.</li><li>The &quot;how you knew from us&quot; field that we called Source before.</li></ul><p>Therefore, our new <code>logEntryParser2</code> must parse the input in that order.
We note that the date is in a different order (in most Europe countries
is usual to write the day before the month) and is separated by the
<code>/</code> symbol instead of <code>-</code>. Also, they are using ID's to identify products
instead of writing the whole name.</p><h3 id="step-1--write-the-new-parser"><a href="#step-1--write-the-new-parser">Step 1: Write the new parser</a></h3><p>Firstly, we write functions to get the ID from a <code>Product</code> and viceversa.
Deriving an <code>Enum</code> instance for <code>Product</code> gives us an automatic implementation of
the methods <code>toEnum</code> and <code>fromEnum</code>. These functions are a correspondence between
a subset of the integers (type <code>Int</code>) and our type (<code>Product</code> in this case).
The automatic derivation associates the integer <code>0</code> to the first constructor, <code>1</code> to the
second, <code>2</code> to the third, and so on. Therefore, we can define functions <code>product(To/From)ID</code>
as follows.</p><pre><code class="active haskell">-- | Different kind of products are numbered from 1 to 4, in the given
--   order.
data Product = Mouse | Keyboard | Monitor | Speakers deriving (Enum,Show)

productFromID :: Int -&gt; Product
productFromID n = toEnum (n-1)

productToID :: Product -&gt; Int
productToID p = fromEnum p + 1

main :: IO ()
main = do
  print $ productFromID 1
  print $ productFromID 3
  print $ productToID Keyboard
  print $ productToID $ productFromID 4</code></pre><p>A parser of products would accept a single digit and will apply <code>productFromID</code>
to get the <code>Product</code> result.</p><pre><code class="active haskell">{-# LANGUAGE OverloadedStrings #-}

import Data.Attoparsec.Char8
import Control.Applicative

data Product = Mouse | Keyboard | Monitor | Speakers deriving (Enum,Show)

productFromID :: Int -&gt; Product
productFromID n = toEnum (n-1)

-- show
productParser2 :: Parser Product
productParser2 = productFromID . read . (:[]) &lt;$&gt; digit

main :: IO ()
main = print $ parseOnly productParser2 &quot;4&quot;
-- /show</code></pre><p>The <code>entryTime</code> field also needs a new parser. The process, however, is equivalent
to the previous one. We just need to parse the input in a different order and use
the new delimiters.</p><pre><code class="active haskell">{-# LANGUAGE OverloadedStrings #-}

import Data.Time
import Data.Attoparsec.Char8

timeParser2 :: Parser LocalTime
timeParser2 = do
  d  &lt;- count 2 digit
  char '/'
  mm &lt;- count 2 digit
  char '/'
  y  &lt;- count 4 digit
  char ' '
  h  &lt;- count 2 digit
  char ':'
  m  &lt;- count 2 digit
  char ':'
  s  &lt;- count 2 digit
  return $
    LocalTime { localDay = fromGregorian (read y) (read mm) (read d)
              , localTimeOfDay = TimeOfDay (read h) (read m) (read s)
                }

main :: IO ()
main = print $ parseOnly timeParser2 &quot;29/06/2013 15:32:23&quot;</code></pre><p>The rest of the fields are unchanged, so we are ready to write the full parser
of the new log entries. Again, this is just invoking the defined parsers in the
correct order.</p><pre><code class="active haskell">{-# LANGUAGE OverloadedStrings #-}

import Data.Word
import Data.Time
import Data.Attoparsec.Char8
import Control.Applicative

-----------------------
-------- TYPES --------
-----------------------

-- | Type for IP's.
data IP = IP Word8 Word8 Word8 Word8 deriving Show

data Product = Mouse | Keyboard | Monitor | Speakers deriving (Show,Enum)

productFromID :: Int -&gt; Product
productFromID n = toEnum (n-1)

data Source = Internet | Friend | NoAnswer deriving Show

data LogEntry =
  LogEntry { entryTime :: LocalTime
           , entryIP   :: IP
           , entryProduct   :: Product
           , source    :: Source
             } deriving Show

type Log = [LogEntry]

-----------------------
------- PARSING -------
-----------------------

-- | Parser of values of type 'IP'.
parseIP :: Parser IP
parseIP = do
  d1 &lt;- decimal
  char '.'
  d2 &lt;- decimal
  char '.'
  d3 &lt;- decimal
  char '.'
  d4 &lt;- decimal
  return $ IP d1 d2 d3 d4

timeParser2 :: Parser LocalTime
timeParser2 = do
  d  &lt;- count 2 digit
  char '/'
  mm &lt;- count 2 digit
  char '/'
  y  &lt;- count 4 digit
  char ' '
  h  &lt;- count 2 digit
  char ':'
  m  &lt;- count 2 digit
  char ':'
  s  &lt;- count 2 digit
  return $
    LocalTime { localDay = fromGregorian (read y) (read mm) (read d)
              , localTimeOfDay = TimeOfDay (read h) (read m) (read s)
                }

productParser2 :: Parser Product
productParser2 = productFromID . read . (:[]) &lt;$&gt; digit

sourceParser :: Parser Source
sourceParser =
      (string &quot;internet&quot; &gt;&gt; return Internet)
  &lt;|&gt; (string &quot;friend&quot; &gt;&gt; return Friend)
  &lt;|&gt; (string &quot;noanswer&quot; &gt;&gt; return NoAnswer)

-- show
logEntryParser2 :: Parser LogEntry
logEntryParser2 = do
  ip &lt;- parseIP
  char ' '
  t &lt;- timeParser2
  char ' '
  p &lt;- productParser2
  char ' ' 
  s &lt;- sourceParser
  return $ LogEntry t ip p s
  
main :: IO ()
main = print $ parseOnly logEntryParser2 &quot;54.41.32.99 29/06/2013 15:32:23 4 internet&quot;
-- /show</code></pre><p>Once we have a function to read log entries we do the same as above to iterate the
parser line by line through the log file.</p><pre><code class="haskell">logParser2 :: Parser Log
logParser2 = many $ logEntryParser2 &lt;* endOfLine</code></pre><h3 id="step-2--merge-both-logs-conserving-order"><a href="#step-2--merge-both-logs-conserving-order">Step 2: Merge both logs conserving order</a></h3><p>Currently we have two log files, but we want all the data together.
The proposed solution is to parse one file, parse the other file, and
merge both of them. The merging can be done since both parsers have
the same <i>type</i> of output (<code>Log</code>). A <code>Log</code> is a list of log entries, so
we could just append both lists and we will have all the data together.
However, since both files are sorted by <code>entryTime</code>, it would be much nicer
if the merged file is also sorted by <code>entryTime</code>.</p><p>Given two sorted lists, it is easy to merge them into one sorted list
in <i>linear time</i>. This is the procedure used to merge in the <i>mergesort</i> algorithm.</p><pre><code class="active haskell">merge :: Ord a =&gt; [a] -&gt; [a] -&gt; [a]
merge xs [] = xs
merge [] ys = ys
merge (x:xs) (y:ys) =
  if x &lt;= y
     then x : merge xs (y:ys)
     else y : merge (x:xs) ys

main :: IO ()
main = print $ merge [1,3,5,7] [2,4,6,8]</code></pre><p>To use <code>merge</code>, the elements of the list must be of a type instance of the
<code>Ord</code> class. <code>Log</code> is a list of <code>LogEntry</code>, so we have to write an <code>Ord</code>
instance for <code>LogEntry</code>. We use <code>entryTime</code> as a reference to compare different
log entries, since our interest is to sort log entries by time.</p><pre><code class="haskell">instance Ord LogEntry where
  le1 &lt;= le2 = entryTime le1 &lt;= entryTime le2</code></pre><p>Now we are ready to merge both log files into one single result of type <code>Log</code>.</p><pre><code class="active haskell">{-# START_FILE sellings.log #-}
2013-06-29 11:16:23 124.67.34.60 keyboard
2013-06-29 11:32:12 212.141.23.67 mouse
2013-06-29 11:33:08 212.141.23.67 monitor
2013-06-29 12:12:34 125.80.32.31 speakers
2013-06-29 12:51:50 101.40.50.62 keyboard
2013-06-29 13:10:45 103.29.60.13 mouse
2013-06-29 16:40:15 154.41.32.99 monitor internet
2013-06-29 16:51:12 103.29.60.13 keyboard internet
2013-06-29 17:13:21 121.95.68.21 speakers friend
2013-06-29 18:20:10 190.80.70.60 mouse noanswer
2013-06-29 18:51:23 102.42.52.64 speakers friend
2013-06-29 19:01:11 78.46.64.23 mouse internet

{-# START_FILE sellings2.log #-}
154.41.32.99 29/06/2013 15:32:23 4 internet
76.125.44.33 29/06/2013 16:56:45 3 noanswer
123.45.67.89 29/06/2013 18:44:29 4 friend
100.23.32.41 29/06/2013 19:01:09 1 internet
151.123.45.67 29/06/2013 20:30:13 2 internet

{-# START_FILE Main.hs #-}
{-# LANGUAGE OverloadedStrings #-}

import Data.Word
import Data.Time
import Data.Attoparsec.Char8
import Control.Applicative
import qualified Data.ByteString as B

-- show
-----------------------
------ SETTINGS -------
-----------------------
-- | File where the log is stored.
logFile :: FilePath
logFile = &quot;sellings.log&quot;

-- | Second file where the log is stored.
logFile2 :: FilePath
logFile2 = &quot;sellings2.log&quot;
-- /show

-----------------------
-------- TYPES --------
-----------------------

-- | Type for IP's.
data IP = IP Word8 Word8 Word8 Word8 deriving (Eq,Show)

-- | Type for products.
data Product = Mouse | Keyboard | Monitor | Speakers deriving (Eq,Show,Enum)

productFromID :: Int -&gt; Product
productFromID n = toEnum (n-1)

data Source = Internet | Friend | NoAnswer deriving (Eq,Show)

data LogEntry =
  LogEntry { entryTime :: LocalTime
           , entryIP   :: IP
           , entryProduct   :: Product
           , source    :: Source
               -- We derive Eq since is needed to be able
               -- to write an instance of Ord.
             } deriving (Eq, Show)

instance Ord LogEntry where
  le1 &lt;= le2 = entryTime le1 &lt;= entryTime le2

type Log = [LogEntry]

-----------------------
------- PARSING -------
-----------------------

-- | Parser of values of type 'IP'.
parseIP :: Parser IP
parseIP = do
  d1 &lt;- decimal
  char '.'
  d2 &lt;- decimal
  char '.'
  d3 &lt;- decimal
  char '.'
  d4 &lt;- decimal
  return $ IP d1 d2 d3 d4

-- | Parser of values of type 'LocalTime'.
timeParser :: Parser LocalTime
timeParser = do
  y  &lt;- count 4 digit
  char '-'
  mm &lt;- count 2 digit
  char '-'
  d  &lt;- count 2 digit
  char ' '
  h  &lt;- count 2 digit
  char ':'
  m  &lt;- count 2 digit
  char ':'
  s  &lt;- count 2 digit
  return $
    LocalTime { localDay = fromGregorian (read y) (read mm) (read d)
              , localTimeOfDay = TimeOfDay (read h) (read m) (read s)
                }

-- | Parser of values of type 'Product'.
productParser :: Parser Product
productParser =
     (string &quot;mouse&quot;    &gt;&gt; return Mouse)
 &lt;|&gt; (string &quot;keyboard&quot; &gt;&gt; return Keyboard)
 &lt;|&gt; (string &quot;monitor&quot;  &gt;&gt; return Monitor)
 &lt;|&gt; (string &quot;speakers&quot; &gt;&gt; return Speakers)

sourceParser :: Parser Source
sourceParser =
      (string &quot;internet&quot; &gt;&gt; return Internet)
  &lt;|&gt; (string &quot;friend&quot; &gt;&gt; return Friend)
  &lt;|&gt; (string &quot;noanswer&quot; &gt;&gt; return NoAnswer)

-- | Parser of log entries.
logEntryParser :: Parser LogEntry
logEntryParser = do
  t &lt;- timeParser
  char ' '
  ip &lt;- parseIP
  char ' '
  p &lt;- productParser
  s &lt;- option NoAnswer $ char ' ' &gt;&gt; sourceParser
  return $ LogEntry t ip p s

logParser :: Parser Log
logParser = many $ logEntryParser &lt;* endOfLine

timeParser2 :: Parser LocalTime
timeParser2 = do
  d  &lt;- count 2 digit
  char '/'
  mm &lt;- count 2 digit
  char '/'
  y  &lt;- count 4 digit
  char ' '
  h  &lt;- count 2 digit
  char ':'
  m  &lt;- count 2 digit
  char ':'
  s  &lt;- count 2 digit
  return $
    LocalTime { localDay = fromGregorian (read y) (read mm) (read d)
              , localTimeOfDay = TimeOfDay (read h) (read m) (read s)
                }

productParser2 :: Parser Product
productParser2 = productFromID . read . (:[]) &lt;$&gt; digit

logEntryParser2 :: Parser LogEntry
logEntryParser2 = do
  ip &lt;- parseIP
  char ' '
  t &lt;- timeParser2
  char ' '
  p &lt;- productParser2
  char ' ' 
  s &lt;- sourceParser
  return $ LogEntry t ip p s

logParser2 :: Parser Log
logParser2 = many $ logEntryParser2 &lt;* endOfLine

-----------------------
------- MERGING -------
-----------------------

merge :: Ord a =&gt; [a] -&gt; [a] -&gt; [a]
merge xs [] = xs
merge [] ys = ys
merge (x:xs) (y:ys) =
  if x &lt;= y
     then x : merge xs (y:ys)
     else y : merge (x:xs) ys

-- show
----------------------
-------- MAIN --------
----------------------

main :: IO ()
main = do
  file1 &lt;- B.readFile logFile
  file2 &lt;- B.readFile logFile2
          -- We are using the Either monad here.
  let r = do xs &lt;- parseOnly logParser  file1
             ys &lt;- parseOnly logParser2 file2
             return $ merge xs ys
  case r of
   Left err -&gt; putStrLn $ &quot;A parsing error was found: &quot; ++ err
   Right log -&gt; mapM_ print log
-- /show</code></pre><h2 id="extracting-information-from-the-log-file"><a href="#extracting-information-from-the-log-file">Extracting information from the log file</a></h2><p>Once the log file is parsed, we can extract information from it.
Following the previous example, we can check what is the product sold with more frequency
or where most users found our webshop.</p><p>Let's calculate the product that has been sold more times. We may create an association list containing
pairs (product,number of sales) for each product. It would have the following type:</p><pre><code class="haskell">type Sales = [(Product,Int)]</code></pre><p>Given a list like this, we can check how many times a product has been sold.</p><pre><code class="haskell">import Data.Maybe (fromMaybe)

salesOf :: Product -&gt; Sales -&gt; Int
salesOf p xs = fromMaybe 0 $ lookup p xs</code></pre><p>We can also add one sale more to the list.</p><pre><code class="haskell">addSale :: Product -&gt; Sales -&gt; Sales
-- If we have no sales, we add the product with 1 sale.
addSale p [] = [(p,1)]
addSale p ((x,n):xs) = if p == x then (x,n+1):xs
                                 else (x,n) : addSale p xs</code></pre><p>Calculating the most sold product can be done using <code>maximumBy</code> (from
the <code>Data.List</code> module) to compare the elements of the list using the
second component of each pair.</p><pre><code class="haskell">import Data.List (maximumBy)

-- | Given a list of sales, returns the most sold product along with
--   its number of sales.
mostSold :: Sales -&gt; Maybe (Product,Int)
mostSold [] = Nothing
mostSold xs = Just $ maximumBy (\x y -&gt; snd x `compare` snd y) xs</code></pre><p>We need to use <code>Maybe</code> to handle the event when nothing has been sold yet.</p><p>The last task remainding is to build a list of type <code>Sales</code> from a value of
<code>Log</code> type. Since each log entry contains one product, we can use a fold in
the log list using <code>addSale</code> for each entry product, adding all these items
to the empty list.</p><pre><code class="haskell">sales :: Log -&gt; Sales
sales = foldr (addSales . entryProduct) []</code></pre><p>Using now the same data as before, we output the product with more sales.</p><pre><code class="active haskell">{-# START_FILE sellings.log #-}
2013-06-29 11:16:23 124.67.34.60 keyboard
2013-06-29 11:32:12 212.141.23.67 mouse
2013-06-29 11:33:08 212.141.23.67 monitor
2013-06-29 12:12:34 125.80.32.31 speakers
2013-06-29 12:51:50 101.40.50.62 keyboard
2013-06-29 13:10:45 103.29.60.13 mouse
2013-06-29 16:40:15 154.41.32.99 monitor internet
2013-06-29 16:51:12 103.29.60.13 keyboard internet
2013-06-29 17:13:21 121.95.68.21 speakers friend
2013-06-29 18:20:10 190.80.70.60 mouse noanswer
2013-06-29 18:51:23 102.42.52.64 speakers friend
2013-06-29 19:01:11 78.46.64.23 mouse internet

{-# START_FILE sellings2.log #-}
154.41.32.99 29/06/2013 15:32:23 4 internet
76.125.44.33 29/06/2013 16:56:45 3 noanswer
123.45.67.89 29/06/2013 18:44:29 4 friend
100.23.32.41 29/06/2013 19:01:09 1 internet
151.123.45.67 29/06/2013 20:30:13 2 internet

{-# START_FILE Main.hs #-}
{-# LANGUAGE OverloadedStrings #-}

import Data.Word
import Data.Time
import Data.Attoparsec.Char8
import Control.Applicative
import qualified Data.ByteString as B
import Data.List (maximumBy)
import Data.Maybe (fromMaybe)

-----------------------
------ SETTINGS -------
-----------------------

-- | File where the log is stored.
logFile :: FilePath
logFile = &quot;sellings.log&quot;

-- | Second file where the log is stored.
logFile2 :: FilePath
logFile2 = &quot;sellings2.log&quot;

-----------------------
-------- TYPES --------
-----------------------

-- | Type for IP's.
data IP = IP Word8 Word8 Word8 Word8 deriving (Eq,Show)

-- | Type for products.
data Product = Mouse | Keyboard | Monitor | Speakers deriving (Eq,Show,Enum)

productFromID :: Int -&gt; Product
productFromID n = toEnum (n-1)

data Source = Internet | Friend | NoAnswer deriving (Eq,Show)

data LogEntry =
  LogEntry { entryTime :: LocalTime
           , entryIP   :: IP
           , entryProduct   :: Product
           , source    :: Source
               -- We derive Eq since is needed to be able
               -- to write an instance of Ord.
             } deriving (Eq, Show)

instance Ord LogEntry where
  le1 &lt;= le2 = entryTime le1 &lt;= entryTime le2

type Log = [LogEntry]

-----------------------
------- PARSING -------
-----------------------

-- | Parser of values of type 'IP'.
parseIP :: Parser IP
parseIP = do
  d1 &lt;- decimal
  char '.'
  d2 &lt;- decimal
  char '.'
  d3 &lt;- decimal
  char '.'
  d4 &lt;- decimal
  return $ IP d1 d2 d3 d4

-- | Parser of values of type 'LocalTime'.
timeParser :: Parser LocalTime
timeParser = do
  y  &lt;- count 4 digit
  char '-'
  mm &lt;- count 2 digit
  char '-'
  d  &lt;- count 2 digit
  char ' '
  h  &lt;- count 2 digit
  char ':'
  m  &lt;- count 2 digit
  char ':'
  s  &lt;- count 2 digit
  return $
    LocalTime { localDay = fromGregorian (read y) (read mm) (read d)
              , localTimeOfDay = TimeOfDay (read h) (read m) (read s)
                }

-- | Parser of values of type 'Product'.
productParser :: Parser Product
productParser =
     (string &quot;mouse&quot;    &gt;&gt; return Mouse)
 &lt;|&gt; (string &quot;keyboard&quot; &gt;&gt; return Keyboard)
 &lt;|&gt; (string &quot;monitor&quot;  &gt;&gt; return Monitor)
 &lt;|&gt; (string &quot;speakers&quot; &gt;&gt; return Speakers)

sourceParser :: Parser Source
sourceParser =
      (string &quot;internet&quot; &gt;&gt; return Internet)
  &lt;|&gt; (string &quot;friend&quot; &gt;&gt; return Friend)
  &lt;|&gt; (string &quot;noanswer&quot; &gt;&gt; return NoAnswer)

-- | Parser of log entries.
logEntryParser :: Parser LogEntry
logEntryParser = do
  t &lt;- timeParser
  char ' '
  ip &lt;- parseIP
  char ' '
  p &lt;- productParser
  s &lt;- option NoAnswer $ char ' ' &gt;&gt; sourceParser
  return $ LogEntry t ip p s

logParser :: Parser Log
logParser = many $ logEntryParser &lt;* endOfLine

timeParser2 :: Parser LocalTime
timeParser2 = do
  d  &lt;- count 2 digit
  char '/'
  mm &lt;- count 2 digit
  char '/'
  y  &lt;- count 4 digit
  char ' '
  h  &lt;- count 2 digit
  char ':'
  m  &lt;- count 2 digit
  char ':'
  s  &lt;- count 2 digit
  return $
    LocalTime { localDay = fromGregorian (read y) (read mm) (read d)
              , localTimeOfDay = TimeOfDay (read h) (read m) (read s)
                }

productParser2 :: Parser Product
productParser2 = productFromID . read . (:[]) &lt;$&gt; digit

logEntryParser2 :: Parser LogEntry
logEntryParser2 = do
  ip &lt;- parseIP
  char ' '
  t &lt;- timeParser2
  char ' '
  p &lt;- productParser2
  char ' ' 
  s &lt;- sourceParser
  return $ LogEntry t ip p s

logParser2 :: Parser Log
logParser2 = many $ logEntryParser2 &lt;* endOfLine

-----------------------
------- MERGING -------
-----------------------

merge :: Ord a =&gt; [a] -&gt; [a] -&gt; [a]
merge xs [] = xs
merge [] ys = ys
merge (x:xs) (y:ys) =
  if x &lt;= y
     then x : merge xs (y:ys)
     else y : merge (x:xs) ys

----------------------
------ COUNTING ------
----------------------

type Sales = [(Product,Int)]

salesOf :: Product -&gt; Sales -&gt; Int
salesOf p xs = fromMaybe 0 $ lookup p xs

addSale :: Product -&gt; Sales -&gt; Sales
addSale p [] = [(p,1)]
addSale p ((x,n):xs) = if p == x then (x,n+1):xs
                                 else (x,n) : addSale p xs
                        
-- | Given a list of sales, returns the most sold product along with
--   its number of sales.
mostSold :: Sales -&gt; Maybe (Product,Int)
mostSold [] = Nothing
mostSold xs = Just $ maximumBy (\x y -&gt; snd x `compare` snd y) xs

sales :: Log -&gt; Sales
sales = foldr (addSale . entryProduct) []

----------------------
-------- MAIN --------
----------------------

-- show
main :: IO ()
main = do
  file1 &lt;- B.readFile logFile
  file2 &lt;- B.readFile logFile2
  let r = do xs &lt;- parseOnly logParser  file1
             ys &lt;- parseOnly logParser2 file2
             return $ merge xs ys
  case r of
   Left err -&gt; putStrLn $ &quot;A parsing error was found: &quot; ++ err
   Right log -&gt;
     case mostSold (sales log) of
       Nothing -&gt; putStrLn &quot;We didn't sell anything yet.&quot;
       Just (p,n) -&gt; putStrLn $ &quot;The product with more sales is &quot; ++ show p
                  ++ &quot; with &quot; ++ show n ++ &quot; sales.&quot;
-- /show</code></pre><h1 id="from-log-file-to-csv"><a href="#from-log-file-to-csv">From log file to CSV</a></h1><p>CSV (Comma Separated Values) files store tabular data and can be used from a large number of applications.
In fact, one of the advantages of using the CSV format is that data stored in this format can be imported
and exported from very different programs. After gathering all the log file information, we are going to
render a CSV table containing it. Then, we will develop a parser to get the data back into Haskell.</p><h2 id="rendering-to-csv"><a href="#rendering-to-csv">Rendering to CSV</a></h2><p>The process of rendering to CSV is straightforward. Rendering is in general simpler than parsing, and  CSV rendering is not an exception.</p><p>We define rendering methods for each type, as we defined parsers for each type.
Sometimes, the renderer looks similar to the parser (see <code>renderIP</code> below).</p><p>Some functions useful when rendering:</p><ul><li><code>&lt;&gt;</code>: This operator from <code>Data.Monoid</code> appends values of types instance of the <code>Monoid</code> class.
<code>ByteString</code> is one of them.</li><li><code>foldMap</code>: Apply a function over the elements of a structure instance of the <code>Foldable</code> class to
values of a type instance of the <code>Monoid</code> class then append all the results.</li><li><code>fromString</code>: It takes a String and return it as a value of any type in the <code>IsString</code> class,
defined at <code>Data.String</code>.</li></ul><pre><code class="active haskell">{-# START_FILE sellings.log #-}
2013-06-29 11:16:23 124.67.34.60 keyboard
2013-06-29 11:32:12 212.141.23.67 mouse
2013-06-29 11:33:08 212.141.23.67 monitor
2013-06-29 12:12:34 125.80.32.31 speakers
2013-06-29 12:51:50 101.40.50.62 keyboard
2013-06-29 13:10:45 103.29.60.13 mouse
2013-06-29 16:40:15 154.41.32.99 monitor internet
2013-06-29 16:51:12 103.29.60.13 keyboard internet
2013-06-29 17:13:21 121.95.68.21 speakers friend
2013-06-29 18:20:10 190.80.70.60 mouse noanswer
2013-06-29 18:51:23 102.42.52.64 speakers friend
2013-06-29 19:01:11 78.46.64.23 mouse internet

{-# START_FILE sellings2.log #-}
154.41.32.99 29/06/2013 15:32:23 4 internet
76.125.44.33 29/06/2013 16:56:45 3 noanswer
123.45.67.89 29/06/2013 18:44:29 4 friend
100.23.32.41 29/06/2013 19:01:09 1 internet
151.123.45.67 29/06/2013 20:30:13 2 internet

{-# START_FILE Main.hs #-}
{-# LANGUAGE OverloadedStrings #-}

import Data.Word
import Data.Time
import Data.Attoparsec.Char8
import Control.Applicative
-- show
import Data.ByteString.Char8 (ByteString,singleton)
import qualified Data.ByteString as B
import qualified Data.ByteString.Char8 as BC
import Data.String
import Data.Char (toLower)
import Data.Monoid hiding (Product)
import Data.Foldable (foldMap)
-- /show

-----------------------
------ SETTINGS -------
-----------------------

-- | File where the log is stored.
logFile :: FilePath
logFile = &quot;sellings.log&quot;

-- | Second file where the log is stored.
logFile2 :: FilePath
logFile2 = &quot;sellings2.log&quot;

-----------------------
-------- TYPES --------
-----------------------

-- | Type for IP's.
data IP = IP Word8 Word8 Word8 Word8 deriving (Eq,Show)

-- | Type for products.
data Product = Mouse | Keyboard | Monitor | Speakers deriving (Eq,Show,Enum)

productFromID :: Int -&gt; Product
productFromID n = toEnum (n-1)

data Source = Internet | Friend | NoAnswer deriving (Eq,Show)

data LogEntry =
  LogEntry { entryTime :: LocalTime
           , entryIP   :: IP
           , entryProduct   :: Product
           , source    :: Source
               -- We derive Eq since is needed to be able
               -- to write an instance of Ord.
             } deriving (Eq, Show)

instance Ord LogEntry where
  le1 &lt;= le2 = entryTime le1 &lt;= entryTime le2

type Log = [LogEntry]

-----------------------
------- PARSING -------
-----------------------

-- | Parser of values of type 'IP'.
parseIP :: Parser IP
parseIP = do
  d1 &lt;- decimal
  char '.'
  d2 &lt;- decimal
  char '.'
  d3 &lt;- decimal
  char '.'
  d4 &lt;- decimal
  return $ IP d1 d2 d3 d4

-- | Parser of values of type 'LocalTime'.
timeParser :: Parser LocalTime
timeParser = do
  y  &lt;- count 4 digit
  char '-'
  mm &lt;- count 2 digit
  char '-'
  d  &lt;- count 2 digit
  char ' '
  h  &lt;- count 2 digit
  char ':'
  m  &lt;- count 2 digit
  char ':'
  s  &lt;- count 2 digit
  return $
    LocalTime { localDay = fromGregorian (read y) (read mm) (read d)
              , localTimeOfDay = TimeOfDay (read h) (read m) (read s)
                }

-- | Parser of values of type 'Product'.
productParser :: Parser Product
productParser =
     (string &quot;mouse&quot;    &gt;&gt; return Mouse)
 &lt;|&gt; (string &quot;keyboard&quot; &gt;&gt; return Keyboard)
 &lt;|&gt; (string &quot;monitor&quot;  &gt;&gt; return Monitor)
 &lt;|&gt; (string &quot;speakers&quot; &gt;&gt; return Speakers)

sourceParser :: Parser Source
sourceParser =
      (string &quot;internet&quot; &gt;&gt; return Internet)
  &lt;|&gt; (string &quot;friend&quot; &gt;&gt; return Friend)
  &lt;|&gt; (string &quot;noanswer&quot; &gt;&gt; return NoAnswer)

-- | Parser of log entries.
logEntryParser :: Parser LogEntry
logEntryParser = do
  t &lt;- timeParser
  char ' '
  ip &lt;- parseIP
  char ' '
  p &lt;- productParser
  s &lt;- option NoAnswer $ char ' ' &gt;&gt; sourceParser
  return $ LogEntry t ip p s

logParser :: Parser Log
logParser = many $ logEntryParser &lt;* endOfLine

timeParser2 :: Parser LocalTime
timeParser2 = do
  d  &lt;- count 2 digit
  char '/'
  mm &lt;- count 2 digit
  char '/'
  y  &lt;- count 4 digit
  char ' '
  h  &lt;- count 2 digit
  char ':'
  m  &lt;- count 2 digit
  char ':'
  s  &lt;- count 2 digit
  return $
    LocalTime { localDay = fromGregorian (read y) (read mm) (read d)
              , localTimeOfDay = TimeOfDay (read h) (read m) (read s)
                }

productParser2 :: Parser Product
productParser2 = productFromID . read . (:[]) &lt;$&gt; digit

logEntryParser2 :: Parser LogEntry
logEntryParser2 = do
  ip &lt;- parseIP
  char ' '
  t &lt;- timeParser2
  char ' '
  p &lt;- productParser2
  char ' ' 
  s &lt;- sourceParser
  return $ LogEntry t ip p s

logParser2 :: Parser Log
logParser2 = many $ logEntryParser2 &lt;* endOfLine

-----------------------
------- MERGING -------
-----------------------

merge :: Ord a =&gt; [a] -&gt; [a] -&gt; [a]
merge xs [] = xs
merge [] ys = ys
merge (x:xs) (y:ys) =
  if x &lt;= y
     then x : merge xs (y:ys)
     else y : merge (x:xs) ys

-- show
-----------------------
------ RENDERING ------
-----------------------

-- | Character that will serve as field separator.
--   It should not be one of the characters that
--   appear in the fields.
sepChar :: Char
sepChar = ','

-- | Rendering of IP's to ByteString.
renderIP :: IP -&gt; ByteString
renderIP (IP a b c d) =
     -- Function @show@ creates a String and
     -- fromString makes it a ByteString.
     fromString (show a)
  &lt;&gt; singleton '.'
  &lt;&gt; fromString (show b)
  &lt;&gt; singleton '.'
  &lt;&gt; fromString (show c)
  &lt;&gt; singleton '.'
  &lt;&gt; fromString (show d)

-- | Render a log entry to a CSV row as ByteString.
renderEntry :: LogEntry -&gt; ByteString
renderEntry le =
     fromString (show $ entryTime le)
  &lt;&gt; singleton sepChar
  &lt;&gt; renderIP (entryIP le)
  &lt;&gt; singleton sepChar
     -- We use @fmap toLower@ to write the product name
     -- in lowercase letters.
  &lt;&gt; fromString (fmap toLower $ show $ entryProduct le)
  &lt;&gt; singleton sepChar
  &lt;&gt; fromString (fmap toLower $ show $ source le)

-- | Render a log file to CSV as ByteString.
renderLog :: Log -&gt; ByteString
renderLog = foldMap $ \le -&gt; renderEntry le &lt;&gt; singleton '\n'

----------------------
-------- MAIN --------
----------------------

main :: IO ()
main = do
  file1 &lt;- B.readFile logFile
  file2 &lt;- B.readFile logFile2
          -- We are using the Either monad here.
  let r = do xs &lt;- parseOnly logParser  file1
             ys &lt;- parseOnly logParser2 file2
             return $ merge xs ys
  case r of
   Left err -&gt; putStrLn $ &quot;A parsing error was found: &quot; ++ err
   Right log -&gt; BC.putStrLn $ renderLog log
-- /show</code></pre><h2 id="parsing-from-csv"><a href="#parsing-from-csv">Parsing from CSV</a></h2><p>Again, as with log files, we use <i>attoparsec</i> for parsing.
Note that the CSV format is similar to the log format, except
in how fields are separated. Therefore, we can re-use our
field parsers.</p><p>We start defining a parser for rows, and then we iterate it
using <code>many</code> exactly as before.</p><pre><code class="active haskell">{-# START_FILE sellings.csv #-}
2013-06-29 11:16:23 , 124.67.34.60  , keyboard , noanswer
2013-06-29 11:32:12 , 212.141.23.67 , mouse    , noanswer
2013-06-29 11:33:08 , 212.141.23.67 , monitor  , noanswer
2013-06-29 12:12:34 , 125.80.32.31  , speakers , noanswer
2013-06-29 12:51:50 , 101.40.50.62  , keyboard , noanswer
2013-06-29 13:10:45 , 103.29.60.13  , mouse    , noanswer
2013-06-29 15:32:23 , 154.41.32.99  , speakers , internet
2013-06-29 16:40:15 , 154.41.32.99  , monitor  , internet
2013-06-29 16:51:12 , 103.29.60.13  , keyboard , internet
2013-06-29 16:56:45 , 76.125.44.33  , monitor  , noanswer
2013-06-29 17:13:21 , 121.95.68.21  , speakers , friend
2013-06-29 18:20:10 , 190.80.70.60  , mouse    , noanswer
2013-06-29 18:44:29 , 123.45.67.89  , speakers , friend
2013-06-29 18:51:23 , 102.42.52.64  , speakers , friend
2013-06-29 19:01:09 , 100.23.32.41  , mouse    , internet
2013-06-29 19:01:11 , 78.46.64.23   , mouse    , internet
2013-06-29 20:30:13 , 151.123.45.67 , keyboard , internet

{-# START_FILE Main.hs #-}
{-# LANGUAGE OverloadedStrings #-}

import Data.Word
import Data.Time
import Data.Attoparsec.Char8
import Control.Applicative
import qualified Data.ByteString as B
-- show
-----------------------
------ SETTINGS -------
-----------------------

-- | File where the CSV is stored.
csvFile :: FilePath
csvFile = &quot;sellings.csv&quot;

-- | Character that will serve as field separator.
--   It should not be one of the characters that
--   appear in the fields.
sepChar :: Char
sepChar = ','
-- /show

-----------------------
-------- TYPES --------
-----------------------

-- | Type for IP's.
data IP = IP Word8 Word8 Word8 Word8 deriving (Eq,Show)

-- | Type for products.
data Product = Mouse | Keyboard | Monitor | Speakers deriving (Eq,Show,Enum)

data Source = Internet | Friend | NoAnswer deriving (Eq,Show)

data LogEntry =
  LogEntry { entryTime :: LocalTime
           , entryIP   :: IP
           , entryProduct   :: Product
           , source    :: Source
               -- We derive Eq since is needed to be able
               -- to write an instance of Ord.
             } deriving (Eq, Show)

type Log = [LogEntry]

-- show
-----------------------
------- PARSING -------
-----------------------
-- /show

-- | Parser of values of type 'IP'.
parseIP :: Parser IP
parseIP = do
  d1 &lt;- decimal
  char '.'
  d2 &lt;- decimal
  char '.'
  d3 &lt;- decimal
  char '.'
  d4 &lt;- decimal
  return $ IP d1 d2 d3 d4

-- | Parser of values of type 'LocalTime'.
timeParser :: Parser LocalTime
timeParser = do
  y  &lt;- count 4 digit
  char '-'
  mm &lt;- count 2 digit
  char '-'
  d  &lt;- count 2 digit
  char ' '
  h  &lt;- count 2 digit
  char ':'
  m  &lt;- count 2 digit
  char ':'
  s  &lt;- count 2 digit
  return $
    LocalTime { localDay = fromGregorian (read y) (read mm) (read d)
              , localTimeOfDay = TimeOfDay (read h) (read m) (read s)
                }
                
-- | Parser of values of type 'Product'.
productParser :: Parser Product
productParser =
     (string &quot;mouse&quot;    &gt;&gt; return Mouse)
 &lt;|&gt; (string &quot;keyboard&quot; &gt;&gt; return Keyboard)
 &lt;|&gt; (string &quot;monitor&quot;  &gt;&gt; return Monitor)
 &lt;|&gt; (string &quot;speakers&quot; &gt;&gt; return Speakers)

sourceParser :: Parser Source
sourceParser =
      (string &quot;internet&quot; &gt;&gt; return Internet)
  &lt;|&gt; (string &quot;friend&quot; &gt;&gt; return Friend)
  &lt;|&gt; (string &quot;noanswer&quot; &gt;&gt; return NoAnswer)

-- show
rowParser :: Parser LogEntry
rowParser = do
  -- Parser of field separators. It skips space characters before
  -- and after the CSV separator char.
  -- Characters considered as space are simple whitespaces and tabs.
  let spaceSkip = many $ satisfy $ inClass [ ' ' , '\t' ]
      sepParser = spaceSkip &gt;&gt; char sepChar &gt;&gt; spaceSkip
  -- Skip spaces at the beginning of the line.
  spaceSkip
  t  &lt;- timeParser
  sepParser
  ip &lt;- parseIP
  sepParser
  p  &lt;- productParser
  sepParser
  s  &lt;- sourceParser
  -- Skip remaining spaces at the end of the line
  spaceSkip
  return $ LogEntry t ip p s

csvParser :: Parser Log
csvParser = many $ rowParser &lt;* endOfLine

----------------------
-------- MAIN --------
----------------------

main :: IO ()
main = do
  file &lt;- B.readFile csvFile
  case parseOnly csvParser file of
    Left err -&gt; putStrLn $ &quot;Error while parsing CSV file: &quot; ++ err
    Right log -&gt; mapM_ print log
-- /show</code></pre><h2 id="using-csv-across-applications"><a href="#using-csv-across-applications">Using CSV across applications</a></h2><p>Use <code>renderLog</code> and <code>Data.ByteString.Char8.writeFile</code> to write a CSV table
using your log information. However, if you are using a character set different
from ASCII or ISO-8859-15, you should consider using the type <code>Text</code> instead
of <code>ByteString</code>. Almost the only change you have to do
is to change the import of <code>Data.Attoparsec.Char8</code> to <code>Data.Attoparsec.Text</code>
(both modules export similar interfaces and are interchangeable) and
adapt the types of the renderer.</p><p>Once you have written your data in CSV format, import it from another application.
Use the table, make any changes that you may want and modified data back in Haskell
by parsing the CSV output of your application. Make sure your application and the
Haskell parser are using the same column separator.</p><h1 id="final-app--read-several-log-files--merge-data-and-render-it-in-csv"><a href="#final-app--read-several-log-files--merge-data-and-render-it-in-csv">Final App: Read several log files, merge data and render it in CSV</a></h1><p>We now present a runnable application that read a list of log files, merge them and
return the result as a CSV table. The files may be read from a local file or an URL.</p><pre><code class="active haskell">{-# START_FILE sellings.log #-}
2013-06-29 11:16:23 124.67.34.60 keyboard
2013-06-29 11:32:12 212.141.23.67 mouse
2013-06-29 11:33:08 212.141.23.67 monitor
2013-06-29 12:12:34 125.80.32.31 speakers
2013-06-29 12:51:50 101.40.50.62 keyboard
2013-06-29 13:10:45 103.29.60.13 mouse
2013-06-29 16:40:15 154.41.32.99 monitor internet
2013-06-29 16:51:12 103.29.60.13 keyboard internet
2013-06-29 17:13:21 121.95.68.21 speakers friend
2013-06-29 18:20:10 190.80.70.60 mouse noanswer
2013-06-29 18:51:23 102.42.52.64 speakers friend
2013-06-29 19:01:11 78.46.64.23 mouse internet

{-# START_FILE sellings2.log #-}
2013-06-29 15:32:23 154.41.32.99 speakers internet
2013-06-29 16:56:45 76.125.44.33 monitor noanswer
2013-06-29 18:44:29 123.45.67.89 speakers friend
2013-06-29 19:01:09 100.23.32.41 mouse internet
2013-06-29 20:30:13 151.123.45.67 keyboard internet

{-# START_FILE Main.hs #-}
{-# LANGUAGE OverloadedStrings #-}

import Data.Word
import Data.Time
import Data.Attoparsec.Char8
import Control.Applicative
import Data.Either (rights)
import Data.Monoid hiding (Product)
import Data.String
import Data.Char (toLower)
import Data.Foldable (foldMap)
-- ByteString stuff
import Data.ByteString.Char8 (ByteString,singleton)
import qualified Data.ByteString as B
import qualified Data.ByteString.Char8 as BC
import Data.ByteString.Lazy (toChunks)
-- HTTP protocol to perform downloads
import Network.HTTP.Conduit

----------------------
------- FILES --------
----------------------

data File = URL String | Local FilePath

-- | Files where the logs are stored.
--   Modify this value to read logs from
--   other sources.
logFiles :: [File]
logFiles =
  [ Local &quot;sellings.log&quot;
  , Local &quot;sellings2.log&quot;
  , URL &quot;http://daniel-diaz.github.io/misc/sellings3.log&quot;
    ]

getFile :: File -&gt; IO ByteString
-- simpleHttp gets a lazy bytestring, while we
-- are using strict bytestrings.
getFile (URL str) = mconcat . toChunks &lt;$&gt; simpleHttp str
getFile (Local fp) = B.readFile fp

-----------------------
-------- TYPES --------
-----------------------

-- | Type for IP's.
data IP = IP Word8 Word8 Word8 Word8 deriving (Eq,Show)

-- | Type for products.
data Product = Mouse | Keyboard | Monitor | Speakers deriving (Eq,Show,Enum)

productFromID :: Int -&gt; Product
productFromID n = toEnum (n-1)

data Source = Internet | Friend | NoAnswer deriving (Eq,Show)

-- | Each log entry in the log file is represented by a value
--   of this type. Modify the fields of 'LogEntry' accordingly
--   to your log file of interest. However, 'entryTime' is a
--   reasonable field and is also used for merging.
data LogEntry =
  LogEntry { entryTime :: LocalTime
           , entryIP   :: IP
           , entryProduct   :: Product
           , source    :: Source
             } deriving (Eq, Show)

instance Ord LogEntry where
  le1 &lt;= le2 = entryTime le1 &lt;= entryTime le2

type Log = [LogEntry]

-----------------------
------- PARSING -------
-----------------------

-- | Parser of values of type 'IP'.
parseIP :: Parser IP
parseIP = do
  d1 &lt;- decimal
  char '.'
  d2 &lt;- decimal
  char '.'
  d3 &lt;- decimal
  char '.'
  d4 &lt;- decimal
  return $ IP d1 d2 d3 d4

-- | Parser of values of type 'LocalTime'.
timeParser :: Parser LocalTime
timeParser = do
  y  &lt;- count 4 digit
  char '-'
  mm &lt;- count 2 digit
  char '-'
  d  &lt;- count 2 digit
  char ' '
  h  &lt;- count 2 digit
  char ':'
  m  &lt;- count 2 digit
  char ':'
  s  &lt;- count 2 digit
  return $
    LocalTime { localDay = fromGregorian (read y) (read mm) (read d)
              , localTimeOfDay = TimeOfDay (read h) (read m) (read s)
                }

-- | Parser of values of type 'Product'.
productParser :: Parser Product
productParser =
     (string &quot;mouse&quot;    &gt;&gt; return Mouse)
 &lt;|&gt; (string &quot;keyboard&quot; &gt;&gt; return Keyboard)
 &lt;|&gt; (string &quot;monitor&quot;  &gt;&gt; return Monitor)
 &lt;|&gt; (string &quot;speakers&quot; &gt;&gt; return Speakers)

sourceParser :: Parser Source
sourceParser =
      (string &quot;internet&quot; &gt;&gt; return Internet)
  &lt;|&gt; (string &quot;friend&quot; &gt;&gt; return Friend)
  &lt;|&gt; (string &quot;noanswer&quot; &gt;&gt; return NoAnswer)

-- | Parser of log entries.
logEntryParser :: Parser LogEntry
logEntryParser = do
  t &lt;- timeParser
  char ' '
  ip &lt;- parseIP
  char ' '
  p &lt;- productParser
  s &lt;- option NoAnswer $ char ' ' &gt;&gt; sourceParser
  return $ LogEntry t ip p s

logParser :: Parser Log
logParser = many $ logEntryParser &lt;* endOfLine

-----------------------
------- MERGING -------
-----------------------

merge :: Ord a =&gt; [a] -&gt; [a] -&gt; [a]
merge xs [] = xs
merge [] ys = ys
merge (x:xs) (y:ys) =
  if x &lt;= y
     then x : merge xs (y:ys)
     else y : merge (x:xs) ys

-----------------------
------ RENDERING ------
-----------------------

-- | Character that will serve as field separator.
--   It should not be one of the characters that
--   appear in the fields.
sepChar :: Char
sepChar = ','

-- | Rendering of IP's to ByteString.
renderIP :: IP -&gt; ByteString
renderIP (IP a b c d) =
     fromString (show a)
  &lt;&gt; singleton '.'
  &lt;&gt; fromString (show b)
  &lt;&gt; singleton '.'
  &lt;&gt; fromString (show c)
  &lt;&gt; singleton '.'
  &lt;&gt; fromString (show d)

-- | Render a log entry to a CSV row as ByteString.
renderEntry :: LogEntry -&gt; ByteString
renderEntry le =
     fromString (show $ entryTime le)
  &lt;&gt; singleton sepChar
  &lt;&gt; renderIP (entryIP le)
  &lt;&gt; singleton sepChar
  &lt;&gt; fromString (fmap toLower $ show $ entryProduct le)
  &lt;&gt; singleton sepChar
  &lt;&gt; fromString (fmap toLower $ show $ source le)

-- | Render a log file to CSV as ByteString.
renderLog :: Log -&gt; ByteString
renderLog = foldMap $ \le -&gt; renderEntry le &lt;&gt; singleton '\n'

----------------------
-------- MAIN --------
----------------------

main :: IO ()
main = do
  files &lt;- mapM getFile logFiles
  let -- Parsed logs
      logs :: [Log]
      logs = rights $ fmap (parseOnly logParser) files
      -- Merged log
      mergedLog :: Log
      mergedLog = foldr merge [] logs
  BC.putStrLn $ renderLog mergedLog</code></pre><h1 id="conclusion"><a href="#conclusion">Conclusion</a></h1><p>Parsing is one of the tasks that Haskell is really good at.
The parser code is much clearer and easier to write than in traditional languages and it may run
<a href="http://newartisans.com/2012/08/parsing-with-haskell-and-attoparsec">faster than a C++ parser</a>.
I invite you to try to parse bigger things. Following the
<a href="http://hackage.haskell.org/package/attoparsec">API reference</a>
it should not be hard. As an example, Bryan O'Sullivan wrote an HTTP parser
<a href="https://bitbucket.org/bos/attoparsec/src/tip/examples/RFC2616.hs">here</a>.
I think it is easy to read once you know <a href="http://tools.ietf.org/html/rfc4180">how HTTP is defined</a>.</p></article>

<div id="disqus_thread"><script>var disqus_shortname = "fpcomplete"; (function() { var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true; dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq); })();</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">comments powered by <span class="logo-disqus">Disqus</span></a></a>
</div>

</div>
</div>
<div class="row article-footer"><div class="span7 meta"><span class="sociallinksunicode social">
<a href="https://twitter.com/home?status=$url$" target="_blank"><i class="icon-twitter"></i></a>&nbsp;
<a href="http://www.facebook.com/sharer/sharer.php?u=$url$" target="_blank"><i class="icon-facebook"></i></a>&nbsp;
<a href="https://plus.google.com/share?url=$url$" target="_blank"><i class="icon-google-plus"></i></a></span>
</div>
</div>
</div>
<div class="footer"><div class="container"><div class="row"><div class="span12"><ul class="menu"><li><a href="https://www.schoolofhaskell.com/">School</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user">Users</a>
</li>

<li><a class="brand" href="https://fpcomplete.com">Sponsored by:
<img src="/static/img/logo.png" title="FPComplete">
</a>
</li>
</ul>
</div>
</div>
<div class="row"><div class="span12"></div>
</div>
</div>
</div>
<link rel="stylesheet" type="text/css" href="/static/bootstrap/css/bootstrap-responsive.css" />
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script><script src="https://www.schoolofhaskell.com/static/combined/Y-3k9_tW.js"></script><script>$(function(){
  $("a.logout").click(function(){
    var form = $("<form method='post'/>");
    form.attr("action", $(this).attr("href"));
    $("body").append(form);
    form.submit();
    return false;
  });
});

$(function(){
    $('.sociallinksunicode a').each(function(){
        $(this).attr('href',$(this).attr('href').replace('$url$',document.location));
    });
});

$(function(){
  // If we need to select a user/select a password then show the
  // details confirmation form, otherwise enable the getting started
  // section.
  if($('.alert-block a').text().match(/(selected a username|change your password)/)) {
    $("#confirm-details").show();
    $("#confirm-details #inputUsername").focus();
  } else {
    $("#get-started").removeClass('disabled').addClass('enabled');
  }

  // For lack of a plain HTML validation story this will do.
  $('.welcome-page').each(function(){
    $('form').submit(check);
  });
  function check(){
    setTimeout(check,500);
    var error = false;
    $('.error').removeClass('error');
    $('#enter-details input').each(function(){
      if($(this).val() == '') {
        $(this).parent().parent().addClass('error');
        error = true;
      }
    });
    if(error) return false;
    if($('[name=password]').val() == $('[name=confirm]').val()) {
      $('#confirm').removeClass('error');
      return true;
    } else {
      $('#confirm').addClass('error');
      return false;
    }
  }
});

$(function(){
  // When scrolling over a snippet editor, activate the "clone in IDE" popovers
  $('article').each(function(){
    var n = 100;
    var wait = 10000;
    function check(){
      if($('.clone').length == 0) {
        setTimeout(check,n);
        return;
      }
      var activated = $.cookie('clone-popover');
      if (activated) return;
      var activate = false;
      $('.controlsRun:onScreen').each(function(){
        $.cookie('clone-popover', 'true', { expires: 30, path: '/' });
        activate = true;
        return false;
      });
      if(activate) {
          $('.clone').each(function(){
              // The bootstrap API is rather unreasonable to say the
              // least.
              next = $(this).parent();
              var title = next.attr('title');
              next.attr('data-content',$(this).attr('data-content'));
              next.attr('title',$(this).attr('title'));
              next.popover('show',{
                  title: $(this).attr('title')
              });
              next.attr('title',title);
          });
          setTimeout(function(){
              $('.clone').each(function(){
                  $(this).parent().popover('hide');
              });
          },wait);
      } else {
        setTimeout(check,n);
      }
    }
    setTimeout(check,n);
  });
});

// onScreen jQuery plugin v0.2.1
// (c) 2011-2013 Ben Pickles
//
// http://benpickles.github.com/onScreen
//
// Released under MIT license.
(function(a){a.expr[":"].onScreen=function(b){var c=a(window),d=c.scrollTop(),e=c.height(),f=d+e,g=a(b),h=g.offset().top,i=g.height(),j=h+i;return h>=d&&h<f||j>d&&j<=f||i>e&&h<=d&&j>=f}})(jQuery);

/*!
 * jQuery Cookie Plugin v1.1
 * https://github.com/carhartl/jquery-cookie
 *
 * Copyright 2011, Klaus Hartl
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.opensource.org/licenses/GPL-2.0
 */
(function($, document) {

  var pluses = /\+/g;
  function raw(s) {
    return s;
  }
  function decoded(s) {
    return decodeURIComponent(s.replace(pluses, ' '));
  }

  $.cookie = function(key, value, options) {

    // key and at least value given, set cookie...
    if (arguments.length > 1 && (!/Object/.test(Object.prototype.toString.call(value)) || value == null)) {
      options = $.extend({}, $.cookie.defaults, options);

      if (value == null) {
	options.expires = -1;
      }

      if (typeof options.expires === 'number') {
	var days = options.expires, t = options.expires = new Date();
	t.setDate(t.getDate() + days);
      }

      value = String(value);

      return (document.cookie = [
	encodeURIComponent(key), '=', options.raw ? value : encodeURIComponent(value),
	options.expires ? '; expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE
	options.path    ? '; path=' + options.path : '',
	options.domain  ? '; domain=' + options.domain : '',
	options.secure  ? '; secure' : ''
      ].join(''));
    }

    // key and possibly options given, get cookie...
    options = value || $.cookie.defaults || {};
    var decode = options.raw ? raw : decoded;
    var cookies = document.cookie.split('; ');
    for (var i = 0, parts; (parts = cookies[i] && cookies[i].split('=')); i++) {
      if (decode(parts.shift()) === key) {
	return decode(parts.join('='));
      }
    }
    return null;
  };
  $.cookie.defaults = {};})(jQuery, document);
</script><!--[if lt IE 10]><script src="https://www.schoolofhaskell.com/static/design/js/ie.js?etag=ayV2DuJ0"></script><![endif]--><script>if(!window.location.href.match(/localhost/)){var track = '/tutorial/school/starting-with-haskell/libraries-and-frameworks/text-manipulation/attoparsec';
window._gaq = [['_setAccount','UA-36928035-1'],track != ''? ['_trackPageview',track] : ['_trackPageview']
,['_trackPageLoadTime']];window._gaq.push(['_setCustomVar',1,'Section','School of Haskell',3]);
window._gaq.push(['_setCustomVar',2,'User Type','Visitor',1]);
(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);

})();}</script>
<!-- Prompt IE 6 users to install Chrome Frame. Remove this if you want to support IE 6.  chromium.org/developers/how-tos/chrome-frame-getting-started --><!--[if lt IE 7 ]><script src="//ajax.googleapis.com/ajax/libs/chrome-frame/1.0.3/CFInstall.min.js"></script><script>window.attachEvent('onload',function(){CFInstall.check({mode:'overlay'})})</script><![endif]--></body></html>