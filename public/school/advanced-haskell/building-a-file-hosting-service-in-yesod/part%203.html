<!DOCTYPE html>
<html><head><title>Part 3 - School of Haskell | School of Haskell</title><meta http-equiv="x-ua-compatible" content="IE=9"><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="google-site-verification" content="Rfxk2TdeMMXEXHgJ2_OO8Rt3hPbQSDao0OXQV_n6z_s" /><link href="//fonts.googleapis.com/css?family=Merriweather" rel="stylesheet" type="text/css"><link href="https://www.schoolofhaskell.com/recent-content/feed" type="application/rss+xml" rel="alternate" title="Recently published content">
<link rel="stylesheet" href="https://www.schoolofhaskell.com/static/combined/UlwEHVcM.css"><style>.social{margin-right:1em}h1{font-family:Merriweather !important}article{font-family:Merriweather !important}article li{font-family:Merriweather !important;line-height:1.6em}h1,h2,h3,h4,h4,h5{font-family:Merriweather !important}.editor p{font-family:Frutiger, "Frutiger Linotype", Univers, Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans Condensed", "Liberation Sans", "Nimbus Sans L", Tahoma, Geneva, "Helvetica Neue", Helvetica, Arial, sans-serif}.article-footer{border-top:1px solid #ddd;padding-top:1em;margin-top:1em}body{font-size:16px !important}.navbar .navbar-inner{background:#3c3f41}.navbar .brand{font-size:14px}.navbar .brand img{width:6em}.navbar .icon-wrench{margin:0 -0.5em 0 -0.5em;padding:0 1em 0 1em;height:20px}.navbar-inverse .nav .active a{background:#333638}.navbar-inverse .nav > li > a{color:#a7a7a7
}.navbar-inverse .btn-navbar{background:#333638}.navbar-inverse .nav > li a:hover,.navbar-inverse .btn{background:#333537 !important}@media (max-width: 979px) {.icon-wrench{padding-left:1em !important}}.breadcrumb{border-top-left-radius:0;border-top-right-radius:0}h1{margin-top:20px}.breadcrumb-container + .main-content h1{margin-top:0}.footer{padding:30px 0;margin-top:70px;border-top:1px solid #e5e5e5;background-color:#f5f5f5}.footer ul.footer-menu{list-style-type:none}.footer ul.footer-menu li{display:inline-block}.footer ul.footer-menu li + li{margin-left:0.5em}.footer ul.footer-menu li + li:before{margin-right:0.5em;content:"Â·";color:#999}.footer ul.menu li{display:inline-block}.footer ul.menu li + li{margin-left:0.5em}.footer .copyright{margin-left:25px}.main-content{min-height:100%}.gravatar{width:80px;height:80px;border-radius:2px;background:#eee}.empty-gravatar{width:0}.container{font-family:"Segoe UI", Candara, "Bitstream Vera Sans", "DejaVu Sans", "Bitstream Vera Sans", "Trebuchet MS", Verdana, "Verdana Ref", sans-serif}.container h1,.container h2,.container h4,.container h4,.container h5{font-family:"Segoe UI", Candara, "Bitstream Vera Sans", "DejaVu Sans", "Bitstream Vera Sans", "Trebuchet MS", Verdana, "Verdana Ref", sans-serif}article{font-family:Merriweather !important}article h1{font-family:Merriweather !important}article li{font-family:Merriweather !important;line-height:1.6em}article li + li{margin-top:0.5em}article div.code{background:#f9f9f9;border:1px solid #d1d1d1;position:relative;border-radius:0.2em;margin:0.25em 0 0.75em 0;min-height:2.5em}article code{color:#005580;font-size:14px;white-space:pre}article a.hoogle > code{color:#0088cc;font-size:14px;white-space:pre;border:0}article .expand-code{display:none}article pre{overflow:auto;word-wrap:normal}article code.active{display:block;max-height:430px}article h1{font-size:31.5px}article h3{font-size:17.5px}article h4{font-size:14px}article h5,article h6{font-size:11.9px}article p{line-height:1.7em}article h1 code,article h2 code,article h3 code,article h4 code,article h5 code,article h6 code{font-size:inherit !important}article h1 a,article h2 a,article h3 a,article h4 a,article h5 a,article h6 a{color:#444}article h1 a:before,article h2 a:before,article h3 a:before,article h4 a:before,article h5 a:before,article h6 a:before{margin-left:-1.5em;padding-right:0.5em;font-family:fontawesome;content:"\f0c1";font-size:20px;color:#fff}article h1 a:hover,article h2 a:hover,article h3 a:hover,article h4 a:hover,article h5 a:hover,article h6 a:hover{text-decoration:none;color:#0088cc}article h1 a:hover:before,article h2 a:hover:before,article h3 a:hover:before,article h4 a:hover:before,article h5 a:hover:before,article h6 a:hover:before{color:#888}article h2{font-size:24.5px}article .popover{font-family:actor}article .popover h3.popover-title{font-family:actor !important;font-size:1em}article .popover .popover-content{width:15em;font-size:1em}article .controlsRun{display:block;padding:0.5em;text-align:right;background:#f2f2f2}article .controlsRun a.clone{margin-right:1em;font-family:actor;text-decoration:none}article .controlsRun a.clone span{padding-left:0.5em}article .controlsRun a.run,article .controlsRun a.reset,article .controlsRun a.show-code{font-size:16px}article .controlsRun a.run span,article .controlsRun a.reset span,article .controlsRun a.show-code span{display:none}article .controlsRun a.reset{margin-left:0.5em;color:#a2becc}article .controlsRun a.reset{display:none}article .controlsRun a.show-code{margin-right:0.75em}article .controlsRun a.run:hover,article .controlsRun a.show-code:hover{text-decoration:none}article .controlsRun a.show-code.active{color:#DC0D0D}article .controlsRun a[disabled]{color:#a2becc;cursor:default}article .collapse-area .collapse-header{background:#0088cc;color:#fff;padding:0.3em;cursor:pointer}article .collapse-area .hidden-toggle:before{content:"\f0d7";font-family:fontawesome;margin-right:0.5em;margin-left:0.25em}article .collapse-area .collapsed-files{overflow:auto;height:auto}article .collapse-area.collapse-disabled{display:none}article .collapse-area.collapse-area-off .collapsed-files{height:0px;overflow:hidden}article .collapse-area.collapse-area-off .hidden-toggle:before{content:"\f0da"}article .snippet-stdio .stdout{margin:0.5em;padding-right:2em;position:relative;word-wrap:break-word}article .snippet-stdio .stdin{-webkit-box-shadow:none;-moz-box-shadow:none;box-shadow:none;-webkit-transition:none;-moz-transition:none;-o-transition:none;transition:none;padding:0;margin:0}article .hoogle-results{margin:0.25em}article .hoogle-results .hoogle-inner{background:#fff;padding:0.5em;border-radius:3px;border:1px solid #ddd}article .hoogle-results .hoogle-inner .close-link{position:relative;float:right;margin-top:-0.5em;margin-right:-0.5em}article .snippet-output-errors{margin:1em 0.5em 0.5em 0.5em;position:relative}article .snippet-output-errors ul{list-style-type:none;margin:0;position:relative}article .snippet-output-errors pre{border:0;border-radius:0;padding:0.25em;margin:0;background:inherit;color:inherit}article .snippet-output-errors .close-link{color:inherit;background:inherit}article .snippet-editors{z-index:0;padding:0.25em}article .close-link{padding:0.5em;background:#eaeaea;border-bottom-left-radius:0.2em;border-top-right-radius:0.2em;position:absolute;top:0;right:0}article .close-link:hover{text-decoration:none}article .snippet-title{padding:0.5em 0 0 0.5em}article .snippet-title .snippet-icon{font-family:FontAwesome;display:inline-block;margin-right:0.5em}article .fullModuleCode + div .snippet-title{margin-top:0.5em;border-top:1px solid #ccc;padding-top:0.5em}article .CodeMirror{height:auto;min-height:1em;line-height:1.5em;background:transparent;font-size:14px !important}article .CodeMirror .highlighted{background:rgba(250, 210, 0, 0.45) !important}article .CodeMirror-widget{margin-left:2em;line-height:1.8}article .CodeMirror.collapsed{height:10em !important}article .editor .expander{text-align:center;display:block;padding:0.5em;text-decoration:none;border-bottom-left-radius:2px;border-bottom-right-radius:2px}article .editor .expander .ellipsis{background:white;border:1px solid #ccc;padding:0 0.5em;height:1em;line-height:0.5em;display:inline-block;color:#555;cursor:pointer}article .editor .expander .ellipsis:hover{background:#ddd;color:#333}article .web-runner{margin:0.5em;padding:0.5em;border:1px solid #ccc;border-radius:3px;background:#f5f5f5}article .web-runner iframe{border:0;margin-top:0.5em;margin-bottom:0;background:white}article .web-runner .controls i{cursor:pointer;color:#0088cc}article .web-runner .controls i:hover{color:#222}article .web-runner .controls i + i{margin-left:0.5em}article .web-runner .controls .icon-remove{float:right}article .hidden{display:block;visibility:visible}article .controlsShowHide{margin-bottom:0.5em}.tutorial-body{float:left !important}.tutorial-nav{float:right !important}@media (max-width: 979px) {.related-content{float:right}.author-name{display:block;margin-left:20px !important;padding-left:5px;margin-top:5px}article h1 a:hover:before,article h2 a:hover:before,article h3 a:hover:before,article h4 a:hover:before,article h5 a:hover:before,article h6 a:hover:before{color:#fff}.tutorial-nav{float:none !important;width:auto !important}.tutorial-body{float:none !important;width:auto !important}}@media (min-width: 980px) and (max-width: 1199px) {.navbar-search{display:none}.tutorial-nav{width:200px}.tutorial-body{width:720px}}#accountPage h1{margin:20px 0 0 0}#accountPage h2{font-size:20px}.group-contents .span8{float:left}.group-contents .span4{float:right}.container > .alert-block{margin-top:1em}.alert{color:#aa874a
}.social{margin-bottom:.8em;display:block}.social a{text-decoration:none}.social i{font-size:1.1em;color:#fff;padding:0.25em;border-radius:0.25em;width:1em;display:inline-block;text-align:center}.social i.icon-twitter{background:#0088cc}.social i.icon-facebook{background:#3b5998
  }.social i.icon-google-plus{background:#dd4b39
  }.well pre{background:#fcfcfc}.well h2{margin-top:0}code{color:#005580;font-size:14px;white-space:pre}</style><!--[if lt IE 8]><link rel="stylesheet" href="https://www.schoolofhaskell.com/static/design/css/ie7.css?etag=TSMl9x1V"><![endif]--><!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]--></head><body class="not-logged-in" itemscope itemtype="http://schema.org/Product"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-H62P" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-H62P');</script><div class="navbar navbar-inverse navbar-static-top"><div class="navbar-inner"><div class="container"><a class="btn btn-navbar" type="button" data-toggle="collapse" data-target=".nav-collapse"><span class="icon-bar"></span>
<span class="icon-bar"></span>
<span class="icon-bar"></span>
</a>
<a class="brand" href="/"><img src="/static/img/haskell-logo-wide.png" title="School of Haskell">
</a>
<div class="nav-collapse collapse"><ul class="nav"><li><a href="https://www.schoolofhaskell.com/">School</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user">Users</a>
</li>
</ul>
<form class="navbar-search pull-left" action="https://www.schoolofhaskell.com/search"><input class="search-query" type="text" placeholder="Search" name="search">
</form>
</div>
</div>
</div>
</div>
<div class="container breadcrumb-container"><div class="row"><div class="span12"><ul class="breadcrumb"><li><a href="https://www.schoolofhaskell.com/">School of Haskell</a>
<span class="divider">/</span>
</li>
<li><a href="https://www.schoolofhaskell.com/school/advanced-haskell">Advanced Haskell</a>
<span class="divider">/</span>
</li>
<li><a href="https://www.schoolofhaskell.com/school/advanced-haskell/building-a-file-hosting-service-in-yesod">Building a File Hosting Service in Yesod</a>
<span class="divider">/</span>
</li>
<li><a href="https://www.schoolofhaskell.com/school/advanced-haskell/building-a-file-hosting-service-in-yesod/part%203">Part 3</a>
</li>
</ul>
</div>
</div>
</div>
<div class="container main-content"><div class="row"><div class="span12"><h1 itemprop="name">Part 3</h1>
</div>
</div>
<div class="row"><div class="span7 meta"><p><span class="date">15 Dec 2014</span>
<span class="author"><a href="https://www.schoolofhaskell.com/user/school">School of Haskell</a>
</span>
<span class="view-edit-link pull-right"><a class="view-source-link" href="https://www.schoolofhaskell.com/tutorial-raw/30/03a459e5cda048b15a0947d34348da3ca275575f">View Markdown source</a>
</span>
</p>
<p class="tags"></p>
</div>
</div>
<div class="row"><div class="span7 meta"><span class="sociallinksunicode social">
<a href="https://twitter.com/home?status=$url$" target="_blank"><i class="icon-twitter"></i></a>&nbsp;
<a href="http://www.facebook.com/sharer/sharer.php?u=$url$" target="_blank"><i class="icon-facebook"></i></a>&nbsp;
<a href="https://plus.google.com/share?url=$url$" target="_blank"><i class="icon-google-plus"></i></a></span>
</div>
</div>
<p class="alert">As of March 2020, School of Haskell has been switched to read-only mode.</p>
<div class="row" itemprop="desc"><div class="span4 tutorial-nav"><div class="related-content"><ul class="nav nav-tabs nav-stacked"><li><script>reddit_target='fpcomplete'</script>
<script src="https://redditstatic.s3.amazonaws.com/button/button1.js"></script>
</li>
<li><a href="https://www.schoolofhaskell.com/user/school/advanced-haskell/building-a-file-hosting-service-in-yesod/part%202">Previous content: Part 2</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user/school/advanced-haskell/building-a-file-hosting-service-in-yesod/part%204">Next content: Part 4</a>
</li>
<li><a href="https://www.schoolofhaskell.com/school/advanced-haskell/building-a-file-hosting-service-in-yesod">Go up to: Building a File Hosting Service in Yesod</a>
</li>
</ul>

</div>
<div class="aside"><h3>Sections</h3>
<ul><li><a href="#storing-file-contents">Storing File Contents</a></li><li><a href="#file-summary-page">File Summary Page</a></li><li><a href="#improved-styling">Improved Styling</a><ul><li><a href="#local-style-sheets">Local Style Sheets</a></li><li><a href="#global-style-sheets">Global Style Sheets</a></li></ul></li><li><a href="#summary">Summary</a></li></ul></div>
</div>
<div class="span8 tutorial-body" data-environment="ghc-7.8-stable-14.09">
<article><p>This is part 3 of a series where we develop a file hosting web application. We
ended the previous entry with the ability to upload files, but only their
names were stored. Today we are going to store file contents as well. A
summary page for each file will display the contents if possible. The ability
to download files from the server will be added next time.</p><h1 id="storing-file-contents"><a href="#storing-file-contents">Storing File Contents</a></h1><p>We need a place to store file contents. One way to go about doing this would
be to create real files on the server's hard drive. We would recommend this
approach if we were storing many files, keeping them for a long period of
time, or wanted to have access to them from outside of the application. To
keep things simple we'll just keep the file contents in memory along with
information about them. This means that our application will reset it's data
each time it runs.</p><p>The application state is currently just a list of filenames. Let's extend this
to an association list of file names to contents. Lazy bytestrings are the
most convenient type for our use. Other types such as strict bytestrings or
vectors of bytes would have worked as well.</p><pre><code class="active haskell web">{-# START_FILE Dispatch.hs #-}
-- show
-- /show
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE TypeFamilies #-}

module Dispatch where

import Yesod

import Foundation
import Handler.Home

mkYesodDispatch &quot;App&quot; resourcesApp
{-# START_FILE Foundation.hs #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE TypeFamilies #-}

-- show
module Foundation where

import Control.Concurrent.STM
{-hi-}import Data.ByteString.Lazy (ByteString){-/hi-}
import Data.Text (Text)

import Yesod

-- data App = App (TVar [Text])
{-hi-}data App = App (TVar [(Text, ByteString)]){-/hi-}
instance Yesod App

instance RenderMessage App FormMessage where
  renderMessage _ _ = defaultFormMessage

mkYesodData &quot;App&quot; $(parseRoutesFile &quot;config/routes&quot;)

getList :: Handler [Text]
getList = do
    App tstate &lt;- getYesod
    -- liftIO $ readTVarIO tstate
{-hi-}    state &lt;- liftIO $ readTVarIO tstate
    return $ map fst state{-/hi-}

-- addFile :: App -&gt; Text -&gt; Handler ()
{-hi-}addFile :: App -&gt; (Text, ByteString) -&gt; Handler (){-/hi-}
addFile (App tstore) op =
    liftIO . atomically $ do
        modifyTVar tstore $ \ ops -&gt; op : ops
-- /show
{-# START_FILE Main.hs #-}
-- show
-- /show
{-# LANGUAGE OverloadedStrings #-}

module Main where

import Control.Concurrent.STM

import Yesod

import Dispatch ()
import Foundation

main :: IO ()
main = do
    tfilenames &lt;- atomically $ newTVar []
    warpEnv $ App tfilenames
{-# START_FILE Handler/Home.hs #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE TypeFamilies #-}

-- show
module Handler.Home where

{-hi-}import Data.Conduit
import Data.Conduit.Binary{-/hi-}
import Data.Default
import Yesod
import Yesod.Default.Util
import Control.Monad.Trans.Resource (runResourceT)

import Foundation

getHomeR :: Handler Html
getHomeR = do
    (formWidget, formEncType) &lt;- generateFormPost uploadForm
    filenames &lt;- getList
    defaultLayout $ do
        setTitle &quot;File Processor&quot;
        $(widgetFileNoReload def &quot;home&quot;)

postHomeR :: Handler Html
postHomeR = do
    ((result, _), _) &lt;- runFormPost uploadForm
    case result of
      FormSuccess fi -&gt; do
        app &lt;- getYesod
        -- addFile app $ fileName fi
{-hi-}        fileBytes &lt;- runResourceT $ fileSource fi $$ sinkLbs
        addFile app (fileName fi, fileBytes){-/hi-}
      _ -&gt; return ()
    redirect HomeR

uploadForm = renderDivs $ fileAFormReq &quot;file&quot;
-- /show
{-# START_FILE templates/home.hamlet #-}
-- show
-- /show
&lt;h2&gt;Previously submitted files
$if null filenames
    &lt;p&gt;No files have been uploaded yet.
$else
    &lt;ul&gt;
        $forall filename &lt;- filenames
            &lt;li&gt;#{filename}
&lt;h2&gt;Submit new file
&lt;form method=post action=@{HomeR} enctype=#{formEncType}&gt;
  ^{formWidget}
  &lt;input type=&quot;submit&quot; value=&quot;Upload&quot;&gt;
{-# START_FILE config/routes #-}
-- show
-- /show
/ HomeR GET POST</code></pre><p>The foundation type, <code>App</code>, has been changed to <code>data App = App (TVar [(Text,
ByteString)])</code>. This prompted a few trivial changes to the collect of accessor
functions in &quot;Foundation.hs&quot;. The type signature for <code>addFile</code> was updated,
but its body remained the same. The <code>getList</code> action was changed to discard
file contents. Keeping these accessor functions in &quot;Foundation.hs&quot; allows us
to update them without touching code in other modules for the most part.</p><p>The <code>postHomeR</code> handler is where we extract file contents into a lazy
bytestring. Yesod achieves high performance by allowing our handler to work
with the incoming data stream as it arrives. The line assigning <code>fileBytes</code>
converts from Yesod's native byte stream to a lazy <code>ByteString</code>.</p><h1 id="file-summary-page"><a href="#file-summary-page">File Summary Page</a></h1><p>Until now we've been using a single page. We'd like to add a second route for
displaying details about files that have been uploaded. Each file will be
identified by its file name in the URL. The key concept here is that route
handlers are able to accept arguments which Yesod parses from the URL.</p><pre><code class="active haskell web">{-# START_FILE Dispatch.hs #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE TypeFamilies #-}

-- show
module Dispatch where

import Yesod

import Foundation
import Handler.Home
{-hi-}import Handler.Preview{-/hi-}

mkYesodDispatch &quot;App&quot; resourcesApp
-- /show
{-# START_FILE Foundation.hs #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE TypeFamilies #-}

-- show
module Foundation where

import Control.Concurrent.STM
import Data.ByteString.Lazy (ByteString)
import Data.Text (Text)
{-hi-}import qualified Data.Text as Text{-/hi-}

import Yesod

data App = App (TVar [(Text, ByteString)])
instance Yesod App

instance RenderMessage App FormMessage where
  renderMessage _ _ = defaultFormMessage

mkYesodData &quot;App&quot; $(parseRoutesFile &quot;config/routes&quot;)

getList :: Handler [Text]
getList = do
    App tstate &lt;- getYesod
    state &lt;- liftIO $ readTVarIO tstate
    return $ map fst state

addFile :: App -&gt; (Text, ByteString) -&gt; Handler ()
addFile (App tstore) op =
    liftIO . atomically $ do
        modifyTVar tstore $ \ ops -&gt; op : ops

{-hi-}getById :: Text -&gt; Handler ByteString
getById ident = do
    App tstore &lt;- getYesod
    operations &lt;- liftIO $ readTVarIO tstore
    case lookup ident operations of
      Nothing -&gt; notFound
      Just bytes -&gt; return bytes{-/hi-}
-- /show
{-# START_FILE Main.hs #-}
-- show
-- /show
{-# LANGUAGE OverloadedStrings #-}

module Main where

import Control.Concurrent.STM

import Yesod

import Dispatch ()
import Foundation

main :: IO ()
main = do
    tfilenames &lt;- atomically $ newTVar []
    warpEnv $ App tfilenames
{-# START_FILE Handler/Home.hs #-}
-- show
-- /show
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE TypeFamilies #-}

module Handler.Home where

import qualified Data.ByteString.Lazy as L
import Data.Conduit
import Data.Conduit.Binary
import Data.Default
import Yesod
import Yesod.Default.Util
import Control.Monad.Trans.Resource (runResourceT)

import Foundation

getHomeR :: Handler Html
getHomeR = do
    (formWidget, formEncType) &lt;- generateFormPost uploadForm
    filenames &lt;- getList
    defaultLayout $ do
        setTitle &quot;File Processor&quot;
        $(widgetFileNoReload def &quot;home&quot;)

postHomeR :: Handler Html
postHomeR = do
    ((result, _), _) &lt;- runFormPost uploadForm
    case result of
      FormSuccess fi -&gt; do
        app &lt;- getYesod
        fileBytes &lt;- runResourceT $ fileSource fi $$ sinkLbs
        addFile app (fileName fi, fileBytes)
      _ -&gt; return ()
    redirect HomeR

uploadForm = renderDivs $ fileAFormReq &quot;file&quot;
{-# START_FILE Handler/Preview.hs #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE TemplateHaskell #-}

-- show
{-hi-}module Handler.Preview where

import Control.Exception hiding (Handler)
import qualified Data.ByteString.Lazy as LB
import Data.Default
import Data.Text (Text)
import qualified Data.Text as Text
import qualified Data.Text.Lazy as LT
import qualified Data.Text.Lazy.Encoding as LT
import Text.Blaze
import Yesod
import Yesod.Default.Util

import Foundation

getPreviewR :: Text -&gt; Handler Html
getPreviewR filename = do
    bytes &lt;- getById filename
    defaultLayout $ do
        setTitle . toMarkup $ &quot;File Processor - &quot; `Text.append` filename
        previewBlock &lt;- liftIO $ preview bytes
        $(widgetFileNoReload def &quot;preview&quot;)

preview :: LB.ByteString -&gt; IO Widget
preview bytes = do
    eText &lt;- try . evaluate $ LT.decodeUtf8 bytes :: IO (Either SomeException LT.Text)
    return $ case eText of
      Left _ -&gt; errorMessage
      Right text -&gt; [whamlet|&lt;pre&gt;#{text}|]
  where
    errorMessage = [whamlet|&lt;pre&gt;Unable to display file contents.|]{-/hi-}
-- /show
{-# START_FILE templates/home.hamlet #-}
&lt;h2&gt;Previously submitted files
$if null filenames
    &lt;p&gt;No files have been uploaded yet.
$else
    &lt;ul&gt;
        $forall filename &lt;- filenames
$#            &lt;li&gt;#{filename}
{-hi-}            &lt;li&gt;
                &lt;a href=@{PreviewR filename}&gt;#{filename}{-/hi-}
&lt;h2&gt;Submit new file
&lt;form method=post action=@{HomeR} enctype=#{formEncType}&gt;
  ^{formWidget}
  &lt;input type=&quot;submit&quot; value=&quot;Upload&quot;&gt;
{-# START_FILE templates/preview.hamlet #-}
{-hi-}&lt;a href=@{HomeR}&gt;home
&lt;h1&gt;#{filename}
&lt;p&gt;
  ^{previewBlock}{-/hi-}
{-# START_FILE config/routes #-}
/           HomeR    GET POST
{-hi-}/file/#Text PreviewR GET{-/hi-}</code></pre><p>Two new files were added. One is a Hamlet template for the preview page. The
other is a route handler for it. The &quot;config/routes&quot; file gained an entry to
define the new route. The part reading <code>#Text</code> is a placeholder which becomes
an argument to any handler functions. Hooks to link our handlers to route
paths are written for us in &quot;Dispatch.hs&quot;, which is why that module imports
the &quot;Handler.Preview&quot; module.</p><p>The handler for <code>PreviewR</code>, <code>getPreviewR</code> should be easy to understand. It
takes an argument which Yesod parses from the supplied URL. It's possible that
no file exists by the given name. In that case <code>getById</code> will abort the
handler by sending an error response.</p><p>The <code>preview</code> action may be difficult to follow. Depending on the type of
file, it would be nice to generate a block of HTML to display a preview of
it. For now we've written support for text documents. The</p><a class="hoogle" href="https://www.stackage.org/lts/hoogle?q=decodeUtf8" title="Hoogle search for: decodeUtf8"><code>decodeUtf8</code></a> function does the conversion, but throws an
exception in the IO monad if the bytestring fails to parse. The reason for
calling <a class="hoogle" href="https://www.stackage.org/lts/hoogle?q=evaluate" title="Hoogle search for: evaluate"><code>evaluate</code></a> is that we want to ensure the error is caught
immediately.<p>Our template for the main page was updated so that file names are linked to
their summary page. Try running the example to see how everything works. See
if you can modify the home template so that it includes a hyperlink to a
nonexistant file. We'll include a solution below.</p><div class="hidden"><pre><code class="active haskell web">{-# START_FILE Dispatch.hs #-}
-- show
-- /show
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE TypeFamilies #-}

module Dispatch where

import Yesod

import Foundation
import Handler.Home
import Handler.Preview

mkYesodDispatch &quot;App&quot; resourcesApp
{-# START_FILE Foundation.hs #-}
-- show
-- /show
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE TypeFamilies #-}

module Foundation where

import Control.Concurrent.STM
import Data.ByteString.Lazy (ByteString)
import Data.Text (Text)
import qualified Data.Text as Text

import Yesod

data App = App (TVar [(Text, ByteString)])
instance Yesod App

instance RenderMessage App FormMessage where
  renderMessage _ _ = defaultFormMessage

mkYesodData &quot;App&quot; $(parseRoutesFile &quot;config/routes&quot;)

getList :: Handler [Text]
getList = do
    App tstate &lt;- getYesod
    state &lt;- liftIO $ readTVarIO tstate
    return $ map fst state

addFile :: App -&gt; (Text, ByteString) -&gt; Handler ()
addFile (App tstore) op =
    liftIO . atomically $ do
        modifyTVar tstore $ \ ops -&gt; op : ops

getById :: Text -&gt; Handler ByteString
getById ident = do
    App tstore &lt;- getYesod
    operations &lt;- liftIO $ readTVarIO tstore
    case lookup ident operations of
      Nothing -&gt; notFound
      Just bytes -&gt; return bytes
{-# START_FILE Main.hs #-}
-- show
-- /show
{-# LANGUAGE OverloadedStrings #-}

module Main where

import Control.Concurrent.STM

import Yesod

import Dispatch ()
import Foundation

main :: IO ()
main = do
    tfilenames &lt;- atomically $ newTVar []
    warpEnv $ App tfilenames
{-# START_FILE Handler/Home.hs #-}
-- show
-- /show
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE TypeFamilies #-}

module Handler.Home where

import qualified Data.ByteString.Lazy as L
import Data.Conduit
import Data.Conduit.Binary
import Data.Default
import Yesod
import Yesod.Default.Util
import Control.Monad.Trans.Resource (runResourceT)

import Foundation

getHomeR :: Handler Html
getHomeR = do
    (formWidget, formEncType) &lt;- generateFormPost uploadForm
    filenames &lt;- getList
    defaultLayout $ do
        setTitle &quot;File Processor&quot;
        $(widgetFileNoReload def &quot;home&quot;)

postHomeR :: Handler Html
postHomeR = do
    ((result, _), _) &lt;- runFormPost uploadForm
    case result of
      FormSuccess fi -&gt; do
        app &lt;- getYesod
        fileBytes &lt;- runResourceT $ fileSource fi $$ sinkLbs
        addFile app (fileName fi, fileBytes)
      _ -&gt; return ()
    redirect HomeR

uploadForm = renderDivs $ fileAFormReq &quot;file&quot;
{-# START_FILE Handler/Preview.hs #-}
-- show
-- /show
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE TemplateHaskell #-}

module Handler.Preview where

import Control.Exception hiding (Handler)
import qualified Data.ByteString.Lazy as LB
import Data.Default
import Data.Text (Text)
import qualified Data.Text as Text
import qualified Data.Text.Lazy as LT
import qualified Data.Text.Lazy.Encoding as LT
import Text.Blaze
import Yesod
import Yesod.Default.Util

import Foundation

getPreviewR :: Text -&gt; Handler Html
getPreviewR filename = do
    bytes &lt;- getById filename
    defaultLayout $ do
        setTitle . toMarkup $ &quot;File Processor - &quot; `Text.append` filename
        previewBlock &lt;- liftIO $ preview bytes
        $(widgetFileNoReload def &quot;preview&quot;)

preview :: LB.ByteString -&gt; IO Widget
preview bytes = do
    eText &lt;- try . evaluate $ LT.decodeUtf8 bytes :: IO (Either SomeException LT.Text)
    return $ case eText of
      Left _ -&gt; errorMessage
      Right text -&gt; [whamlet|&lt;pre&gt;#{text}|]
  where
    errorMessage = [whamlet|&lt;pre&gt;Unable to display file contents.|]
{-# START_FILE templates/home.hamlet #-}
&lt;h2&gt;Previously submitted files
&lt;ul&gt;
{-hi-}  &lt;li&gt;
    &lt;a href=@{PreviewR &quot;missing.txt&quot;}&gt;missing.txt{-/hi-}
  $forall filename &lt;- filenames
    &lt;li&gt;
      &lt;a href=@{PreviewR filename}&gt;#{filename}
&lt;h2&gt;Submit new file
&lt;form method=post action=@{HomeR} enctype=#{formEncType}&gt;
  ^{formWidget}
  &lt;input type=&quot;submit&quot; value=&quot;Upload&quot;&gt;
{-# START_FILE templates/preview.hamlet #-}
-- show
-- /show
&lt;a href=@{HomeR}&gt;home
&lt;h1&gt;#{filename}
&lt;p&gt;
  ^{previewBlock}
{-# START_FILE config/routes #-}
-- show
-- /show
/           HomeR    GET POST
/file/#Text PreviewR GET</code></pre></div><h1 id="improved-styling"><a href="#improved-styling">Improved Styling</a></h1><p>The application is really coming along. We're able to upload files to a
server, and if they are text files we can read the contents within the
browser. In the next part of this series we'll show you how to turn things
around and let users download files as well. Before this we think it's time to
improve the appearance of our application with CSS styling.</p><h2 id="local-style-sheets"><a href="#local-style-sheets">Local Style Sheets</a></h2><p>Yesod supports a template language for writing CSS called Cassius. We've
been using the <a class="hoogle" href="https://www.stackage.org/lts/hoogle?q=widgetFileNoReload" title="Hoogle search for: widgetFileNoReload"><code>widgetFileNoReload</code></a> template haskell function
to load Hamlet templates. As long as you give your Cassius files the same name
they will be added as well. This is also true of JavaScript. As an example,
The following additional file would add styling to our <code>&lt;pre&gt;</code> tag on the
summary page.</p><p>Go ahead and upload a text file, and then take a look at its summary page to
see the new styling.</p><pre><code class="active haskell web">{-# START_FILE Dispatch.hs #-}
-- show
-- /show
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE TypeFamilies #-}

module Dispatch where

import Yesod

import Foundation
import Handler.Home
import Handler.Preview

mkYesodDispatch &quot;App&quot; resourcesApp
{-# START_FILE Foundation.hs #-}
-- show
-- /show
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE TypeFamilies #-}

module Foundation where

import Control.Concurrent.STM
import Data.ByteString.Lazy (ByteString)
import Data.Text (Text)
import qualified Data.Text as Text

import Yesod

data App = App (TVar [(Text, ByteString)])
instance Yesod App

instance RenderMessage App FormMessage where
  renderMessage _ _ = defaultFormMessage

mkYesodData &quot;App&quot; $(parseRoutesFile &quot;config/routes&quot;)

getList :: Handler [Text]
getList = do
    App tstate &lt;- getYesod
    state &lt;- liftIO $ readTVarIO tstate
    return $ map fst state

addFile :: App -&gt; (Text, ByteString) -&gt; Handler ()
addFile (App tstore) op =
    liftIO . atomically $ do
        modifyTVar tstore $ \ ops -&gt; op : ops

getById :: Text -&gt; Handler ByteString
getById ident = do
    App tstore &lt;- getYesod
    operations &lt;- liftIO $ readTVarIO tstore
    case lookup ident operations of
      Nothing -&gt; notFound
      Just bytes -&gt; return bytes
{-# START_FILE Main.hs #-}
-- show
-- /show
{-# LANGUAGE OverloadedStrings #-}

module Main where

import Control.Concurrent.STM

import Yesod

import Dispatch ()
import Foundation

main :: IO ()
main = do
    tfilenames &lt;- atomically $ newTVar []
    warpEnv $ App tfilenames
{-# START_FILE Handler/Home.hs #-}
-- show
-- /show
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE TypeFamilies #-}

module Handler.Home where

import qualified Data.ByteString.Lazy as L
import Data.Conduit
import Data.Conduit.Binary
import Data.Default
import Yesod
import Yesod.Default.Util
import Control.Monad.Trans.Resource (runResourceT)

import Foundation

getHomeR :: Handler Html
getHomeR = do
    (formWidget, formEncType) &lt;- generateFormPost uploadForm
    filenames &lt;- getList
    defaultLayout $ do
        setTitle &quot;File Processor&quot;
        $(widgetFileNoReload def &quot;home&quot;)

postHomeR :: Handler Html
postHomeR = do
    ((result, _), _) &lt;- runFormPost uploadForm
    case result of
      FormSuccess fi -&gt; do
        app &lt;- getYesod
        fileBytes &lt;- runResourceT $ fileSource fi $$ sinkLbs
        addFile app (fileName fi, fileBytes)
      _ -&gt; return ()
    redirect HomeR

uploadForm = renderDivs $ fileAFormReq &quot;file&quot;
{-# START_FILE Handler/Preview.hs #-}
-- show
-- /show
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE TemplateHaskell #-}

module Handler.Preview where

import Control.Exception hiding (Handler)
import qualified Data.ByteString.Lazy as LB
import Data.Default
import Data.Text (Text)
import qualified Data.Text as Text
import qualified Data.Text.Lazy as LT
import qualified Data.Text.Lazy.Encoding as LT
import Text.Blaze
import Yesod
import Yesod.Default.Util

import Foundation

getPreviewR :: Text -&gt; Handler Html
getPreviewR filename = do
    bytes &lt;- getById filename
    defaultLayout $ do
        setTitle . toMarkup $ &quot;File Processor - &quot; `Text.append` filename
        previewBlock &lt;- liftIO $ preview bytes
        $(widgetFileNoReload def &quot;preview&quot;)

preview :: LB.ByteString -&gt; IO Widget
preview bytes = do
    eText &lt;- try . evaluate $ LT.decodeUtf8 bytes :: IO (Either SomeException LT.Text)
    return $ case eText of
      Left _ -&gt; errorMessage
      Right text -&gt; [whamlet|&lt;pre&gt;#{text}|]
  where
    errorMessage = [whamlet|&lt;pre&gt;Unable to display file contents.|]
{-# START_FILE templates/home.hamlet #-}
-- show
-- /show
&lt;h2&gt;Previously submitted files
$if null filenames
    &lt;p&gt;No files have been uploaded yet.
$else
    &lt;ul&gt;
        $forall filename &lt;- filenames
            &lt;li&gt;
                &lt;a href=@{PreviewR filename}&gt;#{filename}
&lt;h2&gt;Submit new file
&lt;form method=post action=@{HomeR} enctype=#{formEncType}&gt;
  ^{formWidget}
  &lt;input type=&quot;submit&quot; value=&quot;Upload&quot;&gt;
{-# START_FILE templates/preview.hamlet #-}
-- show
-- /show
&lt;a href=@{HomeR}&gt;home
&lt;h1&gt;#{filename}
&lt;p&gt;
  ^{previewBlock}
{-# START_FILE templates/preview.cassius #-}
{-hi-}/* add rounded grey box around text */
pre
    -webkit-border-radius: 5pt
    -moz-border-radius: 5pt
    border-radius: 5pt
    border: 1pt solid #999
    background: #DDD
    margin: 1em
    padding: 1em
    white-space: pre-wrap{-/hi-}
{-# START_FILE config/routes #-}
-- show
-- /show
/           HomeR    GET POST
/file/#Text PreviewR GET</code></pre><h2 id="global-style-sheets"><a href="#global-style-sheets">Global Style Sheets</a></h2><p>For small projects like this one a single, global style sheet is
preferred. We'll delete the &quot;templates/preview.cassius&quot; file. Even in larger
projects it's likely that you will have style sheets which should be applied
to every page. To do this we will customize the behavior of</p><a class="hoogle" href="https://www.stackage.org/lts/hoogle?q=defaultLayout" title="Hoogle search for: defaultLayout"><code>defaultLayout</code></a>. This function does just what it's name
implies. It takes whatever widget content you define, and adds it in addition
to it's own collection of Hamlet, Cassius, and Julius templates.<pre><code class="active haskell web">{-# START_FILE Dispatch.hs #-}
-- show
-- /show
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE TypeFamilies #-}

module Dispatch where

import Yesod

import Foundation
import Handler.Home
import Handler.Preview

mkYesodDispatch &quot;App&quot; resourcesApp
{-# START_FILE Foundation.hs #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE TypeFamilies #-}

-- show
module Foundation where

import Control.Concurrent.STM
import Data.ByteString.Lazy (ByteString)
{-hi-}import Data.Default{-/hi-}
import Data.Text (Text)
import qualified Data.Text as Text
{-hi-}import Text.Hamlet{-/hi-}
import Yesod
{-hi-}import Yesod.Default.Util{-/hi-}

data App = App (TVar [(Text, ByteString)])

-- instance Yesod App
{-hi-}instance Yesod App where
  defaultLayout widget = do
    pc &lt;- widgetToPageContent $ $(widgetFileNoReload def &quot;default-layout&quot;)
    withUrlRenderer $(hamletFile &quot;templates/default-layout-wrapper.hamlet&quot;){-/hi-}

instance RenderMessage App FormMessage where
  renderMessage _ _ = defaultFormMessage

mkYesodData &quot;App&quot; $(parseRoutesFile &quot;config/routes&quot;)

getList :: Handler [Text]
getList = do
    App tstate &lt;- getYesod
    state &lt;- liftIO $ readTVarIO tstate
    return $ map fst state

addFile :: App -&gt; (Text, ByteString) -&gt; Handler ()
addFile (App tstore) op =
    liftIO . atomically $ do
        modifyTVar tstore $ \ ops -&gt; op : ops

getById :: Text -&gt; Handler ByteString
getById ident = do
    App tstore &lt;- getYesod
    operations &lt;- liftIO $ readTVarIO tstore
    case lookup ident operations of
      Nothing -&gt; notFound
      Just bytes -&gt; return bytes
-- /show
{-# START_FILE Main.hs #-}
-- show
-- /show
{-# LANGUAGE OverloadedStrings #-}

module Main where

import Control.Concurrent.STM

import Yesod

import Dispatch ()
import Foundation

main :: IO ()
main = do
    tfilenames &lt;- atomically $ newTVar []
    warpEnv $ App tfilenames
{-# START_FILE Handler/Home.hs #-}
-- show
-- /show
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE TypeFamilies #-}

module Handler.Home where

import qualified Data.ByteString.Lazy as L
import Data.Conduit
import Data.Conduit.Binary
import Data.Default
import Yesod
import Yesod.Default.Util
import Control.Monad.Trans.Resource (runResourceT)

import Foundation

getHomeR :: Handler Html
getHomeR = do
    (formWidget, formEncType) &lt;- generateFormPost uploadForm
    filenames &lt;- getList
    defaultLayout $ do
        setTitle &quot;File Processor&quot;
        $(widgetFileNoReload def &quot;home&quot;)

postHomeR :: Handler Html
postHomeR = do
    ((result, _), _) &lt;- runFormPost uploadForm
    case result of
      FormSuccess fi -&gt; do
        app &lt;- getYesod
        fileBytes &lt;- runResourceT $ fileSource fi $$ sinkLbs
        addFile app (fileName fi, fileBytes)
      _ -&gt; return ()
    redirect HomeR

uploadForm = renderDivs $ fileAFormReq &quot;file&quot;
{-# START_FILE Handler/Preview.hs #-}
-- show
-- /show
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE TemplateHaskell #-}

module Handler.Preview where

import Control.Exception hiding (Handler)
import qualified Data.ByteString.Lazy as LB
import Data.Default
import Data.Text (Text)
import qualified Data.Text as Text
import qualified Data.Text.Lazy as LT
import qualified Data.Text.Lazy.Encoding as LT
import Text.Blaze
import Yesod
import Yesod.Default.Util

import Foundation

getPreviewR :: Text -&gt; Handler Html
getPreviewR filename = do
    bytes &lt;- getById filename
    defaultLayout $ do
        setTitle . toMarkup $ &quot;File Processor - &quot; `Text.append` filename
        previewBlock &lt;- liftIO $ preview bytes
        $(widgetFileNoReload def &quot;preview&quot;)

preview :: LB.ByteString -&gt; IO Widget
preview bytes = do
    eText &lt;- try . evaluate $ LT.decodeUtf8 bytes :: IO (Either SomeException LT.Text)
    return $ case eText of
      Left _ -&gt; errorMessage
      Right text -&gt; [whamlet|&lt;pre&gt;#{text}|]
  where
    errorMessage = [whamlet|&lt;pre&gt;Unable to display file contents.|]
{-# START_FILE templates/default-layout.hamlet #-}
{-hi-}^{widget}{-/hi-}
{-# START_FILE templates/default-layout-wrapper.hamlet #-}
{-hi-}$newline never
$doctype 5
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;#{pageTitle pc}
        ^{pageHead pc}
    &lt;body&gt;
        ^{pageBody pc}{-/hi-}
{-# START_FILE templates/home.hamlet #-}
-- show
-- /show
&lt;h2&gt;Previously submitted files
$if null filenames
    &lt;p&gt;No files have been uploaded yet.
$else
    &lt;ul&gt;
        $forall filename &lt;- filenames
            &lt;li&gt;
                &lt;a href=@{PreviewR filename}&gt;#{filename}
&lt;h2&gt;Submit new file
&lt;form method=post action=@{HomeR} enctype=#{formEncType}&gt;
  ^{formWidget}
  &lt;input type=&quot;submit&quot; value=&quot;Upload&quot;&gt;
{-# START_FILE templates/preview.hamlet #-}
-- show
-- /show
&lt;a href=@{HomeR}&gt;home
&lt;h1&gt;#{filename}
&lt;p&gt;
  ^{previewBlock}
{-# START_FILE config/routes #-}
-- show
-- /show
/           HomeR    GET POST
/file/#Text PreviewR GET</code></pre><p>If you run the previous example you will see that nothing has changed. We've
redefined <a class="hoogle" href="https://www.stackage.org/lts/hoogle?q=defaultLayout" title="Hoogle search for: defaultLayout"><code>defaultLayout</code></a> to do essentially the same thing as
it normally does. The function takes a widget as an argument to be placed in
the output HTML's <code>&lt;body&gt;</code> tag.</p><p>Two template files are used because of the way widgets work. A widget is a
collection of HTML, CSS, and JavaScript. You will mostly be working with
widgets when using Yesod, but the <a class="hoogle" href="https://www.stackage.org/lts/hoogle?q=defaultLayout" title="Hoogle search for: defaultLayout"><code>defaultLayout</code></a> is one place
where widgets cannot be used. By calling <a class="hoogle" href="https://www.stackage.org/lts/hoogle?q=widgetToPageContent" title="Hoogle search for: widgetToPageContent"><code>widgetToPageContent</code></a>,
and then inserting that into a non-widget hamlet file we will be able to treat
our &quot;default-layout&quot; template as a widget.</p><p>Now that we've done this we can simply add a file named
&quot;default-layout.cassius&quot; to apply global style sheets:</p><pre><code class="active haskell web">{-# START_FILE Dispatch.hs #-}
-- show
-- /show
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE TypeFamilies #-}

module Dispatch where

import Yesod

import Foundation
import Handler.Home
import Handler.Preview

mkYesodDispatch &quot;App&quot; resourcesApp
{-# START_FILE Foundation.hs #-}
-- show
-- /show
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE TypeFamilies #-}

module Foundation where

import Control.Concurrent.STM
import Data.ByteString.Lazy (ByteString)
import Data.Default
import Data.Text (Text)
import qualified Data.Text as Text
import Text.Hamlet
import Yesod
import Yesod.Default.Util

data App = App (TVar [(Text, ByteString)])

-- instance Yesod App
instance Yesod App where
  defaultLayout widget = do
    pc &lt;- widgetToPageContent $ $(widgetFileNoReload def &quot;default-layout&quot;)
    withUrlRenderer $(hamletFile &quot;templates/default-layout-wrapper.hamlet&quot;)

instance RenderMessage App FormMessage where
  renderMessage _ _ = defaultFormMessage

mkYesodData &quot;App&quot; $(parseRoutesFile &quot;config/routes&quot;)

getList :: Handler [Text]
getList = do
    App tstate &lt;- getYesod
    state &lt;- liftIO $ readTVarIO tstate
    return $ map fst state

addFile :: App -&gt; (Text, ByteString) -&gt; Handler ()
addFile (App tstore) op =
    liftIO . atomically $ do
        modifyTVar tstore $ \ ops -&gt; op : ops

getById :: Text -&gt; Handler ByteString
getById ident = do
    App tstore &lt;- getYesod
    operations &lt;- liftIO $ readTVarIO tstore
    case lookup ident operations of
      Nothing -&gt; notFound
      Just bytes -&gt; return bytes
{-# START_FILE Main.hs #-}
-- show
-- /show
{-# LANGUAGE OverloadedStrings #-}

module Main where

import Control.Concurrent.STM

import Yesod

import Dispatch ()
import Foundation

main :: IO ()
main = do
    tfilenames &lt;- atomically $ newTVar []
    warpEnv $ App tfilenames
{-# START_FILE Handler/Home.hs #-}
-- show
-- /show
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE TypeFamilies #-}

module Handler.Home where

import qualified Data.ByteString.Lazy as L
import Data.Conduit
import Data.Conduit.Binary
import Data.Default
import Yesod
import Yesod.Default.Util
import Control.Monad.Trans.Resource (runResourceT)

import Foundation

getHomeR :: Handler Html
getHomeR = do
    (formWidget, formEncType) &lt;- generateFormPost uploadForm
    filenames &lt;- getList
    defaultLayout $ do
        setTitle &quot;File Processor&quot;
        $(widgetFileNoReload def &quot;home&quot;)

postHomeR :: Handler Html
postHomeR = do
    ((result, _), _) &lt;- runFormPost uploadForm
    case result of
      FormSuccess fi -&gt; do
        app &lt;- getYesod
        fileBytes &lt;- runResourceT $ fileSource fi $$ sinkLbs
        addFile app (fileName fi, fileBytes)
      _ -&gt; return ()
    redirect HomeR

uploadForm = renderDivs $ fileAFormReq &quot;file&quot;
{-# START_FILE Handler/Preview.hs #-}
-- show
-- /show
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE TemplateHaskell #-}

module Handler.Preview where

import Control.Exception hiding (Handler)
import qualified Data.ByteString.Lazy as LB
import Data.Default
import Data.Text (Text)
import qualified Data.Text as Text
import qualified Data.Text.Lazy as LT
import qualified Data.Text.Lazy.Encoding as LT
import Text.Blaze
import Yesod
import Yesod.Default.Util

import Foundation

getPreviewR :: Text -&gt; Handler Html
getPreviewR filename = do
    bytes &lt;- getById filename
    defaultLayout $ do
        setTitle . toMarkup $ &quot;File Processor - &quot; `Text.append` filename
        previewBlock &lt;- liftIO $ preview bytes
        $(widgetFileNoReload def &quot;preview&quot;)

preview :: LB.ByteString -&gt; IO Widget
preview bytes = do
    eText &lt;- try . evaluate $ LT.decodeUtf8 bytes :: IO (Either SomeException LT.Text)
    return $ case eText of
      Left _ -&gt; errorMessage
      Right text -&gt; [whamlet|&lt;pre&gt;#{text}|]
  where
    errorMessage = [whamlet|&lt;pre&gt;Unable to display file contents.|]
{-# START_FILE templates/default-layout.cassius #-}
{-hi-}body
    font-family: Tahoma, Geneva, sans-serif
    font-size: 1pc
form
    clear: both
    margin:auto
    position:relative
    text-decoration: none
    -webkit-border-radius: 5pt
    -moz-border-radius: 5pt
    border-radius: 5pt
    padding:1em
    border: 1pt solid #999
    border: inset 1pt solid #333
    /* Force form elements to be consistent with each other */
    input, textarea, select, button
        margin: 1pt
        -webkit-box-sizing: border-box
        -moz-box-sizing: border-box
        box-sizing: border-box
    select
        width: 100%
    input
        display:block
        border: 1pt solid #999
    input[type=submit]
        float: right
        background: #09C
        color: #fff
        -webkit-border-radius: 5pt
        -moz-border-radius: 5pt
        border-radius: 5pt
        border: 1pt solid #999
    /* Change color on mouseover */
    input[type=submit]:hover
        background:#fff
        color:#09c

/* force bottom border to extend below floating elements */
form::after
    content: &quot;&quot;
    display: block
    visibility: hidden
    clear: both{-/hi-}

/* add rounded grey box around text */
pre
    -webkit-border-radius: 5pt
    -moz-border-radius: 5pt
    border-radius: 5pt
    border: 1pt solid #999
    background: #DDD
    margin: 1em
    padding: 1em
    white-space: pre-wrap
{-# START_FILE templates/default-layout.hamlet #-}
-- show
-- /show
^{widget}
{-# START_FILE templates/default-layout-wrapper.hamlet #-}
-- show
-- /show
$newline never
$doctype 5
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;#{pageTitle pc}
        ^{pageHead pc}
    &lt;body&gt;
        ^{pageBody pc}
{-# START_FILE templates/home.hamlet #-}
-- show
-- /show
&lt;h2&gt;Previously submitted files
$if null filenames
    &lt;p&gt;No files have been uploaded yet.
$else
    &lt;ul&gt;
        $forall filename &lt;- filenames
            &lt;li&gt;
                &lt;a href=@{PreviewR filename}&gt;#{filename}
&lt;h2&gt;Submit new file
&lt;form method=post action=@{HomeR} enctype=#{formEncType}&gt;
  ^{formWidget}
  &lt;input type=&quot;submit&quot; value=&quot;Upload&quot;&gt;
{-# START_FILE templates/preview.hamlet #-}
-- show
-- /show
&lt;a href=@{HomeR}&gt;home
&lt;h1&gt;#{filename}
&lt;p&gt;
  ^{previewBlock}
{-# START_FILE config/routes #-}
-- show
-- /show
/           HomeR    GET POST
/file/#Text PreviewR GET</code></pre><p>The main purpose of this styling is to improve the appearance of the upload
form. The best resource on Cassius templates is Michael Snoyman's book. If you
are familiar with CSS, this example should give you an idea of what Cassius
Syntax looks like.</p><h1 id="summary"><a href="#summary">Summary</a></h1><p>What do you think would happen if 2 files having the same name were uploaded?
As things stand they would both appear in the list, but only one would be
accessible. In the next and final entry of this series we will fix this
problem by keying on unique identifiers rather than filenames. We'll also add
a link to the summary page for downloading files. Finally, we'll expand on the
<code>preview</code> action so that images can be displayed before being downloaded.</p></article>

<div id="disqus_thread"><script>var disqus_shortname = "fpcomplete"; (function() { var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true; dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq); })();</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">comments powered by <span class="logo-disqus">Disqus</span></a></a>
</div>

</div>
</div>
<div class="row article-footer"><div class="span7 meta"><span class="sociallinksunicode social">
<a href="https://twitter.com/home?status=$url$" target="_blank"><i class="icon-twitter"></i></a>&nbsp;
<a href="http://www.facebook.com/sharer/sharer.php?u=$url$" target="_blank"><i class="icon-facebook"></i></a>&nbsp;
<a href="https://plus.google.com/share?url=$url$" target="_blank"><i class="icon-google-plus"></i></a></span>
</div>
</div>
</div>
<div class="footer"><div class="container"><div class="row"><div class="span12"><ul class="menu"><li><a href="https://www.schoolofhaskell.com/">School</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user">Users</a>
</li>

<li><a class="brand" href="https://fpcomplete.com">Sponsored by:
<img src="/static/img/logo.png" title="FPComplete">
</a>
</li>
</ul>
</div>
</div>
<div class="row"><div class="span12"></div>
</div>
</div>
</div>
<link rel="stylesheet" type="text/css" href="/static/bootstrap/css/bootstrap-responsive.css" />
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script><script src="https://www.schoolofhaskell.com/static/combined/Y-3k9_tW.js"></script><script>$(function(){
  $("a.logout").click(function(){
    var form = $("<form method='post'/>");
    form.attr("action", $(this).attr("href"));
    $("body").append(form);
    form.submit();
    return false;
  });
});

$(function(){
    $('.sociallinksunicode a').each(function(){
        $(this).attr('href',$(this).attr('href').replace('$url$',document.location));
    });
});

$(function(){
  // If we need to select a user/select a password then show the
  // details confirmation form, otherwise enable the getting started
  // section.
  if($('.alert-block a').text().match(/(selected a username|change your password)/)) {
    $("#confirm-details").show();
    $("#confirm-details #inputUsername").focus();
  } else {
    $("#get-started").removeClass('disabled').addClass('enabled');
  }

  // For lack of a plain HTML validation story this will do.
  $('.welcome-page').each(function(){
    $('form').submit(check);
  });
  function check(){
    setTimeout(check,500);
    var error = false;
    $('.error').removeClass('error');
    $('#enter-details input').each(function(){
      if($(this).val() == '') {
        $(this).parent().parent().addClass('error');
        error = true;
      }
    });
    if(error) return false;
    if($('[name=password]').val() == $('[name=confirm]').val()) {
      $('#confirm').removeClass('error');
      return true;
    } else {
      $('#confirm').addClass('error');
      return false;
    }
  }
});

$(function(){
  // When scrolling over a snippet editor, activate the "clone in IDE" popovers
  $('article').each(function(){
    var n = 100;
    var wait = 10000;
    function check(){
      if($('.clone').length == 0) {
        setTimeout(check,n);
        return;
      }
      var activated = $.cookie('clone-popover');
      if (activated) return;
      var activate = false;
      $('.controlsRun:onScreen').each(function(){
        $.cookie('clone-popover', 'true', { expires: 30, path: '/' });
        activate = true;
        return false;
      });
      if(activate) {
          $('.clone').each(function(){
              // The bootstrap API is rather unreasonable to say the
              // least.
              next = $(this).parent();
              var title = next.attr('title');
              next.attr('data-content',$(this).attr('data-content'));
              next.attr('title',$(this).attr('title'));
              next.popover('show',{
                  title: $(this).attr('title')
              });
              next.attr('title',title);
          });
          setTimeout(function(){
              $('.clone').each(function(){
                  $(this).parent().popover('hide');
              });
          },wait);
      } else {
        setTimeout(check,n);
      }
    }
    setTimeout(check,n);
  });
});

// onScreen jQuery plugin v0.2.1
// (c) 2011-2013 Ben Pickles
//
// http://benpickles.github.com/onScreen
//
// Released under MIT license.
(function(a){a.expr[":"].onScreen=function(b){var c=a(window),d=c.scrollTop(),e=c.height(),f=d+e,g=a(b),h=g.offset().top,i=g.height(),j=h+i;return h>=d&&h<f||j>d&&j<=f||i>e&&h<=d&&j>=f}})(jQuery);

/*!
 * jQuery Cookie Plugin v1.1
 * https://github.com/carhartl/jquery-cookie
 *
 * Copyright 2011, Klaus Hartl
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.opensource.org/licenses/GPL-2.0
 */
(function($, document) {

  var pluses = /\+/g;
  function raw(s) {
    return s;
  }
  function decoded(s) {
    return decodeURIComponent(s.replace(pluses, ' '));
  }

  $.cookie = function(key, value, options) {

    // key and at least value given, set cookie...
    if (arguments.length > 1 && (!/Object/.test(Object.prototype.toString.call(value)) || value == null)) {
      options = $.extend({}, $.cookie.defaults, options);

      if (value == null) {
	options.expires = -1;
      }

      if (typeof options.expires === 'number') {
	var days = options.expires, t = options.expires = new Date();
	t.setDate(t.getDate() + days);
      }

      value = String(value);

      return (document.cookie = [
	encodeURIComponent(key), '=', options.raw ? value : encodeURIComponent(value),
	options.expires ? '; expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE
	options.path    ? '; path=' + options.path : '',
	options.domain  ? '; domain=' + options.domain : '',
	options.secure  ? '; secure' : ''
      ].join(''));
    }

    // key and possibly options given, get cookie...
    options = value || $.cookie.defaults || {};
    var decode = options.raw ? raw : decoded;
    var cookies = document.cookie.split('; ');
    for (var i = 0, parts; (parts = cookies[i] && cookies[i].split('=')); i++) {
      if (decode(parts.shift()) === key) {
	return decode(parts.join('='));
      }
    }
    return null;
  };
  $.cookie.defaults = {};})(jQuery, document);
</script><!--[if lt IE 10]><script src="https://www.schoolofhaskell.com/static/design/js/ie.js?etag=ayV2DuJ0"></script><![endif]--><script>if(!window.location.href.match(/localhost/)){var track = '/tutorial/school/advanced-haskell/building-a-file-hosting-service-in-yesod/part%203';
window._gaq = [['_setAccount','UA-36928035-1'],track != ''? ['_trackPageview',track] : ['_trackPageview']
,['_trackPageLoadTime']];window._gaq.push(['_setCustomVar',1,'Section','School of Haskell',3]);
window._gaq.push(['_setCustomVar',2,'User Type','Visitor',1]);
(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);

})();}</script>
<!-- Prompt IE 6 users to install Chrome Frame. Remove this if you want to support IE 6.  chromium.org/developers/how-tos/chrome-frame-getting-started --><!--[if lt IE 7 ]><script src="//ajax.googleapis.com/ajax/libs/chrome-frame/1.0.3/CFInstall.min.js"></script><script>window.attachEvent('onload',function(){CFInstall.check({mode:'overlay'})})</script><![endif]--></body></html>